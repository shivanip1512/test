package com.cannontech.common.stream;

import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * Similar to an Optional. A Try can be in two states - success, where it contains a value, and failure, where
 * it contains an exception.
 * <p>
 * The primary difference between Try and Optional is that a Try will capture any exceptions that occur within mapping or
 * filtering operations, to be handled later.
 */
public abstract class Try<T> {
    private Try() {}
    
    /**
     * Create a new Try in the failure state, with the specified failure message.
     */
    public static <T> Try<T> failure(String message) {
        return new Failure<>(message);
    }
    
    /**
     * Create a new Try in the failure state, with the specified failure message and cause.
     */
    public static <T> Try<T> failure(String message, Exception cause) {
        return new Failure<>(message, cause);
    }
    
    /**
     * Create a new Try in the failure state, with the specified failure cause.
     */
    public static <T> Try<T> failure(Exception cause) {
        return new Failure<>(cause);
    }
    
    /**
     * Create a new Try in the success state, with the specified value. Nulls are permitted.
     */
    public static <T> Try<T> success(T value) {
        return new Success<>(value);
    }
    
    /**
     * Create a new Try in the success state, with the specified value. Nulls are permitted.
     */
    public static <T> Try<T> of(T value) {
        return success(value);
    }
    
    /**
     * Create a new Try based on the specified Optional. The Try will be in the failure state if the Optional is empty.
     */
    public static <T> Try<T> of(Optional<T> optional) {
        if (optional.isPresent()) {
            return success(optional.get());
        }
        return failure(new NullPointerException("Empty Optional."));
    }
    
    /**
     * Create a new Try from the result of invoking the supplier. If the supplier throws an exception, a failed Try will
     * be created with that exception.
     */
    public static <T> Try<T> of(ThrowingSupplier<T> supplier) {
        try {
            return success(supplier.get());
        } catch (Exception e) {
            return failure(e);
        }
    }
    
    public static interface ThrowingSupplier<T> {
        T get() throws Exception;
    }
    
    @Override
    public abstract boolean equals(Object obj);
    
    @Override
    public abstract int hashCode();
    
    @Override
    public abstract String toString();
    
    /**
     * @return True, if the Try is successful (and contains a value), otherwise false.
     */
    public abstract boolean isSuccess();
    
    /**
     * @return True, if the Try is failed (and contains an exception), otherwise false.
     */
    public abstract boolean isFailure();
    
    /**
     * If this Try is failed, throw the exception generated by the failure. Otherwise, return the Try.
     */
    public abstract Try<T> throwException() throws Exception;
    
    /**
     * If this Try succeeded, get the contained value, otherwise return null.
     */
    public abstract T get();
    
    /**
     * If this Try is failed, get the contained exception, otherwise return null.
     */
    public abstract Exception getException();
    
    /**
     * Returns an Optional representation of this Try. If the Try is a failure, this is translated into an empty
     * Optional. This loses any exception information contained in a failed Try.
     * @return An Optional containing the value of this Try (if successful) or an empty Optional if this Try is failed.
     */
    public abstract Optional<T> getOptional();
    
    /**
     * If a value is present, and the value matches the given predicate, return a Try containing the value. If the value
     * does not match, return a Try containing a TryFailedException. If the Try is already failed, the try is returned
     * unaltered.
     */
    public abstract Try<T> filter(Predicate<? super T> predicate);
    
    /**
     * If a value is present, apply the provided Optional-bearing mapping function to it, return that result, otherwise 
     * return the failed Try.
     */
    public abstract <U> Try<U> flatMap(Function<? super T, Try<U>> mapper);
    
    /**
     * If a value is present, apply the provided mapping function to it.
     */
    public abstract <U> Try<U> map(Function<? super T, ? extends U> mapper);
    
    /**
     * Attempts the specified mapping. If an exception is thrown, the mapping is retried, up to the specified number of
     * times.
     */
    public abstract <U> Try<U> retry(int times, Function<? super T, ? extends U> mapper);
    
    /**
     * If a value is present, invoke the specified consumer with the value, otherwise do nothing.
     */
    public abstract Try<T> ifSuccess(Consumer<? super T> consumer);
    
    /**
     * If the Try is failed, invoke the specified consumer with the exception, otherwise do nothing.
     */
    public abstract Try<T> ifFailure(Consumer<? super Exception> consumer);
    
    /**
     * If a value is present, return it, otherwise return other.
     */
    public abstract T orElse(T other);
    
    /**
     * If a value is present, return it, otherwise invoke the supplier and return the result.
     */
    public abstract T orElse(Supplier<T> supplier);
    
    /**
     * Failure is a Try containing an exception.
     */
    private static class Failure<T> extends Try<T> {

        private Exception exception;
        
        public Failure(String message) {
          this.exception = new TryFailedException(message);
        }
        
        public Failure(String message, Exception e) {
          this.exception = new TryFailedException(message, e);
        }
        
        public Failure(Exception e) {
          this.exception = e;
        }
        
        @Override
        public boolean isSuccess() {
          return false;
        }
        
        @Override
        public boolean isFailure() {
          return true;
        }
        
        @Override
        public Try<T> throwException() throws Exception {
          throw exception;
        }
        
        @Override
        public T get() {
            return null;
        }

        @Override
        public Exception getException() {
            return exception;
        }
        
        @Override
        public Optional<T> getOptional() {
            return Optional.empty();
        }
        
        @Override
        public Try<T> filter(Predicate<? super T> predicate) {
            return this;
        }
        
        @Override
        public <U> Try<U> flatMap(Function<? super T, Try<U>> mapper) {
            return failure(exception);
        }

        @Override
        public <U> Try<U> map(Function<? super T, ? extends U> mapper) {
            return failure(exception);
        }
        
        @Override
        public <U> Try<U> retry(int times, Function<? super T, ? extends U> mapper) {
            return failure(exception);
        }
        
        @Override
        public Try<T> ifSuccess(Consumer<? super T> consumer) {
            return this;
        }

        @Override
        public Try<T> ifFailure(Consumer<? super Exception> consumer) {
            consumer.accept(exception);
            return this;
        }

        @Override
        public T orElse(T other) {
            return other;
        }
        
        @Override
        public T orElse(Supplier<T> supplier) {
            return supplier.get();
        }
        
        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + ((exception == null) ? 0 : exception.hashCode());
            return result;
        }

        @Override
        @SuppressWarnings("unchecked")
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            Failure<T> other = (Failure<T>) obj;
            if (exception == null) {
                if (other.exception != null) {
                    return false;
                }
            } else if (!exception.equals(other.exception)) {
                return false;
            }
            return true;
        }

        @Override
        public String toString() {
            return "Failure [exception=" + exception + "]";
        }
    }
    
    /**
     * Success is a Try containing a value.
     */
    private static class Success<T> extends Try<T> {
        private T value;
        
        public Success(T value) {
          this.value = value;
        }
        
        @Override
        public boolean isSuccess() {
          return true;
        }
        
        @Override
        public boolean isFailure() {
          return false;
        }
        
        @Override
        public Try<T> throwException() throws Exception {
            return this;
        }
        
        @Override
        public T get() {
            return value;
        }

        @Override
        public Optional<T> getOptional() {
            return Optional.ofNullable(value);
        }
        
        @Override
        public Exception getException() {
            return null;
        }
        
        @Override
        public Try<T> filter(Predicate<? super T> predicate) {
            try {
                if (predicate.test(value)) {
                    return this;
                }
                return failure("Value filtered.");
            } catch (Exception e) {
                return failure("Filtering failed", e);
            }
        }

        @Override
        public <U> Try<U> flatMap(Function<? super T, Try<U>> mapper) {
            try {
                return mapper.apply(value);
            } catch (Exception e) {
                return failure("Mapping failed", e);
            }
        }

        @Override
        public <U> Try<U> map(Function<? super T, ? extends U> mapper) {
            try {
                return success(mapper.apply(value));
            } catch (Exception e) {
                return failure("Mapping failed", e);
            }
        }
        
        @Override
        public <U> Try<U> retry(int times, Function<? super T, ? extends U> mapper) {
            for (int i = 0; i < times; i++) { //1
                try {
                    return success(mapper.apply(value));
                } catch (Exception e) {
                    if (i == times - 1) {
                        return failure("Retry count exceeded. Tried " + times + " times.", e);
                    }
                }
            }
            throw new IllegalStateException();
        }
        
        @Override
        public Try<T> ifSuccess(Consumer<? super T> consumer) {
            consumer.accept(value);
            return this;
        }

        @Override
        public Try<T> ifFailure(Consumer<? super Exception> consumer) {
            return this;
        }

        @Override
        public T orElse(T other) {
            return value;
        }
        
        @Override
        public T orElse(Supplier<T> supplier) {
            return value;
        }
        
        @Override
        public int hashCode() {
            final int prime = 31;
            int result = 1;
            result = prime * result + ((value == null) ? 0 : value.hashCode());
            return result;
        }

        @Override
        @SuppressWarnings("unchecked")
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
            }
            Success<T> other = (Success<T>) obj;
            if (value == null) {
                if (other.value != null) {
                    return false;
                }
            } else if (!value.equals(other.value)) {
                return false;
            }
            return true;
        }

        @Override
        public String toString() {
            return "Success [value=" + value + "]";
        }
    }
    
    public static class TryFailedException extends Exception {
        
        public TryFailedException(String message) {
            super(message);
        }
        
        public TryFailedException(Throwable cause) {
            super(cause);
        }
        
        public TryFailedException(String message, Throwable cause) {
            super(message, cause);
        }
    }
}
