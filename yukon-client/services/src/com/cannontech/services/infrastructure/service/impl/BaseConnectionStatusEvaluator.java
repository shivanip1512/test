package com.cannontech.services.infrastructure.service.impl;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.apache.logging.log4j.Logger;
import org.joda.time.Duration;
import org.joda.time.Instant;
import org.springframework.beans.factory.annotation.Autowired;

import com.cannontech.clientutils.YukonLogManager;
import com.cannontech.common.pao.PaoIdentifier;
import com.cannontech.common.pao.YukonPao;
import com.cannontech.common.pao.attribute.model.BuiltInAttribute;
import com.cannontech.core.dao.RawPointHistoryDao;
import com.cannontech.core.dao.RawPointHistoryDao.AdjacentPointValues;
import com.cannontech.core.dynamic.PointValueQualityHolder;
import com.cannontech.database.db.point.stategroup.CommStatusState;
import com.cannontech.infrastructure.model.InfrastructureWarning;
import com.cannontech.infrastructure.model.InfrastructureWarningType;
import com.cannontech.services.infrastructure.service.InfrastructureWarningEvaluator;

/**
 * Generates warnings for devices whose connection status has been "disconnected" for a configurable amount of time
 */
public abstract class BaseConnectionStatusEvaluator implements InfrastructureWarningEvaluator {

    private static final Logger log = YukonLogManager.getLogger(BaseConnectionStatusEvaluator.class);
    private static final DateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");

    @Autowired private RawPointHistoryDao rphDao;

    @Override
    public List<InfrastructureWarning> evaluate() {
        log.debug("Running Connection status evaluator for PaoTypes: {}", getSupportedTypes());
        
        int warnableTimeMinutes = getWarnableMinutes();
        Duration warnableDuration = Duration.standardMinutes(warnableTimeMinutes);
        log.debug("Required disconnected minutes to warn: {}", warnableTimeMinutes);
        
        Map<PaoIdentifier, PointValueQualityHolder> deviceToPointValue =
            rphDao.getMostRecentAttributeDataByValue(getDevices(), BuiltInAttribute.COMM_STATUS,
                    false, CommStatusState.CONNECTED.getRawState(), null);
        
        Instant now = Instant.now();
        
        return deviceToPointValue.entrySet()
                .stream()
                .map(entry -> buildConnectionStatusInfo(entry, now, warnableDuration))
                .filter(ConnectionStatusInfo::isWarnable)
                .map(entry -> buildWarning(entry))
                .collect(Collectors.toList());
    }

    /**
     * Build an object containing all the relevant info for a device connection status check.
     */
    ConnectionStatusInfo buildConnectionStatusInfo(Map.Entry<PaoIdentifier, PointValueQualityHolder> entry, 
                                                   Instant evaluationTime, Duration warnableDuration) {
        
        ConnectionStatusInfo info = new ConnectionStatusInfo(entry.getKey(), warnableDuration, evaluationTime, entry.getValue());
        if (info.isLastConnectedTimestampWarnable()) {
            AdjacentPointValues adjacentPointValues = rphDao.getAdjacentPointValues(info.getLastConnectedPointValue());
            info.setNextDisconnectedPointValue(adjacentPointValues.getSucceeding());
        }
        return info;
    }

    /**
     * Builds an infrastructure warning for the specified paoIdentifier and point value.
     */
    private InfrastructureWarning buildWarning(ConnectionStatusInfo info) {
        return new InfrastructureWarning(info.getDevicePaoId(),
                                         getWarningType(),
                                         dateFormat.format(info.getNextDisconnectedTimestamp().toDate()));
    }
    
    /**
     * Returns the PAOs that will be examined by the evaluator
     */
    abstract Iterable<? extends YukonPao> getDevices();
    
    /**
     * Returns the warning type that will be generated by the evaluator
     */
    abstract InfrastructureWarningType getWarningType();
    
    /**
     * Returns the number of minutes that need to pass for a device to be considered in violation
     */
    abstract int getWarnableMinutes();
}
