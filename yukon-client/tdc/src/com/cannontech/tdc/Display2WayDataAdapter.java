package com.cannontech.tdc;

/**
 * This class was generated by a SmartGuide.
 * 
 */
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Set;
import java.util.Vector;
import java.util.stream.Collectors;

import javax.swing.table.AbstractTableModel;

import com.cannontech.clientutils.CTILogger;
import com.cannontech.clientutils.CommonUtils;
import com.cannontech.clientutils.commonutils.ModifiedDate;
import com.cannontech.clientutils.tags.IAlarmDefs;
import com.cannontech.clientutils.tags.TagUtils;
import com.cannontech.common.YukonColorPallet;
import com.cannontech.common.gui.util.Colors;
import com.cannontech.common.pao.PaoUtils;
import com.cannontech.common.point.PointQuality;
import com.cannontech.common.util.CtiUtilities;
import com.cannontech.core.dao.PaoDao;
import com.cannontech.core.dao.PointDao;
import com.cannontech.core.image.dao.YukonImageDao;
import com.cannontech.database.data.lite.LitePoint;
import com.cannontech.database.data.lite.LiteYukonPAObject;
import com.cannontech.database.data.point.PointType;
import com.cannontech.database.data.point.PointTypes;
import com.cannontech.database.db.state.YukonImage;
import com.cannontech.message.dispatch.message.PointData;
import com.cannontech.message.dispatch.message.Signal;
import com.cannontech.spring.YukonSpringHook;
import com.cannontech.tdc.alarms.gui.AlarmingRow;
import com.cannontech.tdc.alarms.gui.AlarmingRowVector;
import com.cannontech.tdc.alarms.gui.RowBlinker;
import com.cannontech.tdc.custom.CustomDisplay;
import com.cannontech.tdc.data.Display;
import com.cannontech.tdc.filter.ITDCFilter;
import com.cannontech.tdc.logbox.MessageBoxFrame;
import com.cannontech.tdc.utils.DataBaseInteraction;
import com.cannontech.tdc.utils.TDCDefines;

public class Display2WayDataAdapter extends AbstractTableModel implements com.cannontech.tdc.alarms.gui.AlarmTableModel, com.cannontech.common.gui.util.SortableTableModel
{
	private boolean muted = false;
	private Date currentDate = new Date(); //today

	private Display currentDisplay = Display.UNKNOWN_DISPLAY;

	private RowBlinker currentBlinkingAlarms = null;

	private boolean exceededMaxMsg = true;

	public static final int DEFAULT_FOREGROUNDCOLOR = YukonColorPallet.WHITE.getColorId(); // white as of 3-23-2000
	public static final int DEFAULT_BACKGROUNDCOLOR = YukonColorPallet.BLACK.getColorId();  // black as of 3-23-2000
	public static final int DEFAULT_DISABLEDCOLOR = YukonColorPallet.GRAY.getColorId();  // gray as of 8-31-2000
	public static final int DEFAULT_ALARMCOLOR = YukonColorPallet.WINE.getColorId();  // red as of 1-12-2001
	
	private static final PointValues DUMMY_POINT_VALUES =
						new PointValues(
								TDCDefines.ROW_BREAK_ID,
								PointTypes.INVALID_POINT,
								"", "", "" );	

	private Vector columnNames = null;	
	private Vector columnTypeName = null;

	/* BEGIN -Data for each row */
	private Vector<PointValues> pointValues = null;  // row specific characteristics
	private Vector<Object> rows = null; // values the row contains
	private AlarmingRowVector alarmedRows = null;
	/* END -data for each row */
	
	private Vector pointLimbo = null;
	private Vector blankPoints = null;
	
	//Default colors for alarms 
		/* Events	  2
			Priority1  1
			Priority2  4
			Priority3  0
			Priority4  7
			Priority5  8
			Priority6  5
			Priority7  3
			Priority8  2
			Priority9  10
			Priority10 9
		*/
	private int[] alarmColors = null;

	private class BlankLine
	{
		private int location = 0;
		
		public BlankLine( int loc )
		{
			location = loc;	
		}

		public int getLocation()
		{
			return location;
		}

	};


/**
 * This method was created in VisualAge.
 */
public Display2WayDataAdapter() 
{
	super();
}
/**
 * This method add a Blank row to the table
 */
// ONLY ADDS ROWS INTO EXISTING ROW SPOTS
public void addBlankRow( int location ) 
{
	if( location < 0 )
		return;

	checkRowExceedance();
		
	Vector newRow = new Vector( getColumnCount() );
	
	for( int i = 0; i < getColumnCount(); i++ )
		newRow.addElement("");

	if( location >= getRowCount() )
		getRows().addElement( newRow );
	else
		getRows().insertElementAt( newRow, location );

	createDummyPointValue( location );
}

protected Vector getColumnNames()
{
	if( columnNames == null )
		columnNames = new Vector(16);	
	return columnNames;
}

protected Vector getColumnTypeName()
{
	if( columnTypeName == null )
		columnTypeName = new Vector(16);	
	return columnTypeName;
}

protected Vector<Object> getRows()
{
	if( rows == null )
		rows = new Vector<Object>(64);	
	return rows;
}

/**
 * Insert the method's description here.
 * Creation date: (5/26/00 10:46:37 AM)
 * Version: <version>
 */
protected boolean addBlankRowIfNeeded() 
{
	if( getRowCount() % (getRowCount() <= TDCDefines.ROW_BREAK_COUNT ? TDCDefines.ROW_BREAK_COUNT : TDCDefines.ROW_BREAK_COUNT+1) == 0 )
	{
		addBlankRow( 0 );
		return true;
	}
	else
		return false;
}
/**
 * Insert the method's description here.
 * Creation date: (3/22/00 1:56:48 PM)
 * @param point com.cannontech.message.dispatch.message.Signal
 */
private int addColumnDefinedRow( Signal signal )
{
	synchronized( getAlarmingRowVector() )
	{		
		int columnCount = getColumnCount();
		
		int rowsAdded = 0;
		
		if( columnCount != 0 )
		{
			createRowForEventViewer( signal );

			// put a psuedo value in row location 0
			createPsuedoPointValue( 0, signal );
			
			rowsAdded++;
				
			if( addBlankRowIfNeeded() )
				rowsAdded++;

		}

		return rowsAdded;
		
	} // end of SYNCH
}

/**
 * Insert the method's description here.
 * Creation date: (3/22/00 1:56:48 PM)
 * @param point com.cannontech.message.dispatch.message.Signal
 */
private int addColumnDefinedRow( Signal signal, int pageNumber )
{
	synchronized( getAlarmingRowVector() )
	{		
		int columnCount = getColumnCount();
		
		int rowsAdded = 0;
		
		if( columnCount != 0 )
		{
            // This if filters any signals from updating the page
            // unless its the first page.
            if(pageNumber == 1){
                createRowForEventViewer( signal );
            }

			// put a psuedo value in row location 0
			createPsuedoPointValue( 0, signal );
			
			rowsAdded++;
				
			if( addBlankRowIfNeeded() )
				rowsAdded++;

		}

		return rowsAdded;
		
	} // end of SYNCH
}
/**
 * This method was created in VisualAge.
 */
private boolean buildRowQuery() 
{
	java.util.Date timerStart = null;
	java.util.Date timerStop = null;
	timerStart = new java.util.Date();

	// Init our Rows in their correct order (Use a SQL-92 compliant query now, aka: 8-6-2003)
	String query = new String
		("select d.pointid, d.pointtype, d.devicename, d.pointstate, " +
		 "d.devicetype, u.decimalplaces " +
		 "from display2waydata_view d left outer join pointunit u on d.pointid = u.pointid, display2waydata y " +
		 "where y.displaynum = ? " +
		 "and d.pointid = y.pointid " +
		 "order by y.ordering");
		 		
	Object[] objs = new Object[1];
	objs[0] = Integer.valueOf( getCurrentDisplay().getDisplayNumber() );


	Object[][] pointData = DataBaseInteraction.queryResults( query, objs );

	if ( pointData != null && pointData.length > 0 ) // is there any points?
	{		
		pointValues = new Vector<>(128);
		
		// insert regular points
		for( int i = 0; i < pointData.length; i++ )
		{
			int ptID = Integer.parseInt(pointData[i][0].toString());

			if( ptID == TDCDefines.ROW_BREAK_ID )
			{
				if( blankPoints == null )		
					blankPoints = new Vector(32);

				blankPoints.addElement( new BlankLine(i) );
			}
			else
			{
				PointValues pv = new PointValues(
								 ptID,
								 PointTypes.getType(pointData[i][1].toString()),
							    pointData[i][2].toString(),
							    pointData[i][3].toString(),
							    pointData[i][4].toString() );
				
				//assign the decimal places for each point id here if one is present
				String decPlaces = pointData[i][5].toString();
				if( decPlaces.length() > 0 )
					pv.setDecimalPlaces( Integer.valueOf(decPlaces) );
				
				pointValues.addElement( pv );
			}
		}

		checkForLimboPoints( pointValues );

		timerStop = new java.util.Date();
		CTILogger.debug( 
			 (timerStop.getTime() - timerStart.getTime())*.001 + 
				" secs for Custom Created display DB hit for full display (Loaded " + 
				pointValues.size() + " real points)" );

		return true;

	}
	
	return false;
}
/**
 * Insert the method's description here.
 * Creation date: (9/15/00 1:38:02 PM)
 * @param existingPoints java.util.Vector
 */
private void checkForLimboPoints(Vector existingPoints) 
{
	String query = "select pointid from display2waydata where displaynum = ? order by pointid";
	Object[] objs = new Object[1];
	objs[0] = Integer.valueOf( getCurrentDisplay().getDisplayNumber() );
	Object[][] displayPoints = DataBaseInteraction.queryResults( query, objs );

	for( int i = 0; i < displayPoints.length; i++ )
	{
		boolean pointFound = false;

		for( int j = 0; j < existingPoints.size(); j++ )
		{
			PointValues point = ((PointValues)existingPoints.elementAt(j));

			if( String.valueOf(point.getPointID()).equalsIgnoreCase(displayPoints[i][0].toString()) ||
				displayPoints[i][0].toString().equalsIgnoreCase( String.valueOf(TDCDefines.ROW_BREAK_ID) ) )
			{				
				pointFound = true;
				break;
			}			
		}

		if( pointFound == false )
		{
			if( !getPointLimbo().contains( displayPoints[i][0].toString() ) )
				getPointLimbo().addElement( displayPoints[i][0].toString() );
		}
		
	}
		

}
/**
 * Insert the method's description here.
 * Creation date: (4/20/00 10:09:54 AM)
 * Version: <version>
 */
protected void checkRowExceedance() 
{
   long totalMax = 
      TDCDefines.MAX_ROWS + (TDCDefines.MAX_ROWS / TDCDefines.ROW_BREAK_COUNT);


	if( getRowCount() >= totalMax )
	{
		// remove the bottom row
		removeRow( getRowCount() - 1 );
		
		if( exceededMaxMsg ) // for the message to only print once
		{
			exceededMaxMsg = false;
			TDCMainFrame.messageLog.addMessage("The maximum row count(" + TDCDefines.MAX_ROWS +") has been exceeded", MessageBoxFrame.ERROR_MSG );
		}
	}	
}
/**
 * Insert the method's description here.
 * Creation date: (4/20/00 11:38:04 AM)
 * Version: <version>
 */
public void clearSystemViewerDisplay( boolean forceRepaint )
{
	// FOR NOW, ONLY CLEAR THE EVENT VIEWER AND HISTORICAL VIEWERS
	if( Display.isHistoryDisplay(getCurrentDisplay().getDisplayNumber()) )
	{
		// remove all alarms if any exists
		synchronized ( getAlarmingRowVector() )
		{
			getAlarmingRowVector().removeAllElements();
			killRowBlinker();
		}

		// remove the nonviewable and viewable data 
		synchronized( pointValues )
		{
			pointValues.removeAllElements();
			getRows().removeAllElements();
		}	

		if( forceRepaint )
			fireTableDataChanged();
	}
}
/**
 * Insert the method's description here.
 * Creation date: (4/12/00 2:23:47 PM)
 * Version: <version>
 * @param id long
 */
protected void createDummyPointValue( int location ) 
{
	if( location >= getRowCount() ) //Add the new value
		pointValues.addElement( DUMMY_POINT_VALUES );
	else
		pointValues.insertElementAt( DUMMY_POINT_VALUES, location );
}

/**
 * Insert the method's description here.
 * Creation date: (4/12/00 2:23:47 PM)
 * Version: <version>
 * @param id long
 */
private void createPsuedoPointValue( int location, Signal signal ) 
{
	if( location >= getRowCount() )
		return;  // cant add it off the chart

	PointValues psuedoValue =
		new PointValues(
			(signal == null ? TDCDefines.ROW_BREAK_ID : signal.getPointID()),
			PointTypes.INVALID_POINT,
			"", "", "" );	

	if( location >= getRowCount() ) //Add the new value
		pointValues.addElement( psuedoValue );
	else
		pointValues.insertElementAt( psuedoValue, location );
}


/**
 * Insert the method's description here.
 * Creation date: (4/12/00 2:23:47 PM)
 * Version: <version>
 * @param id long
 */
protected void createPsuedoPointValue( int location ) 
{
	createPsuedoPointValue( location, null );
}


/* TRY TO GET AWAY FROM
protected void createDummyPointValue( long id, long timeStamp, String deviceName, int soe_tag, int location ) 
{
	if( location >= getRowCount() )
		return;  // cant add it off the chart

	// create our storage
	PointValues pointValue = new PointValues( 
		(int)id,
		PointTypes.INVALID_POINT );


	if( location >= getRowCount() ) //Add the new value
		pointValues.addElement( pointValue );
	else  // insert the new value
		pointValues.insertElementAt( pointValue, location );


	pointValue.setTime( new Date(timeStamp) );
	pointValue.setDeviceName( deviceName );
	pointValue.setSOETag( soe_tag );
}
*/

/**
 * Insert the method's description here.
 * Creation date: (4/13/00 5:04:56 PM)
 * Version: <version>
 * @return java.util.Vector
 */
private void createRowForEventViewer( Signal signal )
{
	//set all the date for this row
	Vector newRow = setRowForEventViewer( signal );

	// add the new row to the top of the table	
	if( getRowCount() == 0 )
		getRows().addElement( newRow );			
	else
	{
		checkRowExceedance();
		getRows().insertElementAt( newRow, 0 );
	}

	fireTableRowsInserted( getRowCount(), getRowCount() );
}

public void setCurrentDate( Date date_ )
{
	currentDate = date_;
}

public Date getCurrentDate()
{
	return currentDate;
}

/**
 * Insert the method's description here.
 * Creation date: (4/13/00 12:15:31 PM)
 * Version: <version>
 * @param inc int
 */
private void decrementAlarmedRowsPosition(int decValue, int rowNumber) 
{
	if( getAlarmingRowVector().size() > 0 )
	{
		synchronized( getAlarmingRowVector() )
		{
			for( int i = 0; i < getAlarmingRowVector().size(); i++ )
			{
				AlarmingRow alRow = ((AlarmingRow)getAlarmingRowVector().elementAt(i));
				if( alRow.getRowNumber() > rowNumber )
					alRow.subtractOffset( decValue );
			}		
		}
	}	
}
/**
 * Insert the method's description here.
 * Creation date: (4/5/00 1:31:25 PM)
 * Version: <version>
 */
private void deleteRowFromDataBase( long pointid )
{
	// NOTE: IF THE SELECTED ROW IS A BLANK ROW, ALL BLANK ROWS GET
	// 		 DELETED AFTER THIS CALL
	
	String query = "delete from display2waydata where displaynum = ? " +
		 	" and pointid = ?";


	Object[] objs = new Object[2];
	objs[0] = Integer.valueOf(getCurrentDisplay().getDisplayNumber());
	objs[1] = Long.valueOf(pointid);
	DataBaseInteraction.updateDataBase( query, objs );	
}

/**
 * Insert the method's description here.
 * Creation date: (5/23/00 2:18:04 PM)
 * Version: <version>
 * @param value boolean
 */
public void forcePaintTableRowUpdated( int minLocation, int maxLocation )
{
	fireTableRowsUpdated( minLocation, maxLocation );

}

/**
 * Insert the method's description here.
 * Creation date: (11/10/00 11:20:46 AM)
 * @return int[]
 */
public int getAlarmColor(int colorIndex) 
{
	if( colorIndex < 0 || colorIndex >= alarmColors.length )
		return DEFAULT_ALARMCOLOR;  // use this for the default alarm color
	else
		return alarmColors[colorIndex];
}
/**
 * Insert the method's description here.
 * Creation date: (7/26/00 10:59:14 AM)
 * @return com.cannontech.tdc.AlarmingRowVector
 */
public com.cannontech.tdc.alarms.gui.AlarmingRowVector getAlarmingRowVector() 
{
	if( alarmedRows == null )
	{
		alarmedRows = new com.cannontech.tdc.alarms.gui.AlarmingRowVector();
	}
	
	return alarmedRows;
}
/**
 * Insert the method's description here.
 * Creation date: (3/7/00 2:40:18 PM)
 */
public Set<Integer> getAllPointIDs() 
{	
	if( pointValues != null && pointValues.size() > 0 )
	{
	    return pointValues.stream()
	            .map(pv -> pv.getPointID())
	            .filter(x -> x != TDCDefines.ROW_BREAK_ID)  // only add real point IDs
	            .collect(Collectors.toSet());
	}
	else
		return null;
}
// Data methods

public int getBlankRowCount() 
{
	int count = 0;
	
	for( int i = 0; i < getRowCount(); i++ )
	{
		if( ((Vector)getRows().elementAt( i )).elementAt( 0 ).equals("") )
			count++;
	}
	
	return count;
}
// Data methods
// getBlankRows returns and array of locations where
// a blank row is in order of appearance
public Object[] getBlankRows() 
{
	
	Vector blank = new Vector( 20 );
	
	for( int i = 0; i < getRowCount(); i++ )
	{
		if( ((Vector)getRows().elementAt( i )).elementAt( 0 ).equals("") )
			blank.addElement( Integer.valueOf( i ) );
	}

	Object[] realBlanks = new Object[ blank.size() ];
	blank.copyInto( realBlanks );

	blank = null;
	
	return realBlanks;
}
/**
 * This method was created in VisualAge.
 * @return java.awt.Color
 * @param row int
 * @param col int
 */
public java.awt.Color getCellBackgroundColor(int row, int col) 
{

	java.awt.Color color = Colors.getColor( DEFAULT_BACKGROUNDCOLOR );

	if( row < 0 || row >= getRowCount() )
		return color;
		
	try
	{
		color = Colors.getColor( pointValues.elementAt( row ).getCurrentBackgroundColor() );
	}
	catch( ArrayIndexOutOfBoundsException e )
	{
		//do nothing here
	}
	
	
	return color;
}
	/**
 * Insert the method's description here.
 * Creation date: (2/14/00 4:55:03 PM)
 * @return java.lang.String
 */
public String getCellData( int rowPosition, int colPosition ) 
{
	if( getRowCount() <= 0 || rowPosition >= getRowCount() || colPosition >= getColumnCount() ||
		rowPosition < 0 || colPosition < 0 )
	{
		CTILogger.info(this.getClass().toString() + ".getCellData( int, int ) received a bad position");
		return "";
	}
	else
 		return ((Vector)getRows().elementAt( rowPosition )).elementAt( colPosition ).toString();
}
/**
 * This method was created in VisualAge.
 * @return java.awt.Color
 * @param row int
 * @param col int
 */
public java.awt.Color getCellForegroundColor(int rowNumber, int col) 
{
	if( pointValues == null || rowNumber < 0 || rowNumber >= getRowCount() )
		return Colors.getColor( DEFAULT_FOREGROUNDCOLOR );

	int colorINT = 0;
	
	try
	{		
		colorINT = pointValues.elementAt( rowNumber ).getCurrentForegroundColor();
	}
	catch( ArrayIndexOutOfBoundsException e )  // no defined color, use default
	{
		colorINT = DEFAULT_FOREGROUNDCOLOR;
	}
		
	return Colors.getColor( colorINT );
}
/**
 * Insert the method's description here.
 * Creation date: (2/3/00 3:15:32 PM)
 * @param int loc
 */
private Object getCellValueObject( PointValues point, int loc )
{
	java.text.DecimalFormat doubleToLong = 
				new java.text.DecimalFormat();

	doubleToLong.setParseIntegerOnly( true );
	String buffer = new String();
	PointValues pt = null;

	try
	{
		pt = pointValues.elementAt( loc );
	}
	catch(ArrayIndexOutOfBoundsException ex )
	{
		CTILogger.info("***** ArrayIndexOutOfBoundsException in " + this.getClass() + " of getCellValueObject(PointData, int) exception = " + ex.getMessage() + " /r/n" );
	}
	
	switch (PointType.getForId(point.getPointType()))
	{				
		case Status:
		case CalcStatus:
		{
			if( point.getValue() % 1 == 0 )  // make sure we have a whole number
			{
				int value = Integer.valueOf( doubleToLong.format(point.getValue()) ).intValue();
				buffer = pt.getText( value );
				pt.setCurrentRowColor( value );
			}
			else
				return "INVALID FLOAT FOR A STATUS : " + point.getValue();
			
			return buffer;
		}
		
		
		case PulseAccumulator:
		case DemandAccumulator:
		case CalcAnalog:
		case Analog:
		{
			String returnVal = new String();
				
			try
			{
				returnVal = CommonUtils.formatDecimalPlaces( point.getValue() ,pt.getDecimalPlaces().intValue() );
			}
			catch( NullPointerException ex )
			{
				CTILogger.info("*** Point '" + pt.getPointName() + "' of type " + PointTypes.getType( pt.getPointType() ) + " does not have an entry in the POINTUNIT table. ***");
			}
			
			//doubleToLong.applyPattern(pattern);
			
			//return Double.valueOf( doubleToLong.format(point.getValue()) );
			// By not returning a Double object, the column class becomes a String and thus
			// when sorting the column, we sort on a text basis not numeric!!!!
			return returnVal;//doubleToLong.format(point.getValue());
		}

		default:
			return "";
	}
	
}
public Class getColumnClass(int column)
{
	return String.class;

}
public int getColumnCount() {
	return getColumnNames().size();
}

public String getColumnName(int column) 
{
	if( getColumnNames().elementAt(column) != null ) 
	{
		return getColumnNames().elementAt(column).toString();
	} 
	else 
	{
		return "";
	}
	
}

/**
 * This method was created in VisualAge.
 * @return java.lang.String
 */
public String getColumnTypeName( int index ) 
{
	if( index < 0 || index >= getColumnTypeName().size() )
		return null;
		
	return getColumnTypeName().elementAt( index ).toString();
}

/**
 * Insert the method's description here.
 * Creation date: (3/20/00 5:32:27 PM)
 * @return java.lang.Object
 * @param location int
 */
public Object getPointDynamicValue(int location) 
{
	if ( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_POINTVALUE) )
	{
		Vector rowData = (Vector)getRows().elementAt( location );
			
		return rowData.elementAt( getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_POINTVALUE) );
	}
	else
		return null;

}
/**
 * Insert the method's description here.
 * Creation date: (3/7/00 2:40:18 PM)
 * @return boolean
 * @param ptID java.lang.String
 */
public long getPointID( int rowNumber ) 
{
	if( pointValues != null && pointValues.size() > 0 && rowNumber < pointValues.size() && 
		 rowNumber >= 0 && rowNumber < getRowCount() )
	{
		return Long.valueOf( pointValues.elementAt( rowNumber ).getPointID()).longValue();
	}
	else
		return -1;
}
/**
 * Insert the method's description here.
 * Creation date: (9/14/00 4:36:10 PM)
 * @return java.util.Vector
 */
private java.util.Vector getPointLimbo() 
{
	if( pointLimbo == null )
		pointLimbo = new Vector();
		
	return pointLimbo;
}
/**
 * Insert the method's description here.
 * Creation date: (2/24/00 10:17:07 AM)
 * @return java.lang.String[]
 */
public Object[] getPointsInLimbo() 
{
	if( pointLimbo != null )
	{
		return pointLimbo.toArray();
	}
	else
		return null;
}
/**
 * Insert the method's description here.
 * Creation date: (3/7/00 2:40:18 PM)
 * @return boolean
 * @param ptID java.lang.String
 */
public String getPointType( int loc ) 
{
	if( pointValues != null && pointValues.size() > 0 && loc >= 0 && loc < getRowCount() )
		return PointTypes.getType( pointValues.elementAt( loc ).getPointType());
	else
		return "";
}
/**
 * Insert the method's description here.
 * Creation date: (3/7/00 2:40:18 PM)
 * @return boolean
 * @param ptID java.lang.String
 */
public PointValues getPointValue( int loc ) 
{
	if( pointValues != null && pointValues.size() > 0 && loc >= 0 && loc < getRowCount() )
		return pointValues.elementAt( loc );
	else
		return null;
}
/**
 * Insert the method's description here.
 * Creation date: (2/3/00 2:36:38 PM)
 * @return int
 * @param i int
 */
public int getRowBackgroundColor( int rowNumber ) 
{
	int colorINT = -1;

	if( pointValues == null || rowNumber < 0 || rowNumber >= getRowCount() )
		return DEFAULT_BACKGROUNDCOLOR;
		
	try
	{
		colorINT = pointValues.elementAt( rowNumber ).getCurrentBackgroundColor();
	}
	catch( ArrayIndexOutOfBoundsException e )
	{
		colorINT = DEFAULT_BACKGROUNDCOLOR;
	}
	
	
	return colorINT;
}

public int getRowCount() {
	return getRows().size();
}

/**
 * Insert the method's description here.
 * Creation date: (2/3/00 2:36:38 PM)
 * @return int
 * @param i int
 */
public int getRowForegroundColor( int rowNumber ) 
{
	int colorINT = -1;

	if( pointValues == null || rowNumber < 0 || rowNumber >= getRowCount() )
		return DEFAULT_FOREGROUNDCOLOR;

	try
	{		
		colorINT = pointValues.elementAt( rowNumber ).getCurrentForegroundColor();
	}
	catch( ArrayIndexOutOfBoundsException e )  // no defined color, use default
	{
		colorINT = DEFAULT_FOREGROUNDCOLOR;
	}
		
	return colorINT;
}
/**
 * This method was created in VisualAge.
 */
public int getRowNumber( final long pointid ) 
{
	if( pointValues != null )
	{
		for ( int i = 0; i < pointValues.size(); i++ )
		{
			if( pointValues.elementAt( i ).getPointID() == pointid )
			{
				return ( i );
			}
			
		}
	}
	
	return ( -1 );	
	
}

/**
 * This method was created in VisualAge.
 */
private boolean signalInTable( Signal signal_ ) 
{
	if( pointValues != null )
	{
		for ( int i = 0; i < pointValues.size(); i++ )
		{
			if( pointValues.elementAt( i ).containsSignal(signal_) )
				return true;
		}
	}
	
	return false;
}

/**
 * This method was created in VisualAge.
 */
public int getRowNumber( final Signal signal_ ) 
{
	if( pointValues != null )
	{
		for ( int i = 0; i < pointValues.size(); i++ )
		{
			PointValues pv = pointValues.elementAt( i );

			if( pv.containsSignal(signal_) )
			{
				return ( i );
			}
			
		}
	}
	
	return -1;	
	
}

// DO NOT CALL THIS METHOD DIRECTLY
public Object getValueAt(int aRow, int aColumn)
{
	try
	{
		Vector row = (Vector) getRows().elementAt(aRow);
		return row.get( aColumn );
	}
	catch( ArrayIndexOutOfBoundsException ex )
	{
		CTILogger.debug(getClass().toString() + ".getValueAt("+aColumn+","+aRow+") threw ArrayIndexOutOfBounds, no major problem");
		
		// we need to return a new Object to make the renderer happy
		return new Object();
	}
}
/**
 * Insert the method's description here.
 * Creation date: (7/27/00 12:14:50 PM)
 * @param point com.cannontech.message.dispatch.message.Signal
 */
private void handleAlarm(Signal signal) 
{
	// check if we have an alarm (11 or 01 or 10)
	if( TagUtils.isAnyAlarm(signal.getTags()) )
	{
		//find out what type of alarm signal this is  (0100)
		if( TagUtils.isAlarmUnacked(signal.getTags()) )// we need to flash
		{
			if( Display.isAlarmDisplay(getCurrentDisplay().getDisplayNumber()) )
				insertAlarmDisplayAlarmedRow( signal );
			else if( Display.isReadOnlyDisplay(getCurrentDisplay().getDisplayNumber()) )
				addColumnDefinedRow( signal );
			else if( !Display.isHistoryDisplay(getCurrentDisplay().getDisplayNumber()) )
			{
				int rNum = getRowNumber(signal.getPointID());
				if( rNum >= 0 )
					getPointValue(rNum).updateSignal( signal );
				
				setRowAlarmed( signal );
			}

		}
		else if( TagUtils.isAlarmActive(signal.getTags()) )		
		{	// we need to only show the row (1000),
			// check if we need to stop the flashing of the alarm
			if( Display.isAlarmDisplay(getCurrentDisplay().getDisplayNumber()) )
				insertAlarmDisplayAlarmedRow( signal );
			else if( !Display.isHistoryDisplay(getCurrentDisplay().getDisplayNumber()) )
				setRowUnalarmed( signal, null );
		}
			
	}
	else  // clear the alarm row from the display
	{
		if( Display.isAlarmDisplay(getCurrentDisplay().getDisplayNumber()) )
		{			
			if( isSignalAlarmed(signal) )
			{
				int rNum = setRowUnalarmed( signal, null );
				
				//every row in an alarm display must have at least one signal if we got this far
				if( getPointValue(rNum).getAllSignals().length <= 0 )
					removeRow(rNum);
			}

		}
		else if( getCurrentDisplay().getDisplayNumber() >= Display.PRECANNED_USER_DISPLAY_NUMBER )
			setRowUnalarmed( signal, null ); // if we have a user display, just make sure the row is not flashing

	}
	
}
/**
 * Insert the method's description here.
 * Creation date: (7/27/00 12:14:50 PM)
 * @param point com.cannontech.message.dispatch.message.Signal
 */
private void handleDisablity( Signal point )
{
	if( (point.getTags() & Signal.MASK_ANY_DISABLE) != 0 )  // check if we have an disablement
	{
		//check for a point having its service disabled
		if( TagUtils.isPointOutOfService(point.getTags()) )
		{
			//getPointValue( getRowNumber(point.getId()) ).
		}
		
		//check for a point having its alarming disabled		
		if( (point.getTags() & Signal.MASK_ANY_ALARM_DISABLE) != 0 )
		{

			
		}
		
		//check for a point having its control disabled(Status points only)		
		if( (point.getTags() & Signal.MASK_ANY_CONTROL_DISABLE) != 0 )
		{
			
		}
			
	}
	else  // clear any disablements we may have set for this point
	{
		
	}
	
}
/**
 * Called whenever the part throws an exception.
 * @param exception java.lang.Throwable
 */
private void handleException(java.lang.Throwable exception)
{
	/* Uncomment the following lines to print uncaught exceptions to stdout */
	CTILogger.info("--------- UNCAUGHT EXCEPTION ---------");
	CTILogger.error( exception.getMessage(), exception );;
	
	TDCMainFrame.messageLog.addMessage(exception.toString() + " in : " + this.getClass(), MessageBoxFrame.ERROR_MSG );
}
/**
 * Insert the method's description here.
 * Creation date: (4/13/00 12:15:31 PM)
 * Version: <version>
 * @param inc int
 */
private void incrementAlarmedRowsPosition(int inc) 
{
	if( getAlarmingRowVector().size() > 0 )
	{
		synchronized( getAlarmingRowVector() )
		{
			for( int i = 0; i < getAlarmingRowVector().size(); i++ )
			{
				//if( !isRowSelectedBlank( ((AlarmingRow)alarmedRows.elementAt(i)).getRowNumber() + inc ) )
					((AlarmingRow)getAlarmingRowVector().elementAt(i)).addOffset( inc );
			}
		}
	}			
}
/**
 * Insert the method's description here.
 * Creation date: (4/7/00 1:27:58 PM)
 * Version: <version>
 */
private void initAlarmColors() 
{
	String query = "select stategroupid, rawstate, text, foregroundcolor, backgroundcolor " +
				   " from state where stategroupid = ? and rawstate >= 0" +
				   " order by rawstate";

	Object[] objs = new Object[1];
	objs[0] = Integer.valueOf( com.cannontech.database.db.state.StateGroupUtils.STATEGROUP_ALARM );
	Object[][] alarmStates = DataBaseInteraction.queryResults( query, objs );

	alarmColors = new int[ alarmStates.length + 1 ];
	alarmColors[0] = DEFAULT_BACKGROUNDCOLOR;  // for now, just store a common BG color for all rows

	for( int i = 1; i < alarmColors.length; i++ )
	{
		alarmColors[i] = Integer.parseInt( alarmStates[ i - 1 ][3].toString() );
	}
}
/**
 * This method was created in VisualAge.
 */
private void initColumns() 
{	
	if ( getCurrentDisplay().getDisplayNumber() <= Display.UNKNOWN_DISPLAY_NUMBER )
	 	return;

	synchronized( getAlarmingRowVector() )
	{
		getAlarmingRowVector().removeAllElements();
		killRowBlinker();
	}
	
	getRows().removeAllElements();
	getColumnNames().removeAllElements();
	getColumnTypeName().removeAllElements();

	
	if( pointValues != null )
		pointValues.removeAllElements();

	if( blankPoints != null )
		blankPoints.removeAllElements();
		
	String query = new String
		("select displaycolumns.title, columntype.name, displaycolumns.width " +
		 "from displaycolumns, columntype " +
		 "where displaycolumns.displaynum = ? " +
		 " and columntype.typenum = displaycolumns.typenum "+
		 " order by displaycolumns.ordering");
	Object[] objs = new Object[1];
	objs[0] = Integer.valueOf(getCurrentDisplay().getDisplayNumber());
	Object[][] values = DataBaseInteraction.queryResults( query, objs );

	
	initDataStructures();	
		
	// Get the column names and save them
	for(int column = 0; column < values.length; column++) 
	{
		getColumnNames().addElement( values[column][0] );
		getColumnTypeName().addElement( values[column][1] );
		//columnWidth[ column ] = Integer.valueOf( values[column][2].toString() );
	}


	fireTableStructureChanged(); // Tell the listeners a new table has arrived.
}
/**
 * Insert the method's description here.
 * Creation date: (3/10/00 11:03:26 AM)
 */
private void initDataStructures() 
{
	if ( pointValues == null )
		pointValues = new Vector<>( 60 );

	if ( blankPoints == null )
		blankPoints = new Vector( 15 );
}

private boolean isDateInCurrentDay( Date date_ )
{
	GregorianCalendar lowerCal = new GregorianCalendar();
	lowerCal.setTime( currentDate );
	lowerCal.set( lowerCal.HOUR_OF_DAY, 0 );
	lowerCal.set( lowerCal.MINUTE, 0 );
	lowerCal.set( lowerCal.SECOND, 0 );
	lowerCal.set( lowerCal.MILLISECOND, 000 );
   
	GregorianCalendar upperCal = new GregorianCalendar();
	upperCal.setTime( currentDate );
	upperCal.set( upperCal.HOUR_OF_DAY, 23 );
	upperCal.set( upperCal.MINUTE, 59 );
	upperCal.set( upperCal.SECOND, 59 );
	upperCal.set( upperCal.MILLISECOND, 999 );

	return 
		date_.after(lowerCal.getTime())
		&& date_.before(upperCal.getTime());
}

/**
 * Insert the method's description here.
 * Creation date: (4/12/00 1:06:13 PM)
 * Version: <version>
 * @param point java.lang.Object
 */
protected void insertAlarmDisplayAlarmedRow( Signal signal )
{
	if( signal.getPointID() < 0 || signal.getCategoryID() < Signal.EVENT_SIGNAL )
		return;

	long alarmPage = 0;
	if( signal.getCategoryID() > Signal.EVENT_SIGNAL && signal.getCategoryID() <= Signal.MAX_DISPLAYABLE_ALARM_SIGNAL )
		alarmPage = Display.GLOBAL_ALARM_DISPLAY + (signal.getCategoryID() - Signal.EVENT_SIGNAL);
	else if( signal.getCategoryID() == Signal.EVENT_SIGNAL ) //if we have a Signal.EVENT_SIGNAL, then we want every display possibly handle this Signal
		alarmPage = getCurrentDisplay().getDisplayNumber();

	// all alarms display	
	if( (getCurrentDisplay().getDisplayNumber() == Display.GLOBAL_ALARM_DISPLAY 
	       || alarmPage == getCurrentDisplay().getDisplayNumber()) 
		 && isValidAlarm(signal.getCategoryID()) )
	{
		synchronized( getAlarmingRowVector() )
		{
			if( isSignalAlarmed(signal) )
			{
				try
				{
					int rNum = getRowNumber(signal);

					if( signal.getCategoryID() > Signal.EVENT_SIGNAL )
					{
						getAlarmingRowVector().getAlarmingRow(rNum).setAlarmColor(
								getAlarmColor((int)signal.getCategoryID()) );
					}


					getAlarmingRowVector().getAlarmingRow(rNum).updateSignal( signal );
					
					//set all the signal stuff
					getPointValue(rNum).setTime( signal.getTimeStamp() );
					getPointValue(rNum).updateSignal( signal );


					getRows().setElementAt( 
						setRowForEventViewer(signal), rNum);

					forcePaintTableRowUpdated( rNum, rNum );					
				}
				catch(NullPointerException ex )
				{ 
					CTILogger.info("**** NullPointer found in insertAlarmDisplayAlarmedRow() method : " + ex.getMessage() );
				}
			}
			else
			{
				// if the point isn't alarming and its an EVENT_SIGNAL, we do not want to add it.
				// This means that some other app besides Dispatch has ACKED or CLEARED an existing alarm.
				// If we didnt do this, all AKED alarms would show up on every display!!!
				if( signal.getCategoryID() != Signal.EVENT_SIGNAL )
				{
					int rowLoc = getRowNumber(signal);

					if( rowLoc < 0 )  // if the point does not already exist on the table
					{
						int addedRows = addColumnDefinedRow(signal);
						incrementAlarmedRowsPosition( addedRows );
						fireTableRowsInserted( getRowCount()-addedRows, getRowCount()-1 );
					}

					int rNum = getRowNumber(signal.getPointID());
					getPointValue(rNum).updateSignal( signal );
					setRowAlarmed( signal );
				}
			}
		}	
	}

}

/**
 * This method was created in VisualAge.
 */
private void insertBlankLines() 
{
	for( int i = 0; i < blankPoints.size(); i++ )
		addBlankRow( ((BlankLine)blankPoints.elementAt(i)).getLocation() );
}

/**
 * Insert the method's description here.
 * Creation date: (8/9/00 3:35:39 PM)
 * @return boolean
 * @param signal com.cannontech.message.dispatch.message.Signal
 */
public boolean isCellEditable(int row, int column) 
{
	// make every cell non-editable
	return false;

}

/**
 * Insert the method's description here.
 * Creation date: (3/7/00 2:40:18 PM)
 * @return boolean
 * @param ptID java.lang.String
 */
public boolean isMuted() 
{
	return muted;
}

public void setMuted( boolean muted_ )
{
	muted = muted_;
}

public void silenceAlarms() 
{
	synchronized( getAlarmingRowVector() )
	{
		getAlarmingRowVector().setAllSilenced( true );
	}
}

/**
 * Insert the method's description here.
 * Creation date: (3/30/00 9:29:03 AM)
 * Version: <version>
 * @return boolean
 * @param rowNumber int
 */
public boolean isSignalAlarmed( Signal signal_ )
{
	return getAlarmingRowVector().containsSignal( signal_ );
}

/**
 * Insert the method's description here.
 * Creation date: (3/30/00 9:29:03 AM)
 * Version: <version>
 * @return boolean
 * @param rowNumber int
 */
public boolean isRowInAlarmVector( int rowNumber )
{
	return getAlarmingRowVector().contains( Integer.valueOf( rowNumber ) );
}
/**
 * This method add a Blank row to the table
 */
 
public boolean isRowSelectedBlank( int location )
{
	if( location < getRows().size() && location >= 0 )
	{
		if( getPointValue(location) == DUMMY_POINT_VALUES )
			return true;
		else
			return false;			
	}
	else
		return false;
}
/**
 * Insert the method's description here.
 * Creation date: (4/14/00 11:38:27 AM)
 * Version: <version>
 * @return boolean
 * @param classification long
 */
private boolean isValidAlarm(long alarmState) 
{
	return (alarmState >= Signal.EVENT_SIGNAL && alarmState <= Signal.ALARM_SIGNAL );
}
/**
 * This method creates the table
 */
 
public synchronized void makeTable ( )
{
	initColumns();
	initAlarmColors();

	if ( buildRowQuery() )
	{
		String[] columns = new String[getColumnCount()];
		for( int j = 0; j < columns.length; j++ )
			columns[j] = getColumnTypeName(j).toString();


		for( int i = 0; i < pointValues.size(); i++ ) 
		{
			Vector newRow = new Vector();

			String[] row = CustomDisplay.getValue( 
						columns, 
						(int)(pointValues.get(i)).getPointID() );

			for (int j = 0; j < getColumnCount(); j++) 
			{
				if ( row[j] == null )
					newRow.addElement("");
				else if ( row[j].toString().equals(CustomDisplay.DYNAMIC_ROW) )
					newRow.addElement("   -----");					
				else
  					newRow.addElement( row[j] );   					
			}
				
			getRows().addElement(newRow);
		}
	
	}
		
	// insert blanklines here
	if( blankPoints != null && blankPoints.size() > 0 )
		insertBlankLines();

	fireTableDataChanged(); // refresh the table model
	
	TDCMainFrame.messageLog.addMessage("Table reinited", MessageBoxFrame.INFORMATION_MSG );
	exceededMaxMsg = true;	
}
/**
 * Insert the method's description here.
 * Creation date: (7/27/00 2:51:57 PM)
 * @return boolean
 * @param pointID long
 */
private boolean pointExists(long pointID) 
{
	return ( getRowNumber( pointID ) == -1 ? false : true );
}
/**
 * Insert the method's description here.
 * Creation date: (3/7/00 2:40:18 PM)
 * @return boolean
 * @param ptID java.lang.String
 */
public boolean pointExists(String ptID) 
{
	Long value = null;
	
	try
	{
		value = Long.valueOf(ptID);
	}
	catch( Exception e ) // NumberFormatException of NullPointerException will be the most common caught
	{
		return false;
	}
	
	return pointExists( value.longValue() );
}

/**
 * This method was created in VisualAge.
 */
public synchronized void processPointDataReceived( PointData point )
{
	// make sure we have a PointData and the display is a user defined one
	if ( point == null || pointValues == null || pointValues.size() < 1 
		|| getCurrentDisplay().getDisplayNumber() < Display.PRECANNED_USER_DISPLAY_NUMBER 
		|| point.getTagsOldTimestamp() )
	{
		return;
	}

	int rowLocation = -1;
	if ( (rowLocation = getRowNumber(point.getId())) >= 0)
	{		
		PointValues pv = getPointValue(rowLocation);
		
		
		// changes the current rows pointData values  -- Very Important
		try
		{
			pv.setPointData( point );
		}
		catch(ArrayIndexOutOfBoundsException ex )
		{
			CTILogger.info("***** ArrayIndexOutOfBoundsException in " + this.getClass() + " exception = " + ex.getMessage() + " /r/n" );
		}
		
		
		setCorrectRowValue( 
				pv,
				rowLocation );

	}
	
	//refresh the the changed row
	if( rowLocation >= 0 )
		fireTableRowsUpdated( 
			rowLocation,
			rowLocation + 1 );	
}

private boolean checkFilter( Signal signal )
{	
	if( signal == null ) 
		return false;

	//if we don't care about filters OR we already have added the signal to the table
	if( getCurrentDisplay().getTdcFilter().getConditions().isEmpty() )
		return true;



	boolean retValue = false;

	retValue |=
		TagUtils.isAlarmUnacked(signal.getTags()) // we need to flash
		&& getCurrentDisplay().getTdcFilter().getConditions().get(ITDCFilter.COND_UNACKED_ALARMS);
		 
	retValue |=
		TagUtils.isAlarmActive(signal.getTags())
		&& getCurrentDisplay().getTdcFilter().getConditions().get(ITDCFilter.COND_ACTIVE_ALARMS);	



	retValue &=
		!getCurrentDisplay().getTdcFilter().getConditions().get(ITDCFilter.COND_INACTIVE_ALARMS);


//	retValue &=
//		!getCurrentDisplay().getTdcFilter().getConditions().get(ITDCFilter.COND_HISTORY);

	return retValue;
}

/**
 * This method was created in VisualAge.
 *    ONLY SIGNALS SHOULD BE ALLOWED IN HERE
 */
@SuppressWarnings("unchecked")
public synchronized void processSignalReceived( Signal signal, int pageNumber )
{
	// make sure we have a point and we are not a LOG display
	if( (!checkFilter(signal) && !signalInTable(signal))
		  || Display.isLogDisplay(getCurrentDisplay().getDisplayNumber(), getCurrentDate()) )
	{
		return;
	}

	int rNum = -1;
	if( Display.isReadOnlyDisplay(getCurrentDisplay().getDisplayNumber()) )  
	{
		//just add the raw columns to the display
		addColumnDefinedRow( signal, pageNumber );
	}
	else if( signal.getCondition() >= IAlarmDefs.MIN_CONDITION_ID )
	{
		handleDisablity( signal );
		handleAlarm( signal );
		
		// set all fields that overlap in the PointData() and Signal() data structures
		int signalRowNumber = getRowNumber(signal);
        int rowNum = signalRowNumber > -1 ? signalRowNumber : getRowNumber(signal.getPointID());
        PointValues pv = getPointValue(rowNum);
        if (pv != null) {
            rNum = rowNum;
            //the new row has been added, lets set its signal instance
            pv.updateSignal( signal );
            // update other things that signals can tell us
            pv.setPointState(TagUtils.getTagString(signal.getTags()));
            pv.setTags(signal.getTags());
            Vector<Object> dataRow = (Vector<Object>)getRows().elementAt( rNum );
            if ( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_POINTQUALITY) ) {
                String quality = PointQuality.InitDefault.getAbbreviation();
                if (pv.getPointQuality() != null ) {
                    quality = (String) pv.getPointQuality().getAbbreviation();
                }
                quality += TagUtils.isAlarmActive(signal.getTags()) ? "-(ALM)" : "";
                int index = getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_POINTQUALITY);
                dataRow.setElementAt(quality, index); 
            }
            if ( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_STATE) ){
                dataRow.setElementAt(TagUtils.getTagString( signal.getTags() ), getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_STATE) ); 
            }
            
            // Signal message time stamps should NOT be used for Custom Displays.
            if( !getCurrentDisplay().getType().equals(Display.DISPLAY_TYPES[Display.CUSTOM_DISPLAYS_TYPE_INDEX]) ) {
                setRowTimeStamp(pv, signal.getTimeStamp(), rNum);
            }
        } 
	}
	else  //handle EVENTS here (these signals should never be in our table)
	{
		// find the row number that has this pointid
		rNum = getRowNumber(signal.getPointID());
		PointValues ptVal = getPointValue(rNum);


		//change the PointDatas tags preserving the alarms bits for the PointData
		if( ptVal != null && ptVal.getPointID() != PointTypes.SYS_PID_SYSTEM )
		{
			ptVal.setTags( 
				(ptVal.getTags() & Signal.MASK_ANY_ALARM)
				| (signal.getTags() & ~Signal.MASK_ANY_ALARM) );
		
			//we must change our tables row value
			setCorrectRowValue( 
					ptVal,
					rNum );
		}
		
	}


	if( !checkFilter(signal) )
		removeRow( getRowNumber(signal) );

	//refresh the the changed row
	if( rNum >= 0 )
		fireTableRowsUpdated( 
			rNum,
			rNum + 1 );
}

/**
 * Insert the method's description here.
 * Creation date: (4/5/00 1:16:57 PM)
 * Version: <version>
 * @param rowNumber int
 */
public void removeAllRows() 
{
	getRows().removeAllElements();
	
	fireTableDataChanged();
}
/**
 * Insert the method's description here.
 * Creation date: (4/5/00 1:16:57 PM)
 * Version: <version>
 * @param rowNumber int
 */
private void removeRow( int rowNumber ) 
{
	if( pointValues == null || rowNumber < 0 || rowNumber >= getRowCount() )
		return;

	setRowUnalarmed( null, Integer.valueOf(rowNumber) );

	// just in case the rows below this one are alarming
	if( getAlarmingRowVector().areRowNumbersGreaterAlarming( rowNumber ) )
		decrementAlarmedRowsPosition( 1, rowNumber );

	
	pointValues.removeElementAt( rowNumber );
	getRows().removeElementAt( rowNumber );

	fireTableRowsDeleted( rowNumber, rowNumber );

	//if there is a blank row below this row, remove it
	if( isRowSelectedBlank(rowNumber) )
	{
		removeRow( rowNumber );
		fireTableRowsDeleted( rowNumber, rowNumber );
	}
	
	//if there is a blank row above this row, remove it
	if( isRowSelectedBlank(rowNumber-1) )
	{
		removeRow( rowNumber-1 );
		fireTableRowsDeleted( rowNumber-1, rowNumber-1 );
	}
	
}

/**
 * This method was created in VisualAge.
 */
public void reset() 
{
	getColumnNames().removeAllElements();

	getColumnTypeName().removeAllElements();
	
	if ( pointValues != null )
		pointValues.removeAllElements();

	if ( blankPoints != null )
		blankPoints.removeAllElements();
			
	getRows().removeAllElements();

	getColumnNames().removeAllElements();

	if ( pointLimbo != null )
		pointLimbo.removeAllElements();
		
	getAlarmingRowVector().removeAllElements();

	setCurrentDisplay( Display.UNKNOWN_DISPLAY );

	fireTableDataChanged();
}
/**
 * Insert the method's description here.
 * Creation date: (4/14/00 11:33:17 AM)
 * Version: <version>
 * @param shouldPlay boolean
 */
public void rowDataSwap( int i, int j )
{
	Object tmp = null;

	// swap the pointValues
	PointValues tmpPv = pointValues.elementAt(i);
	pointValues.setElementAt( pointValues.elementAt(j), i );
	pointValues.setElementAt( tmpPv, j );
	
	// handles alarmed rows
	if( isRowInAlarmVector(i) || isRowInAlarmVector(j) )
	{
		synchronized( getAlarmingRowVector() )
		{
			if( isRowInAlarmVector(i) && isRowInAlarmVector(j) )
			{
				int iRow = getAlarmingRowVector().getAlarmingRowLocation( i );
				int jRow = getAlarmingRowVector().getAlarmingRowLocation( j );

				tmp = getAlarmingRowVector().getAlarmingRow(i);
				getAlarmingRowVector().setElementAt( getAlarmingRowVector().elementAt(jRow), iRow );
				getAlarmingRowVector().setElementAt( (AlarmingRow)tmp, jRow );
				
				
				//keep our alarm vector elements consistent
				((AlarmingRow)getAlarmingRowVector().elementAt(iRow)).setRowNumber( i );
				((AlarmingRow)getAlarmingRowVector().elementAt(jRow)).setRowNumber( j );
			}
			else if( isRowInAlarmVector(i) )
			{
				// set row i unalarmed and set row j to alarmed
				tmp = getAlarmingRowVector().getAlarmingRow(i);
				((AlarmingRow)tmp).setRowNumber( j );
				
				// just in case the background color is alarmed and should not be
				pointValues.elementAt( i ).setCurrentBackgroundColor(
					  pointValues.elementAt( i ).getOriginalBackgroundColor() );
			}
			else if( isRowInAlarmVector(j) )
			{
				// set row j unalarmed and set row i to alarmed
				tmp = getAlarmingRowVector().getAlarmingRow(j);
				((AlarmingRow)tmp).setRowNumber( i );

				// just in case the background color is alarmed and should not be
				pointValues.elementAt( j ).setCurrentBackgroundColor(
					  pointValues.elementAt( j ).getOriginalBackgroundColor() );						
			}						
		}
	}

	// swap the actual rows
	tmp = getRows().elementAt(i);
	getRows().setElementAt( getRows().elementAt(j), i );
	getRows().setElementAt( tmp, j );
}
/**
 * Insert the method's description here.
 * Creation date: (1/12/2001 1:06:00 PM)
 * @return boolean
 * @param rowNumber int
 * @param color int
 */
public boolean setBGRowColor(int rowNumber, int color) 
{
	synchronized( pointValues )
	{				
		try
		{
			PointValues pv = pointValues.elementAt(rowNumber);
			
			pv.setCurrentBackgroundColor( color );

			return true;
		}
		catch( ArrayIndexOutOfBoundsException ex )
		{
			/* This happens when the user switches displays, no big deal */
			return false;
		}
	} // end synch pointValues
}

private Integer getCellQualityCount( PointValues point_, int loc_, final Integer lastValue_ )
{
	PointValues pt = null;
	Integer retValue = Integer.valueOf(0);

	try
	{
		pt = pointValues.elementAt( loc_ );

		if( pt != null 
			 && (pt.getPointQuality() == point_.getPointQuality()) )
		{
			retValue = Integer.valueOf( lastValue_.intValue() + 1 );
		}
	}
	catch(ArrayIndexOutOfBoundsException ex )
	{
		CTILogger.info("***** ArrayIndexOutOfBoundsException in " + this.getClass() + " of handleQualityCount() exception = " + ex.getMessage() );
	}


	return retValue;
}

/**
 * This method was created in VisualAge.
 * @param Point com.cannontech.message.dispatch.message.SinglePointChange
 */
@SuppressWarnings("unchecked")
private void setCorrectRowValue( PointValues point, int location ) 
{
	
	if ( getRows().size() > 0 )   // make sure there are some rows
	{
		Vector dataRow = (Vector)getRows().elementAt( location );

		if ( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_QUALITYCNT) )
		{
			Object currentCnt = dataRow.get( getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_QUALITYCNT) );
			if( !(currentCnt instanceof Integer) )
				currentCnt = Integer.valueOf(0);
			
			dataRow.setElementAt(
					getCellQualityCount( point, location, (Integer)currentCnt ),
					getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_QUALITYCNT) );
		}

		if ( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_POINTVALUE) )
		{
			Object message = getCellValueObject( point, location );
			dataRow.setElementAt( message,
					getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_POINTVALUE) );
		}


		if ( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_POINTIMAGE) )
		{
			java.awt.Image img = null;
			int imgID = YukonImage.NONE_IMAGE_ID;
			
			try
			{
				imgID = getPointValue(location).getYukonImageID( (int)point.getValue() );

				if( imgID > YukonImage.NONE_IMAGE_ID )
					img = java.awt.Toolkit.getDefaultToolkit().createImage(
						YukonSpringHook.getBean(YukonImageDao.class).getLiteYukonImage( imgID ).getImageValue() );
			}
			catch( Exception e ) {}
			
			
			
			if( img == null )
				dataRow.setElementAt( CtiUtilities.STRING_NONE, 
					getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_POINTIMAGE) ); 
			else
				dataRow.setElementAt( img, 
					getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_POINTIMAGE) ); 
		}


		if ( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_POINTQUALITY) )
		{
			try {
			    String quality = "";
                if (point.getPointQuality() != null ) {
                    quality = (String) point.getPointQuality().getAbbreviation();
                }
	 			dataRow.setElementAt(
	 					quality	+ (TagUtils.isAlarmActive((int)point.getTags()) ? "-(ALM)" : ""),
						getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_POINTQUALITY) ); 
			}
			catch( IllegalArgumentException ex ) {
				handleException( ex );
			}
		}
	
		if ( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_STATE) )
		{
 			dataRow.setElementAt(
		 			TagUtils.getTagString( (int)point.getTags() ),
					getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_STATE) ); 
		}

		if ( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_POINTTIMESTAMP) )
		{				
			setRowTimeStamp( 
					point,
					point.getPointDataTimeStamp(),
					location );
		}


		if ( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_POINTSTATE) )
		{					
 			dataRow.setElementAt(
		 			TagUtils.isPointOutOfService((int)point.getTags()) ? "Disabled" : "Enabled",
					getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_POINTSTATE) );
		}


		// More Dyanmic cell changes should follow

	
	}

}

private void setRowTimeStamp( PointValues point, Date timeStamp, int location ) 
{
	
	if ( getRows().size() > 0 )   // make sure there are some rows
	{
		Vector dataRow = (Vector)getRows().elementAt( location );

		if ( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_POINTTIMESTAMP) )
		{				
			Object tempDate = new String();
			if( timeStamp.after(CtiUtilities.get1990GregCalendar().getTime()) )
				tempDate = new ModifiedDate( timeStamp.getTime() );

			dataRow.setElementAt( 
					tempDate, 
					getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_POINTTIMESTAMP) ); 
		}
	}

}

/**
 * Insert the method's description here.
 * Creation date: (1/20/00 4:47:45 PM)
 * @param val int
 */
public void setCurrentDisplay( Display display_ ) 
{
   //do this if there was a change in displays
   if( currentDisplay != display_ )
   {
		getAlarmingRowVector().removeAllElements();
      killRowBlinker();
   }

  currentDisplay = display_;
}

/**
 * Insert the method's description here.
 * Creation date: (1/20/00 4:47:45 PM)
 * @param val int
 */
public Display getCurrentDisplay() 
{
	return currentDisplay;	
}


/**
 * Insert the method's description here.
 * Creation date: (2/24/00 10:59:27 AM)
 * @param points java.lang.Object[]
 */
public void setLimboPointsValue(Object[] points) 
{
	if( points == null )
	{
		pointLimbo = null; //.removeAllElements();
		return;
	}
	else
	{
		if( pointLimbo != null )
		{
			pointLimbo.removeAllElements();
			
			for( int i = 0; i < points.length; i++ )
				pointLimbo.addElement( points[i] );
		}
		
	}
	
}

/**
 * Tells a row that contains the given Signal or the given Signals PointID to alarm.
 * Creation date: (3/29/00 2:23:38 PM)
 */
public void setRowAlarmed( Signal signal ) 
{
	//do not process EVENT_SIGNAL messages
	if( signal.getCategoryID() <= Signal.EVENT_SIGNAL )
		return;

	
	//first try to find the alarm by the signal object, then by the pointID
	int rowLoc = getRowNumber(signal);
	if( rowLoc < 0 )
		rowLoc = getRowNumber(signal.getPointID());


	// see if the point is in our display
	if( rowLoc >= 0 )
	{
		synchronized( getAlarmingRowVector() )
		{
			if( !getAlarmingRowVector().contains( Integer.valueOf(rowLoc) ) )
			{
				AlarmingRow alRow = new AlarmingRow( 
										rowLoc,
										getAlarmColor((int)signal.getCategoryID()), 
										getRowBackgroundColor(rowLoc) );

				alRow.updateSignal( signal );

				getAlarmingRowVector().addElement( alRow );
			}
			else
			{
				getAlarmingRowVector().getAlarmingRow(rowLoc).setAlarmColor( 
						getAlarmColor((int)signal.getCategoryID()) );
				
				getAlarmingRowVector().getAlarmingRow(rowLoc).updateSignal( signal );
			}
			
			if( currentBlinkingAlarms == null )
			{
				currentBlinkingAlarms = new RowBlinker( this, getAlarmingRowVector() );
				currentBlinkingAlarms.start();
			}


		} //end synch
		
		fireTableRowsUpdated( rowLoc, rowLoc );
	}


}
/**
 * Insert the method's description here.
 * Creation date: (4/13/00 5:04:56 PM)
 * Version: <version>
 * @return java.util.Vector
 */
private Vector setRowForEventViewer( Signal signal )
{
	if( signal == null )
		return new Vector();


	// how many columns need to be filled in below
	final int COLUMN_COUNT = 6;
	Vector aRow = new Vector( COLUMN_COUNT );

	for( int i = 0; i < COLUMN_COUNT; i++ )
		aRow.addElement( "" );  // put these into the vector just as dummy values

	LitePoint lPoint = YukonSpringHook.getBean(PointDao.class).getLitePoint( signal.getPointID() );
	LiteYukonPAObject lDevice = null;

	//we may not have a valid point
	if( lPoint == null )
	{
		lPoint = LitePoint.NONE_LITE_PT;		
	}

	lDevice = YukonSpringHook.getBean(PaoDao.class).getLiteYukonPAO( lPoint.getPaobjectID() );
	if( lDevice == null )
	{
		lDevice = PaoUtils.LITEPAOBJECT_SYSTEM;
	}


	// set DeviceName
	if( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_DEVICENAME) )
		aRow.setElementAt( CommonUtils.createString( lDevice.getPaoName() ), getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_DEVICENAME) );

	// set PointName		
	if( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_POINTNAME) )
		aRow.setElementAt( CommonUtils.createString( lPoint.getPointName() ), getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_POINTNAME) );

	// set Message/Description
	if( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_UOFM) )
		aRow.setElementAt( CommonUtils.createString( signal.getDescription() ), getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_UOFM) );

	// set Action
	if( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_TXT_MSG) )
		aRow.setElementAt( CommonUtils.createString( signal.getAction() ), getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_TXT_MSG));

	// set TimeStamp
	if( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_POINTTIMESTAMP) )
		aRow.setElementAt( new ModifiedDate( signal.getTimeStamp().getTime() ), getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_POINTTIMESTAMP) );

	// set Username
	if( getColumnTypeName().contains(CustomDisplay.COLUMN_TYPE_DEVICEID) )
		aRow.setElementAt( CommonUtils.createString( signal.getUserName() ), getColumnTypeName().indexOf(CustomDisplay.COLUMN_TYPE_DEVICEID) );



	return aRow;
}

/**
 * Allows the deletion of an alarm from a table by its Signal or RowNumber.
 * 
 * @return the row number affected 
 * Creation date: (3/29/00 2:23:38 PM)
 */
private int setRowUnalarmed( Signal signal_, Integer rowNum_ ) 
{
	//first try to look for the signal, then look by the pointID
	if( rowNum_ == null )
	{
		int rNum = getRowNumber(signal_);	
		if( rNum < 0 && signal_ != null )
			rNum = getRowNumber( signal_.getPointID() );
		
		rowNum_ = Integer.valueOf(rNum);
	}

	//strange, we are unable to find the row at this time
	if( rowNum_.intValue() < 0 )
		return rowNum_.intValue();

	getPointValue( rowNum_.intValue() ).removeSignal( signal_ );
	
	synchronized ( getAlarmingRowVector() )
	{
		if( getAlarmingRowVector().contains(rowNum_) )
		{
			AlarmingRow alRow = getAlarmingRowVector().getAlarmingRow( rowNum_.intValue() );
			alRow.removeSignal( signal_ );
	
			if( !alRow.isBlinking() || signal_ == null )
			{
				getAlarmingRowVector().removeElement(rowNum_);

				if( getAlarmingRowVector().size() == 0 )
					killRowBlinker();
			}
		}
	}
	
	return rowNum_.intValue();
}

/**
 * Insert the method's description here.
 * Creation date: (4/14/00 11:33:17 AM)
 * Version: <version>
 * @param shouldPlay boolean
 */
public void setAlarmMute( boolean mute ) 
{
	muted = mute;
}

private synchronized void killRowBlinker()
{
   if( currentBlinkingAlarms != null )
   {
      currentBlinkingAlarms.destroy();
		currentBlinkingAlarms = null;
   }

}

}
