/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
//#include <iostream.h>

/**
*
* Description:
*  This is a set of methods to accesses the Windows NT Services API, 
*  enabling JAVA code to access it through JNI, quite convenient I thought.
*
* Author: 
*  Tobias Eriksson  
*
* Compile:
*
* cl /I d:\j2sdk1.4.1\include /I d:\j2sdk1.4.1\include\win32 -LD JNTServices.c  advapi32.lib -FeJNTServices.dll
*
*
 
gcc -c JNTServices.c -IC:\j2sdk1.4.0_01\include -IC:\j2sdk1.4.0_01\include\win32 
gcc -shared JNTServices.o -Wl,--add-stdcall-alias  -o JNTServices.dll

*/

/*
	The following error codes can be of interrest:

	#define ERROR_PATH_NOT_FOUND             3L
	#define ERROR_ACCESS_DENIED              5L
	#define ERROR_INVALID_HANDLE             6L
	#define ERROR_DUP_NAME                   52L
	#define ERROR_INVALID_PARAMETER          87L    // dderror
	#define ERROR_INVALID_NAME               123L
	#define ERROR_DEPENDENT_SERVICES_RUNNING 1051L
	#define ERROR_INVALID_SERVICE_CONTROL    1052L
	#define ERROR_SERVICE_REQUEST_TIMEOUT    1053L
	#define ERROR_SERVICE_NO_THREAD          1054L
	#define ERROR_SERVICE_DATABASE_LOCKED    1055L
	#define ERROR_SERVICE_ALREADY_RUNNING    1056L
	#define ERROR_INVALID_SERVICE_ACCOUNT    1057L
	#define ERROR_SERVICE_DISABLED           1058L
	#define ERROR_CIRCULAR_DEPENDENCY        1059L
	#define ERROR_SERVICE_DOES_NOT_EXIST     1060L
	#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061L
	#define ERROR_SERVICE_NOT_ACTIVE         1062L
	#define ERROR_SERVICE_DEPENDENCY_FAIL    1068L
	#define ERROR_SERVICE_LOGON_FAILED       1069L
	#define ERROR_SERVICE_EXISTS             1073L
	#define ERROR_SERVICE_MARKED_FOR_DELETE  1072L
	#define ERROR_SERVICE_DEPENDENCY_DELETED 1075L
	

  */

/*
	The followinf codes are possible install options:

	#define SERVICE_BOOT_START             0x00000000
	#define SERVICE_SYSTEM_START           0x00000001
	#define SERVICE_AUTO_START             0x00000002
	#define SERVICE_DEMAND_START           0x00000003
	#define SERVICE_DISABLED               0x00000004

 */

/* Header for class com_cannontech_tdc_windows_JNTServices */

#ifndef _Included_com_cannontech_tdc_windows_JNTServices
#define _Included_com_cannontech_tdc_windows_JNTServices
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     NTServices
 * Method:    start
 * Signature: (Ljava/lang/String;I[Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_com_cannontech_tdc_windows_JNTServices_start
(JNIEnv *env, jobject jobj, jstring jsServiceShortName, jint jiNumberOfArgs, jobjectArray aArgs, jstring jsMachineName)
{
   SC_HANDLE myService, scm;
   BOOL success;
   int errorcode=0; // 0=success
   int i;
   
   //
   // Move all the args into the appropriate variables
   //
   const char *sServiceShortName = (*env)->GetStringUTFChars(env, jsServiceShortName, 0);
   char **sArgs = NULL;
   int iNumberOfArgs=0; 

	if( aArgs == NULL ) iNumberOfArgs=0;
	else iNumberOfArgs=(*env)->GetArrayLength( env, aArgs );  // We could in fact just look at jiNumberOfArgs but to be absolutely safe we'll go for the actual array size


   if( iNumberOfArgs > 0 ) 
   {
		sArgs = (char**) malloc( sizeof( char* ) * (int) iNumberOfArgs );

		//
		// populate the array
		//
		for( i=0; i<iNumberOfArgs; i++)
		{
			sArgs[ i ] = (char*) (*env)->GetStringUTFChars(env, (jstring) (*env)->GetObjectArrayElement( env, aArgs, i) , 0);
		}
   }

   //
   // Open a Service Control Manager connection
   //
   scm = OpenSCManager(
            (jsMachineName == NULL ? NULL : (LPCTSTR) (*env)->GetStringUTFChars(env, jsMachineName, 0)),
            NULL, SC_MANAGER_CREATE_SERVICE);
   
   if (!scm)
   {
      // cerr << "OpenSCManager Fails!" << GetLastError() << endl;
	  errorcode=GetLastError();
   }
   else
   {
		//cout << "Opened Service Control Manager...\n";

		//
		// Get the service's handle
		//
		myService = OpenService(scm, (LPCTSTR) sServiceShortName, SERVICE_ALL_ACCESS | DELETE);
		if (!myService)
		{
			// cerr << "OpenService Fails!" << GetLastError() << endl;
			errorcode=GetLastError();
		}
		else
		{
			//
			// Start the service
			//
			success = StartService( myService, (DWORD) iNumberOfArgs, (LPCTSTR*) sArgs );
			if( !success )
			{
				errorcode=GetLastError();
			}
		}
   }
   if( sArgs != NULL ) free( sArgs );
   (*env)->ReleaseStringUTFChars(env, jsServiceShortName, sServiceShortName );
   return errorcode;
}

/*
 * Class:     NTServices
 * Method:    stop
 * Signature: (Ljava/lang/String;II)I
 */
JNIEXPORT jint JNICALL Java_com_cannontech_tdc_windows_JNTServices_stop
(JNIEnv *env, jobject jobj, jstring jsServiceShortName, jint iNumberOfRetries, jint iTimeoutInms, jstring jsMachineName )
{
	SC_HANDLE myService, scm;
	SERVICE_STATUS status;
	int counter=(int) iNumberOfRetries;
	BOOL stopped=FALSE; 
	int errorcode=0; // 0=success
	//
	// Move all the args into the appropriate variables
	//
	const char *sServiceShortName = (*env)->GetStringUTFChars(env, jsServiceShortName, 0);

	//
	// Open a Service Control Manager connection
	//
	scm = OpenSCManager(
            (jsMachineName == NULL ? NULL : (LPCTSTR) (*env)->GetStringUTFChars(env, jsMachineName, 0)),
            NULL,
            SC_MANAGER_CREATE_SERVICE);

	if (!scm)
	{
		// cerr << "OpenSCManager Fails!" << GetLastError() << endl;
		errorcode=GetLastError();
	}
	else
	{
		while( counter >= 0 && errorcode == 0 && stopped != TRUE )
		{				
			printf( "Looping trying to stop service [%d/%d].\n",counter,iNumberOfRetries );				
			//
			// Get the service's handle
			//
			myService = OpenService(scm, (LPCTSTR) sServiceShortName, SERVICE_ALL_ACCESS | DELETE);
			if (!myService)
			{
				errorcode=GetLastError();
				printf( "OpenService Fails! %d, doesnotexist=%d", errorcode, ERROR_SERVICE_DOES_NOT_EXIST );
			}	
			else
			{
				//
				// Stop the service
				//
				DWORD          dwCheckPoint = 0xFFFFFFFF;
				DWORD          dwStartTime = GetCurrentTime();
				if( ControlService(myService, SERVICE_CONTROL_STOP, &status ) )
				{
					//
					// Loop until we've succeeded or timed out
					//
					//fprintf( stderr, "Current state; %d\n", status.dwCurrentState );
					//printf("[1]Current state; %d\n", status.dwCurrentState );
					while( (status.dwCurrentState != SERVICE_STOPPED ) &&
							((GetCurrentTime() - dwStartTime) < (DWORD)iTimeoutInms))
					{
						//fprintf( stderr, "Current state; %d\n", status.dwCurrentState );
						//printf("[2]Current state; %d\n", status.dwCurrentState );
						if( dwCheckPoint == status.dwCheckPoint )
						{ 
							// Give up--check point hasn't been incremented
							break;
						}
						dwCheckPoint = status.dwCheckPoint;	
						Sleep(status.dwWaitHint);
						QueryServiceStatus( myService, &status);
						printf( "Waiting for %s service to stop.", sServiceShortName );
					}
					
					if( status.dwCurrentState == SERVICE_STOPPED )
					{
						//
						// service stopped, end the loop
						//
						stopped=TRUE;
					}
				}
				else
				{		
					errorcode=GetLastError();					
					if( errorcode == ERROR_SERVICE_NOT_ACTIVE )
					{						
						stopped=TRUE;
					}
					else
					{
						//printf( "Could not call ControlService status=%d\n",errorcode );
					}
				}
			}	
			CloseServiceHandle(myService);
			counter--;
		}
	}	
	
	if( stopped != TRUE && errorcode == 0 )
	{
		errorcode = -1;
	}
	CloseServiceHandle(scm);	
	(*env)->ReleaseStringUTFChars(env, jsServiceShortName, sServiceShortName );
	return errorcode;   
}

/*
 * Class:     NTServices
 * Method:    install
 * Signature: (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_com_cannontech_tdc_windows_JNTServices_install
(JNIEnv *env, jobject jobj, jstring jsServiceShortName, jstring jsServiceFullName, jstring jsEXEPath, jint iStartType, jstring jsMachineName )
{
	SC_HANDLE myService, scm;
	int errorcode = 0; // 0=success
	DWORD dwStartType=SERVICE_DEMAND_START;

	//
	// Move all the args into the appropriate variables
	//
	const char *sServiceShortName = (*env)->GetStringUTFChars(env, jsServiceShortName, 0);
	const char *sServiceFullName = (*env)->GetStringUTFChars(env, jsServiceFullName, 0);
	const char *sEXEPath = (*env)->GetStringUTFChars(env, jsEXEPath, 0);

	dwStartType = (DWORD) iStartType;	
		
	//
	// open a connection to the SCM
	//
	scm = OpenSCManager(
             (jsMachineName == NULL ? NULL : (LPCTSTR) (*env)->GetStringUTFChars(env, jsMachineName, 0)),             
             NULL, SC_MANAGER_CREATE_SERVICE);

	if (!scm)
	{		
		errorcode = GetLastError();
		//fprintf(stderr,"(%s) OpenSCManager fails! last error; %d",sServiceShortName,errorcode);
	}
	else
	{
		// cout << "Opened Service Control Manager...\n";

		//
		// Install the new service
		//
		myService = CreateService(
							scm,
							(LPCTSTR) sServiceShortName, // the internal service name used by the SCM
							(LPCTSTR) sServiceFullName,  // the external label seen in the Service Control applet
							SERVICE_ALL_ACCESS,  // We want full access to control the service
							SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS,  // The service is a single app and not a driver
							dwStartType,  // The service will be started by us manually
							SERVICE_ERROR_NORMAL,  // If error during service start, don't misbehave.
							(LPCTSTR) sEXEPath,
							0,
							0,
							0,
							0,
							0);

		//
		// Did we succeed
		//
		if (!myService)
		{
			//fprintf( stderr, "(%s) Last error; %d",sServiceShortName,GetLastError() );
			errorcode = GetLastError();
		}
		else
		{
			//fprintf( stderr, "%s service successfully installed.\n", sServiceShortName );
		}
   }
	//
	// clean up
	//
	CloseServiceHandle(myService);
	CloseServiceHandle(scm);	
	(*env)->ReleaseStringUTFChars(env, jsServiceShortName, sServiceShortName );	
	(*env)->ReleaseStringUTFChars(env, jsServiceFullName, sServiceFullName );	
	(*env)->ReleaseStringUTFChars(env, jsEXEPath, sEXEPath );
	return (jint) errorcode;
}

/*
 * Class:     NTServices
 * Method:    uninstall
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_com_cannontech_tdc_windows_JNTServices_uninstall
(JNIEnv *env, jobject jobj, jstring jsServiceShortName, jstring jsMachineName)
{
	
   SC_HANDLE myService, scm;
   BOOL success;
   SERVICE_STATUS status;
   int errorcode=0; // 0=success

   //
   // Move all the args into the appropriate variables
   //
   const char *sServiceShortName = (*env)->GetStringUTFChars(env, jsServiceShortName, 0);

   //
   // Open a Service Control Manager connection
   //
   scm = OpenSCManager(
            (jsMachineName == NULL ? NULL : (LPCTSTR) (*env)->GetStringUTFChars(env, jsMachineName, 0)),
            NULL,
            SC_MANAGER_CREATE_SERVICE);

   if (!scm)
   {
//       cerr << "OpenSCManager Fails!" << GetLastError() << endl;
	  errorcode = GetLastError();
   }
   else
   {
	
		//
		// Get the service's handle
		//
		myService = OpenService(scm, (LPCTSTR) sServiceShortName, SERVICE_ALL_ACCESS | DELETE);
		if (!myService)
		{
			// cerr << "OpenService Fails!" << GetLastError() << endl;
			errorcode = GetLastError();
		}
		else
		{
			//
			// it's necessary to stop it first
			//
			success = QueryServiceStatus(myService, &status);
			if (!success)
			{
//				cerr << "QueryServiceStatus fails!" << GetLastError() << endl;
				errorcode = GetLastError();
			}
			else
			{
				if (status.dwCurrentState != SERVICE_STOPPED)
				{	
					//
					// Stop service first
					//
//					cerr << "Service '" << sServiceShortName << "' is not stopped." << endl;
					errorcode = -1;
				}
				else
				{
					//
					// Delete the service
					//
					success = DeleteService(myService);
					if (!success)
					{
						// cerr << "DeleteService Fails!" << GetLastError() << endl;
						errorcode = GetLastError();
					}
				}
			}
		}
   }
	
   //
   // close down what we've used
   //
   CloseServiceHandle(myService);
   CloseServiceHandle(scm);
   return (jint) errorcode;	
}

/*
 * Class:     NTServices
 * Method:    getStatus
 * Signature: (Ljava/lang/String;)I
 */
JNIEXPORT jint JNICALL Java_com_cannontech_tdc_windows_JNTServices_getStatus
(JNIEnv *env, jobject jobj, jstring jsServiceShortName, jstring jsMachineName )
{
   SC_HANDLE myService, scm;
   BOOL success;
   SERVICE_STATUS status;
   int errorcode=0; // 0=success
   int returnStatus=0;

   //
   // Move all the args into the appropriate variables
   //
   const char *sServiceShortName = (*env)->GetStringUTFChars(env, jsServiceShortName, 0);

   //
   // Open a Service Control Manager connection
   //
   scm = OpenSCManager(
            (jsMachineName == NULL ? NULL : (LPCTSTR) (*env)->GetStringUTFChars(env, jsMachineName, 0)),
            NULL, 
            SC_MANAGER_CREATE_SERVICE);

   if (!scm)
   {
	  errorcode = GetLastError();
   }
   else
   {
	
		//
		// Get the service's handle
		//
		myService = OpenService(scm, (LPCTSTR) sServiceShortName, SERVICE_ALL_ACCESS | DELETE);
		if (!myService)
		{
			errorcode = GetLastError();
		}
		else
		{
			//
			// it's necessary to stop it first
			//
			success = QueryServiceStatus(myService, &status);
			if (!success)
			{
				errorcode = GetLastError();
			}
			else
			{
				returnStatus = status.dwCurrentState;
			}
		}
   }
	
   //
   // If we've failed to retrieve the status then return the errorcode, butmultiply it with -1 to distinguish it from the status codes.
   //
   if( errorcode != 0 )
   {
	   returnStatus = errorcode * -1;
   }

   //
   // close down what we've used
   //
   CloseServiceHandle(myService);
   CloseServiceHandle(scm);

   return (jint) returnStatus;	
}

/*
 * Class:     NTServices
 * Method:    getAllServices
 * Signature: (Ljava/lang/String;I[Ljava/lang/String;)I
 */
JNIEXPORT jobjectArray JNICALL Java_com_cannontech_tdc_windows_JNTServices_getAllServices
(JNIEnv *env, jobject jobj, jstring jsMachineName ){
 
	jobjectArray ret;
	unsigned iIndex=0;

	SC_HANDLE hHandle = OpenSCManager( 
        (jsMachineName == NULL ? NULL : (LPCTSTR) (*env)->GetStringUTFChars(env, jsMachineName, 0)),
            NULL, 
            SC_MANAGER_ALL_ACCESS);
	
    ENUM_SERVICE_STATUS service;
    
    DWORD dwBytesNeeded = 0;
    DWORD dwServicesReturned = 0;
    DWORD dwResumedHandle = 0;
    DWORD dwServiceType = SERVICE_WIN32 | SERVICE_DRIVER;

    // Query services
    BOOL retVal = EnumServicesStatus(
            hHandle, 
            dwServiceType, 
            SERVICE_STATE_ALL, 
            &service, 
            sizeof(ENUM_SERVICE_STATUS), 
            &dwBytesNeeded, 
            &dwServicesReturned,
            &dwResumedHandle);


    if (!retVal) {
        // Need big buffer
        if (ERROR_MORE_DATA == GetLastError()) {
            // Set the buffer
            DWORD dwBytes = sizeof(ENUM_SERVICE_STATUS) + dwBytesNeeded;
            ENUM_SERVICE_STATUS* pServices = NULL;
            pServices = malloc( sizeof( ENUM_SERVICE_STATUS ) * dwBytes );

            // Now query again for services
            EnumServicesStatus(
                  hHandle, 
                  SERVICE_WIN32 | SERVICE_DRIVER, //type
                  SERVICE_STATE_ALL,   //state
                  pServices,
                  dwBytes,
                  &dwBytesNeeded,
                  &dwServicesReturned,
                  &dwResumedHandle);

            // now traverse each service to get information			
			ret = (jobjectArray) (*env)->NewObjectArray( env,
					(jsize) dwServicesReturned, 
					(*env)->FindClass( env, "java/lang/String"),
					(*env)->NewStringUTF(env,"")
					);
			
            for ( iIndex = 0; iIndex < dwServicesReturned; iIndex++) {                
                // cout << TEXT("Display Name") << (pServices + iIndex)->lpDisplayName << TEXT('\t');
                // cout << TEXT("Service Name") << (pServices + iIndex)->lpServiceName << endl;                                    
				// fprintf( stderr, "Service[%d]; %s \n",iIndex, (pServices + iIndex)->lpServiceName );

               
               QUERY_SERVICE_CONFIG ptrCfg;
               SC_HANDLE scHandle = OpenService( hHandle, (pServices + iIndex)->lpServiceName, SC_MANAGER_ALL_ACCESS );
               BOOL b = QueryServiceConfig(scHandle,&ptrCfg,sizeof(QUERY_SERVICE_CONFIG),&dwBytesNeeded );

                
               DWORD dwBytesQ = sizeof(QUERY_SERVICE_CONFIG) + dwBytesNeeded;
               QUERY_SERVICE_CONFIG* pCfg = malloc( sizeof( QUERY_SERVICE_CONFIG ) * dwBytesQ );

               BOOL be = QueryServiceConfig(
                           scHandle,
                           pCfg,
                           dwBytesQ,
                           &dwBytesNeeded );




               char *tmpbuf = (char*) malloc( strlen( (pServices + iIndex)->lpDisplayName ) + strlen( (pServices + iIndex)->lpServiceName ) + strlen( (pCfg)->lpLoadOrderGroup ) + 10 );
			   sprintf( tmpbuf, "%s|%s|%d|%d|%s", 
                           (pServices + iIndex)->lpDisplayName, 
                           (pServices + iIndex)->lpServiceName,
                           (pServices + iIndex)->ServiceStatus.dwServiceType,
                           (pServices + iIndex)->ServiceStatus.dwCurrentState,
                           (pCfg)->lpLoadOrderGroup );
				
				(*env)->SetObjectArrayElement( env, 
											ret, 
											iIndex, 
											(*env)->NewStringUTF( env, 
															      tmpbuf
															    ) 
											);
            }

            free( pServices );
            pServices = 0;

        }
        // there is any other reason
        else {
            // ErrorDescription(GetLastError());
			//fprintf( stderr, "Error; %d\n", GetLastError() );
        }
    }

    if (!CloseServiceHandle(hHandle)) {
        // ErrorDescription(GetLastError());
		//fprintf( stderr, "Error; %d\n", GetLastError() );
    }
    else {
        // cout << "Close SCM sucessfully" << endl;
		//fprintf( stderr, "Closed SCM successfully\n" );
    }

    return ret;
}


#ifdef __cplusplus
}
#endif
#endif

