<?xml version="1.0" encoding="UTF-8"?>
<?PowerDesigner AppLocale="UTF16" Code="INFORMIX9" Family="INFORMIX" Name="INFORMIX SQL 9.x" signature="XDB_XML" version="12.0.0.1642"?>
<!-- do not edit this file -->

<DBMS xmlns:a="attribute" xmlns:c="collection" xmlns:o="object">

<o:DBMS Id="o1">
<a:ObjectID>6EE87B23-1381-4E35-B5E5-271248D82ACC</a:ObjectID>
<a:Name>INFORMIX SQL 9.x</a:Name>
<a:Code>INFORMIX9</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1031818156</a:ModificationDate>
<a:Modifier>psitja</a:Modifier>
<a:Family>INFORMIX</a:Family>
<a:CheckGlobalScript>&#39;******************************************************************************
&#39;* Purpose:  This VB-Script holds global definitions shared by all the custom-
&#39;*            checks scripts of the model extension.
&#39;******************************************************************************

Option Explicit &#39; This is to ensure all used variables are defined

</a:CheckGlobalScript>
<c:Categories>
<o:TargetCategory Id="o2">
<a:Name>General</a:Name>
<a:Comment>Target DBMS identification</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o3">
<a:Name>SqlSupport</a:Name>
<a:Comment>SQL syntax allowed. This does not impact the script generation, but it impacts the SQL Preview</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o4">
<a:Name>EnableCheck</a:Name>
<a:Comment>Determines if the generation of check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o5">
<a:Name>Enableconstname</a:Name>
<a:Comment>Determines if constraint names are used during the generation</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o6">
<a:Name>UniqConstName</a:Name>
<a:Comment>Determines if unique constraint names for objects are authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o7">
<a:Name>EnableMultiCheck</a:Name>
<a:Comment>Determines if the generation of multiple check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o8">
<a:Name>Script</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the Script generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o9">
<a:Name>Sql</a:Name>
<a:Comment>Contains sub-categories Syntax, Format, File and Keywords. Each sub-category contains entries whose values define general syntax for the database</a:Comment>
<c:Categories>
<o:TargetCategory Id="o10">
<a:Name>Syntax</a:Name>
<a:Comment>Contains general parameters for SQL syntax</a:Comment>
<c:Categories>
<o:CharacterTargetItem Id="o11">
<a:Name>Terminator</a:Name>
<a:Comment>End of command character</a:Comment>
<a:CharacterTargetItem.Value>;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o12">
<a:Name>BlockTerminator</a:Name>
<a:Comment>End of block character</a:Comment>
<a:StringTargetItem.Value>/</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:CharacterTargetItem Id="o13">
<a:Name>Delimiter</a:Name>
<a:Comment>Field separation character. Example: col1, col2, col3</a:Comment>
<a:CharacterTargetItem.Value>,</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o14">
<a:Name>Quote</a:Name>
<a:Comment>Character used to enclose string values</a:Comment>
<a:CharacterTargetItem.Value>&quot;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o15">
<a:Name>SqlContinue</a:Name>
<a:Comment>Continuation character</a:Comment>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o16">
<a:Name>LineComment</a:Name>
<a:Comment>Characters used to enclose a single line comment</a:Comment>
<a:StringTargetItem.Value>--</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o17">
<a:Name>BlockComment</a:Name>
<a:Comment>Characters used to enclose a multi-line comment</a:Comment>
</o:StringTargetItem>
<o:TextTargetItem Id="o18">
<a:Name>UsingBlockTerm</a:Name>
<a:TextTargetItem.Value>create function, end function, 1
create procedure, end procedure, 1</a:TextTargetItem.Value>
<a:Comment>List of objects using block definition during reverse.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o19">
<a:Name>Format</a:Name>
<a:Comment>Contains entries that define script formatting</a:Comment>
<c:Categories>
<o:StringTargetItem Id="o20">
<a:Name>IllegalChar</a:Name>
<a:Comment>Invalid characters for names</a:Comment>
<a:StringTargetItem.Value>&quot; +-*/!=&lt;&gt;&#39;&quot;()&amp;~#{[|^@]Â°}$Â£Â¤%Âµ,?;.:Â§&quot;</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o21">
<a:Name>UpperCaseOnly</a:Name>
<a:Comment>Uppercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o22">
<a:Name>LowerCaseOnly</a:Name>
<a:Comment>Lowercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o23">
<a:Name>EnableOwnerPrefix</a:Name>
<a:Comment>Object codes can have a prefix made of the object owner code</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o24">
<a:Name>File</a:Name>
<a:Comment>Contains header, footer and usage text entries used during the generation</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o25">
<a:Name>Header</a:Name>
<a:Comment>Header text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o26">
<a:Name>Footer</a:Name>
<a:Comment>Footer text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o27">
<a:Name>EnableMultiFile</a:Name>
<a:Comment>Multi-script allowed</a:Comment>
</o:BooleanTargetItem>
<o:StringTargetItem Id="o28">
<a:Name>ScriptExt</a:Name>
<a:Comment>Main script extension in database generation</a:Comment>
<a:StringTargetItem.Value>sql</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o29">
<a:Name>TableExt</a:Name>
<a:Comment>Other scripts extension in database generation</a:Comment>
<a:StringTargetItem.Value>tab</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o30">
<a:Name>StartCommand</a:Name>
<a:Comment>Command for executing a script</a:Comment>
<a:StringTargetItem.Value>isql %NAMESCRIPT%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o31">
<a:Name>Usage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Run the database creation script:
        isql - &lt; %NAMESCRIPT%</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in database generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o32">
<a:Name>Usage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Run the database creation scripts:
        isql - &lt; &lt;script_name&gt;</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in database generation</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o33">
<a:Name>TriggerExt</a:Name>
<a:Comment>Script file extension in triggers and procedures generation</a:Comment>
<a:StringTargetItem.Value>trg</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o34">
<a:Name>TrgUsage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Execute the trigger creation script</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o35">
<a:Name>TrgUsage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Execute the triggers creation scripts</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o36">
<a:Name>Keywords</a:Name>
<a:Comment>Contains the list of reserved words and functions available in SQL</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o37">
<a:Name>ReservedDefault</a:Name>
<a:TextTargetItem.Value>USER
CURRENT
NULL
TODAY
SITENAME
DBSERVERNAME</a:TextTargetItem.Value>
<a:Comment>Reserved default values</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o38">
<a:Name>GroupFunc</a:Name>
<a:TextTargetItem.Value>avg()
count()
max()
min()
sum()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions to use with group keywords.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o39">
<a:Name>NumberFunc</a:Name>
<a:TextTargetItem.Value>abs()
acos()
asin()
atan()
atan2()
cos()
exp()
hex()
logn()
log10()
mod()
pow()
round()
sin()
sqrt()
tan()
trunc()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used on numbers</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o40">
<a:Name>CharFunc</a:Name>
<a:TextTargetItem.Value>length()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for characters and strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o41">
<a:Name>DateFunc</a:Name>
<a:TextTargetItem.Value>current
date()
day()
extend()
mdy()
month()
today
units
weekday()
year()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for dates</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o42">
<a:Name>ConvertFunc</a:Name>
<a:TextTargetItem.Value>trim()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used to convert values between hex and integer and handling strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o43">
<a:Name>OtherFunc</a:Name>
<a:TextTargetItem.Value>dbinfo()
rowid
user</a:TextTargetItem.Value>
<a:Comment>List of other SQL functions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o44">
<a:Name>ListOperators</a:Name>
<a:TextTargetItem.Value>||
=
!=
&lt;&gt;
&gt;
&lt;
&gt;=
&lt;=
*=
=*
not
in
not in
between
not between
exists
not exists
like
not like
matches
not matches
is
is not
= any
!= any
&gt; any
&lt; any
&gt;= any
&lt;= any
= all
!= all
&gt; all
&lt; all
&gt;= all
&lt;= all</a:TextTargetItem.Value>
<a:Comment>List of operators for comparing values, boolean, and various semantic operators</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o45">
<a:Name>Commit</a:Name>
<a:TextTargetItem.Value>commit</a:TextTargetItem.Value>
<a:Comment>Command for validating the transaction by OBDC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o46">
<a:Name>ReservedWord</a:Name>
<a:TextTargetItem.Value>ABSOLUTE
ACCESS
ACCESS_METHOD
ADD
AFTER
AGREGATE
ALIGNMENT
ALL
ALL_ROWS
ALLOCATE
ALTER
AND
ANSI
ANY
APPEND
AS
ASC
AT
ATTACH
AUDIT
AUTHORIZATION
AUTO
AUTOFREE
AVG
BEFORE
BEGIN
BETWEEN
BINARY
BOOLEAN
BOTH
BUFFERED
BUILTIN
BY
BYTE
CACHE
CALL
CANNOTHASH
CARDINALITY
CASCADE
CASE
CAST
CHAR
CHAR_LENGTH
CHARACTER
CHARACTER_LENGTH
CHECK
CLASS
CLIENT
CLOSE
CLUSTER
CLUSTERSIZE
COARSE
COBOL
CODESET
COLLECTION
COLUMN
COMMIT
COMMITTED
COMMUTATOR
CONCURRENT
CONNECT
CONNECTION
CONST
CONSTRAINT
CONSTRAINTS
CONSTRUTOR
CONTINUE
COPY
COSTFUNC
COUNT
CRCOLS
CREATE
CURRENT
CURSOR
DATABASE
DATAFILES
DATASKIP
DATE
DATETIME
DAY
DBA
DBDATE
DBMONEY
DBPASSWORD
DEALLOCATE
DEBUG
DEC
DET_T
DECIMAL
DECLARE
DECODE
DEFAULT
DEFERRED
DEFERRED_PREPARE
DEFINE
DELAY
DELETE
DELIMITER
DELUXE
DEREF
DESC
DESCRIBE
DESCRIPTOR
DETACH
DIAGNOSTIC
DIRTY
DISABLED
DISCONNECT
DISTINCT
DISTRIBUTIONS
DOCUMENT
DOMAIN
DORMANT
DOUBLE
DROP
DTIME_T
EACH
ELIF
ELSE
ENABLED
END
ENUM
ENVIRONNEMENT
ERROR
ESCAPE
EXCEPTION
EXCLUSIVE
EXEC
EXECUTE
EXISTS
EXIT
EXPLAIN
EXPLICIT
EXPRESS
EXPRESSION
EXTEND
EXTENT
EXTERN
EXTERNAL
FAR
FETCH
FILE
FILLFACTOR
FILTERING
FIRST
FIRST_ROWS
FIXCHAR
FIXED
FLOAT
FLUSH
FOR
FOREACH
FOREIGN
FORMAT
FORTRAN
FOUND
FRACTION
FRAGMENT
FREE
FROM
FUNCTION
GENERAL
GET
GK
GLOBAL
GO
GOTO
GRANT
GROUP
HANDLESNULL
HASH
HAVING
HIGH
HOLD
HOUR
HYBRID
IF
IFX_INST_T
IFX_LO_CREATE_SPEC_T
IFX_LO_STATE_T
IMMEDIATE
IMPLICIT
IN
INDEX
INDEXES
INDICATOR
INFORMIX
INIT
INITCAP
INNER
INSERT
INT
INT8
INTEG
INTEGER
INTERNAL
INTERNALLENGTH
INTERVAL
INTO
INTRVL_T
IS
ISOLATION
ITEM
ITERATOR
JOIN
KEEP
KEY
LABELEQ
LABELGE
LABELGLB
LABELGT
LABELLE
LABELLT
LABELLUB
LABELTOSTRING
LANGUAGE
LAST
LEADING
LEFT
LET
LEVEL
LIKE
LISTING
LOC_T
LOCAL
LOCATOR
LOCK
LOCKS
LOG
LONG
LOW
LOWER
LVARCHAR
MATCHES
MAX
MAXERRORS
MAXLEN
MDY
MEDIAN
MEDIUM
MEMORY_RESIDENT
MIDDLE
MIN
MINUTE
MODE
MODERATE
MODIFY
MODULE
MONEY
MONTH
MOUNTING
MULTISET
NAME
NCHAR
NEGATOR
NEW
NEXT
NO
NON_RESIDENT
NONE
NORMAL
NOT
NOTEMPLATEARG
NULL
NUMERIC
NVARCHAR
NVL
OCTET_LENGTH
OF
OFF
OLD
ON
ONLY
OPAQUE
OPCLASS
OPEN
OPERATIONAL
OPTICAL
OPTIMIZATION
OPTION
OR
ORDER
OUT
OUTER
PAGE
PARALLELIZABLE
PARAMETER
PASCAL
PASSEDBYVALUE
PDQPRIORITY
PERCALLCOST
PLI
PLOAD
PRECISION
PREPARE
PREVIOUS
PRIMARY
PRIOR
PRIVATE
PRIVILEGES
PROCEDURE
PUBLIC
PUT
RAISE
RANGE
ROW
READ
REAL
RECORDEND
RECOVER
REF
REFERENCES
REFERENCING
REGISTER
REJECTFILE
RELATIVE
RELEASE
REMAINDER
RENAME
REOPTIMIZATION
REPEATABLE
REPLICATION
RESERVE
RESOLUTION
RESOURCE
RESTRICT
RESUME
RETAIN
RETURN
RETURNING
RETURNS
REVOKE
ROBIN
ROLE
ROLLBACK
ROLLFORWARD
ROUND
ROUTINE
ROW
ROWID
ROWIDS
ROWS
SAMEAS
SAMPLES
SCHEDULE
SCHEMA
SCRATCH
SCROLL
SECOND
SECONDARY
SECTION
SELCONST
SELECT
SELFUNC
SERIAL
SERIAL_T
SERIALIZABLE
SESSION
SET
SHARE
SHORT
SIGNED
SIZE
SKALL
SKINHIBIT
SKSHOW
SMALLFLOAT
SMALLINT
SOME
SPECIFIC
SQL
SQLCODE
SQLERROR
SQLWARNING
STABILITY
STACK
STANDARD
START
STATIC
STATISTICS
STDEV
STEP
STOP
STRATEGY
STRINGTOLABEL
STRUCT
STYLE
SUBSTR
SUBSTRING
SUM
SUPPORT
SYNC
SYNONYM
SYSTEM
TABLE
TEMP
TEXT
THEN
TIME
TIMEOUT
TO
TODAY
TRACE
TRAILING
TRANSACTION
TRIGGER
TRIGGERS
TRIM
TYPE
TYPEDEF
UNCOMMITTED
UNDER
UNION
UNIQUE
UNITS
UNLOCK
UNSIGNED
UPDATE
UPPER
USAGE
USER
USING
VALUE
VALUES
VAR
VARCHAR
VARIABLE
VARIANCE
VARIANT
VARYING
VIEW
VIOLATIONS
WAIT
WARNING
WHEN
WHENEVER
WHERE
WHILE
WITH
WITHOUT
WORK
WRITE
XLOAD
XUNLOAD
YEAR
</a:TextTargetItem.Value>
<a:Comment>Reserved words</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o47">
<a:Name>Objects</a:Name>
<a:Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:Comment>
<c:Categories>
<o:TargetCategory Id="o48">
<a:Name>Table</a:Name>
<a:Code>TABL</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLE&quot;        // generated code of the table
   &quot;TNAME&quot;        // name of the table
   &quot;TCODE&quot;        // code of the table
   &quot;TLABL&quot;        // comment of the table
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;TABLDEFN&quot;     // complete body of the table definition. Contains definition of columns, checks and keys
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o49">
<a:Name>Enable</a:Name>
<a:Comment>Table allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o50">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o51">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKT_%.U14:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for check of table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o52">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%CLASS% ?
create table [%QUALIFIER%]%TABLE% of type [%CLASSQUALIFIER%]%CLASS% [%TABLDEFN% ? (
%TABLDEFN%
)
[%OPTIONS%]]
:
create table [%QUALIFIER%]%TABLE% [%TABLDEFN% ? (
%TABLDEFN%
)
[%OPTIONS%]]
]
</a:TextTargetItem.Value>
<a:Comment>Command for creating a table. Example: create table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o53">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with crcols
in %s : category=storage
&lt;fragment_by&gt; : composite=yes
{
with rowids
fragment by round robin in : composite=yes, separator=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
fragment by expression : composite=yes, separator=yes
{
&lt;expression_list&gt; : composite=yes, multiple=yes
{
&lt;expression&gt; %s : nextmand=yes
in %s : category=storage
}
remainder in %s : category=storage
}
fragment by hash : composite=yes
{
&lt;column_list&gt; : composite=yes, separator=yes, parenthesis=yes
{
&lt;column&gt; %s : multiple=yes
}
in : composite=yes, separator=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
}
fragment by hybrid : composite=yes
{
&lt;column_list&gt; : composite=yes, separator=yes, parenthesis=yes
{
&lt;column&gt; %s : multiple=yes
}
expression : composite=yes, separator=yes
{
&lt;expression_list&gt; : composite=yes, multiple=yes
{
&lt;expression&gt; %s : nextmand=yes
in : composite=yes
{
&lt;dbspace&gt; %s : category=storage
&lt;multiple_dbspace&gt; : composite=yes, separator=yes, parenthesis=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
}
}
}
&lt;hybrid_range&gt; : composite=yes
{
&lt;range&gt; : composite=yes, parenthesis=yes
{
range : composite=yes, parenthesis=yes
{
&lt;column&gt; %s
min %s
max %s
}
}
range : composite=yes, parenthesis=yes
{
&lt;column&gt; %s
min %s
max %s
}
in : composite=yes, separator=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
}
remainder in : composite=yes, separator=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
}
fragment by range : composite=yes
{
&lt;column_range&gt; : composite=yes, parenthesis=yes
{
&lt;column&gt; %s
min %s
max %s
}
in : composite=yes, separator=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
remainder in %s : category=storage
}
}
put : composite=yes, separator=yes
{
&lt;list&gt; : composite=yes, multiple=yes
{
&lt;column&gt; %s : nexmand=yes
in : composite=yes, separator=yes, parenthesis=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
&lt;option&gt; : composite=yes, parenthesis=yes, separator=yes
{
extent size %s
&lt;logging&gt; %s : list=log|no log, default=no log
high integ
&lt;access time&gt; %s : list=keep access time|no keep access time, default=no keep access time
}
}
}
&lt;extent_options&gt; : composite=yes
{
extent size %d
next size %d
}
lock mode %s : list=page|row|table, default=page
using %s : composite=yes, parenthesis=yes, separator=yes, default=B-tree
{
&lt;parameter_and_value&gt; %s : multiple=yes
}</a:TextTargetItem.Value>
<a:Comment>Available options for creating a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o54">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for table options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o55">
<a:Name>TableComment</a:Name>
<a:Comment>Command for adding a table comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o56">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop table [%QUALIFIER%]%TABLE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table. Example: drop table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o57">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>rename table [%OLDQUALIFIER%]%OLDTABL% to %NEWTABL%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o58">
<a:Name>AlterTableHeader</a:Name>
<a:Comment>Alter table header</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o59">
<a:Name>AlterTableFooter</a:Name>
<a:Comment>Alter table footer</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o60">
<a:Name>DropTableCheck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o61">
<a:Name>DefineTableCheck</a:Name>
<a:TextTargetItem.Value>[check (%.A:CONSTRAINT%)
      [constraint [%R%?[%QUALIFIER%]]%CONSTNAME%]]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of table check constraints</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o62">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a table.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>ALTER=Alter
DELETE=Delete
INDEX=Index
INSERT=Insert
REFERENCES=Refer.
SELECT=Select
UPDATE=Update</a:MapTargetItem.Value>
<a:List>ALTER
DELETE
INDEX
INSERT
REFERENCES
SELECT
UPDATE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o63">
<a:Name>SqlListQuery</a:Name>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o64">
<a:Name>AddTableCheck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add constraint check (%.A:CONSTRAINT%)
      [constraint [%R%?[%QUALIFIER%]]%CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script for modifying table constraints within an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o65">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, OPTIONS EX ...}

select
   t.owner,
   t.tabname,
   &#39;in &#39; || trim(dbinfo(&#39;DBSPACE&#39;, t.partnum)) ||
   &#39; extent size &#39; || t.fextsize ||
   &#39; next size &#39; || t.nextsize ||
   &#39; lock mode page &#39;,
   -1
from
   informix.systables t
where 
   t.locklevel in (&#39;P&#39;, &#39;B&#39;)
   and t.partnum != 0
[  and t.owner = %.q:OWNER%]
[  and t.tabname=%.q:TABLE%]
union select
   t.owner,
   t.tabname,
   &#39;in &#39; || trim(dbinfo(&#39;DBSPACE&#39;, t.partnum)) ||
   &#39; extent size &#39; || t.fextsize ||
   &#39; next size &#39; || t.nextsize ||
   &#39; lock mode row &#39;,
   -1
from
   informix.systables t
where 
   t.locklevel in (&#39;R&#39;)
   and t.partnum != 0
[  and t.owner = %.q:OWNER%]
[  and t.tabname=%.q:TABLE%]
union select
   t.owner,
   t.tabname,
   &#39;in &#39; || trim(dbinfo(&#39;DBSPACE&#39;, t.partnum)) ||
   &#39; extent size &#39; || t.fextsize ||
   &#39; next size &#39; || t.nextsize,
   -1
from
   informix.systables t
where 
   t.locklevel not in (&#39;R&#39;, &#39;B&#39;, &#39;P&#39;)
   and t.partnum != 0
[  and t.owner = %.q:OWNER%]
[  and t.tabname=%.q:TABLE%]
union select
   t.owner,
   t.tabname,
   &#39;fragment by %SqlFragQuery.FragType% &#39;,
   -1
from
   informix.systables t
where 
   t.partnum = 0
[  and t.owner = %.q:OWNER%]
[  and t.tabname=%.q:TABLE%]
union select
   t.owner,
   t.tabname,
   &#39;%SqlFragQuery.FragSprt&#39;||f.evalpos||&#39;% %SqlFragQuery.FragExpr&#39;||f.evalpos||&#39;% %SqlFragQuery.FragIn% %SqlFragQuery.FragDbsp&#39;||f.evalpos||&#39;% &#39;,
   f.evalpos
from
   informix.systables t,
   informix.sysfragments f
where 
   t.partnum = 0
   and t.tabid=f.tabid
[  and t.owner = %.q:OWNER%]
[  and t.tabname=%.q:TABLE%]
union select
   t.owner,
   t.tabname,
   &#39; extent size &#39; || t.fextsize ||
   &#39; next size &#39; || t.nextsize ||
   &#39; lock mode page &#39;,
   999
from
   informix.systables t
where 
   t.locklevel in (&#39;P&#39;, &#39;B&#39;)
   and t.partnum = 0
[  and t.owner = %.q:OWNER%]
[  and t.tabname=%.q:TABLE%]
union select
   t.owner,
   t.tabname,
   &#39; extent size &#39; || t.fextsize ||
   &#39; next size &#39; || t.nextsize ||
   &#39; lock mode row &#39;,
   999
from
   informix.systables t
where 
   t.locklevel in (&#39;R&#39;)
   and t.partnum = 0
[  and t.owner = %.q:OWNER%]
[  and t.tabname=%.q:TABLE%]
union select
   t.owner,
   t.tabname,
   &#39; extent size &#39; || t.fextsize ||
   &#39; next size &#39; || t.nextsize,
   999
from
   informix.systables t
where 
   t.locklevel not in (&#39;R&#39;, &#39;B&#39;, &#39;P&#39;)
   and t.partnum = 0
[  and t.owner = %.q:OWNER%]
[  and t.tabname=%.q:TABLE%]
order by 1, 2, 4</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o66">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, CLASS}
SELECT t.owner, t.tabname, x.name
FROM informix.systables t, informix.sysxtdtypes x
WHERE x.mode = &#39;R&#39;
AND t.type_xid = x.extended_id
[  and t.owner = %.q:OWNER%]
[  and t.tabname=%.q:TABLE%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o67">
<a:Name>AllowedADT</a:Name>
<a:TextTargetItem.Value>NAMED ROW TYPE</a:TextTargetItem.Value>
<a:Comment>List of ADT on which a table can be based</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o68">
<a:Name>SqlFragQuery</a:Name>
<a:TextTargetItem.Value>{A, a(E=&quot;expression&quot;, R=&quot;round robin in&quot;, H=&quot;hash&quot;), B, b, C, c, D, d(0=&quot;&quot;, *=&quot;,&quot;), Z, z(R=&quot;&quot;, *=&quot;in &quot;)}

select
   &#39;FragType&#39;, f.strategy,
   &#39;FragDbsp&#39;||f.evalpos, f.dbspace,
   &#39;FragExpr&#39;||f.evalpos, f.exprtext,
   &#39;FragSprt&#39;||f.evalpos, f.evalpos,
   &#39;FragIn&#39;, f.strategy
from
   informix.systables t,
   informix.sysfragments f
where 
   t.partnum = 0
   and f.fragtype=&#39;T&#39;
   and t.tabid=f.tabid
[  and t.owner = %.q:OWNER%]
[  and t.tabname=%.q:TABLE%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse extra physical option data</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o69">
<a:Name>SqlChckQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, CONSTNAME ID, CONSTRAINT ...}

select
   t.owner,
   t.tabname,
   k.constrname,
   v.checktext,
   v.seqno
from
   systables t,
   sysconstraints k,
   syschecks v
where
   t.tabid = k.tabid
   and v.constrid=k.constrid
   and v.type=&#39;T&#39;
[  and t.owner = %.q:OWNER%]
[  and t.tabname=%.q:TABLE%]
order by
   1, 2, 3, 5</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o70">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE, PERMISSION}

select 
p.grantee grantee, 
  decode(substr(p.tabauth,1,1), &#39;s&#39;, &#39;SELECT&#39;, &#39;S&#39;, &#39;SELECT+&#39;, &#39;&#39;) ||&#39;,&#39;||
  decode(substr(p.tabauth,2,1), &#39;u&#39;, &#39;UPDATE&#39;, &#39;U&#39;, &#39;UPDATE+&#39;, &#39;&#39;) ||&#39;,&#39;||
  decode(substr(p.tabauth,4,1), &#39;i&#39;, &#39;INSERT&#39;, &#39;I&#39;, &#39;INSERT+&#39;, &#39;&#39;) ||&#39;,&#39;||
  decode(substr(p.tabauth,5,1), &#39;d&#39;, &#39;DELETE&#39;, &#39;D&#39;, &#39;DELETE+&#39;, &#39;&#39;) ||&#39;,&#39;||
  decode(substr(p.tabauth,6,1), &#39;x&#39;, &#39;INDEX&#39;, &#39;X&#39;, &#39;INDEX+&#39;, &#39;&#39;)  ||&#39;,&#39;||
  decode(substr(p.tabauth,7,1), &#39;a&#39;, &#39;ALTER&#39;, &#39;A&#39;, &#39;ALTER+&#39;, &#39;&#39;)  ||&#39;,&#39;||
  decode(substr(p.tabauth,8,1), &#39;r&#39;, &#39;REFERENCES&#39;, &#39;R&#39;, &#39;REFERENCES+&#39;, &#39;&#39;)
from informix.systables s, informix.systabauth p
where 
  (s.tabname = %.q:TABLE% ) and
[ s.owner = %.q:OWNER% and ]
  (s.tabid = p.tabid)</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o71">
<a:Name>Index</a:Name>
<a:Code>INDX</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
   &quot;INDEX&quot;        // generated code of the index
   &quot;INDEXNAME&quot;    // index name
   &quot;INDEXCODE&quot;    // index code
   &quot;UNIQUE&quot;       // keyword &quot;unique&quot; when the index is unique
   &quot;INDEXTYPE&quot;    // index type (available only for a few DBMS)
   &quot;INDEXKEY&quot;     // keywords &quot;primary&quot;, &quot;unique&quot; or &quot;foreign&quot; depending on the index origin
   &quot;CIDXLIST&quot;     // list of index columns. Eg: A asc, B desc, C asc
   &quot;CLUSTER&quot;      // keyword &quot;cluster&quot; when the index is cluster
For index columns, the following system variables are available:
   &quot;ASC&quot;          // keywords &quot;ASC&quot; or &quot;DESC&quot; depending on sort order
   &quot;ISASC&quot;        // TRUE if the index column sort is ascending
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o72">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o73">
<a:Name>MaxColIndex</a:Name>
<a:Comment>Maximum number of columns in an index</a:Comment>
<a:IntegerTargetItem.Value>16</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o74">
<a:Name>Enable</a:Name>
<a:Comment>Index allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o75">
<a:Name>EnableAscDesc</a:Name>
<a:Comment>ASC, DESC keywords allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o76">
<a:Name>UniqName</a:Name>
<a:Comment>Unique index name in the database</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o77">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [%UNIQUE%] [%CLUSTER%] index [%QUALIFIER%]%INDEX% on [%TABLQUALIFIER%]%TABLE% (
%CIDXLIST%
)
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating an index. Example: create index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o78">
<a:Name>AddColIndex</a:Name>
<a:TextTargetItem.Value>        %20:COLUMN% [%ASC%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an index column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o79">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>using %s : composite=yes, parenthesis=yes, separator=yes, default=B-tree
{
&lt;parameter_and_value&gt; %s : multiple=yes
}
fillfactor %d
in %s : category=storage
&lt;fragment_by&gt; : composite=yes
{
with rowids
fragment by round robin in : composite=yes, separator=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
fragment by expression : composite=yes, separator=yes
{
&lt;expression_list&gt; : composite=yes, multiple=yes
{
&lt;expression&gt; %s : nextmand=yes
in %s : category=storage
}
remainder in %s : category=storage
}
fragment by hash : composite=yes
{
&lt;column_list&gt; : composite=yes, separator=yes, parenthesis=yes
{
&lt;column&gt; %s : multiple=yes
}
in : composite=yes, separator=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
}
fragment by hybrid : composite=yes
{
&lt;column_list&gt; : composite=yes, separator=yes, parenthesis=yes
{
&lt;column&gt; %s : multiple=yes
}
expression : composite=yes, separator=yes
{
&lt;expression_list&gt; : composite=yes, multiple=yes
{
&lt;expression&gt; %s : nextmand=yes
in : composite=yes
{
&lt;dbspace&gt; %s : category=storage
&lt;multiple_dbspace&gt; : composite=yes, separator=yes, parenthesis=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
}
}
}
&lt;hybrid_range&gt; : composite=yes
{
&lt;range&gt; : composite=yes, parenthesis=yes
{
range : composite=yes, parenthesis=yes
{
&lt;column&gt; %s
min %s
max %s
}
}
range : composite=yes, parenthesis=yes
{
&lt;column&gt; %s
min %s
max %s
}
in : composite=yes, separator=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
}
remainder in : composite=yes, separator=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
}
fragment by range : composite=yes
{
&lt;column_range&gt; : composite=yes, parenthesis=yes
{
&lt;column&gt; %s
min %s
max %s
}
in : composite=yes, separator=yes
{
&lt;dbspace&gt; %s : category=storage, multiple=yes
}
remainder in %s : category=storage
}
}
&lt;enability&gt; %s : list=disabled|enabled, default=enabled
filtering %s : list=with error|without error
lock mode %s : list=coarse|normal, default=normal</a:TextTargetItem.Value>
<a:Comment>Default options for creating an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o80">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for index options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o81">
<a:Name>SqlSysIndexQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, INDEX, INDEXKEY}

select
   t.owner, t.tabname, i.idxname, &#39;UNIQUE&#39;
from
   informix.sysindexes i,
   informix.systables t
where
   t.tabid=i.tabid
[   and t.owner=%.q:SCHEMA%]
[   and t.tabname = %.q:TABLE%]
   and i.idxname like &#39; %&#39;
</a:TextTargetItem.Value>
<a:Comment>SQL query to list system indexes created by the database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o82">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop index [%QUALIFIER%]%INDEX%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an index. Example: drop index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o83">
<a:Name>EnableCluster</a:Name>
<a:Comment>Cluster option available for indexes</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o84">
<a:Name>SqlFragQuery</a:Name>
<a:TextTargetItem.Value>{B, b, C, c, D, d(0=&quot;fragment by expression&quot;, *=&quot;,&quot;)}

select
   &#39;FragDbsp&#39;||f.evalpos, f.dbspace,
   &#39;FragExpr&#39;||f.evalpos, f.exprtext,
   &#39;FragSprt&#39;||f.evalpos, f.evalpos
from
   informix.systables t,
   informix.sysfragments f
where 
   t.tabid=f.tabid
   and f.fragtype = &#39;I&#39;
   and f.strategy != &#39;I&#39;
   and f.indexname not like &#39; %&#39;
[  and t.owner = %.q:SCHEMA%]
[  and t.tabname = %.q:TABLE%]
[  and f.indexname = %.q:INDEX%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse extra physical option data</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o85">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER ID, TABLE ID, INDEX ID, OPTIONS EX ...}

select
   t.owner,
   t.tabname,
   f.indexname,
   &#39;%SqlFragQuery.FragSprt&#39;||f.evalpos||&#39;% %SqlFragQuery.FragExpr&#39;||f.evalpos||&#39;% in %SqlFragQuery.FragDbsp&#39;||f.evalpos||&#39;% &#39;,
   f.evalpos
from
   informix.sysfragments f,
   informix.systables t
where 
   t.tabid=f.tabid
   and f.fragtype = &#39;I&#39;
   and f.strategy != &#39;I&#39;
   and f.indexname not like &#39; %&#39;
[  and t.owner = %.q:TABLOWNER%]
[  and t.tabname = %.q:TABLE%]
[  and f.indexname = %.q:INDEX%]
order by 1,2,3,5
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o86">
<a:Name>CreateBeforeKey</a:Name>
<a:Comment>Allow to invert generation order of indexes and keys</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o87">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o88">
<a:Name>Column</a:Name>
<a:Code>COLN</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for columns)
   &quot;COLUMN&quot;       // generated code of the column
   &quot;COLNNO&quot;       // position of the column in the list of columns of the table
   &quot;COLNNAME&quot;     // name of the column
   &quot;COLNCODE&quot;     // code of the column
   &quot;PRIMARY&quot;      // keyword &quot;primary&quot; if the column is primary
   &quot;ISPKEY&quot;       // TRUE if the column is part of the primary key
   &quot;FOREIGN&quot;      // TRUE if the column is part of one foreign key
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o89">
<a:Name>Enable</a:Name>
<a:Comment>Column allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o90">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o91">
<a:Name>EnableDefault</a:Name>
<a:Comment>Default values allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o92">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKC_%.U8:COLUMN%_%.U5:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for a column check parameter</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o93">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[%CLASS% ?
[%NOTNULL% ?
   not null [%R%?constraint %CONSTNAME%] %20:COLUMN%]
:  %20:COLUMN% %30:DATATYPE%[%.6:DATATYPE%=SERIAL?[%ExtSerialStart%=0?:[(%ExtSerialStart%)]]] [default %DEFAULT%] [%NOTNULL%?not null [%R%?constraint %CONSTNAME%]]
      [%CONSTDEFN%]
      [%R%?[%ISPKEY%?primary key [constraint [%R%?[%QUALIFIER%]]%PKNAME%]]]
]</a:TextTargetItem.Value>
<a:Comment>Command for defining a table column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o94">
<a:Name>ColumnComment</a:Name>
<a:Comment>Command for adding a column comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o95">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>rename column [%QUALIFIER%]%TABLE%.%OLDCOLN% to %NEWCOLN%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o96">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table %TABLE%
   add %20:COLUMN% %30:DATATYPE%[%.6:DATATYPE%=SERIAL?[%ExtSerialStart%=0?:[(%ExtSerialStart%)]]] [default %DEFAULT%] [%NOTNULL%?not null [%R%?constraint %CONSTNAME%]]
      [%CONSTDEFN%]
      [%R%?[%ISPKEY%?primary key [constraint [%R%?[%QUALIFIER%]]%PKNAME%]]]
</a:TextTargetItem.Value>
<a:Comment>Command for adding a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o97">
<a:Name>ModifyColumn</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   modify %COLUMN% %DATATYPE% %NOTNULL%</a:TextTargetItem.Value>
<a:Comment>Command for modifying a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o98">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE% drop %COLUMN%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o99">
<a:Name>ModifyColnDflt</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   modify %COLUMN% %DATATYPE% default %DEFAULT%</a:TextTargetItem.Value>
<a:Comment>Command for modifying a column default in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o100">
<a:Name>ModifyColnChck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   modify %COLUMN% %DATATYPE% 
   [%CONSTDEFN%]</a:TextTargetItem.Value>
<a:Comment>Command for modifying a column check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o101">
<a:Name>DropColnChck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE% drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a column check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o102">
<a:Name>AltEnableAddColnChk</a:Name>
<a:Comment>Column check constraint allowed in an alter table statement</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:MapTargetItem Id="o103">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a column.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>REFERENCES=Refer.
SELECT=Select
UPDATE=Update</a:MapTargetItem.Value>
<a:List>REFERENCES
SELECT
UPDATE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o104">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, DOMAIN, ExtSerialStart}

select 
   t.owner,
   t.tabname,
   c.colname,
   d.name,
   decode(c.coltype, 262, h.serialv, 274, h.serialv, NULL)
from
   informix.syscolumns c,
   informix.systables t,
   outer informix.sysxtdtypes d,
   sysmaster:informix.sysptnhdr h
where
   d.extended_id = c.extended_id
   and t.tabid=c.tabid
   and h.partnum = t.partnum
[  and t.owner=%.q:SCHEMA%]
[  and t.tabname=%.q:TABLE%]
[  and c.colname=%.q:COLUMN%]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes
To get approximation of initial value for ExtSerialStart instead of current value, 
just change the &quot;h.serialv&quot; to &quot;(h.serialv - h.nrows)&quot; in the query</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o105">
<a:Name>DefineColnChck</a:Name>
<a:TextTargetItem.Value>[check (%.A:CONSTRAINT%)
      [constraint [%R%?[%QUALIFIER%]]%CONSTNAME%]]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of column check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o106">
<a:Name>AddColnChck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add %COLUMN% %DATATYPE% check (%.A:CONSTRAINT%)
   [constraint [%R%?[%QUALIFIER%]]%CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script for modifying column constraints within an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o107">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, NOTNULL, DATATYPE, DEFAULT}

select
   t.owner, t.tabname, c.colname, 
   case(trunc(c.coltype / 256)) when 0 then &#39;&#39; else &#39;not null&#39; end,
   case(x.name) when null then
      case(mod(c.coltype, 256))
         when 0 then &#39;char&#39;
            ||case(c.collength) when 1 then &#39;&#39; else c.collength::varchar(5) end
         when 1 then &#39;smallint&#39;
         when 2 then &#39;integer&#39;
         when 3 then &#39;float&#39;
         when 4 then &#39;smallfloat&#39;
         when 5 then &#39;decimal&#39;
            ||case(c.collength) when 4351 then &#39;&#39; else &#39;(&#39;||trunc(c.collength / 256)::varchar(5)||case(mod(c.collength, 256)) when 255 then &#39;&#39; else &#39;, &#39;||mod(c.collength, 256)::varchar(5) end||&#39;)&#39; end
         when 6 then &#39;serial&#39;
         when 7 then &#39;date&#39;
         when 8 then &#39;money&#39;
            ||case(c.collength) when 4098 then &#39;&#39; else &#39;(&#39;||trunc(c.collength / 256)::varchar(5)||case(mod(c.collength, 256)) when 255 then &#39;&#39; else &#39;, &#39;||mod(c.collength, 256)::varchar(5) end||&#39;)&#39; end
         when 9 then &#39;null&#39;
         when(10) then &#39;datetime &#39;
            ||case(mod(trunc(c.collength/16, 0), 16)) when 0 then &#39;year&#39; when 2 then &#39;month&#39; when 4 then &#39;day&#39; when 6 then &#39;hour&#39; when 8 then &#39;minute&#39; when 10 then &#39;second&#39; when 11 then &#39;fraction(1)&#39; when 12 then &#39;fraction(2)&#39; when 13 then &#39;fraction(3)&#39; when 14 then &#39;fraction(4)&#39; when 15 then &#39;fraction(5)&#39; else &#39;&#39; end 
            || &#39; to &#39; || case(mod(c.collength, 16))   when 0 then &#39;year&#39; when 2 then &#39;month&#39; when 4 then &#39;day&#39; when 6 then &#39;hour&#39; when 8 then &#39;minute&#39; when 10 then &#39;second&#39; when 11 then &#39;fraction(1)&#39; when 12 then &#39;fraction(2)&#39; when 13 then &#39;fraction(3)&#39; when 14 then &#39;fraction(4)&#39; when 15 then &#39;fraction(5)&#39; else &#39;&#39; end 
         when 11 then &#39;byte&#39;
         when 12 then &#39;text&#39;
         when 13 then &#39;varchar&#39;
            ||case(c.collength) when 257 then &#39;&#39; else &#39;(&#39;||mod(c.collength, 256)::varchar(5)||case(trunc(c.collength / 256)) when 0 then &#39;&#39; else &#39;, &#39;||trunc(c.collength / 256)::varchar(5) end||&#39;)&#39; end
         when(14) then &#39;interval &#39;
            ||case(mod(trunc(c.collength/16, 0), 16)) when 0 then &#39;year&#39; when 2 then &#39;month&#39; when 4 then &#39;day&#39; when 6 then &#39;hour&#39; when 8 then &#39;minute&#39; when 10 then &#39;second&#39; when 11 then &#39;fraction(1)&#39; when 12 then &#39;fraction(2)&#39; when 13 then &#39;fraction(3)&#39; when 14 then &#39;fraction(4)&#39; when 15 then &#39;fraction(5)&#39; else &#39;&#39; end 
            || &#39; to &#39; || case(mod(c.collength, 16))   when 0 then &#39;year&#39; when 2 then &#39;month&#39; when 4 then &#39;day&#39; when 6 then &#39;hour&#39; when 8 then &#39;minute&#39; when 10 then &#39;second&#39; when 11 then &#39;fraction(1)&#39; when 12 then &#39;fraction(2)&#39; when 13 then &#39;fraction(3)&#39; when 14 then &#39;fraction(4)&#39; when 15 then &#39;fraction(5)&#39; else &#39;&#39; end 
         when 15 then &#39;nchar&#39;
            ||case(c.collength) when 1 then &#39;&#39; else c.collength::varchar(5) end
         when 16 then &#39;nvarchar&#39;
            ||case(c.collength) when 257 then &#39;&#39; else &#39;(&#39;||mod(c.collength, 256)::varchar(5)||case(trunc(c.collength / 256)) when 0 then &#39;&#39; else &#39;, &#39;||trunc(c.collength / 256)::varchar(5) end||&#39;)&#39; end
         when 17 then &#39;int8&#39;
         when 18 then &#39;serial8&#39;
         else &#39;&#39; end else x.name end,
   case(d.type) 
      when &#39;U&#39; then &#39;user&#39; 
      when &#39;C&#39; then &#39;current&#39; 
      when &#39;N&#39; then &#39;null&#39; 
      when &#39;T&#39; then &#39;today&#39; 
      when &#39;S&#39; then &#39;dbservername&#39; 
      else case(c.coltype) 
         when 0 then &#39;&#39;&#39;&#39; || trim(d.default) || &#39;&#39;&#39;&#39; 
         when 12 then &#39;&#39;&#39;&#39; || trim(d.default) || &#39;&#39;&#39;&#39; 
         when 13 then &#39;&#39;&#39;&#39; || trim(d.default) || &#39;&#39;&#39;&#39; 
         when 15 then &#39;&#39;&#39;&#39; || trim(d.default) || &#39;&#39;&#39;&#39; 
         when 16 then &#39;&#39;&#39;&#39; || trim(d.default) || &#39;&#39;&#39;&#39; 
         else &#39;&#39;
         end
   end
from
   &quot;informix&quot;.syscolumns c,
   &quot;informix&quot;.systables t,
   outer &quot;informix&quot;.sysxtdtypes x,
   outer &quot;informix&quot;.sysdefaults d
where 
   c.tabid = t.tabid
   and d.tabid = t.tabid
   and d.colno = c.colno
   and c.extended_id = x.extended_id
[  and t.owner = %.q:OWNER%]
[  and t.tabname = %.q:TABLE%]
 </a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o108">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{ GRANTEE ID, COLNPERMISSION ID, COLUMN ...}
select
p.grantee grantee,
decode (substr(p.colauth,1,1), &#39;s&#39;, &#39;SELECT&#39;, &#39;S&#39;, &#39;SELECT+&#39;, &#39;&#39;),
c.colname ||&#39;,&#39;
from informix.systables s, informix.syscolauth p, informix.syscolumns c
where
s.tabname = %.q:TABLE% and
[ s.owner = %.q:OWNER% and ]
s.tabid = p.tabid and
c.tabid = p.tabid and
c.colno = p.colno and
(substr(p.colauth,1,1) = &#39;s&#39; or substr(p.colauth,1,1) =&#39;S&#39;)
union
select
p.grantee grantee,
decode (substr(p.colauth,2,1), &#39;u&#39;, &#39;UPDATE&#39;, &#39;U&#39;, &#39;UPDATE+&#39;, &#39;&#39;),
c.colname ||&#39;,&#39;
from informix.systables s, informix.syscolauth p, informix.syscolumns c
where
s.tabname = %.q:TABLE% and
[ s.owner = %.q:OWNER% and ]
s.tabid = p.tabid and
c.tabid = p.tabid and
c.colno = p.colno and
(substr(p.colauth,2,1) = &#39;u&#39; or substr(p.colauth,2,1) = &#39;U&#39;)
union
select
p.grantee grantee,
decode (substr(p.colauth,3,1), &#39;r&#39;, &#39;REFERENCES&#39;, &#39;R&#39;, &#39;REFERENCES+&#39;, &#39;&#39;),
c.colname ||&#39;,&#39;
from informix.systables s, informix.syscolauth p, informix.syscolumns c
where
s.tabname = %.q:TABLE% and
[ s.owner = %.q:OWNER% and ]
s.tabid = p.tabid and
c.tabid = p.tabid and
c.colno = p.colno and
(substr(p.colauth,3,1) = &#39;r&#39; or substr(p.colauth,3,1) = &#39;R&#39;)
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o109">
<a:Name>Insert</a:Name>
<a:TextTargetItem.Value>alter table %TABLE%
   add %20:COLUMN% %30:DATATYPE%[%.6:DATATYPE%=SERIAL?[%ExtSerialStart%=0?:[(%ExtSerialStart%)]]] [default %DEFAULT%] [%NOTNULL%?not null [%R%?constraint %CONSTNAME%]][
      %CONSTDEFN%][
      %R%?[%ISPKEY%?primary key [constraint [%R%?[%QUALIFIER%]]%PKNAME%]]][
      before %NEXTCOLN%]
</a:TextTargetItem.Value>
<a:Comment>Command for inserting a column</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:IntegerTargetItem Id="o110">
<a:Name>MaxConstLen</a:Name>
<a:Comment>Maximum constraint name length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TargetCategory Id="o111">
<a:Name>User</a:Name>
<a:Code>USER</a:Code>
<a:Comment>The following system variables are available:
   &quot;USER&quot;         // generated code of the user
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o112">
<a:Name>Enable</a:Name>
<a:Comment>User allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o113">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o114">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{USER}

select
   username
from
   informix.sysusers u
where u.usertype &lt;&gt; &#39;G&#39;
[and UPPER(username) = %.qU:SCHEMA%]
order by
   username</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o115">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o116">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{USER ID, PRIVILEGE ...}

select 
   username,
case 
    when ( usertype = &#39;C&#39;) then &#39;CONNECT&#39;
    when ( usertype = &#39;D&#39;) then &#39;DBA&#39;
    when ( usertype = &#39;R&#39;) then &#39;RESOURCE&#39;
end
from 
   informix.sysusers u
where u.usertype &lt;&gt; &#39;G&#39;
order by 
   username
</a:TextTargetItem.Value>
<a:Comment>Query to reverse privileges</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:BooleanTargetItem Id="o117">
<a:Name>EnableOption</a:Name>
<a:Comment>Physical options allowed  YES/NO</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TargetCategory Id="o118">
<a:Name>Reference</a:Name>
<a:Code>REFR</a:Code>
<a:Comment>The following system variables are available:
   &quot;REFR&quot;         // generated code of the reference
   &quot;REFNAME&quot;      // reference name
   &quot;PARENT&quot;       // generated code of the parent table
   &quot;PNAME&quot;        // name of the parent table
   &quot;PCODE&quot;        // code of the parent table
   &quot;CHILD&quot;        // generated code of the reference
   &quot;CNAME&quot;        // name of the child table
   &quot;CCODE&quot;        // code of the child table
   &quot;PQUALIFIER&quot;   // qualifier of the parent table. See QUALIFIER
   &quot;CQUALIFIER&quot;   // qualifier of the child table. See QUALIFIER
   &quot;REFRNAME&quot;     // Reference name
   &quot;REFRCODE&quot;     // Reference code
   &quot;FKCONSTRAINT&quot; // Reference constraint name (foreign key)
   &quot;PKCONSTRAINT&quot; // constraint name of the parent key used to reference object
   &quot;CKEYCOLUMNS&quot;  // list of parent key columns. Eg: C1, C2, C3
   &quot;FKEYCOLUMNS&quot;  // list of child foreign key columns. Eg:
   &quot;UPDCONST&quot;     // Update declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;DELCONST&quot;     // Delete declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;MINCARD&quot;      // Min cardinality
   &quot;MAXCARD&quot;      // Max cardinality
   &quot;POWNER&quot;       // Parent table owner
   &quot;COWNER&quot;       // child table owner
   &quot;CHCKONCMMT&quot;   // TRUE when check on commit is selected on the reference (ASA 6.0 specific)

For reference joins (couple of column in a reference),
the following system variables are available:
   &quot;CKEYCOLUMN&quot;   // generated code of the parent table column (primary key)
   &quot;FKEYCOLUMN&quot;   // generated code of the child table column (foreign key)
   &quot;PK&quot;           // primary key column generated code
   &quot;PKNAME&quot;       // primary key column name
   &quot;FK&quot;           // foreign key column generated code
   &quot;FKNAME&quot;       // foreign key column name
   &quot;AK&quot;           // alternate key column code (same as PK)
   &quot;AKNAME&quot;       // alternate key column name (same as PKNAME)
   &quot;COLTYPE&quot;      // primary column column datatype
   &quot;DEFAULT&quot;      // foreign key column default value
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o119">
<a:Name>Enable</a:Name>
<a:Comment>Foreign key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o120">
<a:Name>FKAutoIndex</a:Name>
<a:Comment>Foreign key is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o121">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>FK_%.U7:REFR%_%.U7:PARENT%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for foreign keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o122">
<a:Name>CheckOnCommit</a:Name>
<a:Comment>Referential integrity test differed after the COMMIT</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o123">
<a:Name>DclDelIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT
CASCADE</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for delete</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o124">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>foreign key (%FKEYCOLUMNS%)
      references [%PQUALIFIER%]%PARENT%[ (%CKEYCOLUMNS%)][%R%? on delete %DELCONST%:[%DELCONST%=RESTRICT? :[ on delete %DELCONST%]]]
      [constraint [%R%?[%S%.]]%CONSTNAME%]
</a:TextTargetItem.Value>
<a:Comment>Command for defining a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o125">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add constraint [%R%?(]foreign key (%FKEYCOLUMNS%)
      references [%PQUALIFIER%]%PARENT%[ (%CKEYCOLUMNS%)][%R%? on delete %DELCONST%:[%DELCONST%=RESTRICT? :[ on delete %DELCONST%]]]
      [constraint [%R%?[%S%.]]%CONSTNAME%][%R%?)]
</a:TextTargetItem.Value>
<a:Comment>Command for adding a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o126">
<a:Name>DclUpdIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for update</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o127">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a foreign key</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o128">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{COWNER, CHILD, FKCONSTRAINT, POWNER, PARENT, PKCONSTRAINT, DELCONST(&#39;R&#39;=&#39;Restrict&#39;, &#39;C&#39;=&#39;Cascade&#39;)}

select 
   c.owner, 
   ct.tabname, 
   c.constrname, 
   pt.owner, 
   pt.tabname,
   rc.constrname,
   r.delrule
from 
   informix.systables pt, 
   informix.systables ct, 
   informix.sysconstraints c, 
   informix.sysreferences r, 
   informix.sysconstraints rc
where
   r.constrid = c.constrid 
   and c.constrtype = &#39;R&#39;
   and c.tabid = ct.tabid
   and r.ptabid = pt.tabid
   and r.primary = rc.constrid
   [and ct.tabname=%.q:TABLE%]
   [and ct.owner=%.q:SCHEMA%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o129">
<a:Name>SqlListChildrenQuery</a:Name>
<a:TextTargetItem.Value>{CKEYCOLUMN, FKEYCOLUMN}

select clp.colname, clf.colname
from
informix.systables t, informix.sysreferences r, informix.sysconstraints csf, informix.sysconstraints csp,
informix.sysindexes ixf, informix.sysindexes ixp, informix.syscolumns clf, informix.syscolumns clp
where
   csf.constrname=%.q:FKCONSTRAINT%   and r.ptabid=t.tabid   and csf.constrid=r.constrid
   and csp.constrid=r.primary   and csf.idxname=ixf.idxname   and csp.idxname=ixp.idxname
   and clf.tabid=ixf.tabid   and clf.colno=ixf.part1   and clp.tabid=ixp.tabid   and clp.colno=ixp.part1
union select clp.colname, clf.colname
from
informix.systables t, informix.sysreferences r, informix.sysconstraints csf, informix.sysconstraints csp,
informix.sysindexes ixf, informix.sysindexes ixp, informix.syscolumns clf, informix.syscolumns clp
where
   csf.constrname=%.q:FKCONSTRAINT%   and r.ptabid=t.tabid   and csf.constrid=r.constrid
   and csp.constrid=r.primary   and csf.idxname=ixf.idxname   and csp.idxname=ixp.idxname
   and clf.tabid=ixf.tabid   and clf.colno=ixf.part2   and clp.tabid=ixp.tabid   and clp.colno=ixp.part2
union select clp.colname, clf.colname
from
informix.systables t, informix.sysreferences r, informix.sysconstraints csf, informix.sysconstraints csp,
informix.sysindexes ixf, informix.sysindexes ixp, informix.syscolumns clf, informix.syscolumns clp
where
   csf.constrname=%.q:FKCONSTRAINT%   and r.ptabid=t.tabid   and csf.constrid=r.constrid
   and csp.constrid=r.primary   and csf.idxname=ixf.idxname   and csp.idxname=ixp.idxname
   and clf.tabid=ixf.tabid   and clf.colno=ixf.part3   and clp.tabid=ixp.tabid   and clp.colno=ixp.part3
union select clp.colname, clf.colname
from
informix.systables t, informix.sysreferences r, informix.sysconstraints csf, informix.sysconstraints csp,
informix.sysindexes ixf, informix.sysindexes ixp, informix.syscolumns clf, informix.syscolumns clp
where
   csf.constrname=%.q:FKCONSTRAINT%   and r.ptabid=t.tabid   and csf.constrid=r.constrid
   and csp.constrid=r.primary   and csf.idxname=ixf.idxname   and csp.idxname=ixp.idxname
   and clf.tabid=ixf.tabid   and clf.colno=ixf.part4   and clp.tabid=ixp.tabid   and clp.colno=ixp.part4
union select clp.colname, clf.colname
from
informix.systables t, informix.sysreferences r, informix.sysconstraints csf, informix.sysconstraints csp,
informix.sysindexes ixf, informix.sysindexes ixp, informix.syscolumns clf, informix.syscolumns clp
where
   csf.constrname=%.q:FKCONSTRAINT%   and r.ptabid=t.tabid   and csf.constrid=r.constrid
   and csp.constrid=r.primary   and csf.idxname=ixf.idxname   and csp.idxname=ixp.idxname
   and clf.tabid=ixf.tabid   and clf.colno=ixf.part5   and clp.tabid=ixp.tabid   and clp.colno=ixp.part5
</a:TextTargetItem.Value>
<a:Comment>SQL query to list reference joins</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o130">
<a:Name>PKey</a:Name>
<a:Code>PKEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o131">
<a:Name>Enable</a:Name>
<a:Comment>Primary key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o132">
<a:Name>PkAutoIndex</a:Name>
<a:Comment>Primary key is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o133">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>PK_%.U15:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for primary keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o134">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>primary key (%PKEYCOLUMNS%)
      [constraint [%R%?[%QUALIFIER%]]%CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o135">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add constraint primary key (%PKEYCOLUMNS%)
      [constraint [%R%?[%QUALIFIER%]]%CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Command for adding a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o136">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a primary key</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o137">
<a:Name>Key</a:Name>
<a:Code>KEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;COLUMNS&quot;      // List of columns of the key. Eg: &quot;A, B, C&quot;
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o138">
<a:Name>Enable</a:Name>
<a:Comment>UNIQUE constraint allowed for tables</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o139">
<a:Name>UniqConstAutoIndex</a:Name>
<a:Comment>UNIQUE constraint is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o140">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>AK_%.U6:AKEY%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for alternate keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o141">
<a:Name>SqlAkeyIndex</a:Name>
<a:Comment>SQL query to obtain the alternate key indexes of a table by ODBC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o142">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o143">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>unique (%COLUMNS%)
      [constraint [%R%?[%QUALIFIER%]]%CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o144">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add constraint unique (%COLUMNS%)
      [constraint [%R%?[%QUALIFIER%]]%CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Command for adding an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o145">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{TABLE, ISPKEY (&#39;P&#39;=1, *=0), CONSTNAME, COLUMNS}

select 
   t.tabname,
   k.constrtype,
   k.constrname,
   c1.colname || &#39;,&#39; ||
   nvl(c2.colname, &#39; &#39;) || &#39;,&#39; ||
   nvl(c3.colname, &#39; &#39;) || &#39;,&#39; ||
   nvl(c4.colname, &#39; &#39;) || &#39;,&#39; ||
   nvl(c5.colname, &#39; &#39;) || &#39;,&#39; ||
   nvl(c6.colname, &#39; &#39;) || &#39;,&#39; ||
   nvl(c7.colname, &#39; &#39;) || &#39;,&#39; ||
   nvl(c8.colname, &#39; &#39;)
from 
   &quot;informix&quot;.sysconstraints k,
   &quot;informix&quot;.sysindices x,
   &quot;informix&quot;.syscolumns c1,
   outer &quot;informix&quot;.syscolumns c2,
   outer &quot;informix&quot;.syscolumns c3,
   outer &quot;informix&quot;.syscolumns c4,
   outer &quot;informix&quot;.syscolumns c5,
   outer &quot;informix&quot;.syscolumns c6,
   outer &quot;informix&quot;.syscolumns c7,
   outer &quot;informix&quot;.syscolumns c8,
   &quot;informix&quot;.systables t
where 
   k.constrtype in (&#39;P&#39;, &#39;U&#39;)
   and x.idxname=k.idxname
   and t.tabid=k.tabid
   and c1.tabid=k.tabid    
   and c2.tabid=k.tabid    
   and c3.tabid=k.tabid    
   and c4.tabid=k.tabid    
   and c5.tabid=k.tabid    
   and c6.tabid=k.tabid    
   and c7.tabid=k.tabid    
   and c8.tabid=k.tabid    
   and c1.colno = &quot;informix&quot;.ikeyextractcolno(x.indexkeys ,0 )
   and c2.colno = &quot;informix&quot;.ikeyextractcolno(x.indexkeys ,1 )
   and c3.colno = &quot;informix&quot;.ikeyextractcolno(x.indexkeys ,2 )
   and c4.colno = &quot;informix&quot;.ikeyextractcolno(x.indexkeys ,3 )
   and c5.colno = &quot;informix&quot;.ikeyextractcolno(x.indexkeys ,4 )
   and c6.colno = &quot;informix&quot;.ikeyextractcolno(x.indexkeys ,5 )
   and c7.colno = &quot;informix&quot;.ikeyextractcolno(x.indexkeys ,6 )
   and c8.colno = &quot;informix&quot;.ikeyextractcolno(x.indexkeys ,7 )
[  and t.tabname=%.q:TABLE%]
[  and t.owner=%.q:OWNER%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o146">
<a:Name>Domain</a:Name>
<a:Code>PDMDOMN</a:Code>
<a:Comment>The following system variables are available:
   &quot;DOMAIN&quot;       // generated code of the domain (also available for columns)
SQL Server specific domain system variables:
   &quot;RULENAME&quot;     // name of the rule object associated with the domain
   &quot;DEFAULTNAME&quot;  // name of the default object associated with the domain
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o147">
<a:Name>Enable</a:Name>
<a:Comment>User defined data types allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o148">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o149">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create distinct type [%QUALIFIER%]%DOMAIN% as %DATATYPE%</a:TextTargetItem.Value>
<a:Comment>Command for creating a user defined data type</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o150">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop type %DOMAIN% restrict</a:TextTargetItem.Value>
<a:Comment>Command for dropping a user defined data type</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o151">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{DOMAIN, DTTPCODE} 

select 
   x.name, 
   y.description
from 
   informix.sysxtdtypes x, 
   informix.sysxtddesc y
where 
   x.type not in (40,41)
   and x.extended_id &gt; 2047
   and x.extended_id = y.extended_id</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o152">
<a:Name>Tablespace</a:Name>
<a:Code>TSPC</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLESPACE&quot;   // generated code of the tablespace
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o153">
<a:Name>Enable</a:Name>
<a:Comment>Tablespace allowed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o154">
<a:Name>Create</a:Name>
<a:Comment>Command for creating a tablespace. Example: create tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o155">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a tablespace. Example: drop tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o156">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for tablespace options.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o157">
<a:Name>Storage</a:Name>
<a:Code>STOR</a:Code>
<a:Comment>The following system variables are available:
   &quot;STORAGE&quot;      // generated code of the storage
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o158">
<a:Name>Enable</a:Name>
<a:Comment>Storage allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o159">
<a:Name>Create</a:Name>
<a:Comment>Command for creating a storage. Example: create storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o160">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a storage. Example: drop storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o161">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for storage options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o162">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{STORAGE}
SELECT name FROM SYSMASTER:INFORMIX.SYSDBSPACES </a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o163">
<a:Name>Database</a:Name>
<a:Code>DTBS</a:Code>
<a:Comment>The following system variables are available:
   &quot;DATABASE&quot;     // generated code of the database
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o164">
<a:Name>Enable</a:Name>
<a:Comment>Database allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o165">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create database %DATABASE%
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a database. Example: create database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o166">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>in %s : category=storage
with %s : list=log|buffered log|log mode ansi, default=log</a:TextTargetItem.Value>
<a:Comment>Available options for creating a database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o167">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for database options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o168">
<a:Name>OpenDatabase</a:Name>
<a:TextTargetItem.Value>database %DATABASE%</a:TextTargetItem.Value>
<a:Comment>Command for opening a database. Example: open database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o169">
<a:Name>CloseDatabase</a:Name>
<a:TextTargetItem.Value>close database</a:TextTargetItem.Value>
<a:Comment>Command for closing a database. Example: close database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o170">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop database %DATABASE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a database. Example: drop database %DATABASE%</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o171">
<a:Name>View</a:Name>
<a:Code>VIEW</a:Code>
<a:Comment>The following system variables are available:
   &quot;VIEW&quot;         // generated code of the view
   &quot;VIEWNAME&quot;     // view name
   &quot;VIEWCODE&quot;     // view code
   &quot;VIEWCOLN&quot;     // List of columns of the view. Eg: &quot;A, B, C&quot;
   &quot;SQL&quot;          // SQL text of the view. Eg: Select * from T1
   &quot;VIEWCHECK&quot;    // Keyword &quot;with check option&quot; if selected on the view
   &quot;SCRIPT&quot;       // complete view creation order. Eg: create view V1 as select * from T1
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o172">
<a:Name>Enable</a:Name>
<a:Comment>View allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o173">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create view [%QUALIFIER%]%VIEW% [(%VIEWCOLN%)] as
%SQL%
[%VIEWCHECK%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a view. Example: create view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o174">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop view [%QUALIFIER%]%VIEW%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a view. Example: drop view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o175">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a view.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>DELETE=Delete
INSERT=Insert
SELECT=Select
UPDATE=Update</a:MapTargetItem.Value>
<a:List>DELETE
INSERT
SELECT
UPDATE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o176">
<a:Name>ViewComment</a:Name>
<a:Comment>Command for adding a view comment.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o177">
<a:Name>ViewCheck</a:Name>
<a:TextTargetItem.Value>with check option</a:TextTargetItem.Value>
<a:Comment>Option for checking a view</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o178">
<a:Name>SqlListQuery</a:Name>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o179">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, VIEW ID, SCRIPT ...}

select
   t.owner,
   t.tabname,
   v.viewtext,
   v.seqno
from
   informix.systables t,
   informix.sysviews v
where
   t.tabtype=&#39;V&#39;
   and t.tabid=v.tabid
   [and t.owner=%.q:SCHEMA%]
order by
   t.owner,
   t.tabname,
   v.seqno
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o180">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{ GRANTEE, PERMISSION}

select 
p.grantee grantee, 
case (substr(p.tabauth,1,1)) when &#39;s&#39; then &#39;SELECT&#39; else &#39;&#39; end ||&#39;,&#39;||
case (substr(p.tabauth,1,1)) when &#39;S&#39; then &#39;SELECT+&#39; else &#39;&#39; end ||&#39;,&#39;||
case (substr(p.tabauth,2,1)) when &#39;u&#39; then &#39;UPDATE&#39; else &#39;&#39; end  ||&#39;,&#39;||
case (substr(p.tabauth,2,1)) when &#39;U&#39; then &#39;UPDATE+&#39; else &#39;&#39; end  ||&#39;,&#39;||
case (substr(p.tabauth,4,1)) when &#39;i&#39; then &#39;INSERT&#39; else &#39;&#39; end  ||&#39;,&#39;||
case (substr(p.tabauth,4,1)) when &#39;I&#39; then &#39;INSERT+&#39; else &#39;&#39; end  ||&#39;,&#39;||
case (substr(p.tabauth,5,1)) when &#39;d&#39; then &#39;DELETE&#39; else &#39;&#39; end  ||&#39;,&#39;||
case (substr(p.tabauth,5,1)) when &#39;D&#39; then &#39;DELETE+&#39; else &#39;&#39; end
from informix.systables s, informix.systabauth p
where 
(s.tabname = %.q:VIEW% ) and
[ s.owner = %.q:OWNER% and ]
(s.tabid = p.tabid)</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o181">
<a:Name>Trigger</a:Name>
<a:Code>TRGR</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
 trigger object specific items
   &quot;ORDER&quot;        // order number of the trigger (to sort the triggers when the DBMS supports more than one trigger of one type)
   &quot;TRIGGER&quot;      // generated code of trigger
   &quot;TRGTYPE&quot;      // trigger type (keywords &quot;beforeinsert&quot;, &quot;afterupdate&quot;, ...)
   &quot;TRGEVENT&quot;     // trigger event (keywords &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;)
   &quot;TRGTIME&quot;      // trigger time (keywords NULL, &quot;before&quot;, &quot;after&quot;)
 inside the body of the trigger, macros redefine variables on objects
   &quot;REFNO&quot;        // reference position in the list of references of the table
 customized error messages management
   &quot;ERRNO&quot;        // error number for standard error
   &quot;ERRMSG&quot;       // error message for standard error
   &quot;MSGTAB&quot;       // name of the table containing user-defined error messages
   &quot;MSGNO&quot;        // in the user-defined error table, name of the column containing the error numbers
   &quot;MSGTXT&quot;       // in the user-defined error table, name of the column containing the error messages
   &quot;SCRIPT&quot;       // body of trigger or procedure
   &quot;TRGDEFN&quot;      // complete body of the trigger definition. Contains variable declarations and body of trigger or procedure
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o182">
<a:Name>Enable</a:Name>
<a:Comment>Trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o183">
<a:Name>EnableMultiTrigger</a:Name>
<a:Comment>Multi trigger allowed</a:Comment>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o184">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o185">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop trigger [%QUALIFIER%]%TRIGGER%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a trigger. Example: drop trigger %TRIGGER%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o186">
<a:Name>DefaultTriggerName</a:Name>
<a:TextTargetItem.Value>%TEMPLATE%_%.L:TABLE%</a:TextTargetItem.Value>
<a:Comment>Default trigger name</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o187">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, TRIGGER, TRGEVENT(D=delete, I=insert, U=update)}

select
   t.owner,
   t.tabname,
   r.trigname,
   r.event
from
   informix.systables t,
   informix.systriggers r
where
   r.tabid=t.tabid
   [and t.owner=%.q:SCHEMA%]
order by
   r.trigname
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o188">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, TRIGGER ID, SCRIPT ...}

select
   tb.owner,
   tb.tabname,
   tr.trigname,
   tt.data,
   tt.seqno,
   tt.datakey
from
   informix.systables tb,
   informix.systriggers tr,
   informix.systrigbody tt
where
   tr.tabid=tb.tabid
   and tr.trigid=tt.trigid
   and tt.datakey in (&#39;A&#39;,&#39;D&#39;)
   [and tb.owner=%.q:SCHEMA%]
order by
   tb.owner,
   tb.tabname,
   tr.trigname,
   tt.seqno,
   tt.datakey desc</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o189">
<a:Name>UseErrorMsgTable</a:Name>
<a:TextTargetItem.Value>let errno  = %ERRNO%;
select %MSGTXT%
into   errmsg
from   %MSGTAB%
where  %MSGNO% = %ERRNO%;
raise exception -746, 0, errmsg;</a:TextTargetItem.Value>
<a:Comment>Errors handling using an error messages table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o190">
<a:Name>UseErrorMsgText</a:Name>
<a:TextTargetItem.Value>let errno  = %ERRNO%;
let errmsg = &quot;%ERRMSG%&quot;;
raise exception -746, 0, errmsg;</a:TextTargetItem.Value>
<a:Comment>Errors handling using fixed error messages</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o191">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create trigger [%QUALIFIER%]%TRIGGER% %TRGEVENT%[ of %COLUMNS%] on [%TABLQUALIFIER%]%TABLE%
%TRGDEFN%
</a:TextTargetItem.Value>
<a:Comment>Command for creating a trigger. Example: create trigger on [%QUALIFIER%]%TABLE% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o192">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o193">
<a:Name>Procedure</a:Name>
<a:Code>PROC</a:Code>
<a:Comment>The following system variables are available:
   &quot;PROC&quot;         // generated code of the procedure (also available for trigger when the trigger is implemented with a procedure)
   &quot;FUNC&quot;         // generated code of the procedure if the procedure is a function (with return value)
   &quot;PROCPRMS&quot;     // list of parameters of the procedure (also available for function)
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o194">
<a:Name>Enable</a:Name>
<a:Comment>Procedure allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o195">
<a:Name>EnableFunc</a:Name>
<a:Comment>Function allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o196">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o197">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop procedure [%QUALIFIER%]%PROC%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a procedure. Example: drop procedure %PROC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o198">
<a:Name>CustomProc</a:Name>
<a:TextTargetItem.Value>create procedure [%QUALIFIER%]%PROC%(&lt;arg&gt; &lt;type&gt;)
returning &lt;type&gt;;
define &lt;var&gt; &lt;type&gt;;

end procedure;
</a:TextTargetItem.Value>
<a:Comment>Command for creating a stored procedure</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o199">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, PROC}

select
   owner,
   procname
from 
   informix.sysprocedures
[where owner=%.q:SCHEMA%]
order by
   procname</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o200">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a procedure.
The first column is the SQL name of permission (eg: EXECUTE)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>EXECUTE=Execute</a:MapTargetItem.Value>
<a:List>EXECUTE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o201">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, PROC ID, SCRIPT ...}

select
   pr.owner,
   pr.procname,
   pt.data,
   pt.seqno
from
   informix.sysprocedures pr,
   informix.sysprocbody pt
where
   pr.procid=pt.procid
   and datakey=&#39;T&#39;
   [and pr.owner=%.q:SCHEMA%]
   [and pr.procname=%.q:PROC%]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o202">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create[ dba] procedure [%QUALIFIER%]%PROC%[%PROCPRMS%?([%PROCPRMS%])]
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a procedure. Example: create procedure %PROC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o203">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{ GRANTEE, PERMISSION}

select 
p.grantee grantee, &#39;EXECUTE&#39;
from informix.sysprocedures s, informix.sysprocauth p
where 
(s.procname = %.q:PROC% ) and
(s.procid = p.procid)</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o204">
<a:Name>CustomFunc</a:Name>
<a:TextTargetItem.Value>create function [%QUALIFIER%]%FUNC% (&lt;arg&gt; &lt;type&gt;)
returning &lt;type&gt;;
define &lt;var&gt; &lt;type&gt;;

end function;
</a:TextTargetItem.Value>
<a:Comment>Command for creating a function</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o205">
<a:Name>CreateFunc</a:Name>
<a:TextTargetItem.Value>create[ dba] function [%QUALIFIER%]%FUNC%[%PROCPRMS%?([%PROCPRMS%])]
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a function. Example: create function %FUNC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o206">
<a:Name>DropFunc</a:Name>
<a:TextTargetItem.Value>drop function [%QUALIFIER%]%FUNC%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a function. Example: drop function %FUNC%</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o207">
<a:Name>Abstract Data Type Attribute</a:Name>
<a:Code>ATTR</a:Code>
<a:Comment>The following system variables are available:
   &quot;ADTATTR&quot;      // generated code of the abstract data type attribute
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o208">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%ADTATTR% %DATATYPE%  [%NOTNULL%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an abstract data type attribute</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o209">
<a:Name>AllowedADT</a:Name>
<a:TextTargetItem.Value>NAMED ROW TYPE</a:TextTargetItem.Value>
<a:Comment>List of ADTs which can be used as the datatype of an ADT attribute</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o210">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{ ADT, ADTATTR , DTTPCODE(0=CHAR , 1=SMALLINT , 2=INTEGER , 3=FLOAT , 4=SMALLFLOAT , 5=DECIMAL , 6=SERIAL , 7=DATE , 8=MONEY , 9=NULL , 10=DATETIME , 11=BYTE , 12=TEXT , 13=VARCHAR , 14=INTERVAL , 15=NCHAR , 16=NVARCHAR , 17=INT8, 18=SERIAL8 , 19=SET , 20=MULTISET , 21=LIST , 22=ROW , 23=COLLECTION , 24=ROWREF , 40=OPAQUE , 41=OPAQUE , 4118=&#39;NAMED ROW TYPE&#39; , 256=CHAR , 257=SMALLINT , 258=INTEGER , 259=FLOAT , 260=SMALLFLOAT , 261=DECIMAL , 262=SERIAL , 263=DATE , 264=MONEY , 265=NULL, 266=DATETIME , 267=BYTE , 268=TEXT , 269=VARCHAR , 270=INTERVAL, 271=NCHAR , 272=NVARCHAR , 273=INT8 , 274=SERIAL8 , 275=SET, 276=MULTISET , 277=LIST , 278=ROW , 279=COLLECTION , 280=ROWREF , 281=OPAQUE , 282=OPAQUE , 4374=&#39;NAMED ROW TYPE&#39;) , LENGTH}
SELECT x.name, a.fieldname, a.type, a.length
FROM informix.sysxtdtypes x, informix.sysattrtypes a
WHERE x.extended_id=a.extended_id
AND a.levelno != 0</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o211">
<a:Name>Abstract Data Type</a:Name>
<a:Code>ADT</a:Code>
<a:Comment>The following system variables are available:
   &quot;ADT&quot;          // generated code of the abstract data type
   &quot;TYPE&quot;         // ADT type
   &quot;SIZE&quot;         // ADT size
   &quot;FILE&quot;         // ADT: Java file
   &quot;ISARRAY&quot;      // ADT: is an array?
   &quot;ISLIST&quot;       // ADT: is a list?
   &quot;ISSTRUCT&quot;     // ADT: is a structure?
   &quot;ISOBJECT&quot;     // ADT: is an object?
   &quot;ISJAVA&quot;       // ADT: is a JAVA class?
   &quot;ADTDEF&quot;       // ADT definition
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o212">
<a:Name>Enable</a:Name>
<a:Comment>Abstract Data Types allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o213">
<a:Name>EnableAdtOnDomn</a:Name>
<a:Comment>Abstract Data Types allowed on domain</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o214">
<a:Name>EnableAdtOnColn</a:Name>
<a:Comment>Abstract Data Types allowed on column</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o215">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{ADT, OWNER , TYPE (R=&#39;NAMED ROW TYPE&#39;)}
SELECT name, owner, mode
FROM informix.sysxtdtypes
WHERE mode=&#39;R&#39;
ORDER BY name</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o216">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%ISLIST% ? create distinct type [%QUALIFIER%]%ADT% as %TYPE%(%DATATYPE% NOT NULL)]
[%ISSTRUCT% ? create row type  [%QUALIFIER%]%ADT%
(
    %ADTDEF%
)]</a:TextTargetItem.Value>
<a:Comment>Command for adding an abstract data type</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o217">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop row type [%QUALIFIER%]%ADT% restrict</a:TextTargetItem.Value>
<a:Comment>Command for dropping an abstract data type</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o218">
<a:Name>Synonym</a:Name>
<a:Code>SYNM</a:Code>
<a:Comment>Manages the synonym object.</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o219">
<a:Name>Enable</a:Name>
<a:Comment>Synonym allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o220">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [%VISIBILITY% ]synonym [%QUALIFIER%]%SYNONYM% for [%BASEQUALIFIER%]%BASEOBJECT%</a:TextTargetItem.Value>
<a:Comment>Command for creating a synonym.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o221">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop synonym [%QUALIFIER%]%SYNONYM%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a synonym.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o222">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{ OWNER, SYNONYM , VISIBILITY }

select 
   t.owner,
   t.tabname, 
   case 
      when ( t.tabtype = &#39;P&#39;) then &#39;PRIVATE&#39;
      when ( t.tabtype = &#39;S&#39;) then &#39;PUBLIC&#39;
   end
from informix.syssyntable s, informix.systables t
where s.tabid = t.tabid
[and t.owner=%.q:SCHEMA%]</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o223">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{ OWNER, SYNONYM , VISIBILITY,  BASEOWNER, BASEOBJECT }

select 
   t.owner,
   t.tabname, 
   case 
      when ( t.tabtype = &#39;P&#39;) then &#39;PRIVATE&#39;
      when ( t.tabtype = &#39;S&#39;) then &#39;PUBLIC&#39;
   end,
   t1.owner,
   t1.tabname
from informix.syssyntable s, informix.systables t,informix.systables t1
where s.tabid = t.tabid and s.btabid = t1.tabid
[and t.owner=%.q:SCHEMA%]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o224">
<a:Name>EnableSynonym</a:Name>
<a:Comment>Synonym supported</a:Comment>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o225">
<a:Name>Privilege</a:Name>
<a:Comment>Manages the system privileges for a user, role or group</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o226">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>grant %PRIVLIST% to %USER%</a:TextTargetItem.Value>
<a:Comment>Command for granting privileges.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o227">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>revoke %REVPRIVLIST% from %USER%</a:TextTargetItem.Value>
<a:Comment>Command for revoking privileges.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o228">
<a:Name>System</a:Name>
<a:TextTargetItem.Value>CONNECT
RESOURCE
DBA</a:TextTargetItem.Value>
<a:Comment>List of system privileges</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o229">
<a:Name>Exclusive</a:Name>
<a:Comment>TRUE if the system privileges are exclusive.</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o230">
<a:Name>Permission</a:Name>
<a:Code>PERM</a:Code>
<a:Comment>Manages the permissions on database objects</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o231">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>grant %PERMLIST% on [%QUALIFIER%]%OBJECT% to %GRANTEE% [%GRANTOPTION%]
</a:TextTargetItem.Value>
<a:Comment>Command for granting permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o232">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>revoke %REVPERMLIST% on [%QUALIFIER%]%OBJECT% from %GRANTEE%</a:TextTargetItem.Value>
<a:Comment>Command for revoking permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o233">
<a:Name>GrantOption</a:Name>
<a:TextTargetItem.Value>with grant option</a:TextTargetItem.Value>
<a:Comment>Option for the grant statement.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o234">
<a:Name>Role</a:Name>
<a:Code>ROLE</a:Code>
<a:Comment>Manages the role object.</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o235">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create role %ROLE%</a:TextTargetItem.Value>
<a:Comment>Command for creating a role.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o236">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop role %ROLE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a role.</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o237">
<a:Name>Enable</a:Name>
<a:Comment>Role allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o238">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>grant %ROLE% to %USER%</a:TextTargetItem.Value>
<a:Comment>Command for assigning a role to a user or another role</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o239">
<a:Name>Unbind</a:Name>
<a:TextTargetItem.Value>revoke %ROLE% from %USER%</a:TextTargetItem.Value>
<a:Comment>Command for unassiging a role from a user or another role</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o240">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{ROLE}

select 
   username
from 
   informix.sysusers u
where u.usertype = &#39;G&#39;
order by 
   username</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o241">
<a:Name>SqlListChildrenQuery</a:Name>
<a:TextTargetItem.Value>{ROLE ID, MEMBER }

select rolename, grantee from informix.sysroleauth</a:TextTargetItem.Value>
<a:Comment>SQL query to list assigned ids to the role.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o242">
<a:Name>DataType</a:Name>
<a:Comment>Contains data type translation entries. These entries list the correspondence between internal data types and the target database data types</a:Comment>
<c:Categories>
<o:MapTargetItem Id="o243">
<a:Name>AmcdDataType</a:Name>
<a:Comment>Data types translation table from internal data types to target database data types.
        %n is the length of the data type
        %s is the size of the data type
        %p is the precision of the data type</a:Comment>
<a:MapTargetItem.Value>&lt;UNDEF&gt;=&lt;Undefined&gt;
A%n=CHAR(%n)
VA%n=VARCHAR(%n)
LA=VARCHAR(1)
LA%n=VARCHAR(%n)
LVA=LVARCHAR
LVA%n=LVARCHAR
BT=SMALLINT
BT%n=DEC(3)
SI=SMALLINT
I=INTEGER
LI=INT8
N=NUMERIC
N%n=NUMERIC(%n)
N%s,%p=NUMERIC(%s,%p)
DC=DEC
DC%n=DEC(%n)
DC%s,%p=DEC(%s,%p)
SF=SMALLFLOAT
F=FLOAT
F%n=FLOAT(%n)
LF=DOUBLE PRECISION
MN=MONEY
MN%n=MONEY(%n)
MN%s,%p=MONEY(%s,%p)
D=DATE
T=DATETIME HOUR TO SECOND
DT=DATETIME YEAR TO SECOND
TS=DATETIME YEAR TO FRACTION
BL=BOOLEAN
NO=SERIAL
NO%n=SERIAL
BIN%n=BYTE
LBIN=BYTE
LBIN%n=BYTE
TXT=TEXT
TXT%n=TEXT
MBT=NCHAR
MBT%n=NCHAR(%n)
VMBT=NVARCHAR(255)
VMBT%n=NVARCHAR(%n)
PIC=BYTE
PIC%n=BYTE
BMP=BYTE
BMP%n=BYTE
OLE=BYTE
OLE%n=BYTE
*=CHAR(10)</a:MapTargetItem.Value>
<a:List>&lt;UNDEF&gt;
A%n
VA%n
LA
LA%n
LVA
LVA%n
BT
BT%n
SI
I
LI
N
N%n
N%s,%p
DC
DC%n
DC%s,%p
SF
F
F%n
LF
MN
MN%n
MN%s,%p
D
T
DT
TS
BL
NO
NO%n
BIN%n
LBIN
LBIN%n
TXT
TXT%n
MBT
MBT%n
VMBT
VMBT%n
PIC
PIC%n
BMP
BMP%n
OLE
OLE%n
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o244">
<a:Name>PhysDataType</a:Name>
<a:Comment>Data types translation table from target database data types to internal data types.</a:Comment>
<a:MapTargetItem.Value>&lt;Undefined&gt;=&lt;UNDEF&gt;
BOOLEAN=BL
CHAR=A1
CHAR(%n)=A%n
CHARACTER=A1
CHARACTER(%n)=A%n
NCHAR=MBT
NCHAR(%n)=MBT%n
VARCHAR(%n)=VA%n
VARCHAR(%n,%m)=VA%n
NVARCHAR(%n)=VMBT%n
NVARCHAR(%n,%m)=VMBT%n
CHARACTER VARYING(%n)=VA%n
CHARACTER VARYING(%n,%m)=VA%n
LVARCHAR=LVA
DECIMAL=DC
DECIMAL(%n)=DC%n
DECIMAL(%s,%p)=DC%s,%p
DEC=DC
DEC(%n)=DC%n
DEC(%s,%p)=DC%s,%p
NUMERIC=N
NUMERIC(%n)=N%n
NUMERIC(%s,%p)=N%s,%p
MONEY=MN
MONEY(%n)=MN%n
MONEY(%s,%p)=MN%s,%p
INTEGER=I
INT=I
SMALLINT=SI
INT8=LI
SERIAL=NO
SERIAL8=NO
FLOAT=F
FLOAT(%n)=F%n
DOUBLE PRECISION=LF
SMALLFLOAT=SF
REAL=SF
DATE=D
DATETIME HOUR TO SECOND=T
DATETIME YEAR TO SECOND=DT
DATETIME YEAR TO FRACTION=DT
DATETIME YEAR TO FRACTION(%n)=DT
INTERVAL=DT
BYTE=LBIN
TEXT=TXT
*=A10</a:MapTargetItem.Value>
<a:List>&lt;Undefined&gt;
BOOLEAN
CHAR
CHAR(%n)
CHARACTER
CHARACTER(%n)
NCHAR
NCHAR(%n)
VARCHAR(%n)
VARCHAR(%n,%m)
NVARCHAR(%n)
NVARCHAR(%n,%m)
CHARACTER VARYING(%n)
CHARACTER VARYING(%n,%m)
LVARCHAR
DECIMAL
DECIMAL(%n)
DECIMAL(%s,%p)
DEC
DEC(%n)
DEC(%s,%p)
NUMERIC
NUMERIC(%n)
NUMERIC(%s,%p)
MONEY
MONEY(%n)
MONEY(%s,%p)
INTEGER
INT
SMALLINT
INT8
SERIAL
SERIAL8
FLOAT
FLOAT(%n)
DOUBLE PRECISION
SMALLFLOAT
REAL
DATE
DATETIME HOUR TO SECOND
DATETIME YEAR TO SECOND
DATETIME YEAR TO FRACTION
DATETIME YEAR TO FRACTION(%n)
INTERVAL
BYTE
TEXT
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o245">
<a:Name>PhysDttpSize</a:Name>
<a:Comment>Table of storage sizes of target database data type</a:Comment>
</o:MapTargetItem>
<o:MapTargetItem Id="o246">
<a:Name>HostDataType</a:Name>
<a:Comment>Data types translation from database data type to procedure data type</a:Comment>
<a:MapTargetItem.Value>CHAR(%n)=char(%n)
SMALLINT=smallint
INTEGER=integer
NUMERIC=numeric
NUMERIC(%n)=numeric(%n)
NUMERIC(%s,%p)=numeric(%s,%p)
DEC=dec
DEC(%n)=dec(%n)
DEC(%s,%p)=dec(%s,%p)
SMALLFLOAT=smallfloat
FLOAT=float
DOUBLE PRECISION=double precision
MONEY=money
MONEY(%n)=money(%n)
MONEY(%n,%p)=money(%s,%p)
DATE=date
DATETIME=datetime
SERIAL=integer
SERIAL(%n)=integer</a:MapTargetItem.Value>
<a:List>CHAR(%n)
SMALLINT
INTEGER
NUMERIC
NUMERIC(%n)
NUMERIC(%s,%p)
DEC
DEC(%n)
DEC(%s,%p)
SMALLFLOAT
FLOAT
DOUBLE PRECISION
MONEY
MONEY(%n)
MONEY(%n,%p)
DATE
DATETIME
SERIAL
SERIAL(%n)
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o247">
<a:Name>PhysLogADTType</a:Name>
<a:Comment>Abstract Data types translation table from target database abstract data types to internal abstract data types.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:MapTargetItem.Value>NAMED ROW TYPE=Structured</a:MapTargetItem.Value>
<a:List>NAMED ROW TYPE
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o248">
<a:Name>LogPhysADTType</a:Name>
<a:Comment>Abstract Data types translation table from internal abstract data types to target database abstract data types.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:MapTargetItem.Value>Array=&lt;Undefined&gt;
Java=&lt;Undefined&gt;
List=&lt;Undefined&gt;
Object=&lt;Undefined&gt;
Structured=NAMED ROW TYPE</a:MapTargetItem.Value>
<a:List>Array
Java
List
Object
Structured
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o249">
<a:Name>OdbcPhysDataType</a:Name>
<a:Comment>Data types translation table from ODBC data types to target database data types.</a:Comment>
<a:MapTargetItem.Value>DATETIME YEAR TO FRACTION(5)(%p)=DATETIME YEAR TO FRACTION(5)
FLOAT(16,255)=DECIMAL
INT8(%n)=INT8
MONEY(16,2)=MONEY
FLOAT(%n,255)=DECIMAL(%n)
FLOAT(15)=FLOAT
DATETIME YEAR TO FRACTION(%s)(%p)=DATETIME YEAR TO FRACTION(%n)
FIXED UDT(1)=BOOLEAN
INTEGER(10)=INTEGER
SMALLINT(5)=SMALLINT
SMALLFLOAT(7)=SMALLFLOAT
DATE(10)=DATE
CHAR(1)=CHAR
NCHAR(1)=NCHAR
MONEY(%s, 2)=MONEY(%s)
TEXT(2147483647)=TEXT
FIXED UDT(72)=BLOB
SERIAL8(%n)=SERIAL8</a:MapTargetItem.Value>
<a:List>DATETIME YEAR TO FRACTION(5)(%p)
FLOAT(16,255)
INT8(%n)
MONEY(16,2)
FLOAT(%n,255)
FLOAT(15)
DATETIME YEAR TO FRACTION(%s)(%p)
FIXED UDT(1)
INTEGER(10)
SMALLINT(5)
SMALLFLOAT(7)
DATE(10)
CHAR(1)
NCHAR(1)
MONEY(%s, 2)
TEXT(2147483647)
FIXED UDT(72)
SERIAL8(%n)
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o250">
<a:Name>PhysOdbcDataType</a:Name>
<a:Comment>Data types translation table from target database data types to ODBC data types.</a:Comment>
<a:MapTargetItem.Value>INT=INTEGER
DEC=DECIMAL
DEC(%n)=DECIMAL(%n)
DEC(%s,%p)=DECIMAL(%s,%p)
CHARACTER VARYING=VARCHAR
CHARACTER VARYING(%n)=VARCHAR(%n)</a:MapTargetItem.Value>
<a:List>INT
DEC
DEC(%n)
DEC(%s,%p)
CHARACTER VARYING
CHARACTER VARYING(%n)
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o251">
<a:Name>AllowedADT</a:Name>
<a:TextTargetItem.Value>NAMED ROW TYPE</a:TextTargetItem.Value>
<a:Comment>The list of ADT which can be used as the datatype of a domain or column</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:ProfileTargetItem Id="o252">
<a:Name>Profile</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TargetCategory Id="o253">
<a:Name>Shared</a:Name>
<a:Code>Shared</a:Code>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TargetCategory>
<o:MetaClassTargetItem Id="o254">
<a:Name>Column</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o255">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o256">
<a:ObjectID>34C88645-F557-4CCC-B513-EE4DA7B429E5</a:ObjectID>
<a:Name>ExtSerialStart</a:Name>
<a:Comment>This extended attributes defines the initial value of the column having SERIAL datatype</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>10</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o257">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o258">
<a:Name>Informix</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtSerialStart&quot; AttributeID=&quot;{34C88645-F557-4CCC-B513-EE4DA7B429E5}&quot; Name=&quot;ExtSerialStart&quot; Caption=&quot;Serial start&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
</c:Categories>
</o:ProfileTargetItem>
</c:Categories>
<c:TriggerItems>
<o:TriggerItem Id="o259">
<a:ObjectID>1114D111-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>InsertChildParentExist</a:Name>
<a:Code>InsertChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT()
--  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when inserting a child in &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;new_%.14L:FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; then&quot;)
   select count(*)
   into   numrows
   from   [%PQUALIFIER%]%PARENT%
   where  .JOIN(&quot;%PK% = new_%.14L:FK%&quot;, &quot;and   &quot;,&quot;&quot;, &quot;;&quot;)

   if (numrows = 0) then
      .ERROR(-1002, &quot;Parent does not exist in &quot;[%PQUALIFIER%]%PARENT%&quot;. Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
   end if;
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Parent must exist when inserting child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o260">
<a:ObjectID>1114D112-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>InsertTooManyChildren</a:Name>
<a:Code>InsertTooManyChildren</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
--  The cardinality of Parent &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; cannot exceed %MAXCARD%
if .JOIN(&quot;new_%.14L:FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; then&quot;)
   select count(*)
   into cardinality
   from   [%CQUALIFIER%]%CHILD% 
   where .JOIN(&quot;%FK% = new_%.14L:FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)  
   if (cardinality &gt;= %MAXCARD%) then
      .ERROR(-1007, &quot;Child Maximum cardinality exceeded! Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
   end if;
end if;
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot exceed the maximum cardinality constraint when inserting the child</a:Comment>
<a:Declaration>define  cardinality integer;
.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o261">
<a:ObjectID>1114D114-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UpdateChangeColumn</a:Name>
<a:Code>UpdateChangeColumn</a:Code>
<a:Text>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
--  Non modifiable column &quot;%COLUMN%&quot; cannot be modified
if (old_%.14L:COLUMN% != new_%.14L:COLUMN%) then
   .ERROR(-1001, &quot;Non modifiable column &quot;%COLUMN%&quot; cannot be modified.&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot modify non modifiable column constraint</a:Comment>
<a:Declaration>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o262">
<a:ObjectID>1114D115-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UpdateChildParentExist</a:Name>
<a:Code>UpdateChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT()
--  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when updating a child in &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;new_%.14L:FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; then&quot;)
   select count(*)
   into   numrows
   from   [%PQUALIFIER%]%PARENT%
   where  .JOIN(&quot;%PK% = new_%.14L:FK%&quot;, &quot;and   &quot;,&quot;&quot;, &quot;;&quot;)

   if (numrows = 0) then
      .ERROR(-1003, &quot;&quot;[%PQUALIFIER%]%PARENT%&quot; does not exist. Cannot modify child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
   end if;
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Parent must exist when updating a child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o263">
<a:ObjectID>1114D116-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UpdateTooManyChildren</a:Name>
<a:Code>UpdateTooManyChildren</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
--  The cardinality of Parent &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; cannot exceed %MAXCARD%
if .JOIN(&quot;new_%.14L:FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; then&quot;)
   select count(*)
   into cardinality
   from   [%CQUALIFIER%]%CHILD%
   where .JOIN(&quot;%FK% = new_%.14L:FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)  
   if (cardinality &gt;= %MAXCARD%) then
      .ERROR(-1007, &quot;Child maximum cardinality exceeded! Cannot modify child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
   end if;
end if;
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot exceed the maximum cardinality constraint when updating the child</a:Comment>
<a:Declaration>define  cardinality integer;
.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o264">
<a:ObjectID>1114D117-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UpdateChildChangeParent</a:Name>
<a:Code>UpdateChildChangeParent</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
--  Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;
if (.JOIN(&quot;old_%.14L:FK% != new_%.14L:FK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   .ERROR(-1004, &quot;Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot change parent constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o265">
<a:ObjectID>1114D118-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UpdateParentRestrict</a:Name>
<a:Code>UpdateParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
--  Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;
if (.JOIN(&quot;old_%.14L:PK% != new_%.14L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   select count(*)
   into   numrows
   from   [%CQUALIFIER%]%CHILD%
   where  .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

   if (numrows &gt; 0) then
      .ERROR(-1005, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)
   end if;
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o266">
<a:ObjectID>1114D119-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UpdateParentCascade</a:Name>
<a:Code>UpdateParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
--  Modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; for all children in &quot;[%CQUALIFIER%]%CHILD%&quot;
if (.JOIN(&quot;old_%.14L:PK% != new_%.14L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = new_%.14L:PK%&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o267">
<a:ObjectID>1114D11A-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UpdateParentSetNull</a:Name>
<a:Code>UpdateParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in &quot;[%CQUALIFIER%]%CHILD%&quot;
if (.JOIN(&quot;old_%.14L:PK% != new_%.14L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o268">
<a:ObjectID>1114D11B-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UpdateParentSetDefault</a:Name>
<a:Code>UpdateParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot; 
.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;
if (.JOIN(&quot;old_%.14L:PK% != new_%.14L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o269">
<a:ObjectID>1114D11D-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>DeleteParentRestrict</a:Name>
<a:Code>DeleteParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
--  Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;
select count(*)
into   numrows
from   [%CQUALIFIER%]%CHILD%
where  .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

if (numrows &gt; 0) then
   .ERROR(-1006, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o270">
<a:ObjectID>1114D11E-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>DeleteParentCascade</a:Name>
<a:Code>DeleteParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
--  Delete all children in &quot;[%CQUALIFIER%]%CHILD%&quot;
delete from [%CQUALIFIER%]%CHILD%
where  .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o271">
<a:ObjectID>1114D11F-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>DeleteParentSetNull</a:Name>
<a:Code>DeleteParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in child &quot;[%CQUALIFIER%]%CHILD%&quot;
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
where  .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o272">
<a:ObjectID>1114D120-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>DeleteParentSetDefault</a:Name>
<a:Code>DeleteParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot; 
.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
where  .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o273">
<a:ObjectID>1114D124-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UseErrorMsgTable</a:Name>
<a:Code>UseErrorMsgTable</a:Code>
<a:Text>let errno  = %ERRNO%;
select %MSGTXT%
into   errmsg
from   %MSGTAB%
where  %MSGNO% = %ERRNO%;
raise exception -746, 0, errmsg;</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Errors handling using an error messages table</a:Comment>
</o:TriggerItem>
<o:TriggerItem Id="o274">
<a:ObjectID>1114D125-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UseErrorMsgText</a:Name>
<a:Code>UseErrorMsgText</a:Code>
<a:Text>let errno  = %ERRNO%;
let errmsg = &quot;%ERRMSG%&quot;;
raise exception -746, 0, errmsg;</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Errors handling using fixed error messages</a:Comment>
</o:TriggerItem>
</c:TriggerItems>
<c:TriggerTemplates>
<o:TriggerTemplate Id="o275">
<a:ObjectID>1114D110-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>InsertProc</a:Name>
<a:Code>InsertProc</a:Code>
<a:Text>--  Insert procedure &quot;%PROC%&quot; for table &quot;[%TABLQUALIFIER%]%TABLE%&quot;
create procedure [%QUALIFIER%]%PROC%(.FKCOLN(&quot;new_%.14L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;)&quot;)
    .DeclInsertChildParentExist
    .DeclInsertTooManyChildren
    define  errno       integer;
    define  errmsg      char(255);
    define  numrows     integer;

    .InsertChildParentExist
    .InsertTooManyChildren

end procedure;
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1034242980</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Insert procedure</a:Comment>
<a:Time/>
<a:Event>InsertProc</a:Event>
<a:TriggerName>pi_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o259"/>
<o:TriggerItem Ref="o260"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o276">
<a:ObjectID>1114D113-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UpdateProc</a:Name>
<a:Code>UpdateProc</a:Code>
<a:Text>--  Update procedure &quot;%PROC%&quot; for table &quot;[%TABLQUALIFIER%]%TABLE%&quot;
create procedure [%QUALIFIER%]%PROC%(.INCOLN(&quot;old_%.14L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;,&quot;)
                        .INCOLN(&quot;new_%.14L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;)&quot;)
    .DeclUpdateChangeColumn
    .DeclUpdateChildParentExist
    .DeclUpdateTooManyChildren
    .DeclUpdateChildChangeParent
    .DeclUpdateParentRestrict
    .DeclUpdateParentCascade
    .DeclUpdateParentSetNull
    .DeclUpdateParentSetDefault
    define  errno    integer;
    define  errmsg   char(255);
    define  numrows  integer;

    .UpdateChangeColumn
    .UpdateChildParentExist
    .UpdateTooManyChildren
    .UpdateChildChangeParent
    .UpdateParentRestrict
    .UpdateParentCascade
    .UpdateParentSetNull
    .UpdateParentSetDefault

end procedure;
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1034242980</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update procedure</a:Comment>
<a:Time/>
<a:Event>UpdateProc</a:Event>
<a:TriggerName>pu_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o261"/>
<o:TriggerItem Ref="o262"/>
<o:TriggerItem Ref="o263"/>
<o:TriggerItem Ref="o264"/>
<o:TriggerItem Ref="o265"/>
<o:TriggerItem Ref="o266"/>
<o:TriggerItem Ref="o267"/>
<o:TriggerItem Ref="o268"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o277">
<a:ObjectID>1114D11C-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>DeleteProc</a:Name>
<a:Code>DeleteProc</a:Code>
<a:Text>--  Delete procedure &quot;%PROC%&quot; for table &quot;[%TABLQUALIFIER%]%TABLE%&quot;
create procedure [%QUALIFIER%]%PROC%(.PKCOLN(&quot;old_%.14L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;)&quot;)
    .DeclDeleteParentRestrict
    .DeclDeleteParentCascade
    .DeclDeleteParentSetNull
    .DeclDeleteParentSetDefault
    define  errno    integer;
    define  errmsg   char(255);
    define  numrows  integer;

    .DeleteParentRestrict
    .DeleteParentCascade
    .DeleteParentSetNull
    .DeleteParentSetDefault

end procedure;
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1034242980</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete procedure</a:Comment>
<a:Time/>
<a:Event>DeleteProc</a:Event>
<a:TriggerName>pd_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o269"/>
<o:TriggerItem Ref="o270"/>
<o:TriggerItem Ref="o271"/>
<o:TriggerItem Ref="o272"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o278">
<a:ObjectID>1114D121-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>InsertTrigger</a:Name>
<a:Code>InsertTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% insert on [%TABLQUALIFIER%]%TABLE%
referencing new as new_ins
   for each row (execute procedure [%QUALIFIER%]%PROC%(.FKCOLN(&quot;new_ins.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;));&quot;)
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1034242980</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Insert trigger</a:Comment>
<a:Time/>
<a:TriggerName>ti_%.L:TABLE%</a:TriggerName>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o279">
<a:ObjectID>1114D122-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>UpdateTrigger</a:Name>
<a:Code>UpdateTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% update on [%TABLQUALIFIER%]%TABLE%
referencing new as new_upd old as old_upd
   for each row (execute procedure [%QUALIFIER%]%PROC%(.INCOLN(&quot;old_upd.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;,&quot;)
                                          .INCOLN(&quot;new_upd.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;));&quot;)
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1034242980</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update trigger</a:Comment>
<a:Time/>
<a:Event>Update</a:Event>
<a:TriggerName>tu_%.L:TABLE%</a:TriggerName>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o280">
<a:ObjectID>1114D123-2EF7-11D3-A993-006097355E2B</a:ObjectID>
<a:Name>DeleteTrigger</a:Name>
<a:Code>DeleteTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% delete on [%TABLQUALIFIER%]%TABLE%
referencing old as old_del
   for each row (execute procedure [%QUALIFIER%]%PROC%(.PKCOLN(&quot;old_del.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;));&quot;)
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1034242980</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete trigger</a:Comment>
<a:Time/>
<a:Event>Delete</a:Event>
<a:TriggerName>td_%.L:TABLE%</a:TriggerName>
</o:TriggerTemplate>
</c:TriggerTemplates>
</o:DBMS>

</DBMS>