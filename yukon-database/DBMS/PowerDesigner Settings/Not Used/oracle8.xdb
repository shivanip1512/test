<?xml version="1.0" encoding="UTF-8"?>
<?PowerDesigner AppLocale="UTF16" Code="ORACLE V8" Family="ORACLE" Name="ORACLE Version 8" signature="XDB_XML" version="12.0.0.1690"?>
<!-- do not edit this file -->

<DBMS xmlns:a="attribute" xmlns:c="collection" xmlns:o="object">

<o:DBMS Id="o1">
<a:ObjectID>92DEBEF1-D412-4A2A-A563-4DCAC8D52601</a:ObjectID>
<a:Name>ORACLE Version 8</a:Name>
<a:Code>ORACLE V8</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1095428027</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Family>ORACLE</a:Family>
<a:CheckGlobalScript>&#39;******************************************************************************
&#39;* Purpose:  This VB-Script holds global definitions shared by all the custom-
&#39;*            checks scripts of the model extension.
&#39;******************************************************************************

Option Explicit &#39; This is to ensure all used variables are defined

</a:CheckGlobalScript>
<c:Categories>
<o:TargetCategory Id="o2">
<a:Name>General</a:Name>
<a:Comment>Target DBMS identification</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o3">
<a:Name>SqlSupport</a:Name>
<a:Comment>SQL syntax allowed. This does not impact the script generation, but it impacts the SQL Preview</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o4">
<a:Name>EnableCheck</a:Name>
<a:Comment>Determines if the generation of check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o5">
<a:Name>Enableconstname</a:Name>
<a:Comment>Determines if constraint names are used during the generation</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o6">
<a:Name>UniqConstName</a:Name>
<a:Comment>Determines if unique constraint names for objects are authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o7">
<a:Name>EnableMultiCheck</a:Name>
<a:Comment>Determines if the generation of multiple check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o8">
<a:Name>Script</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the Script generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o9">
<a:Name>Sql</a:Name>
<a:Comment>Contains sub-categories Syntax, Format, File and Keywords. Each sub-category contains entries whose values define general syntax for the database</a:Comment>
<c:Categories>
<o:TargetCategory Id="o10">
<a:Name>Syntax</a:Name>
<a:Comment>Contains general parameters for SQL syntax</a:Comment>
<c:Categories>
<o:CharacterTargetItem Id="o11">
<a:Name>Terminator</a:Name>
<a:Comment>End of command character</a:Comment>
<a:CharacterTargetItem.Value>;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o12">
<a:Name>BlockTerminator</a:Name>
<a:Comment>End of block character</a:Comment>
<a:StringTargetItem.Value>/</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o13">
<a:Name>UseBlockTerm</a:Name>
<a:Comment>Use end of block character by default</a:Comment>
</o:BooleanTargetItem>
<o:CharacterTargetItem Id="o14">
<a:Name>Delimiter</a:Name>
<a:Comment>Field separation character. Example: col1, col2, col3</a:Comment>
<a:CharacterTargetItem.Value>,</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o15">
<a:Name>Quote</a:Name>
<a:Comment>Character used to enclose string values</a:Comment>
<a:CharacterTargetItem.Value>&#39;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o16">
<a:Name>SqlContinue</a:Name>
<a:Comment>Continuation character</a:Comment>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o17">
<a:Name>LineComment</a:Name>
<a:Comment>Characters used to enclose a single line comment</a:Comment>
<a:StringTargetItem.Value>--</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o18">
<a:Name>BlockComment</a:Name>
<a:Comment>Characters used to enclose a multi-line comment</a:Comment>
<a:StringTargetItem.Value>/* */</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o19">
<a:Name>UsingBlockTerm</a:Name>
<a:TextTargetItem.Value>create function, end, 1
{
   begin,,2
   {
      begin, end, 3
      loop, end loop, 4
      if, end if, 4
      case, end case, 4
   }
}
create or replace function, end, 1
{
   begin,,2
   {
      begin, end, 3
      loop, end loop, 4
      if, end if, 4
      case, end case, 4
   }
}
create procedure, end, 1
{
   begin,,2
   {
      begin, end, 3
      loop, end loop, 4
      if, end if, 4
      case, end case, 4
   }
}
create or replace procedure, end, 1
{
   begin,,2
   {
      begin, end, 3
      loop, end loop, 4
      if, end if, 4
      case, end case, 4
   }
}
create trigger, end, 1
{
   begin,,2
   {
      begin, end, 3
      loop, end loop, 4
      if, end if, 4
      case, end case, 4
   }
}
create or replace trigger, end, 1
{
   begin,,2
   {
      begin, end, 3
      loop, end loop, 4
      if, end if, 4
      case, end case, 4
   }
}
create package, end, 1
{
   procedure, ;, 2
   {
      is,end,3
                                {
         is,,4
         begin,,4
                                                {
         
            begin, end, 6
            loop, end loop, 7
            if, end if, 7
            case, end case, 7
         }
                                }
   }
   function, ;, 2
   {
      is,end,3
                                {
         is,,4
         begin,,4
                                                {
            begin, end, 6
            loop, end loop, 7
            if, end if, 7
            case, end case, 7
         }
                                }
   }
   begin,,2
   {
      begin, end, 4
      loop, end loop, 5
      if, end if, 5
      case, end case, 5
   }
}
create or replace package, end, 1
{
   procedure, ;, 2
   {
      is,end,3
                                {
         is,,4
         begin,,4
         {
            begin, end, 6
            loop, end loop, 7
            if, end if, 7
            case, end case, 7
         }
                                }
   }
   function, ;, 2
   {
      is,end,3
                                {
         is,,4
         begin,,4
         {
            begin, end, 6
            loop, end loop, 7
            if, end if, 7
            case, end case, 7
         }
                                }
   }
   begin,,2
   {
      begin, end, 4
      loop, end loop, 5
      if, end if, 5
      case, end case, 5
   }
}

create type body, end, 1
{
   procedure, ;, 2
   {
      is,end,3
                                {
         is,,4
         begin,,4
                                                {
         
            begin, end, 6
            loop, end loop, 7
            if, end if, 7
            case, end case, 7
         }
                                }
   }
   function, ;, 2
   {
      is,end,3
                                {
         is,,4
         begin,,4
                                                {
            begin, end, 6
            loop, end loop, 7
            if, end if, 7
            case, end case, 7
         }
                                }
   }
   begin,,2
   {
      begin, end, 4
      loop, end loop, 5
      if, end if, 5
      case, end case, 5
   }
}
create or replace type body, end, 1
{
   procedure, ;, 2
   {
      is,end,3
                                {
         is,,4
         begin,,4
         {
            begin, end, 6
            loop, end loop, 7
            if, end if, 7
            case, end case, 7
         }
                                }
   }
   function, ;, 2
   {
      is,end,3
                                {
         is,,4
         begin,,4
         {
            begin, end, 6
            loop, end loop, 7
            if, end if, 7
            case, end case, 7
         }
                                }
   }
   begin,,2
   {
      begin, end, 4
      loop, end loop, 5
      if, end if, 5
      case, end case, 5
   }
}

</a:TextTargetItem.Value>
<a:Comment>List of objects using block definition during reverse.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o20">
<a:Name>Format</a:Name>
<a:Comment>Contains entries that define script formatting</a:Comment>
<c:Categories>
<o:StringTargetItem Id="o21">
<a:Name>IllegalChar</a:Name>
<a:Comment>Invalid characters for names</a:Comment>
<a:StringTargetItem.Value>&quot;\ +-*/!=&amp;&lt;&gt;&#39;&quot;()&quot;.</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o22">
<a:Name>UpperCaseOnly</a:Name>
<a:Comment>Uppercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o23">
<a:Name>LowerCaseOnly</a:Name>
<a:Comment>Lowercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o24">
<a:Name>EnableOwnerPrefix</a:Name>
<a:Comment>Object codes can have a prefix made of the object owner code</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o25">
<a:Name>CaseSensitivityUsingQuote</a:Name>
<a:Comment>Determines if the case sensitivity for identifiers is managed using double quotes</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o26">
<a:Name>File</a:Name>
<a:Comment>Contains header, footer and usage text entries used during the generation</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o27">
<a:Name>Header</a:Name>
<a:Comment>Header text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o28">
<a:Name>Footer</a:Name>
<a:Comment>Footer text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o29">
<a:Name>EnableMultiFile</a:Name>
<a:Comment>Multi-script allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:StringTargetItem Id="o30">
<a:Name>ScriptExt</a:Name>
<a:Comment>Main script extension in database generation</a:Comment>
<a:StringTargetItem.Value>sql</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o31">
<a:Name>TableExt</a:Name>
<a:Comment>Other scripts extension in database generation</a:Comment>
<a:StringTargetItem.Value>tab</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o32">
<a:Name>StartCommand</a:Name>
<a:Comment>Command for executing a script</a:Comment>
<a:StringTargetItem.Value>start %NAMESCRIPT%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o33">
<a:Name>Usage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter:
        sqlplus &lt;username&gt;/&lt;password&gt;
  (3) Run the database creation script:
        %STARTCMD%</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in database generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o34">
<a:Name>Usage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter:
        sqlplus &lt;username&gt;/&lt;password&gt;
  (3) Run the database creation scripts:
        %STARTCMD% &lt;script_name&gt;</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in database generation</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o35">
<a:Name>TriggerExt</a:Name>
<a:Comment>Script file extension in triggers and procedures generation</a:Comment>
<a:StringTargetItem.Value>trg</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o36">
<a:Name>TrgUsage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start SQL interpreter:
        sqlplus &lt;username&gt;/&lt;password&gt;
  (3) Execute the trigger creation script:
        start %NAMESCRIPT%</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o37">
<a:Name>TrgUsage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start SQL interpreter:
        sqlplus &lt;username&gt;/&lt;password&gt;
  (3) Execute the triggers creation scripts:
        start &lt;script_name&gt;</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o38">
<a:Name>TrgHeader</a:Name>
<a:TextTargetItem.Value>-- Integrity package declaration
create or replace package IntegrityPackage AS
 procedure InitNestLevel;
 function GetNestLevel return number;
 procedure NextNestLevel;
 procedure PreviousNestLevel;
 end IntegrityPackage;
/

-- Integrity package definition
create or replace package body IntegrityPackage AS
 NestLevel number;

-- Procedure to initialize the trigger nest level
 procedure InitNestLevel is
 begin
 NestLevel := 0;
 end;


-- Function to return the trigger nest level
 function GetNestLevel return number is
 begin
 if NestLevel is null then
     NestLevel := 0;
 end if;
 return(NestLevel);
 end;

-- Procedure to increase the trigger nest level
 procedure NextNestLevel is
 begin
 if NestLevel is null then
     NestLevel := 0;
 end if;
 NestLevel := NestLevel + 1;
 end;

-- Procedure to decrease the trigger nest level
 procedure PreviousNestLevel is
 begin
 NestLevel := NestLevel - 1;
 end;

 end IntegrityPackage;
/</a:TextTargetItem.Value>
<a:Comment>Header text for a triggers and procedures generation script</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o39">
<a:Name>Keywords</a:Name>
<a:Comment>Contains the list of reserved words and functions available in SQL</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o40">
<a:Name>ReservedWord</a:Name>
<a:TextTargetItem.Value>ACCESS
ADD
ALL
ALTER
AND
ANY
AS
ASC
AUDIT
BETWEEN
BY
CHAR
CHECK
CLUSTER
COLUMN
COMMENT
COMPRESS
CONNECT
CREATE
CURRENT
DATE
DECIMAL
DEFAULT
DELETE
DESC
DISTINCT
DROP
ELSE
EXCLUSIVE
EXISTS
FILE
FLOAT
FOR
FROM
GRANT
GROUP
HAVING
IDENTIFIED
IMMEDIATE
IN
INCREMENT
INDEX
INITIAL
INSERT
INTEGER
INTERSECT
INTO
IS
LEVEL
LIKE
LOCK
LONG
MAXEXTENTS
MINUS
MODE
MODIFY
NETWORK
NOAUDIT
NOCOMPRESS
NOT
NOWAIT
NULL
NUMBER
OF
OFFLINE
ON
ONLINE
OPTION
OR
ORDER
PCTFREE
PRIOR
PRIVILEGES
PUBLIC
RAW
RENAME
RESOURCE
REVOKE
ROW
ROWID
ROWNUM
ROWS
SELECT
SESSION
SET
SHARE
SIZE
SMALLINT
START
SUCCESSFUL
SYNONYM
SYSDATE
TABLE
THEN
TO
TRIGGER
UID
UNION
UNIQUE
UPDATE
USER
VALIDATE
VALUES
VARCHAR
VARCHAR2
VIEW
WHENEVER
WHERE
WITH</a:TextTargetItem.Value>
<a:Comment>Reserved words</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o41">
<a:Name>ReservedDefault</a:Name>
<a:TextTargetItem.Value>NULL
SYSDATE</a:TextTargetItem.Value>
<a:Comment>Reserved default values</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o42">
<a:Name>GroupFunc</a:Name>
<a:TextTargetItem.Value>avg()
count()
glb()
lub()
max()
min()
stddev()
sum()
variance()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions to use with group keywords.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o43">
<a:Name>NumberFunc</a:Name>
<a:TextTargetItem.Value>abs()
acos()
asin()
atan()
atan2()
ceil()
cos()
cosh()
exp()
floor()
ln()
log()
mod()
power()
round()
sign()
sin()
sinh()
sqrt()
tan()
tanh()
trunc()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used on numbers</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o44">
<a:Name>CharFunc</a:Name>
<a:TextTargetItem.Value>ascii()
chr()
concat()
initcap()
instr()
instrb()
length()
lengthb()
lower()
lpad()
ltrim()
nls_initcap()
nls_lower()
nls_upper()
nlssort()
replace()
rpad()
rtrim()
soundex()
substr()
substrb()
translate()
upper()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for characters and strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o45">
<a:Name>DateFunc</a:Name>
<a:TextTargetItem.Value>add_months()
last_day()
months_between()
new_time()
next_day()
round()
sysdate
trunc()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for dates</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o46">
<a:Name>ConvertFunc</a:Name>
<a:TextTargetItem.Value>chartorowid()
convert()
hextoraw()
rawtohex()
rowidtochar()
to_char()
to_date()
to_label()
to_multi_byte()
to_number()
to_single_byte()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used to convert values between hex and integer and handling strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o47">
<a:Name>OtherFunc</a:Name>
<a:TextTargetItem.Value>bfilename()
currval
decode()
dump()
empty_blob()
empty_clob()
greatest()
least()
level
nls_charset_decl_len()
nls_charset_id()
nls_charset_name()
nvl()
nextval
rowid
rownum
uid
user
userenv()
vsize()</a:TextTargetItem.Value>
<a:Comment>List of other SQL functions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o48">
<a:Name>ListOperators</a:Name>
<a:TextTargetItem.Value>=
!=
^=
&lt;&gt;
&gt;
&lt;
&gt;=
&lt;=
*=
=*
not
in
not in
between
not between
exists
not exists
like
not like
is
is not
= any
!= any
&gt; any
&lt; any
&gt;= any
&lt;= any
= all
!= all
&gt; all
&lt; all
&gt;= all
&lt;= all</a:TextTargetItem.Value>
<a:Comment>List of operators for comparing values, boolean, and various semantic operators</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o49">
<a:Name>Commit</a:Name>
<a:TextTargetItem.Value>commit</a:TextTargetItem.Value>
<a:Comment>Command for validating the transaction by OBDC</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o50">
<a:Name>Objects</a:Name>
<a:Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:Comment>
<c:Categories>
<o:TargetCategory Id="o51">
<a:Name>Domain</a:Name>
<a:Comment>The following system variables are available:
   &quot;DOMAIN&quot;       // generated code of the domain (also available for columns)
SQL Server specific domain system variables:
   &quot;RULENAME&quot;     // name of the rule object associated with the domain
   &quot;DEFAULTNAME&quot;  // name of the default object associated with the domain
</a:Comment>
</o:TargetCategory>
<o:TargetCategory Id="o52">
<a:Name>Table</a:Name>
<a:Code>TABL</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLE&quot;        // generated code of the table
   &quot;TNAME&quot;        // name of the table
   &quot;TCODE&quot;        // code of the table
   &quot;TLABL&quot;        // comment of the table
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;TABLDEFN&quot;     // complete body of the table definition. Contains definition of columns, checks and keys
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o53">
<a:Name>Enable</a:Name>
<a:Comment>Table allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o54">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o55">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKT_%.U26:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for check of table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o56">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%CLASS% ?
create table [%QUALIFIER%]%TABLE% of [%CLASSQUALIFIER%]%CLASS% [%TABLDEFN% ? (
   %TABLDEFN%
)]
[%OPTIONS%]
:create table [%QUALIFIER%]%TABLE% [%TABLDEFN% ? (
   %TABLDEFN%
)
[%OPTIONS%]]
]
</a:TextTargetItem.Value>
<a:Comment>Command for creating a table. Example: create table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o57">
<a:Name>BeforeCreate</a:Name>
<a:TextTargetItem.Value>.if (%CLUSTERCOLUMNS%)
%CreateCluster%;
.endif(\n)
</a:TextTargetItem.Value>
<a:Comment>Commands executed before create statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o58">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>on commit %s : list=delete rows|preserve rows, default=preserve rows
&lt;physical_properties&gt; : composite=yes
{
&lt;segment_attributes_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
}
organization : composite=yes
{
index : composite=yes
{
&lt;index_organized_table_clause&gt; : composite=yes
{
&lt;segment_attributes_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
}
pctthreshold %d
including %s : nextmand=yes
overflow : composite=yes
{
&lt;segment_attributes_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
}
}
}
}
heap : composite=yes
{
&lt;segment_attributes_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
}
}
}
cluster %s : composite=yes, separator=yes, parenthesis=yes
{
&lt;column&gt; %s : multiple=yes
}
&lt;lob_storage_clause&gt; : composite=yes
{
lob : composite=yes, multiple=yes
{
&lt;lob_item_list&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;lob_item&gt; %s : multiple=yes
}
store as : composite=yes, chldordr=yes
{
&lt;lob_segname&gt; %s
&lt;lob_parameters&gt; : composite=yes, parenthesis=yes
{
tablespace %s : category=tablespace
&lt;storage_in_row&gt; %s : list=enable storage in row|disable storage in row, default=disable storage in row
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
chunk %d
pctversion %d
&lt;cache_clause&gt; %s : list=cache|nocache, default=cache
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
&lt;lob_index_clause&gt; : composite=yes
{
index : composite=yes, chldordr=yes
{
&lt;lob_index_name&gt; %s
&lt;lob_index_parameters&gt; : composite=yes, parenthesis=yes
{
tablespace %s : category=tablespace
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
initrans %d : default=1
maxtrans %d
}
}
}
}
}
}
}
&lt;nested_table_list&gt; : composite=yes, separator=yes
{
&lt;nested_table_col_properties&gt; : composite=yes, multiple=yes
{
nested table %s : composite=yes
{
store as %s
}
}
}
}
&lt;table_properties&gt; : composite=yes
{
&lt;table_partitioning_clauses&gt; : composite=yes
{
&lt;range_partitioning_clause&gt; : composite=yes
{
partition by range : composite=yes
{
&lt;column_list&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;column&gt; %s : multiple=yes
}
&lt;partition_list&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;partition_definition&gt; : composite=yes, multiple=yes
{
partition : composite=yes
{
&lt;partition_name&gt; %s : nextmand=yes
values less than : composite=yes, parenthesis=yes, separator=yes
{
&lt;value_list&gt; %s : multiple=yes, default=maxvalue
}
&lt;segment_attributes_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
}
}
}
}
}
}
}
&lt;cache_clause&gt; %s : list=cache|nocache, default=cache
&lt;parallel_clause&gt; : composite=yes
{
noparallel
parallel : composite=yes, parenthesis=yes
{
degree %s : default=default
instances %s : default=default
}
}
enable : composite=yes
{
&lt;validate_clause&gt; %s : list=validate|novalidate, default=validate
&lt;constraints&gt; : composite=yes
{
&lt;constraint_type&gt; : composite=yes
{
unique : composite=yes
{
&lt;column_list&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;column&gt; %s : multiple=yes
}
}
primary key
constraint %s
}
using index : prevmand=yes, composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
}
exceptions into %s
}
all triggers
}
disable : composite=yes
{
&lt;constraints&gt; : composite=yes
{
&lt;constraint_type&gt; : composite=yes
{
unique : composite=yes
{
&lt;column_list&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;column&gt; %s : multiple=yes
}
}
primary key
constraint %s
}
cascade : prevmand=yes
}
all triggers
}
as %s
}</a:TextTargetItem.Value>
<a:Comment>Available options for creating a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o59">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for table options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o60">
<a:Name>CreateCluster</a:Name>
<a:TextTargetItem.Value>create cluster  [%QUALIFIER%]C_%TCODE% (
   %CLUSTERCOLUMNS%
)

</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o61">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, OPTIONS EX ...}

select
   t.owner,
   t.table_name,
   decode  (t.pct_free,  NULL, &#39;&#39;, 0, &#39;&#39;, &#39; pctfree &#39;  ||t.pct_free)
   ||decode(t.pct_used,  NULL, &#39;&#39;, 0, &#39;&#39;, &#39; pctused &#39;  ||t.pct_used)
   ||decode(t.ini_trans, NULL, &#39;&#39;, 0, &#39;&#39;, &#39; initrans &#39; ||t.ini_trans)
   ||decode(t.max_trans, NULL, &#39;&#39;, 0, &#39;&#39;, &#39; maxtrans &#39; ||t.max_trans)
   ||decode(t.tablespace_name, NULL, &#39;&#39;, &#39; tablespace &#39;||t.tablespace_name)
   ||decode(t.logging, &#39;NO&#39;, &#39; nologging&#39;, &#39;YES&#39;, &#39; logging&#39;, &#39;&#39;)
   ||decode(nvl(t.initial_extent,nvl(t.next_extent,nvl(t.min_extents,nvl(t.max_extents,nvl(t.pct_increase,nvl(t.freelists,nvl(t.freelist_groups,NULL))))))), NULL, &#39;&#39;, &#39; storage (&#39;
      ||decode (t.initial_extent, NULL, &#39;&#39;, &#39; initial &#39; ||(t.initial_extent/1024)||&#39;K&#39;)
      ||decode (t.next_extent, NULL, &#39;&#39;, &#39; next &#39; ||(t.next_extent/1024)||&#39;K&#39;)
      ||decode (t.min_extents, NULL, &#39;&#39;, &#39; minextents &#39; ||t.min_extents)
      ||decode (t.max_extents, NULL, &#39;&#39;, 2147483645, &#39; maxextents unlimited&#39;, &#39; maxextents &#39; ||t.max_extents)
      ||decode (t.pct_increase, NULL, &#39;&#39;, &#39; pctincrease &#39; ||t.pct_increase)
      ||decode (t.freelists, NULL, &#39;&#39;, &#39; freelists &#39;||t.freelists)
      ||decode (t.freelist_groups, NULL, &#39;&#39;, &#39; freelist groups &#39;||t.freelist_groups)
      ||&#39; )&#39;)
   ||&#39; %SqlLobStorage.&#39;||t.owner||t.table_name||&#39;%&#39;
   ||&#39; %SqlNestedTable.&#39;||t.owner||t.table_name||&#39;%&#39;
   ||decode (t.cluster_name, NULL, &#39;&#39;, &#39; cluster &#39;||t.cluster_name||&#39; (%SqlClustDef.&#39;||t.owner||t.table_name||&#39;%)&#39;)
   ||decode (t.partitioned, &#39;YES&#39;, &#39;%SqlPartitionDef.&#39;||t.owner||t.table_name||&#39;%&#39;, &#39;&#39;)
   ||decode (t.cache, &#39;Y&#39;, &#39; cache&#39;, &#39; &#39;)
   ||decode (ltrim(t.degree), &#39;1&#39;, &#39; noparallel&#39;, &#39;DEFAULT&#39;, &#39; parallel&#39;, &#39; parallel &#39;||ltrim(t.degree))
from
   all_tables t
where 1=1
[  and t.owner=%.q:OWNER% ]
[  and t.table_name=%.q:TABLE%]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o62">
<a:Name>SqlChckQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, CONSTNAME, CONSTRAINT}

select 
   k.owner, 
   k.table_name, 
   k.constraint_name, 
   k.search_condition
from 
   sys.all_constraints k
where 
  k.constraint_type=&#39;C&#39;
  and 1 &lt; (select count(*) from sys.all_cons_columns c 
    where c.owner=k.owner and c.table_name=k.table_name and c.constraint_name=k.constraint_name)
[ and k.owner = %.q:SCHEMA%]
[ and k.table_name = %.q:TABLE%]
order by 1,2,3
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o63">
<a:Name>TableComment</a:Name>
<a:TextTargetItem.Value>comment on table [%QUALIFIER%]%TABLE% is
%.q:COMMENT%</a:TextTargetItem.Value>
<a:Comment>Command for adding a table comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o64">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop table [%QUALIFIER%]%TABLE% [cascade constraints]</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table. Example: drop table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o65">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>rename %OLDTABL% to %NEWTABL%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o66">
<a:Name>AlterTableHeader</a:Name>
<a:Comment>Alter table header</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o67">
<a:Name>AlterTableFooter</a:Name>
<a:Comment>Alter table footer</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o68">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a table.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>ALTER=Alter
DELETE=Delete
INDEX=Index
INSERT=Insert
REFERENCES=Refer.
SELECT=Select
UPDATE=Update</a:MapTargetItem.Value>
<a:List>ALTER
DELETE
INDEX
INSERT
REFERENCES
SELECT
UPDATE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o69">
<a:Name>DropTableCheck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o70">
<a:Name>DefineTableCheck</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME%] check (%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of table check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o71">
<a:Name>SqlClustDef</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   t.owner||t.table_name,
   decode (c.column_id, 1, k.tab_column_name, &#39;,&#39;||k.tab_column_name),
   c.column_id
from
[%ISDBAUSER%?dba_clu_columns:user_clu_columns] k, 
   all_tab_columns c,
   all_tables t
where 1=1
[  and t.table_name = %.q:TABLE%]
[  and t.owner = %.q:OWNER%]
   and k.cluster_name = t.cluster_name
   and k.table_name = t.table_name
   and c.table_name = k.cluster_name
   and c.column_name = k.clu_column_name
order by 1, 3</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o72">
<a:Name>SqlHashPartDef</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   tp.table_owner||tp.table_name,
   decode (tp.partition_position, 1, &#39;&#39;, &#39;, &#39;)
   ||&#39;partition &#39;  ||tp.partition_name  ||&#39; tablespace &#39;  ||tp.tablespace_name
from
   all_tab_partitions tp
where tp.high_value_length = 0
[  and tp.table_owner=%.q:OWNER% ]
[  and tp.table_name=%.q:TABLE%]
order by 
   1, tp.partition_position
</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o73">
<a:Name>SqlHVQuery</a:Name>
<a:TextTargetItem.Value>{VAR1NAME, VAR1VALUE}

select
   &#39;HighVal&#39;||tp.partition_position,
   tp.high_value
from
   all_tab_partitions tp
where 1=1
[  and tp.table_owner=%.q:OWNER% ]
[  and tp.table_name=%.q:TABLE%]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse extra physical option data</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o74">
<a:Name>AddTableCheck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME%] check (%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script for modifying table constraints within an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o75">
<a:Name>SqlListRefrTables</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, POWNER, PARENT}

select
   c.owner,
   c.table_name,
   r.owner,
   r.table_name
from
   sys.all_constraints c,
   sys.all_constraints r
where
   (c.constraint_type = &#39;R&#39; and c.r_constraint_name = r.constraint_name and c.r_owner = r.owner)
[   and c.owner = %.q:SCHEMA%]
[   and c.table_name = %.q:TABLE%]
union select
   c.owner,
   c.table_name,
   r.owner,
   r.table_name
from
   sys.all_constraints c,
   sys.all_constraints r
where
   (r.constraint_type = &#39;R&#39; and r.r_constraint_name = c.constraint_name and r.r_owner = c.owner)
[   and c.owner = %.q:SCHEMA%]
[   and c.table_name = %.q:TABLE%]
order by 1, 2, 3, 4</a:TextTargetItem.Value>
<a:Comment>SQL query to list the tables referenced by table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o76">
<a:Name>SqlLobStorage</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   l.owner||l.table_name,
   decode (l.column_name, NULL, &#39;&#39;, &#39; lob (&#39;||l.column_name||&#39;)&#39;
      ||&#39; store as &#39;||decode(substr(l.segment_name, 1, 7), &#39;SYS_LOB&#39;, &#39;&#39;, &#39; &#39;||l.segment_name)
      ||&#39; ( chunk &#39;||l.chunk
      ||&#39; pctversion &#39;||l.pctversion
      ||decode (l.cache, &#39;NO&#39;, &#39; nocache &#39;, &#39;YES&#39;, &#39; cache &#39;)
      ||decode (l.logging, &#39;NO&#39;, &#39; nologging &#39;, &#39;YES&#39;, &#39; logging &#39;)
      ||decode (l.in_row, &#39;NO&#39;, &#39; disable&#39;, &#39;YES&#39;, &#39; enable&#39;)||&#39; storage in row )&#39;)
from 
   all_lobs l
where 1=1
[  and l.owner=%.q:OWNER% ]
[  and l.table_name=%.q:TABLE%]
</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o77">
<a:Name>SqlNestedTable</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   n.owner||n.parent_table_name,   
   &#39; nested table &#39;||n.parent_table_column||&#39; store as &#39;||n.table_name ||&#39;,&#39;
from
   all_nested_tables n
where 1=1
[  and n.owner=%.q:OWNER% ]
[  and n.parent_table_name=%.q:TABLE%]
</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o78">
<a:Name>AllowedADT</a:Name>
<a:TextTargetItem.Value>OBJECT</a:TextTargetItem.Value>
<a:Comment>List of ADT on which a table can be based</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o79">
<a:Name>SqlPartColumnList</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   c.owner||c.name,
   decode (c.column_position, 1, &#39;&#39;, &#39;, &#39;)||c.column_name
from
   all_part_key_columns c
where
   c.object_type like &#39;TABLE%&#39;
[  and c.name=%.q:TABLE%]
order by 
   1, c.column_position</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o80">
<a:Name>SqlPartitionDef</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL EX ...}

select
   pt.owner||pt.table_name,
   decode (pt.PARTITIONING_TYPE, 
      &#39;RANGE&#39;, &#39;partition by range (%SqlPartColumnList.&#39;||pt.owner||pt.table_name||&#39;%) (%SqlRangePartDef.&#39;||pt.owner||pt.table_name||&#39;%)&#39;, 
      &#39;HASH&#39;, &#39;partition by hash (%SqlPartColumnList.&#39;||pt.owner||pt.table_name||&#39;%) (%SqlHashPartDef.&#39;||pt.owner||pt.table_name||&#39;%)&#39;, 
      &#39;&#39;)   
from
   all_part_tables pt
where 1=1
[  and pt.owner=%.q:OWNER% ]
[  and pt.table_name=%.q:TABLE%]
</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o81">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE}

select
   t.owner,
   t.table_name
from
   sys.all_all_tables t
where
   not exists (select 1 from sys.all_snapshots s where s.owner = t.owner and t.table_name = s.table_name)
   and t.iot_name is null
[  and t.table_name=%.q:TABLE%]
[  and t.owner=%.q:SCHEMA%]
order by
   t.owner, t.table_name
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o82">
<a:Name>SqlRangePartDef</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL EX ...}

select
   tp.table_owner||tp.table_name,
   decode (tp.partition_position, 1, &#39;&#39;, &#39;, &#39;)
   ||&#39;partition &#39;  ||tp.partition_name  ||&#39; values less than (%SqlHVQuery.HighVal&#39;||tp.partition_position||&#39;%) &#39;
   ||decode (tp.pct_free, NULL, &#39;&#39;, 10, &#39;&#39;, 0, &#39;&#39;, &#39; pctfree &#39;  ||tp.pct_free)
   ||decode (tp.pct_used, NULL, &#39;&#39;, 40, &#39;&#39;, 0, &#39;&#39;,  &#39; pctused &#39;  ||tp.pct_used)
   ||decode (tp.ini_trans, NULL, &#39;&#39;, 1, &#39;&#39;, 0, &#39;&#39;,  &#39; initrans &#39;  ||tp.ini_trans)
   ||decode (tp.max_trans, NULL, &#39;&#39;, 255, &#39;&#39;, 0, &#39;&#39;,  &#39; maxtrans &#39;  ||tp.max_trans)
   ||decode (tp.tablespace_name, &#39;SYSTEM&#39;, &#39;&#39;, NULL, &#39;&#39;, &#39; tablespace &#39;  ||tp.tablespace_name)
   ||decode(nvl(tp.initial_extent,nvl(tp.next_extent,nvl(tp.min_extent,nvl(tp.max_extent,nvl(tp.pct_increase,nvl(tp.freelists,nvl(tp.freelist_groups,NULL))))))), NULL, &#39;&#39;, &#39; storage (&#39;
      ||decode (tp.initial_extent, NULL, &#39;&#39;, &#39; initial &#39; ||(tp.initial_extent/1024)||&#39;K&#39;)
      ||decode (tp.next_extent, NULL, &#39;&#39;, &#39; next &#39; ||(tp.next_extent/1024)||&#39;K&#39;)
      ||decode (tp.min_extent, NULL, &#39;&#39;, &#39; minextents &#39; ||tp.min_extent)
      ||decode (tp.max_extent, NULL, &#39;&#39;, 2147483645, &#39; maxextents unlimited&#39;, &#39; maxextents &#39; ||tp.max_extent)
      ||decode (tp.pct_increase, NULL, &#39;&#39;, &#39; pctincrease &#39; ||tp.pct_increase)
      ||decode (tp.freelists, NULL, &#39;&#39;, &#39; freelists &#39;||tp.freelists)
      ||decode (tp.freelist_groups, NULL, &#39;&#39;, &#39; freelist groups &#39;||tp.freelist_groups)
      ||&#39; )&#39;)
from
   all_tab_partitions tp
where 1=1
[  and tp.table_owner=%.q:OWNER% ]
[  and tp.table_name=%.q:TABLE%]
order by 
   1, tp.partition_position
</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o83">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

[%ISDBAUSER% ?
select s.grantee grantee,
s.privilege
||
decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;)
|| &#39;,&#39;
from dba_tab_privs s
where
  s.table_name = %.q:TABLE%
[and s.owner = %.q:OWNER%]
order by grantee
:
select s.grantee grantee,
s.privilege
||
decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;)
|| &#39;,&#39;
from user_tab_privs s
where
  s.table_name = %.q:TABLE%
[and s.owner = %.q:OWNER%]
order by grantee
]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o84">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COMMENT, CLASSOWNER, CLASS}

select
   t.owner,
   t.table_name,
   r.comments,
   t.table_type_owner,
   t.table_type
from
   sys.all_tab_comments r,
   sys.all_all_tables t
where
   t.table_name = r.table_name
   and t.owner = r.owner
   and not exists (select 1 from sys.all_snapshots s where s.owner = t.owner and t.table_name = s.table_name)
[  and t.table_name=%.q:TABLE%]
[  and t.owner=%.q:OWNER%]
order by
   t.owner, t.table_name
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o85">
<a:Name>TypeList</a:Name>
<a:Comment>Defines list of available types
Name is the displayed value
Value is the stored value in the object</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:MapTargetItem.Value>Relational=
Object=OBJECT</a:MapTargetItem.Value>
<a:List>Relational
Object
</a:List>
</o:MapTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o86">
<a:Name>Abstract Data Type Procedure</a:Name>
<a:Code>PDMADPR</a:Code>
<a:Comment>Manages the abstract data type package procedure</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o87">
<a:Name>EnableParameterDefault</a:Name>
<a:Comment>Allow to define default value for parameter</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o88">
<a:Name>ParameterTypes</a:Name>
<a:Comment>Available types for abstract data type procedure</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o89">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[%SUPERPROC%?overriding :not overriding ][%ISSPEC%?[%PROCNOTFINAL%?not final :final ][%PROCABSTRACT%?not instantiable :instantiable ]][%PROCTYPE% ][%PROCSTATIC%?static :member ]%PROCFUNC% %ADTPROC% (%PARAM%)[ return %PROCRETURN%][ [.O:[as][is]] 
%PROCDEFN%]
</a:TextTargetItem.Value>
<a:Comment>Command for defining a procedure</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o90">
<a:Name>ProcedureBody</a:Name>
<a:TextTargetItem.Value>begin
end</a:TextTargetItem.Value>
<a:Comment>Template for the body of a abstract data type procedure</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o91">
<a:Name>ProcedureTypes</a:Name>
<a:Comment>List of available procedure types and their corresponding internal code</a:Comment>
<a:MapTargetItem.Value>Procedure=PROC
Function=FUNC
Map=MAP
Order=ORDR</a:MapTargetItem.Value>
<a:List>Procedure
Function
Map
Order
</a:List>
</o:MapTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o92">
<a:Name>Column</a:Name>
<a:Code>COLN</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for columns)
   &quot;COLUMN&quot;       // generated code of the column
   &quot;COLNNO&quot;       // position of the column in the list of columns of the table
   &quot;COLNNAME&quot;     // name of the column
   &quot;COLNCODE&quot;     // code of the column
   &quot;PRIMARY&quot;      // keyword &quot;primary&quot; if the column is primary
   &quot;ISPKEY&quot;       // TRUE if the column is part of the primary key
   &quot;FOREIGN&quot;      // TRUE if the column is part of one foreign key
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o93">
<a:Name>Enable</a:Name>
<a:Comment>Column allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o94">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o95">
<a:Name>EnableDefault</a:Name>
<a:Comment>Default values allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o96">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKC_%.U17:COLUMN%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for a column check parameter</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o97">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[%CLASS% ? [%NOTNULL% ? %20:COLUMN% [default %DEFAULT%] [%NOTNULL%]
      [%CONSTDEFN%]
:[%DEFAULT% ? %20:COLUMN% [default %DEFAULT%] [%NOTNULL%]
      [%CONSTDEFN%]
:[%CONSTRAINT% ? %20:COLUMN%
      [%CONSTDEFN%]]]]
:%20:COLUMN% %30:DATATYPE% [default %DEFAULT%] [%R% ? [with rowid] [scope is [%QUALIFIER%]%S%] [constraint %CONSTNAME%] ] [%NOTNULL%]
      [%CONSTDEFN%]
]</a:TextTargetItem.Value>
<a:Comment>Command for defining a table column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o98">
<a:Name>ColumnComment</a:Name>
<a:TextTargetItem.Value>comment on column [%QUALIFIER%]%TABLE%.%COLUMN% is
%.q:COMMENT%</a:TextTargetItem.Value>
<a:Comment>Command for adding a column comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o99">
<a:Name>Rename</a:Name>
<a:Comment>Command for renaming a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o100">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE% add %COLUMN% %DATATYPE% [default %DEFAULT%][ %NOTNULL%]
   [[constraint %CONSTNAME%] check (%.A:CONSTRAINT%)[ %ExtColumnDeferOption%]]</a:TextTargetItem.Value>
<a:Comment>Command for adding a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o101">
<a:Name>ModifyColumn</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE% modify %COLUMN% %DATATYPE%[%R% ? [with rowid] [scope is [%QUALIFIER%]%S%]]</a:TextTargetItem.Value>
<a:Comment>Command for modifying a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o102">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o103">
<a:Name>ModifyColnNull</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   modify %COLUMN% %MAND%</a:TextTargetItem.Value>
<a:Comment>Command for modifying null/not null for a column in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o104">
<a:Name>ModifyColnDflt</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   modify %COLUMN% default %DEFAULT%</a:TextTargetItem.Value>
<a:Comment>Command for modifying a column default in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o105">
<a:Name>ModifyColnChck</a:Name>
<a:Comment>Command for modifying a column check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o106">
<a:Name>DropColnChck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a column check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o107">
<a:Name>AltEnableAddColnChk</a:Name>
<a:Comment>Column check constraint allowed in an alter table statement</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o108">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, DTTPCODE, LENGTH, SIZE, PREC, NOTNULL (N=&#39;NOT NULL&#39;, *=NULL), DEFAULT, COMMENT}

select
   c.owner,
   c.table_name,
   c.column_name,
   decode(c.data_type_owner, NULL, c.data_type, c.data_type_owner||&#39;.&#39;||c.data_type),
   decode(c.data_type_owner, NULL, decode(c.character_set_name, NULL, decode(c.data_type, &#39;RAW&#39;, c.data_length, c.data_precision), c.char_col_decl_length), NULL),
   c.data_precision,
   decode(c.data_precision, NULL, NULL, c.data_scale),
   c.nullable,
   c.data_default,
   m.comments
from
   sys.all_tab_columns c,
   sys.all_col_comments m
where
   c.table_name = %.q:TABLE%
   and c.table_name = m.table_name
   and c.column_name = m.column_name
   and c.owner = m.owner
[  and c.owner=%.q:SCHEMA%]
order by
   c.owner, c.table_name, c.column_id</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o109">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a column.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>REFERENCES=Refer.
INSERT=Insert
UPDATE=Update</a:MapTargetItem.Value>
<a:List>REFERENCES
INSERT
UPDATE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o110">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o111">
<a:Name>SqlChckQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, CONSTNAME, CONSTRAINT, ExtColumnDeferOption}

select
   c.owner,
   c.table_name,
   c.column_name,
   k.constraint_name,
   k.search_condition,
   decode(k.deferrable||k.deferred,
      &#39;DEFERRABLEIMMEDIATE&#39;, &#39;initially immediate deferrable&#39;,
      &#39;DEFERRABLEDEFERRED&#39;, &#39;deferrable initially deferred&#39;, &#39;not deferrable&#39;)
from
   sys.all_cons_columns c,
   sys.all_constraints k
where
   c.table_name=k.table_name
   and c.owner = k.owner
   and c.constraint_name=k.constraint_name
   and 1 = (select count(*) from sys.all_cons_columns x
      where x.owner=c.owner and x.constraint_name = c.constraint_name and x.table_name = c.table_name)
   and k.generated != &#39;GENERATED NAME&#39;
   and k.constraint_type=&#39;C&#39;
   [and c.table_name=%.q:TABLE%]
   [and c.owner=%.q:SCHEMA%]
order by 1, 2, 3, 4
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o112">
<a:Name>AddColnChck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME%] check (%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script for modifying column constraints within an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o113">
<a:Name>DefineColnChck</a:Name>
<a:TextTargetItem.Value>[%R%?[%ISPKEY%?[constraint %PKNAME% ]primary key ][%ISAKEY%?[constraint %AKNAME% ]unique ]][[constraint %CONSTNAME%] check (%.A:CONSTRAINT%)[ %ExtColumnDeferOption%]]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of column check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o114">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, COLNPERMISSION ID, COLUMN ...}

[%ISDBAUSER% ?
select 
  s.grantee, 
  s.privilege || decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;),
  s.column_name || &#39;,&#39;
from DBA_COL_PRIVS s
where s.table_name = %.q:TABLE%
[and s.owner = %.q:OWNER%]
order by 2
:
select 
  s.grantee, 
  s.privilege || decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;),
  s.column_name || &#39;,&#39;
from USER_COL_PRIVS s
where s.table_name = %.q:TABLE%
[and s.owner = %.q:OWNER%]
order by 2
]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o115">
<a:Name>Index</a:Name>
<a:Code>INDX</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
   &quot;INDEX&quot;        // generated code of the index
   &quot;INDEXNAME&quot;    // index name
   &quot;INDEXCODE&quot;    // index code
   &quot;UNIQUE&quot;       // keyword &quot;unique&quot; when the index is unique
   &quot;INDEXTYPE&quot;    // index type (available only for a few DBMS)
   &quot;INDEXKEY&quot;     // keywords &quot;primary&quot;, &quot;unique&quot; or &quot;foreign&quot; depending on the index origin
   &quot;CIDXLIST&quot;     // list of index columns. Eg: A asc, B desc, C asc
   &quot;CLUSTER&quot;      // keyword &quot;cluster&quot; when the index is cluster
For index columns, the following system variables are available:
   &quot;ASC&quot;          // keywords &quot;ASC&quot; or &quot;DESC&quot; depending on sort order
   &quot;ISASC&quot;        // TRUE if the index column sort is ascending
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o116">
<a:Name>Enable</a:Name>
<a:Comment>Index allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o117">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o118">
<a:Name>MaxColIndex</a:Name>
<a:Comment>Maximum number of columns in an index</a:Comment>
<a:IntegerTargetItem.Value>32</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o119">
<a:Name>UniqName</a:Name>
<a:Comment>Unique index name in the database</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o120">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [%UNIQUE%?%UNIQUE% :[%INDEXTYPE% ]]index [%QUALIFIER%]%INDEX% on [%CLUSTER%?cluster C_%TCODE%:[%TABLQUALIFIER%]%TABLE% (
   %CIDXLIST%
)]
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating an index. Example: create index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o121">
<a:Name>AddColIndex</a:Name>
<a:TextTargetItem.Value>%COLUMN% [%ASC%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an index column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o122">
<a:Name>IndexType</a:Name>
<a:TextTargetItem.Value>bitmap</a:TextTargetItem.Value>
<a:Comment>List of types available for an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o123">
<a:Name>DefIndexType</a:Name>
<a:Comment>Default type for an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o124">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>global partition by range : composite=yes
{
&lt;column_list&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;column&gt; %s : multiple=yes
}
&lt;partition_list&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;global_partition_clause&gt; : composite=yes, multiple=yes
{
partition %s
values less than : composite=yes, parenthesis=yes, separator=yes
{
&lt;value_list&gt; %s : multiple=yes, default=maxvalue
}
&lt;segment_attributes_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
}
}
}
}
&lt;local_partitioned_index&gt; : composite=yes
{
local : composite=yes
{

}
}
&lt;index_attributes&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
&lt;sort&gt; %s : list=sort|nosort|reverse, default=nosort
&lt;parallel_clause&gt; : composite=yes
{
noparallel
parallel : composite=yes, parenthesis=yes
{
degree %s : default=default
instances %s : default=default
}
}
}</a:TextTargetItem.Value>
<a:Comment>Default options for creating an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o125">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for index options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o126">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER, TABLE, OWNER, INDEX, OPTIONS}

select
   i.table_owner,
   i.table_name,
   i.owner,
   i.index_name,
   decode(i.pct_free, 10, &#39;&#39;, &#39;pctfree &#39; || i.pct_free) ||
   decode(i.ini_trans, 2, &#39;&#39;, &#39; initrans &#39; || i.ini_trans) ||
   decode(i.max_trans, 255, &#39;&#39;, &#39; maxtrans &#39; || i.max_trans) ||
   decode(i.tablespace_name, &#39;SYSTEM&#39;, &#39;&#39;, &#39; tablespace &#39; || i.tablespace_name)
from
   all_indexes i
where 1=1
[  and i.table_owner=%.q:SCHEMA%]
[  and i.table_name=%.q:TABLE%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o127">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop index [%QUALIFIER%]%INDEX%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an index. Example: drop index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o128">
<a:Name>SqlSysIndexQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, INDEX}

select
   i.table_owner,
   i.table_name,
   i.index_name
from
   all_indexes i
where
   i.generated=&#39;Y&#39;
</a:TextTargetItem.Value>
<a:Comment>SQL query to list system indexes created by the database</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o129">
<a:Name>EnableCluster</a:Name>
<a:Comment>Cluster option available for indexes</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o130">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o131">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER ID, TABLE ID, OWNER ID, INDEX ID, UNIQUE ID, INDEXTYPE ID, CIDXLIST ...}

select
   i.table_owner,
   i.table_name,
   i.owner,
   i.index_name,
   decode(i.uniqueness, &#39;UNIQUE&#39;, &#39;unique&#39;, &#39;&#39;),
   decode(i.index_type, &#39;BITMAP&#39;, &#39;bitmap&#39;, &#39;&#39;),
   c.column_name||&#39;, &#39;,
   c.column_position
from
   all_indexes i,
   all_ind_columns c
where not exists (select 1 from all_constraints k where k.constraint_name = i.index_name and k.owner=i.table_owner and k.constraint_type in (&#39;P&#39;, &#39;U&#39;))
   and c.table_owner=i.table_owner
   and c.table_name=i.table_name
   and c.index_name=i.index_name
[  and i.table_owner=%.q:SCHEMA%]
[  and i.table_name=%.q:TABLE%]
order by 1,2,3,4,8
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o132">
<a:Name>PKey</a:Name>
<a:Code>PKEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o133">
<a:Name>Enable</a:Name>
<a:Comment>Primary key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o134">
<a:Name>PkAutoIndex</a:Name>
<a:Comment>Primary key is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o135">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>PK_%.U27:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for primary keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o136">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>&lt;constraint_state&gt; : composite=yes
{
&lt;deferrable&gt; %s : list=deferrable|not deferrable, default=deferrable
initially %s : list=immediate|deferred, default=immediate
using index : composite=yes
{

pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
&lt;sort&gt; %s : list=sort|nosort|reverse, default=nosort
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
}
&lt;enable&gt; %s : list=enable|disable, default=enable
&lt;validate_clause&gt; %s : list=validate|novalidate, default=validate
exceptions into %s
}</a:TextTargetItem.Value>
<a:Comment>Available options for creating a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o137">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for primary key options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o138">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME%] primary key (%PKEYCOLUMNS%)
      [%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o139">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME%] primary key (%PKEYCOLUMNS%)
      [%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for adding a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o140">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop primary key [cascade]</a:TextTargetItem.Value>
<a:Comment>Command for dropping a primary key</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o141">
<a:Name>Key</a:Name>
<a:Code>KEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;COLUMNS&quot;      // List of columns of the key. Eg: &quot;A, B, C&quot;
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o142">
<a:Name>Enable</a:Name>
<a:Comment>UNIQUE constraint allowed for tables</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o143">
<a:Name>UniqConstAutoIndex</a:Name>
<a:Comment>UNIQUE constraint is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o144">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>AK_%.U18:AKEY%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for alternate keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o145">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>&lt;constraint_state&gt; : composite=yes
{
&lt;deferrable&gt; %s : list=deferrable|not deferrable, default=deferrable
initially %s : list=immediate|deferred, default=immediate
using index : composite=yes
{

pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
&lt;sort&gt; %s : list=sort|nosort|reverse, default=nosort
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
}
&lt;enable&gt; %s : list=enable|disable, default=enable
&lt;validate_clause&gt; %s : list=validate|novalidate, default=validate
exceptions into %s
}</a:TextTargetItem.Value>
<a:Comment>Available options for an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o146">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for alternate key options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o147">
<a:Name>SqlAkeyIndex</a:Name>
<a:TextTargetItem.Value>select I.INDEX_NAME
from ALL_INDEXES I, ALL_CONSTRAINTS CS
where CS.CONSTRAINT_TYPE = &#39;U&#39; and CS.OWNER = %.q:USER% and
      CS.CONSTRAINT_NAME = I.INDEX_NAME and
      I.TABLE_OWNER = %.q:USER% and I.TABLE_NAME = %.q:TABLE%</a:TextTargetItem.Value>
<a:Comment>SQL query to obtain the alternate key indexes of a table by ODBC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o148">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop unique (%COLUMNS%) [cascade]</a:TextTargetItem.Value>
<a:Comment>Command for dropping an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o149">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME%] unique (%COLUMNS%)
      [%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o150">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME%] unique (%COLUMNS%)
      [%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for adding an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o151">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, ISPKEY ID, CONSTNAME ID, COLUMNS ...}

select
   t.owner,
   t.table_name,
   decode(t.constraint_type,&#39;P&#39;,1,0),
   t.constraint_name,
   c.column_name||&#39;,&#39;,
   c.position
from
   all_constraints t,
   all_cons_columns c
where
   c.constraint_name = t.constraint_name
   and c.owner = t.owner
   and t.constraint_type in (&#39;P&#39;,&#39;U&#39;)
[  and t.table_name=%.q:TABLE%]
[  and t.owner=%.q:OWNER%]
order by
   1, 2, 4, 6</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o152">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, CONSTNAME, OPTIONS}

[%ISODBCUSER%?select
   &#39;%SCHEMA%&#39;,
   c.table_name,
   c.constraint_name,
   &#39;using index&#39;||
   &#39; pctfree &#39; || i.pct_free||
   &#39; initrans &#39; || i.ini_trans ||
   &#39; maxtrans &#39; || i.max_trans ||
   &#39; tablespace &#39; || i.tablespace_name||
   &#39; storage (initial &#39;|| (i.initial_extent/1024)||&#39;K&#39; ||
   &#39; next &#39;|| (i.next_extent/1024)||&#39;K&#39; ||
   &#39; minextents &#39;|| i.min_extents ||
   decode (i.max_extents, 2147483645, &#39; maxextents unlimited&#39;, &#39; maxextents &#39;|| i.max_extents) ||
   &#39; pctincrease &#39;|| i.pct_increase||
   &#39; freelists &#39;||i.freelists ||
   &#39; freelist groups &#39;||i.freelist_groups ||&#39;)&#39;
from
   sys.user_indexes i,
   sys.user_constraints c
where
   i.index_name=c.constraint_name
   and i.table_name=c.table_name
   and c.constraint_type in (&#39;P&#39;, &#39;U&#39;)
[  and c.table_name=%.q:TABLE%]
:select
   i.table_owner,
   c.table_name,
   c.constraint_name,
   &#39;using index&#39;||
   &#39; pctfree &#39; || i.pct_free||
   &#39; initrans &#39; || i.ini_trans ||
   &#39; maxtrans &#39; || i.max_trans ||
   &#39; tablespace &#39; || i.tablespace_name||
   &#39; storage (initial &#39;|| (i.initial_extent/1024)||&#39;K&#39; ||
   &#39; next &#39;|| (i.next_extent/1024)||&#39;K&#39; ||
   &#39; minextents &#39;|| i.min_extents ||
   decode (i.max_extents, 2147483645, &#39; maxextents unlimited&#39;, &#39; maxextents &#39;|| i.max_extents) ||
   &#39; pctincrease &#39;|| i.pct_increase||
   &#39; freelists &#39;||i.freelists ||
   &#39; freelist groups &#39;||i.freelist_groups ||&#39;)&#39;
from
   sys.all_indexes i,
   sys.all_constraints c
where
   i.index_name=c.constraint_name
   and i.table_name=c.table_name
   and c.constraint_type in (&#39;P&#39;, &#39;U&#39;)
[  and i.table_owner=%.q:SCHEMA%]
[  and c.table_name=%.q:TABLE%]
]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o153">
<a:Name>Procedure</a:Name>
<a:Code>PROC</a:Code>
<a:Comment>The following system variables are available:
   &quot;PROC&quot;         // generated code of the procedure (also available for trigger when the trigger is implemented with a procedure)
   &quot;FUNC&quot;         // generated code of the procedure if the procedure is a function (with return value)
   &quot;PROCPRMS&quot;     // list of parameters of the procedure (also available for function)
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o154">
<a:Name>Enable</a:Name>
<a:Comment>Procedure allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o155">
<a:Name>EnableFunc</a:Name>
<a:Comment>Function allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o156">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o157">
<a:Name>MaxFuncLen</a:Name>
<a:Comment>Function name length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o158">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop procedure [%QUALIFIER%]%PROC%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a procedure. Example: drop procedure %PROC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o159">
<a:Name>DropFunc</a:Name>
<a:TextTargetItem.Value>drop function [%QUALIFIER%]%FUNC%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a function. Example: drop function %FUNC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o160">
<a:Name>CustomProc</a:Name>
<a:TextTargetItem.Value>create or replace procedure [%QUALIFIER%]%PROC%(&lt;arg&gt; in out &lt;type&gt;) as
declare
begin

end;
</a:TextTargetItem.Value>
<a:Comment>Command for creating a stored procedure</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o161">
<a:Name>CustomFunc</a:Name>
<a:TextTargetItem.Value>create or replace function [%QUALIFIER%]%FUNC%(&lt;arg&gt; &lt;type&gt;) return &lt;type&gt; as
declare
    &lt;retval&gt;  &lt;type&gt;;
begin
    return (&lt;retval&gt;);
end;
</a:TextTargetItem.Value>
<a:Comment>Command for creating a function</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o162">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o163">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, PROC, FUNC}

[%ISODBCUSER% ?
select distinct
   %.q:SCHEMA%,
   decode (type, &#39;PROCEDURE&#39;, name, &#39;&#39;),
   decode (type, &#39;FUNCTION&#39;, name, &#39;&#39;)
from
   sys.user_source
where
   type in (&#39;PROCEDURE&#39;, &#39;FUNCTION&#39;)
order by
   2, 3
:
select distinct
   owner,
   decode (type, &#39;PROCEDURE&#39;, name, &#39;&#39;),
   decode (type, &#39;FUNCTION&#39;, name, &#39;&#39;)
from
   sys.all_source
where
   type in (&#39;PROCEDURE&#39;, &#39;FUNCTION&#39;)
[  and owner = %.q:SCHEMA%]
order by
   1, 2, 3
]</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o164">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, PROC ID, SCRIPT ...}

select
   owner,
   name,
   text
from
   sys.all_source
where
   type in (&#39;PROCEDURE&#39;,&#39;FUNCTION&#39;)
   [and owner=%.q:SCHEMA%]
order by
   owner,
   name,
   line
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o165">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a procedure.
The first column is the SQL name of permission (eg: EXECUTE)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>EXECUTE=Execute</a:MapTargetItem.Value>
<a:List>EXECUTE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o166">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create[ or replace] procedure [%QUALIFIER%]%PROC%[%PROCPRMS%?([%PROCPRMS%])]
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a procedure. Example: create procedure %PROC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o167">
<a:Name>CreateFunc</a:Name>
<a:TextTargetItem.Value>create[ or replace] function [%QUALIFIER%]%FUNC%[%PROCPRMS%?([%PROCPRMS%])]
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a function. Example: create function %FUNC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o168">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

[%ISDBAUSER% ?
select s.grantee grantee,
s.privilege
||
decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;)
|| &#39;,&#39;
from dba_tab_privs s
where
  s.table_name = %.q:PROC%
[and s.owner = %.q:OWNER%]
order by grantee
:
select s.grantee grantee,
s.privilege
||
decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;)
|| &#39;,&#39;
from user_tab_privs s
where
  s.table_name = %.q:PROC%
[and s.owner = %.q:OWNER%]
order by grantee
]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o169">
<a:Name>EnableSynonym</a:Name>
<a:Comment>Synonym supported</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o170">
<a:Name>Reference</a:Name>
<a:Code>REFR</a:Code>
<a:Comment>The following system variables are available:
   &quot;REFR&quot;         // generated code of the reference
   &quot;REFNAME&quot;      // reference name
   &quot;PARENT&quot;       // generated code of the parent table
   &quot;PNAME&quot;        // name of the parent table
   &quot;PCODE&quot;        // code of the parent table
   &quot;CHILD&quot;        // generated code of the reference
   &quot;CNAME&quot;        // name of the child table
   &quot;CCODE&quot;        // code of the child table
   &quot;PQUALIFIER&quot;   // qualifier of the parent table. See QUALIFIER
   &quot;CQUALIFIER&quot;   // qualifier of the child table. See QUALIFIER
   &quot;REFRNAME&quot;     // Reference name
   &quot;REFRCODE&quot;     // Reference code
   &quot;FKCONSTRAINT&quot; // Reference constraint name (foreign key)
   &quot;PKCONSTRAINT&quot; // constraint name of the parent key used to reference object
   &quot;CKEYCOLUMNS&quot;  // list of parent key columns. Eg: C1, C2, C3
   &quot;FKEYCOLUMNS&quot;  // list of child foreign key columns. Eg:
   &quot;UPDCONST&quot;     // Update declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;DELCONST&quot;     // Delete declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;MINCARD&quot;      // Min cardinality
   &quot;MAXCARD&quot;      // Max cardinality
   &quot;POWNER&quot;       // Parent table owner
   &quot;COWNER&quot;       // child table owner
   &quot;CHCKONCMMT&quot;   // TRUE when check on commit is selected on the reference (ASA 6.0 specific)

For reference joins (couple of column in a reference),
the following system variables are available:
   &quot;CKEYCOLUMN&quot;   // generated code of the parent table column (primary key)
   &quot;FKEYCOLUMN&quot;   // generated code of the child table column (foreign key)
   &quot;PK&quot;           // primary key column generated code
   &quot;PKNAME&quot;       // primary key column name
   &quot;FK&quot;           // foreign key column generated code
   &quot;FKNAME&quot;       // foreign key column name
   &quot;AK&quot;           // alternate key column code (same as PK)
   &quot;AKNAME&quot;       // alternate key column name (same as PKNAME)
   &quot;COLTYPE&quot;      // primary column column datatype
   &quot;DEFAULT&quot;      // foreign key column default value
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o171">
<a:Name>Enable</a:Name>
<a:Comment>Foreign key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o172">
<a:Name>FKAutoIndex</a:Name>
<a:Comment>Foreign key is auto-indexed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o173">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>FK_%.U8:CHILD%_%.U9:REFR%_%.U8:PARENT%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for foreign keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o174">
<a:Name>CheckOnCommit</a:Name>
<a:Comment>Referential integrity test differed after the COMMIT</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o175">
<a:Name>DclDelIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT
CASCADE</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for delete</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o176">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME%] foreign key (%FKEYCOLUMNS%)
      references [%PQUALIFIER%]%PARENT% [(%CKEYCOLUMNS%)]
     [%R%?on delete %DELCONST%:[%DELCONST%=RESTRICT? :[ on delete %DELCONST%]]][ %ExtReferenceDeferOption%]
</a:TextTargetItem.Value>
<a:Comment>Command for defining a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o177">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add [%R%?(][constraint %CONSTNAME%] foreign key (%FKEYCOLUMNS%)
      references [%PQUALIFIER%]%PARENT% [(%CKEYCOLUMNS%)]
     [%R%?on delete %DELCONST%:[%DELCONST%=RESTRICT? :[ on delete %DELCONST%]]][ %ExtReferenceDeferOption%]
[%R%?)]</a:TextTargetItem.Value>
<a:Comment>Command for adding a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o178">
<a:Name>DclUpdIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for update</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o179">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{COWNER, CHILD, FKCONSTRAINT, POWNER, PARENT, PKCONSTRAINT, DELCONST, ExtReferenceDeferOption}

select
   c.owner,
   c.table_name,
   c.constraint_name,
   p.owner,
   p.table_name,
   p.constraint_name,
   c.delete_rule,
   decode(c.deferrable||c.deferred,
      &#39;DEFERRABLEIMMEDIATE&#39;, &#39;initially immediate deferrable&#39;,
      &#39;DEFERRABLEDEFERRED&#39;, &#39;deferrable initially deferred&#39;, &#39;not deferrable&#39;)
from
   sys.all_constraints c,
   sys.all_constraints p
where
   c.constraint_type = &#39;R&#39;
   and c.r_constraint_name = p.constraint_name
   and c.r_owner = p.owner
   and c.generated != &#39;GENERATED_NAME&#39;
[  and c.table_name = %.q:TABLE%]
[  and c.owner = %.q:SCHEMA%]
order by
   1,2
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o180">
<a:Name>SqlListChildrenQuery</a:Name>
<a:TextTargetItem.Value>{CKEYCOLUMN, FKEYCOLUMN}

[%ISODBCUSER%?select
   p.column_name,
   f.column_name
from
   sys.user_cons_columns f,
   sys.all_cons_columns p
where
  f.position = p.position
  and f.table_name=%.q:TABLE%
[ and p.owner=%.q:POWNER%]
  and p.table_name=%.q:PARENT%
  and f.constraint_name=%.q:FKCONSTRAINT%
  and p.constraint_name=%.q:PKCONSTRAINT%
order by
   f.position
:select
   p.column_name,
   f.column_name
from
   sys.all_cons_columns f,
   sys.all_cons_columns p
where
  f.position = p.position
  and f.owner=%.q:SCHEMA%
  and f.table_name=%.q:TABLE%
[ and p.owner=%.q:POWNER%]
  and p.table_name=%.q:PARENT%
  and f.constraint_name=%.q:FKCONSTRAINT%
  and p.constraint_name=%.q:PKCONSTRAINT%
order by f.position
]
</a:TextTargetItem.Value>
<a:Comment>SQL query to list reference joins</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o181">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o182">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a foreign key</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o183">
<a:Name>DB Package Pragma</a:Name>
<a:Code>PDMPKPA</a:Code>
<a:Comment>Manages the database package pragma directive</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o184">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>pragma %DBPKPRAGMA% (%DBPKPRAGMAOBJ%, %DBPKPRAGMAPARAM%)</a:TextTargetItem.Value>
<a:Comment>Command for defining a pragma directive</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o185">
<a:Name>View</a:Name>
<a:Code>VIEW</a:Code>
<a:Comment>The following system variables are available:
   &quot;VIEW&quot;         // generated code of the view
   &quot;VIEWNAME&quot;     // view name
   &quot;VIEWCODE&quot;     // view code
   &quot;VIEWCOLN&quot;     // List of columns of the view. Eg: &quot;A, B, C&quot;
   &quot;SQL&quot;          // SQL text of the view. Eg: Select * from T1
   &quot;VIEWCHECK&quot;    // Keyword &quot;with check option&quot; if selected on the view
   &quot;SCRIPT&quot;       // complete view creation order. Eg: create view V1 as select * from T1
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o186">
<a:Name>Enable</a:Name>
<a:Comment>View allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o187">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create[%VIEWSTYLE%=view? or replace][%ExtViewForce%? force:[%R%?[ no force]]] %.L:VIEWSTYLE% [%QUALIFIER%]%VIEW%[
   %OPTIONS%][(%VIEWCOLN%)] as
%SQL%
[%VIEWCHECK%] [%R%with read only]</a:TextTargetItem.Value>
<a:Comment>Command for creating a view. Example: create view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o188">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop %.L:VIEWSTYLE% [%QUALIFIER%]%VIEW%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a view. Example: drop view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o189">
<a:Name>ViewComment</a:Name>
<a:TextTargetItem.Value>comment on table [%QUALIFIER%]%VIEW% is
%.q:COMMENT%</a:TextTargetItem.Value>
<a:Comment>Command for adding a view comment.</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o190">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a view.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>DELETE=Delete
INSERT=Insert
SELECT=Select
UPDATE=Update</a:MapTargetItem.Value>
<a:List>DELETE
INSERT
SELECT
UPDATE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o191">
<a:Name>ViewCheck</a:Name>
<a:TextTargetItem.Value>with check option</a:TextTargetItem.Value>
<a:Comment>Option for checking a view</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o192">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, VIEW, VIEWSTYLE}

select
   v.owner,
   v.view_name,
   &#39;&#39;
from
   sys.all_views v
[where v.owner=%.q:SCHEMA%]
union select
   v.owner,
   v.name,
   &#39;snapshot&#39;
from
  sys.all_snapshots v
[where v.owner=%.q:SCHEMA%]
order by
   1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o193">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, VIEW, SCRIPT EX, COMMENT}

select
   v.owner,
   v.view_name,
   &#39;%SqlGetViewText.&#39;||v.view_name||&#39;Text%&#39;,
   r.comments
from
   sys.all_views v,
   sys.all_tab_comments r
where  r.table_name = v.view_name
   and r.owner = v.owner
   and r.table_type = &#39;VIEW&#39;
[  and v.owner=%.q:OWNER%]
[  and v.view_name=%.q:VIEW%]
union select
   v.owner,
   v.name,
   &#39;%SqlGetSnapshotText.&#39;||v.name||&#39;Text%&#39;,
   r.comments
from
   sys.all_snapshots v,
   sys.all_tab_comments r
where  r.table_name = v.name
   and r.owner = v.owner
   and r.table_type = &#39;TABLE&#39;
[  and v.owner=%.q:OWNER%]
[  and v.name=%.q:VIEW%]
order by 1,2
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o194">
<a:Name>SqlGetViewText</a:Name>
<a:TextTargetItem.Value>{A, a}

select
   view_name||&#39;Text&#39;, text
from
   sys.all_views
where view_name=%.q:VIEW%
and owner=%.q:OWNER%</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o195">
<a:Name>SqlGetSnapshotText</a:Name>
<a:TextTargetItem.Value>{A, a}

select
   name||&#39;Text&#39;, query
from
   sys.all_snapshots
where name=%.q:VIEW%
and owner=%.q:OWNER%</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o196">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>&lt;snapshot_options&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
&lt;lob_storage_clause&gt; : composite=yes
{
lob : composite=yes, multiple=yes
{
&lt;lob_item_list&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;lob_item&gt; %s : multiple=yes
}
store as : composite=yes, chldordr=yes
{
&lt;lob_segname&gt; %s
&lt;lob_parameters&gt; : composite=yes, parenthesis=yes
{
tablespace %s : category=tablespace
&lt;storage_in_row&gt; %s : list=enable storage in row|disable storage in row, default=disable storage in row
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
chunk %d
pctversion %d
&lt;cache_clause&gt; %s : list=cache|nocache, default=cache
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
&lt;lob_index_clause&gt; : composite=yes
{
index : composite=yes, chldordr=yes
{
&lt;lob_index_name&gt; %s
&lt;lob_index_parameters&gt; : composite=yes, parenthesis=yes
{
tablespace %s : category=tablespace
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
initrans %d : default=1
maxtrans %d
}
}
}
}
}
}
}
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
&lt;cache_clause&gt; %s : list=cache|nocache, default=cache
cluster %s : composite=yes, separator=yes, parenthesis=yes
{
&lt;column&gt; %s : multiple=yes
}
&lt;table_partition_clause&gt; : composite=yes
{
partition by range : composite=yes
{
&lt;column_list&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;column&gt; %s : multiple=yes
}
&lt;partition_list&gt; : composite=yes, separator=yes, parenthesis=yes
{
partition : composite=yes, multiple=yes
{
&lt;partition_name&gt; %s : nextmand=yes
values less than : composite=yes, parenthesis=yes, separator=yes
{
&lt;value_list&gt; %s : multiple=yes, default=maxvalue
}
&lt;segment_attributes_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
}
}
}
}
}
&lt;parallel_clause&gt; : composite=yes
{
noparallel
parallel : composite=yes, parenthesis=yes
{
degree %s : default=default
instances %s : default=default
}
}
&lt;using_index_clause&gt; : composite = yes
{
using no index
using index : composite=yes
{
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
tablespace %s : category=tablespace
}
}
refresh : composite=yes
{
&lt;fast_complete_force&gt; %s : list=fast|complete|force, default=fast
start with %s
next %s
with %s : list=primary key|rowid
using : composite=yes, chldmand=yes
{
&lt;default_rollback_segment&gt; %s : list=default master rollback segment|default local rollback segment, default=default local rollback segment
master rollback segment %s
local rollback segment %s
}
}
for %s : list=update, default=update
}</a:TextTargetItem.Value>
<a:Comment>Available options for creating a snapshot (or materialized view)</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o197">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, VIEW ID, OPTIONS EX ...}

select
   v.owner,
   v.name,
   decode (t.pct_free, NULL, &#39;&#39;, 10, &#39;&#39;, 0, &#39;&#39;, &#39; pctfree &#39;  ||t.pct_free)
   ||decode (t.pct_used, NULL, &#39;&#39;, 40, &#39;&#39;, 0, &#39;&#39;,  &#39; pctused &#39;  ||t.pct_used)
   ||decode (t.ini_trans, NULL, &#39;&#39;, 1, &#39;&#39;, 0, &#39;&#39;,  &#39; initrans &#39;  ||t.ini_trans)
   ||decode (t.max_trans, NULL, &#39;&#39;, 255, &#39;&#39;, 0, &#39;&#39;,  &#39; maxtrans &#39;  ||t.max_trans)
   ||decode (t.tablespace_name, &#39;SYSTEM&#39;, &#39;&#39;, NULL, &#39;&#39;, &#39; tablespace &#39;  ||t.tablespace_name)
   ||decode (t.logging, &#39;NO&#39;, &#39; nologging&#39;, &#39;&#39;)
   ||decode(nvl(t.initial_extent,nvl(t.next_extent,nvl(t.min_extents,nvl(t.max_extents,nvl(t.pct_increase,nvl(t.freelists,nvl(t.freelist_groups,NULL))))))), NULL, &#39;&#39;, &#39; storage (&#39;
      ||decode (t.initial_extent, NULL, &#39;&#39;, &#39; initial &#39; ||(t.initial_extent/1024)||&#39;K&#39;)
      ||decode (t.next_extent, NULL, &#39;&#39;, &#39; next &#39; ||(t.next_extent/1024)||&#39;K&#39;)
      ||decode (t.min_extents, NULL, &#39;&#39;, &#39; minextents &#39; ||t.min_extents)
      ||decode (t.max_extents, NULL, &#39;&#39;, 2147483645, &#39; maxextents unlimited&#39;, &#39; maxextents &#39; ||t.max_extents)
      ||decode (t.pct_increase, NULL, &#39;&#39;, &#39; pctincrease &#39; ||t.pct_increase)
      ||decode (t.freelists, NULL, &#39;&#39;, &#39; freelists &#39;||t.freelists)
      ||decode (t.freelist_groups, NULL, &#39;&#39;, &#39; freelist groups &#39;||t.freelist_groups)
      ||&#39; )&#39;)
   ||decode (t.cluster_name, NULL, &#39;&#39;, &#39; cluster &#39;||t.cluster_name||&#39; (&#39;),
   0
from
   all_tables t, all_snapshots v
where  v.table_name = t.table_name
   and v.owner = t.owner
[  and v.owner=%.q:OWNER% ]
[  and v.name=%.q:VIEW%]
union select
   v.owner,
   v.name,
   decode (c.column_id, 1, c.column_name, &#39;,&#39;||c.column_name),
   c.column_id
from
   all_snapshots v, all_tables t, all_clusters k, all_tab_columns c
where  v.table_name = t.table_name
   and v.owner = t.owner
   and t.cluster_name=k.cluster_name
   and t.owner=k.owner
   and c.owner=t.owner
   and c.table_name=k.cluster_name
   and t.cluster_name is not null
[  and v.owner=%.q:OWNER% ]
[  and v.name=%.q:VIEW%]
union select
   v.owner,
   v.name,
   &#39;)&#39;,
   98
from
   all_tables t, all_snapshots v
where  v.table_name = t.table_name
   and v.owner = t.owner
   and t.cluster_name is not null
[  and v.owner=%.q:OWNER% ]
[  and v.name=%.q:VIEW%]
union select
   v.owner,
   v.name,
   &#39;lob (&#39;||l.column_name||&#39;) store as (&#39;
   ||&#39; chunk &#39;||l.chunk
   ||&#39; pctversion &#39;||l.pctversion
   ||decode (l.cache, &#39;NO&#39;, &#39; nocache &#39;, &#39;YES&#39;, &#39; cache &#39;)
   ||decode (l.logging, &#39;NO&#39;, &#39; nologging &#39;, &#39;YES&#39;, &#39; logging &#39;)
   ||decode (l.in_row, &#39;NO&#39;, &#39; disable&#39;, &#39;YES&#39;, &#39; enable&#39;)||&#39; storage in row&#39;
   ||&#39; )&#39;,
   99
from
   all_lobs l,
   all_snapshots v
where
   l.table_name=v.table_name
   and l.owner=v.owner
[  and v.owner=%.q:OWNER% ]
[  and v.name=%.q:VIEW%]
union select
   v.owner,
   v.name,
   decode (kc.column_position, 1, decode (pt.PARTITIONING_TYPE, &#39;RANGE&#39;, &#39;partition by range (&#39;, &#39;HASH&#39;, &#39;partition by hash (&#39;, &#39;&#39;), &#39;, &#39;)||kc.column_name,
   kc.column_position+100
from
   all_snapshots v, all_part_tables pt, all_part_key_columns kc
where  v.table_name = pt.table_name
   and v.owner = pt.owner
   and kc.name=pt.table_name
   and kc.object_type like &#39;VIEW%&#39;
[  and v.owner=%.q:OWNER% ]
[  and v.name=%.q:VIEW%]
union select
   v.owner,
   v.name,
   decode (tp.partition_position, 1, &#39;) (&#39;, &#39;, &#39;)
   ||&#39;partition &#39;  ||tp.partition_name  ||&#39; values less than (%SqlHVQuery.HighVal&#39;||tp.partition_position||&#39;%) &#39;
   ||decode (tp.pct_free, NULL, &#39;&#39;, 10, &#39;&#39;, 0, &#39;&#39;, &#39; pctfree &#39;  ||tp.pct_free)
   ||decode (tp.pct_used, NULL, &#39;&#39;, 40, &#39;&#39;, 0, &#39;&#39;,  &#39; pctused &#39;  ||tp.pct_used)
   ||decode (tp.ini_trans, NULL, &#39;&#39;, 1, &#39;&#39;, 0, &#39;&#39;,  &#39; initrans &#39;  ||tp.ini_trans)
   ||decode (tp.max_trans, NULL, &#39;&#39;, 255, &#39;&#39;, 0, &#39;&#39;,  &#39; maxtrans &#39;  ||tp.max_trans)
   ||decode (tp.tablespace_name, &#39;SYSTEM&#39;, &#39;&#39;, NULL, &#39;&#39;, &#39; tablespace &#39;  ||tp.tablespace_name)
   ||decode(nvl(tp.initial_extent,nvl(tp.next_extent,nvl(tp.min_extent,nvl(tp.max_extent,nvl(tp.pct_increase,nvl(tp.freelists,nvl(tp.freelist_groups,NULL))))))), NULL, &#39;&#39;, &#39; storage (&#39;
      ||decode (tp.initial_extent, NULL, &#39;&#39;, &#39; initial &#39; ||(tp.initial_extent/1024)||&#39;K&#39;)
      ||decode (tp.next_extent, NULL, &#39;&#39;, &#39; next &#39; ||(tp.next_extent/1024)||&#39;K&#39;)
      ||decode (tp.min_extent, NULL, &#39;&#39;, &#39; minextents &#39; ||tp.min_extent)
      ||decode (tp.max_extent, NULL, &#39;&#39;, 2147483645, &#39; maxextents unlimited&#39;, &#39; maxextents &#39; ||tp.max_extent)
      ||decode (tp.pct_increase, NULL, &#39;&#39;, &#39; pctincrease &#39; ||tp.pct_increase)
      ||decode (tp.freelists, NULL, &#39;&#39;, &#39; freelists &#39;||tp.freelists)
      ||decode (tp.freelist_groups, NULL, &#39;&#39;, &#39; freelist groups &#39;||tp.freelist_groups)
      ||&#39; )&#39;)
   tp.partition_position+200
from
   all_snapshots v, all_tab_partitions tp
where tp.high_value_length &gt; 0
   and tp.table_owner = v.owner
   and tp.table_name = v.table_name
[  and v.owner=%.q:OWNER% ]
[  and v.name=%.q:VIEW%]
union select
   v.owner,
   v.name,
   decode (tp.partition_position, 1, &#39;) (&#39;, &#39;, &#39;)
   ||&#39;partition &#39;  ||tp.partition_name  ||&#39; tablespace &#39;  ||tp.tablespace_name,
   tp.partition_position+200
from
   all_snapshots v, all_tab_partitions tp
where tp.high_value_length = 0
   and tp.table_owner = v.owner
   and tp.table_name = v.table_name
[  and v.owner=%.q:OWNER% ]
[  and v.name=%.q:VIEW%]
union select
   v.owner,
   v.name,
   decode (pt.PARTITIONING_TYPE, &#39;RANGE&#39;, &#39;)&#39;, &#39;HASH&#39;, &#39;)&#39;, &#39;&#39;),
   299
 from
   all_snapshots v, all_part_tables pt
where  pt.owner = v.owner
   and pt.table_name = v.table_name
[  and v.owner=%.q:OWNER% ]
[  and v.name=%.q:VIEW%]
union select
   v.owner,
   v.name,
   decode (t.cache, &#39;Y&#39;, &#39; cache&#39;, &#39; &#39;)
   ||decode (ltrim(t.degree), &#39;1&#39;, &#39; noparallel&#39;, &#39;DEFAULT&#39;, &#39; parallel&#39;, &#39; parallel &#39;||ltrim(t.degree)),
   300
from
   all_tables t, all_snapshots v
where t.owner = v.owner
   and t.table_name = v.table_name
[  and v.owner=%.q:OWNER% ]
[  and v.name=%.q:VIEW%]
union select
   v.owner,
   v.name,
   &#39; refresh &#39;||v.type
   ||decode(v.start_with, NULL, &#39;&#39;, &#39; start with &#39;  ||v.start_with)
   ||decode(v.next, NULL, &#39;&#39;, &#39; next &#39;  ||v.next),
   400
from
   all_snapshots v
where 1=1
[  and v.owner=%.q:OWNER% ]
[  and v.name=%.q:VIEW%]
order by 1, 2, 4
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o198">
<a:Name>SqlHVQuery</a:Name>
<a:TextTargetItem.Value>{VAR1NAME, VAR1VALUE}

select
   &#39;HighVal&#39;||tp.partition_position,
   tp.high_value
from
   all_tab_partitions tp
where 1=1
[  and tp.table_owner=%.q:OWNER% ]
[  and tp.table_name=%.q:VIEW%]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse extra physical option data</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o199">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

[%ISDBAUSER% ?
select s.grantee grantee,
s.privilege
||
decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;)
|| &#39;,&#39;
from dba_tab_privs s
where
  s.table_name = %.q:VIEW%
[and s.owner = %.q:OWNER%]
order by grantee
:
select s.grantee grantee,
s.privilege
||
decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;)
|| &#39;,&#39;
from user_tab_privs s
where
  s.table_name = %.q:VIEW%
[and s.owner = %.q:OWNER%]
order by grantee
]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o200">
<a:Name>SqlColnListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, VIEW ID, VIEWSTYLE ID, VIEWCOLN ...}

select
   v.owner,
   v.view_name,
   &#39;&#39;,
   c.column_name||&#39;, &#39;,
   c.column_id
from
   sys.all_views v,
   sys.all_tab_columns c
where
   c.table_name=v.view_name
   and c.owner=v.owner
   [and v.owner=%.q:OWNER%]
   [and v.view_name=%.q:VIEW%]
order by
   1, 2, 5</a:TextTargetItem.Value>
<a:Comment>SQL query to list view columns</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o201">
<a:Name>ReversedQueries</a:Name>
<a:TextTargetItem.Value>SqlColnListQuery</a:TextTargetItem.Value>
<a:Comment>Additional attributes queries to be called by ODBC</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o202">
<a:Name>TypeList</a:Name>
<a:Comment>Defines list of available type
Name is the displayed value
Value is the stored value in the object</a:Comment>
<a:MapTargetItem.Value>View=
Materialized view=MATERIALIZED
Snapshot=SNAPSHOT</a:MapTargetItem.Value>
<a:List>View
Materialized view
Snapshot
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o203">
<a:Name>EnableIndex</a:Name>
<a:TextTargetItem.Value>MATERIALIZED</a:TextTargetItem.Value>
<a:Comment>List of types for which view index is available.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o204">
<a:Name>Permission</a:Name>
<a:Code>PERM</a:Code>
<a:Comment>Manages the permissions on database objects</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o205">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>grant %PERMLIST% on [%QUALIFIER%]%OBJECT% to %GRANTEE% [%GRANTOPTION%]
</a:TextTargetItem.Value>
<a:Comment>Command for granting permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o206">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>revoke %REVPERMLIST% on [%QUALIFIER%]%OBJECT% from %GRANTEE%</a:TextTargetItem.Value>
<a:Comment>Command for revoking permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o207">
<a:Name>GrantOption</a:Name>
<a:TextTargetItem.Value>with grant option</a:TextTargetItem.Value>
<a:Comment>Option for the grant statement.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o208">
<a:Name>RevokeOption</a:Name>
<a:Comment>Option for the revoke statement.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o209">
<a:Name>Tablespace</a:Name>
<a:Code>TSPC</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLESPACE&quot;   // generated code of the tablespace
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o210">
<a:Name>Enable</a:Name>
<a:Comment>Tablespace allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o211">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create tablespace %TABLESPACE%
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a tablespace. Example: create tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o212">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop tablespace %TABLESPACE% [including contents ][cascade constraints]</a:TextTargetItem.Value>
<a:Comment>Command for dropping a tablespace. Example: drop tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o213">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>&lt;permanent_datafile&gt; : composite=yes
{
datafile : composite=yes, separator=yes
{
&lt;file_spec&gt; : composite=yes, multiple=yes
{
&lt;filename&gt; %s : squoted=yes
size %d
reuse
&lt;autoextend_clause&gt; : composite=yes
{
autoextend off
autoextend on : composite=yes
{
next %s
maxsize %s : default=UNLIMITED
}
}
}
}
}
&lt;permanent_tablespace&gt; : composite=yes
{
minimum extent %s
&lt;logging_clause&gt; %s : list=logging|nologging, default=logging
default : composite=yes
{
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default
}
}
&lt;online&gt; %s : default=online, list=online|offline
&lt;permanent&gt; %s : default=permanent, list=permanent|temporary
}</a:TextTargetItem.Value>
<a:Comment>Default options for creating a tablespace.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o214">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for tablespace options.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o215">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{TABLESPACE}

select
   t.tablespace_name
from
   user_tablespaces t
where
   t.status not in(&#39;INVALID&#39;)
order by
   t.tablespace_name
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o216">
<a:Name>SqlDatafileOptsQuery</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   f.tablespace_name,
   decode(rownum, 1, &#39;datafile &#39;, &#39;, &#39;)
   ||&#39;&#39;&#39;&#39;||f.file_name||&#39;&#39;&#39;&#39;
   ||decode (f.bytes, 0, &#39;&#39;, &#39; size &#39;||f.bytes/1024||&#39;K&#39;)
   ||decode (f.autoextensible, &#39;NO&#39;, &#39; autoextend off&#39;, &#39; autoextend on&#39;
      ||&#39; next &#39;||increment_by*8||&#39;K&#39;
      ||&#39; maxsize &#39;||decode (f.maxbytes, 34359721984, &#39;unlimited&#39;, f.maxbytes/1024||&#39;K&#39;)
   ), rownum
from
   dba_data_files f
where
   f.tablespace_name=%.q:TABLESPACE%
order by 3</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o217">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{TABLESPACE, OPTIONS EX}

[%ISDBAUSER%?select
   t.tablespace_name,
   &#39;%SqlDatafileOptsQuery.&#39;||t.tablespace_name||&#39;%&#39;
   ||&#39; default storage (&#39;
      ||&#39;initial &#39; ||(t.initial_extent/1024)||&#39;K &#39; 
      ||decode (t.next_extent, NULL, &#39;&#39;, &#39;next &#39; ||(t.next_extent/1024)||&#39;K &#39;) 
      ||decode (t.min_extents, NULL, &#39;&#39;, &#39;minextents &#39; ||t.min_extents||&#39; &#39;) 
      ||decode (t.max_extents, NULL, &#39;&#39;, 2147483645, &#39;maxextents unlimited &#39;, &#39;maxextents &#39; ||t.max_extents||&#39; &#39;) 
      ||decode (t.pct_increase, NULL, &#39;&#39;, &#39;pctincrease &#39; ||t.pct_increase)
   ||&#39;) &#39;
   ||decode (t.status, &#39;OFFLINE&#39;, &#39;offline &#39;, &#39;&#39;)
   ||decode (t.contents, &#39;PERMANENT&#39;, &#39;&#39;, t.contents)
from
   dba_tablespaces t
order by 1]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o218">
<a:Name>Privilege</a:Name>
<a:Comment>Manages the system privileges for a user, role or group</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o219">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>grant %PRIVLIST% to %USER% [%GRANTOPTION%]
</a:TextTargetItem.Value>
<a:Comment>Command for granting privileges.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o220">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>revoke %REVPRIVLIST% from %USER%</a:TextTargetItem.Value>
<a:Comment>Command for revoking privileges.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o221">
<a:Name>System</a:Name>
<a:TextTargetItem.Value>ALTER ANY CLUSTER
ALTER ANY INDEX
ALTER ANY LIBRARY
ALTER ANY PROCEDURE
ALTER ANY ROLE
ALTER ANY SEQUENCE
ALTER ANY SNAPSHOT
ALTER ANY TABLE
ALTER ANY TRIGGER
ALTER DATABASE
ALTER PROFILE
ALTER RESOURCE COST
ALTER ROLLBACK SEGMENT
ALTER SESSION
ALTER SYSTEM
ALTER TABLESPACE
ALTER USER
ANALYZE ANY
AQ TYPE ACCESS
AUDIT ANY
AUDIT SYSTEM
BACKUP ANY TABLE
BECOME USER
COMMENT ANY TABLE
CREATE ANY CLUSTER
CREATE ANY DIRECTORY
CREATE ANY INDEX
CREATE ANY LIBRARY
CREATE ANY PROCEDURE
CREATE ANY SEQUENCE
CREATE ANY SNAPSHOT
CREATE ANY SYNONYM
CREATE ANY TABLE
CREATE ANY TRIGGER
CREATE ANY TYPE
CREATE ANY VIEW
CREATE CLUSTER
CREATE DATABASE LINK
CREATE LIBRARY
CREATE PROCEDURE
CREATE PROFILE
CREATE PUBLIC DATABASE LINK
CREATE PUBLIC SYNONYM
CREATE ROLE
CREATE ROLLBACK SEGMENT
CREATE SEQUENCE
CREATE SESSION
CREATE SNAPSHOT
CREATE SYNONYM
CREATE TABLE
CREATE TABLESPACE
CREATE TRIGGER
CREATE TYPE
CREATE USER
CREATE VIEW
DELETE ANY TABLE
DROP ANY CLUSTER
DROP ANY DIRECTORY
DROP ANY INDEX
DROP ANY LIBRARY
DROP ANY PROCEDURE
DROP ANY ROLE
DROP ANY SEQUENCE
DROP ANY SNAPSHOT
DROP ANY SYNONYM
DROP ANY TABLE
DROP ANY TRIGGER
DROP ANY TYPE
DROP ANY VIEW
DROP PROFILE
DROP PUBLIC DATABASE LINK
DROP PUBLIC SYNONYM
DROP ROLLBACK SEGMENT
DROP TABLESPACE
DROP USER
EXECUTE ANY LIBRARY
EXECUTE ANY PROCEDURE
EXECUTE ANY TYPE
FORCE ANY TRANSACTION
FORCE TRANSACTION
GRANT ANY PRIVILEGE
GRANT ANY ROLE
INSERT ANY TABLE
LOCK ANY TABLE
MANAGE TABLESPACE
RESTRICTED SESSION
SELECT ANY SEQUENCE
SELECT ANY TABLE
UNLIMITED TABLESPACE
UPDATE ANY TABLE
CONNECT
RESOURCE
DBA
DELETE_CATALOG_ROLE
EXECUTE_CATALOG_ROLE
SELECT_CATALOG_ROLE
EXP_FULL_DATABASE
IMP_FULL_DATABASE
AQ_USER_ROLE
AQ_ADMINISTRATOR_ROLE
SNMPAGENT
RECOVERY_CATALOG_OWNER
HS_ADMIN_ROLE</a:TextTargetItem.Value>
<a:Comment>List of system privileges</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o222">
<a:Name>GrantOption</a:Name>
<a:TextTargetItem.Value>with admin option</a:TextTargetItem.Value>
<a:Comment>Option for the grant statement.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o223">
<a:Name>Storage</a:Name>
<a:Code>STOR</a:Code>
<a:Comment>The following system variables are available:
   &quot;STORAGE&quot;      // generated code of the storage
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o224">
<a:Name>Enable</a:Name>
<a:Comment>Storage allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o225">
<a:Name>Create</a:Name>
<a:Comment>Command for creating a storage. Example: create storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o226">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a storage. Example: drop storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o227">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default|keep|recycle, default=default</a:TextTargetItem.Value>
<a:Comment>Default options for creating a storage</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o228">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for storage options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o229">
<a:Name>SqlListQuery</a:Name>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o230">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{STORAGE, OPTIONS}

SELECT SEGMENT_NAME, &#39;INITIAL &#39; || INITIAL_EXTENT ||
  &#39; NEXT &#39; || NEXT_EXTENT || &#39; MIN_EXTENTS &#39; || MIN_EXTENTS ||
  &#39; MAX_EXTENTS &#39; || MAX_EXTENTS || &#39; PCTINCREASE &#39; || PCT_INCREASE ||
  &#39; FREELISTS &#39; || FREELISTS || &#39; FREELIST_GROUPS &#39; || FREELIST_GROUPS OPTS
FROM USER_SEGMENTS</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o231">
<a:Name>Database</a:Name>
<a:Code>DTBS</a:Code>
<a:Comment>The following system variables are available:
   &quot;DATABASE&quot;     // generated code of the database
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o232">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create database [%DATABASE%]
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a database. Example: create database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o233">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>controlfile reuse
logfile : composite=yes, separator=yes
{
   &lt;log_file_clause&gt; : composite=yes, multiple=yes
   {
      group %d
      &lt;file_spec&gt; : composite=yes
      {
         &lt;filename&gt; %s
         size %d
         reuse
      }
   }
}
maxlogfiles %d
maxlogmembers %d
maxloghistory %d
maxdatafiles %d
maxinstances %d
&lt;archivelog&gt; %s : default=noarchivelog, list=archivelog | noarchivelog
character set %s
national character set
datafile : composite=yes, separator=yes
{
   &lt;datafile_clause&gt; : composite=yes, multiple=yes
   {
      &lt;file_spec&gt; : composite=yes
      {
         &lt;filename&gt; %s
         size %d
         reuse
      }
      &lt;autoextend_clause&gt; : composite=yes
      {
         autoextend off
         autoextend on : composite=yes
         {
            next %s
            maxsize %s : default=UNLIMITED
         }
      }
   }
}
</a:TextTargetItem.Value>
<a:Comment>Available options for creating a database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o234">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for database options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o235">
<a:Name>OpenDatabase</a:Name>
<a:Comment>Command for opening a database. Example: open database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o236">
<a:Name>CloseDatabase</a:Name>
<a:Comment>Command for closing a database. Example: close database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o237">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a database. Example: drop database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o238">
<a:Name>Enable</a:Name>
<a:Comment>Database allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o239">
<a:Name>Role</a:Name>
<a:Code>ROLE</a:Code>
<a:Comment>Manages the role object.</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o240">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>grant %ROLE% to %USER%</a:TextTargetItem.Value>
<a:Comment>Command for assigning a role to a user or another role</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o241">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create role %ROLE%</a:TextTargetItem.Value>
<a:Comment>Command for creating a role.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o242">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop role %ROLE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a role.</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o243">
<a:Name>Enable</a:Name>
<a:Comment>Role allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o244">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o245">
<a:Name>SqlListChildrenQuery</a:Name>
<a:TextTargetItem.Value>{ ROLE ID, MEMBER ...}

[%ISDBAUSER% ?
select granted_role, grantee
from dba_role_privs
]</a:TextTargetItem.Value>
<a:Comment>SQL query to list assigned ids to the role.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o246">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{ ROLE }

[%ISDBAUSER% ?
select role from dba_roles
union select &#39;PUBLIC&#39; from dual
]</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o247">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{ ROLE ID, PRIVILEGE ... }

[%ISDBAUSER% ?
select
  s.grantee,
  s.privilege
  || decode(s.admin_option, &#39;YES&#39;, &#39;+&#39;, NULL)
  || &#39;,&#39;
from dba_sys_privs s, dba_roles r
where s.grantee = r.role
union select
  s.grantee,
  s.privilege
  || decode(s.admin_option, &#39;YES&#39;, &#39;+&#39;, NULL)
  || &#39;,&#39;
from dba_sys_privs s
where (s.grantee = &#39;PUBLIC&#39;)
]</a:TextTargetItem.Value>
<a:Comment>Query to reverse privileges</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o248">
<a:Name>Abstract Data Type</a:Name>
<a:Code>ADT</a:Code>
<a:Comment>The following system variables are available:
   &quot;ADT&quot;          // generated code of the abstract data type
   &quot;TYPE&quot;         // ADT type
   &quot;SIZE&quot;         // ADT size
   &quot;FILE&quot;         // ADT: Java file
   &quot;ISARRAY&quot;      // ADT: is an array?
   &quot;ISLIST&quot;       // ADT: is a list?
   &quot;ISSTRUCT&quot;     // ADT: is a structure?
   &quot;ISOBJECT&quot;     // ADT: is an object?
   &quot;ISJAVA&quot;       // ADT: is a JAVA class?
   &quot;ADTDEF&quot;       // ADT definition
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o249">
<a:Name>AfterCreate</a:Name>
<a:TextTargetItem.Value>/
.if(%ADTBODY% != &quot;&quot;)


%CreateBody%
/
.endif</a:TextTargetItem.Value>
<a:Comment>Commands executed after create statement</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o250">
<a:Name>Enable</a:Name>
<a:Comment>Abstract Data Types allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o251">
<a:Name>Authorizations</a:Name>
<a:TextTargetItem.Value>CURRENT_USER
DEFINER</a:TextTargetItem.Value>
<a:Comment>Available invoker rights for an abstract data type</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o252">
<a:Name>EnableAdtOnDomn</a:Name>
<a:Comment>Abstract Data Types allowed on domain</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o253">
<a:Name>CreateBody</a:Name>
<a:TextTargetItem.Value>create [or replace ]type body [%QUALIFIER%]%ADT% [.O:[as][is]]
   %ADTBODY%
end;
</a:TextTargetItem.Value>
<a:Comment>Command for creating the abstract datatype body</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o254">
<a:Name>EnableAdtOnColn</a:Name>
<a:Comment>Abstract Data Types allowed on column</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o255">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, ADT, TYPE, SIZE, DTTPCODE, LENGTH, PREC}

select
   o.owner,
   o.type_name,
   decode(o.incomplete, &#39;YES&#39;, &#39;&#39;, decode(o.typecode, &#39;COLLECTION&#39;, decode(c.coll_type, &#39;VARYING ARRAY&#39;, &#39;VARRAY&#39;, c.coll_type), o.typecode)),
   c.upper_bound,
   c.elem_type_name,
   c.length,
   c.precision
from
   all_types o,
   all_coll_types c
where
   (c.owner(+)=o.owner and c.type_name(+)=o.type_name)
   and o.owner is not null
[  and o.owner=%.q:SCHEMA%]
order by 1, 2
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o256">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%ISARRAY%?create [or replace ]type [%QUALIFIER%]%ADT% [.O:[as][is]] [.O:[varray][varying array]] (%SIZE%) of %DATATYPE%]
[%ISLIST%?create [or replace ]type [%QUALIFIER%]%ADT% [.O:[as][is]] table of %DATATYPE%]
[%ISOBJECT%?create [or replace ]type [%QUALIFIER%]%ADT% [authid %ADTAUTH% ][.O:[as][is]] object[ (
    %ADTDEF%
)]]</a:TextTargetItem.Value>
<a:Comment>Command for adding an abstract data type</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o257">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop type [%QUALIFIER%]%ADT%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an abstract data type</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o258">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for an abstract data type.
The first column is the SQL name of permission (eg: EXECUTE)
The second column is a shortname to display in a grid</a:Comment>
</o:MapTargetItem>
<o:TextTargetItem Id="o259">
<a:Name>ReversedStatements</a:Name>
<a:TextTargetItem.Value>CreateBody</a:TextTargetItem.Value>
<a:Comment>Additional statements to be reversed by script</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o260">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, ADT ID, ADTHEADER ..., ADTTEXT ...}

select
   o.owner,
   o.type_name,
   decode(s.type, &#39;TYPE&#39;, s.text, &#39;&#39;),
   decode(s.type, &#39;TYPE BODY&#39;, s.text, &#39;&#39;)
from
   all_types o,
   all_source s
where 
   o.typecode = &#39;OBJECT&#39;
   and s.owner = o.owner
   and s.name = o.type_name
   and s.type in (&#39;TYPE&#39;, &#39;TYPE BODY&#39;)
[  and o.owner=%.q:OWNER%]
[  and o.type_name=%.q:ADT%]
order by 1, 2, s.type, s.line</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o261">
<a:Name>AllowedADT</a:Name>
<a:TextTargetItem.Value>OBJECT
TABLE
VARRAY</a:TextTargetItem.Value>
<a:Comment>List of ADTs which can be used as the datatype of an ADT type</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o262">
<a:Name>SqlPermQuery</a:Name>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o263">
<a:Name>User</a:Name>
<a:Code>USER</a:Code>
<a:Comment>The following system variables are available:
   &quot;USER&quot;         // generated code of the user
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o264">
<a:Name>Enable</a:Name>
<a:Comment>User allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o265">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o266">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{USER}

select username from all_users
[where UPPER(username) = %.qU:SCHEMA%]
order by username
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o267">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o268">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create user %USER% identified by [%PASSWORD%?%PASSWORD%:&#39;&#39;]</a:TextTargetItem.Value>
<a:Comment>Command for creating a user</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o269">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop user %USER%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a user</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o270">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{ USER ID, PRIVILEGE ... }

[%ISDBAUSER% ?
select
  s.grantee,
  s.privilege
 || decode(admin_option, &#39;YES&#39;, &#39;+&#39;, NULL)
 || &#39;,&#39;
from dba_sys_privs s, all_users a
where s.grantee = a.username
]</a:TextTargetItem.Value>
<a:Comment>Query to reverse privileges</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o271">
<a:Name>Trigger</a:Name>
<a:Code>TRGR</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
 trigger object specific items
   &quot;ORDER&quot;        // order number of the trigger (to sort the triggers when the DBMS supports more than one trigger of one type)
   &quot;TRIGGER&quot;      // generated code of trigger
   &quot;TRGTYPE&quot;      // trigger type (keywords &quot;beforeinsert&quot;, &quot;afterupdate&quot;, ...)
   &quot;TRGEVENT&quot;     // trigger event (keywords &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;)
   &quot;TRGTIME&quot;      // trigger time (keywords NULL, &quot;before&quot;, &quot;after&quot;)
 inside the body of the trigger, macros redefine variables on objects
   &quot;REFNO&quot;        // reference position in the list of references of the table
 customized error messages management
   &quot;ERRNO&quot;        // error number for standard error
   &quot;ERRMSG&quot;       // error message for standard error
   &quot;MSGTAB&quot;       // name of the table containing user-defined error messages
   &quot;MSGNO&quot;        // in the user-defined error table, name of the column containing the error numbers
   &quot;MSGTXT&quot;       // in the user-defined error table, name of the column containing the error messages
   &quot;SCRIPT&quot;       // body of trigger or procedure
   &quot;TRGDEFN&quot;      // complete body of the trigger definition. Contains variable declarations and body of trigger or procedure
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o272">
<a:Name>Enable</a:Name>
<a:Comment>Trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o273">
<a:Name>EnableMultiTrigger</a:Name>
<a:Comment>Multi trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o274">
<a:Name>DefaultTriggerName</a:Name>
<a:TextTargetItem.Value>%TEMPLATE%_%.L:TABLE%</a:TextTargetItem.Value>
<a:Comment>Default trigger name</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o275">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o276">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop trigger [%QUALIFIER%]%TRIGGER%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a trigger. Example: drop trigger %TRIGGER%</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o277">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:StringTargetItem Id="o278">
<a:Name>EventDelimiter</a:Name>
<a:Comment>Events separation character.</a:Comment>
<a:StringTargetItem.Value>or</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o279">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER, TABLE, OWNER, TRIGGER, TRGEVENT, TRGTIME}

select
   table_owner,
   table_name,
   owner,
   trigger_name,
   lower(triggering_event),
   decode (substr(trigger_type, 1, 1),&#39;A&#39;, &#39;after&#39;, &#39;B&#39;, &#39;before&#39;)
from
   sys.all_triggers
[where owner=%.q:SCHEMA%]
order by
   owner, table_name
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o280">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER, TABLE, OWNER, TRIGGER, TRGDESC, TRGBODY}

select 
   table_owner,
   table_name,
   owner,
   trigger_name,
   &#39;create trigger &#39; || description || decode(when_clause, NULL, &#39;&#39;, &#39;when (&#39;||when_clause||&#39;)&#39;),
   trigger_body
from 
   sys.all_triggers
where 1=1
[  and table_owner=%.q:SCHEMA%]
[  and table_name=%.q:TABLE%]
order by 1, 2
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o281">
<a:Name>UseErrorMsgTable</a:Name>
<a:TextTargetItem.Value>select %MSGNO%, %MSGTXT%
into   errno, errmsg
from   %MSGTAB%
where  %MSGNO% = %ERRNO%;
raise integrity_error;</a:TextTargetItem.Value>
<a:Comment>Errors handling using an error messages table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o282">
<a:Name>UseErrorMsgText</a:Name>
<a:TextTargetItem.Value>errno  := %ERRNO%;
errmsg := %.q:ERRMSG%;
raise integrity_error;</a:TextTargetItem.Value>
<a:Comment>Errors handling using fixed error messages</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o283">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create[ or replace] trigger [%QUALIFIER%]%TRIGGER%[ %TRGTIME%][ %TRGEVENT%[ of %COLUMNS%]][ order %ORDER%] on [%TABLQUALIFIER%]%TABLE%
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a trigger. Example: create trigger on [%QUALIFIER%]%TABLE% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o284">
<a:Name>ViewTime</a:Name>
<a:TextTargetItem.Value>instead of</a:TextTargetItem.Value>
<a:Comment>Time list available from trigger on view.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:IntegerTargetItem Id="o285">
<a:Name>MaxConstLen</a:Name>
<a:Comment>Maximum constraint name length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o286">
<a:Name>EnableOption</a:Name>
<a:Comment>Physical options allowed  YES/NO</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TargetCategory Id="o287">
<a:Name>Abstract Data Type Attribute</a:Name>
<a:Code>ATTR</a:Code>
<a:Comment>The following system variables are available:
   &quot;ADTATTR&quot;      // generated code of the abstract data type attribute
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o288">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%ADTATTR% %DATATYPE%</a:TextTargetItem.Value>
<a:Comment>Command for defining an abstract data type attribute</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o289">
<a:Name>AllowedADT</a:Name>
<a:TextTargetItem.Value>OBJECT
TABLE
VARRAY</a:TextTargetItem.Value>
<a:Comment>List of ADTs which can be used as the datatype of an ADT attribute</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o290">
<a:Name>Sequence</a:Name>
<a:Code>SQNC</a:Code>
<a:Comment>The following system variables are available:
   &quot;SQNC&quot;         // generated code of the sequence
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o291">
<a:Name>Enable</a:Name>
<a:Comment>Sequence allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o292">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create sequence [%QUALIFIER%]%SQNC%
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command to create a sequence</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o293">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop sequence [%QUALIFIER%]%SQNC%</a:TextTargetItem.Value>
<a:Comment>Command to drop a sequence</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o294">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>&lt;initial&gt; : composite=yes
{
increment by %d
start with %d
}
&lt;maxvalue&gt; : composite=yes
{
maxvalue %d
nomaxvalue
}
&lt;minvalue&gt; : composite=yes
{
minvalue %d
nominvalue
}
&lt;cycle&gt; %s : list= cycle | nocycle
&lt;cache&gt; : composite=yes
{
cache %d
nocache
}
&lt;order&gt; %s : list= order | noorder</a:TextTargetItem.Value>
<a:Comment>Options for creating a sequence</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o295">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for sequence options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o296">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, SQNC, OPTIONS}

[%ISODBCUSER%?select
   %.q:SCHEMA%,
   sequence_name,
   &#39; increment by &#39;||increment_by
   ||&#39; start with &#39;||last_number
   ||decode(max_value, 999999999999999999999999999, &#39; nomaxvalue &#39;, -1 , &#39; nomaxvalue &#39; ,&#39; maxvalue &#39;||max_value )
   ||decode(min_value, 1, &#39; nominvalue &#39;, -99999999999999999999999999, &#39; nominvalue &#39; , &#39; minvalue &#39;||min_value )
   ||decode(cycle_flag, &#39;N&#39; , &#39; nocycle &#39;, &#39; cycle &#39;)
   ||decode(cache_size, 20, &#39;&#39;, 0, &#39; nocache &#39;, &#39; cache &#39;||cache_size)
   ||decode(order_flag, &#39;N&#39;, &#39; noorder &#39;, &#39;order&#39;)
from
   user_sequences
order by
   sequence_name
:select
   sequence_owner,
   sequence_name,
   &#39; increment by &#39;||increment_by
   ||&#39; start with &#39;||last_number
   ||decode(max_value, 999999999999999999999999999, &#39; nomaxvalue &#39;, -1 , &#39; nomaxvalue &#39; ,&#39; maxvalue &#39;||max_value )
   ||decode(min_value, 1, &#39; nominvalue &#39;, -99999999999999999999999999, &#39; nominvalue &#39; , &#39; minvalue &#39;||min_value )
   ||decode(cycle_flag, &#39;N&#39; , &#39; nocycle &#39;, &#39; cycle &#39;)
   ||decode(cache_size, 20, &#39;&#39;, 0, &#39; nocache &#39;, &#39; cache &#39;||cache_size)
   ||decode(order_flag, &#39;N&#39;, &#39; noorder &#39;, &#39;order&#39;)
from
   sys.all_sequences
[where sequence_owner=%.q:SCHEMA%]
order by
   1, 2]
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o297">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a sequence.
The first column is the SQL name of permission
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>ALTER=Alter
SELECT=Select</a:MapTargetItem.Value>
<a:List>ALTER
SELECT
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o298">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>rename %OLDNAME% to %NEWNAME%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a sequence</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o299">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o300">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

[%ISDBAUSER%?select 
   s.grantee,
   s.privilege
   ||decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;)|| &#39;,&#39;
from 
   sys.dba_tab_privs s
where
   s.table_name = %.q:SQNC%
[  and s.owner = %.q:OWNER%]
:select 
   s.grantee,
   s.privilege
   ||decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;)|| &#39;,&#39;
from 
   sys.user_tab_privs s
where
   s.table_name = %.q:SQNC%
[  and s.owner = %.q:OWNER%]
]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o301">
<a:Name>EnableSynonym</a:Name>
<a:Comment>Synonym supported</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o302">
<a:Name>Synonym</a:Name>
<a:Code>SYNM</a:Code>
<a:Comment>Manages the synonym object.</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o303">
<a:Name>Enable</a:Name>
<a:Comment>Synonym allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o304">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [%ISPUBLIC% ?public ]synonym [%QUALIFIER%]%SYNONYM% for [%BASEQUALIFIER%]%BASEOBJECT%</a:TextTargetItem.Value>
<a:Comment>Command for creating a synonym.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o305">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop [%ISPUBLIC% ?public ]synonym [%QUALIFIER%]%SYNONYM%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a synonym.</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o306">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o307">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, SYNONYM, VISIBILITY}

select
   t.owner,
   t.synonym_name,
   decode( t.owner, &#39;PUBLIC&#39;, &#39;PUBLIC&#39;, &#39;PRIVATE&#39;)
from
   sys.all_synonyms t
where
   t.table_owner not in (&#39;ORDSYS&#39;, &#39;SYS&#39;,&#39;WKSYS&#39;,&#39;MDSYS&#39;,&#39;CTXSYS&#39;,&#39;OLAPSYS&#39;)
[  and t.owner=%.q:SCHEMA%]
order by
   t.owner, t.synonym_name
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o308">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, SYNONYM, BASEOWNER, BASEOBJECT}

select
   t.owner,
   t.synonym_name,
   t.table_owner,
   t.table_name
from
   sys.all_synonyms t
where
   t.table_owner not in (&#39;ORDSYS&#39;, &#39;SYS&#39;,&#39;WKSYS&#39;,&#39;MDSYS&#39;,&#39;CTXSYS&#39;,&#39;OLAPSYS&#39;)
[  and t.owner=%.q:OWNER%]
[  and t.synonym_name=%.q:SYNONYM%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o309">
<a:Name>PublicOwner</a:Name>
<a:Comment>TRUE when the owner is PUBLIC for a public synonym</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o310">
<a:Name>DB Package</a:Name>
<a:Code>DBPK</a:Code>
<a:Comment>Manages the database package</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o311">
<a:Name>Enable</a:Name>
<a:Comment>Database package allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o312">
<a:Name>Authorizations</a:Name>
<a:TextTargetItem.Value>CURRENT_USER
DEFINER</a:TextTargetItem.Value>
<a:Comment>Available invoker rights for a database package</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o313">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [or replace ]package [%QUALIFIER%]%DBPACKAGE% [authid %DBPACKAGEPRIV% ][.O:[as][is]]
[   %DBPACKAGESPEC%]
end[ %DBPACKAGE%];
</a:TextTargetItem.Value>
<a:Comment>Command for creating a database package.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o314">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop package [%QUALIFIER%]%DBPACKAGE% </a:TextTargetItem.Value>
<a:Comment>Command for dropping a database package.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o315">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, DBPACKAGE}

[%ISODBCUSER% ?
select distinct
   %.q:SCHEMA%,
   decode (type, &#39;PACKAGE&#39;, name, &#39;&#39;)
from
   sys.user_source
where
   type in (&#39;PACKAGE&#39;)
order by
   2
:
select distinct
   owner,
   decode (type, &#39;PACKAGE&#39;, name, &#39;&#39;)
from
   sys.all_source
where
   type in (&#39;PACKAGE&#39;)
[  and owner = %.q:SCHEMA%]
order by
   1, 2
]</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o316">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, DBPACKAGE ID, TYPE ID, DBPACKAGEHEADER ..., DBPACKAGETEXT ...}

[%ISODBCUSER% ?select
   %.q:SCHEMA%,
   s.name,
   s.type,
   s.text,
   &#39;&#39;,
   s.line
from
   sys.user_source s
where
   s.type = &#39;PACKAGE&#39;  and s.name = %.q:DBPACKAGE% 
union select
   %.q:SCHEMA%,
   s.name,
   s.type,
   &#39;&#39;,
   s.text,
   s.line
from
   sys.user_source s
where
   s.type = &#39;PACKAGE BODY&#39; and s.name = %.q:DBPACKAGE% 
order by 2, 3, 6
:
select
   s.owner,
   s.name,
   s.type,
   s.text,
   null,
   s.line
from
   sys.all_source s
where
   s.type = &#39;PACKAGE&#39;  and s.name = %.q:DBPACKAGE% 
[  and s.owner = %.q:SCHEMA%]
union select
   s.owner,
   s.name,
   s.type,
   null,
   s.text,
   s.line
from
   sys.all_source s
where
   s.type = &#39;PACKAGE BODY&#39;  and s.name = %.q:DBPACKAGE% 
[  and s.owner = %.q:SCHEMA%]
order by 1, 2, 3, 6
]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o317">
<a:Name>ReversedStatements</a:Name>
<a:TextTargetItem.Value>CreateBody</a:TextTargetItem.Value>
<a:Comment>Additional statements to be reversed by script</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o318">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a database package.
The first column is the SQL name of permission (eg: EXECUTE)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>EXECUTE=Execute</a:MapTargetItem.Value>
<a:List>EXECUTE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o319">
<a:Name>AfterCreate</a:Name>
<a:TextTargetItem.Value>%CreateBody%
/</a:TextTargetItem.Value>
<a:Comment>Commands executed after create statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o320">
<a:Name>CreateBody</a:Name>
<a:TextTargetItem.Value>create [or replace ]package body [%QUALIFIER%]%DBPACKAGE% [.O:[as][is]]
   %DBPACKAGEBODY%
[begin
   %DBPACKAGEINIT%
]end[ %DBPACKAGE%];

</a:TextTargetItem.Value>
<a:Comment>Command for creating the database package body</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o321">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o322">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

[%ISDBAUSER% ?
select s.grantee grantee,
s.privilege
||
decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;)
|| &#39;,&#39;
from dba_tab_privs s
where
  s.table_name = %.q:DBPACKAGE%
[and s.owner = %.q:OWNER%]
order by grantee
:
select s.grantee grantee,
s.privilege
||
decode (s.grantable,&#39;YES&#39;,&#39;+&#39;,&#39;NO&#39;,&#39;&#39;)
|| &#39;,&#39;
from user_tab_privs s
where
  s.table_name = %.q:DBPACKAGE%
[and s.owner = %.q:OWNER%]
order by grantee
]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o323">
<a:Name>EnableSynonym</a:Name>
<a:Comment>Synonym supported</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o324">
<a:Name>DB Package Procedure</a:Name>
<a:Code>PDMPKPR</a:Code>
<a:Comment>Manages the database package procedure</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o325">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%DBPKPROCTYPE% %DBPKPROC%[ (%DBPKPROCPARAM%)][ return %DBPKPROCRETURN%][ [.O:[as][is]]
%DBPKPROCCODE%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a procedure</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o326">
<a:Name>ParameterTypes</a:Name>
<a:TextTargetItem.Value>in
in nocopy
in out
in out nocopy
out
out nocopy</a:TextTargetItem.Value>
<a:Comment>Available types for database package procedure</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o327">
<a:Name>DBProcedureBody</a:Name>
<a:TextTargetItem.Value>begin
end</a:TextTargetItem.Value>
<a:Comment>Template for the body of a database package procedure</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o328">
<a:Name>DB Package Variable</a:Name>
<a:Code>PDMPKVA</a:Code>
<a:Comment>Manages the database package variable</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o329">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%DBPKVAR% [%DBPKVARCONST% ]%DBPKVARTYPE%[ :=%DBPKVARVALUE%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a variable</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o330">
<a:Name>DB Package Type</a:Name>
<a:Code>PDMPKTY</a:Code>
<a:Comment>Manages the database package type</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o331">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[%DBPKISSUBTYPE%?subtype %DBPKTYPE%[ is %DBPKTYPEVAR%]:type %DBPKTYPE%[ is %DBPKTYPEVAR%]]</a:TextTargetItem.Value>
<a:Comment>Command for defining a type</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o332">
<a:Name>DB Package Cursor</a:Name>
<a:Code>PDMPKCU</a:Code>
<a:Comment>Manages the database package cursor</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o333">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>cursor %DBPKCURSOR% [ (%DBPKCURSORPARAM%)][ return %DBPKCURSORRETURN%][ is
 %DBPKCURSORQUERY%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a cursor</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o334">
<a:Name>DB Package Exception</a:Name>
<a:Code>PDMPKEX</a:Code>
<a:Comment>Manages the database package exception</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o335">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%DBPKEXC% exception</a:TextTargetItem.Value>
<a:Comment>Command for defining an exception</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o336">
<a:Name>Parameter</a:Name>
<a:Code>PDMPARM</a:Code>
<a:Comment>Manages parameters for abstract data type procedure, database package procedure and database package cursor</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o337">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%DBPKPARM% [%DBPKPARMTYPE% ]%DBPKPARMDTTP% [default %DBPKPARMDEFAULT%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a parameter</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o338">
<a:Name>DataType</a:Name>
<a:Comment>Contains data type translation entries. These entries list the correspondence between internal data types and the target database data types</a:Comment>
<c:Categories>
<o:MapTargetItem Id="o339">
<a:Name>AmcdDataType</a:Name>
<a:Comment>Data types translation table from internal data types to target database data types.
        %n is the length of the data type
        %s is the size of the data type
        %p is the precision of the data type</a:Comment>
<a:MapTargetItem.Value>&lt;UNDEF&gt;=&lt;Undefined&gt;
A%n=CHAR(%n)
VA%n=VARCHAR2(%n)
LA=LONG
LA%n=LONG
LVA=LONG
LVA%n=LONG
BT=SMALLINT
BT%n=SMALLINT
SI=SMALLINT
I=INTEGER
LI=INTEGER
N=NUMBER
N%n=NUMBER(%n)
N%s,%p=NUMBER(%s,%p)
DC=NUMBER
DC%n=NUMBER(%n)
DC%s,%p=NUMBER(%s,%p)
SF=FLOAT
F=FLOAT
F%n=FLOAT(%n)
LF=FLOAT
MN=NUMBER(8,2)
MN%n=NUMBER(%n)
MN%s,%p=NUMBER(%s,%p)
D=DATE
T=DATE
DT=DATE
TS=DATE
BL=SMALLINT
NO=NUMBER(6)
NO%n=NUMBER(%n)
BIN%n=RAW(%n)
LBIN=LONG RAW
LBIN%n=LONG RAW
TXT=LONG
TXT%n=LONG
MBT=NCHAR(1)
MBT%n=NCHAR(%n)
VMBT=NVARCHAR2(255)
VMBT%n=NVARCHAR2(%n)
PIC=LONG RAW
PIC%n=LONG RAW
BMP=LONG RAW
BMP%n=LONG RAW
OLE=LONG RAW
OLE%n=LONG RAW
*=CHAR(10)</a:MapTargetItem.Value>
<a:List>&lt;UNDEF&gt;
A%n
VA%n
LA
LA%n
LVA
LVA%n
BT
BT%n
SI
I
LI
N
N%n
N%s,%p
DC
DC%n
DC%s,%p
SF
F
F%n
LF
MN
MN%n
MN%s,%p
D
T
DT
TS
BL
NO
NO%n
BIN%n
LBIN
LBIN%n
TXT
TXT%n
MBT
MBT%n
VMBT
VMBT%n
PIC
PIC%n
BMP
BMP%n
OLE
OLE%n
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o340">
<a:Name>PhysDataType</a:Name>
<a:Comment>Data types translation table from target database data types to internal data types.</a:Comment>
<a:MapTargetItem.Value>&lt;Undefined&gt;=&lt;UNDEF&gt;
CHAR=A1
CHARACTER=A1
CHAR(%n)=A%n
CHARACTER(%n)=A%n
CHARACTER VARYING(%n)=VA%n
CHAR VARYING(%n)=VA%n
VARCHAR(%n)=VA%n
VARCHAR2(%n)=VA%n
NVARCHAR2(%n)=VMBT%n
LONG=LA
LONG VARCHAR=LVA
SMALLINT=SI
INT=I
INTEGER=I
REAL=N
DOUBLE PRECISION=N
DEC=N
DEC(%n)=N%n
DEC(%s,%p)=N%s,%p
DECIMAL=N
DECIMAL(%n)=N%n
DECIMAL(%s,%p)=N%s,%p
NUMBER=N
NUMBER(%n)=N%n
NUMBER(%s,%p)=N%s,%p
FLOAT=F
FLOAT(%n)=F%n
DATE=DT
RAW(%n)=BIN%n
LONG RAW=LBIN
MLSLABEL=BIN
NCHAR(%n)=MBT%n
ROWID=A64
CLOB=LBIN
NCLOB=LBIN
BLOB=LBIN
BFILE=LBIN
*=A10</a:MapTargetItem.Value>
<a:List>&lt;Undefined&gt;
CHAR
CHARACTER
CHAR(%n)
CHARACTER(%n)
CHARACTER VARYING(%n)
CHAR VARYING(%n)
VARCHAR(%n)
VARCHAR2(%n)
NVARCHAR2(%n)
LONG
LONG VARCHAR
SMALLINT
INT
INTEGER
REAL
DOUBLE PRECISION
DEC
DEC(%n)
DEC(%s,%p)
DECIMAL
DECIMAL(%n)
DECIMAL(%s,%p)
NUMBER
NUMBER(%n)
NUMBER(%s,%p)
FLOAT
FLOAT(%n)
DATE
RAW(%n)
LONG RAW
MLSLABEL
NCHAR(%n)
ROWID
CLOB
NCLOB
BLOB
BFILE
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o341">
<a:Name>PhysDttpSize</a:Name>
<a:Comment>Table of storage sizes of target database data type</a:Comment>
<a:MapTargetItem.Value>DATE=7</a:MapTargetItem.Value>
<a:List>DATE
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o342">
<a:Name>OdbcPhysDataType</a:Name>
<a:Comment>Data types translation table from ODBC data types to target database data types.</a:Comment>
<a:MapTargetItem.Value>CHAR(1)=CHAR
FLOAT(126)=FLOAT
FLOAT(63)=REAL</a:MapTargetItem.Value>
<a:List>CHAR(1)
FLOAT(126)
FLOAT(63)
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o343">
<a:Name>HostDataType</a:Name>
<a:Comment>Data types translation from database data type to procedure data type</a:Comment>
<a:MapTargetItem.Value>CHAR=char
CHARACTER=char
CHAR(%n)=varchar
NCHAR(%n)=nchar
CHARACTER(%n)=varchar
CHARACTER VARYING(%n)=varchar
CHAR VARYING(%n)=varchar
VARCHAR(%n)=varchar
VARCHAR2(%n)=varchar
NVARCHAR2(%n)=nvarchar2
LONG=long
LONG VARCHAR=long
SMALLINT=integer
INT=integer
INTEGER=integer
REAL=number
DOUBLE PRECISION=number
DEC=number
DEC(%n)=number
DEC(%s,%p)=number
DECIMAL=number
DECIMAL(%n)=number
DECIMAL(%s,%p)=number
NUMBER=number
NUMBER(%n)=number
NUMBER(%s,%p)=number
FLOAT=float
FLOAT(%n)=number
DATE=date
RAW(%n)=raw
LONG RAW=raw</a:MapTargetItem.Value>
<a:List>CHAR
CHARACTER
CHAR(%n)
NCHAR(%n)
CHARACTER(%n)
CHARACTER VARYING(%n)
CHAR VARYING(%n)
VARCHAR(%n)
VARCHAR2(%n)
NVARCHAR2(%n)
LONG
LONG VARCHAR
SMALLINT
INT
INTEGER
REAL
DOUBLE PRECISION
DEC
DEC(%n)
DEC(%s,%p)
DECIMAL
DECIMAL(%n)
DECIMAL(%s,%p)
NUMBER
NUMBER(%n)
NUMBER(%s,%p)
FLOAT
FLOAT(%n)
DATE
RAW(%n)
LONG RAW
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o344">
<a:Name>PhysLogADTType</a:Name>
<a:Comment>Abstract Data types translation table from target database abstract data types to internal abstract data types.</a:Comment>
<a:MapTargetItem.Value>OBJECT=Object
TABLE=List
VARRAY=Array</a:MapTargetItem.Value>
<a:List>OBJECT
TABLE
VARRAY
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o345">
<a:Name>LogPhysADTType</a:Name>
<a:Comment>Abstract Data types translation table from internal abstract data types to target database abstract data types.</a:Comment>
<a:MapTargetItem.Value>Array=VARRAY
Java=&lt;Undefined&gt;
List=TABLE
Object=OBJECT
Structured=&lt;Undefined&gt;</a:MapTargetItem.Value>
<a:List>Array
Java
List
Object
Structured
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o346">
<a:Name>AllowedADT</a:Name>
<a:TextTargetItem.Value>OBJECT
TABLE
VARRAY</a:TextTargetItem.Value>
<a:Comment>The list of ADT which can be used as the datatype of a domain or column</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o347">
<a:Name>PhysOdbcDataType</a:Name>
<a:Comment>Data types translation table from target database data types to ODBC data types.</a:Comment>
<a:MapTargetItem.Value>INT=INTEGER
DEC=DECIMAL
DEC(%n)=DECIMAL(%n)
DEC(%s,%p)=DECIMAL(%s,%p)
CHARACTER VARYING=VARCHAR
CHARACTER VARYING(%n)=VARCHAR(%n)
CHAR VARYING=VARCHAR
CHAR VARYING(%n)=VARCHAR(%n)</a:MapTargetItem.Value>
<a:List>INT
DEC
DEC(%n)
DEC(%s,%p)
CHARACTER VARYING
CHARACTER VARYING(%n)
CHAR VARYING
CHAR VARYING(%n)
</a:List>
</o:MapTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o348">
<a:Name>Customize</a:Name>
<a:Comment>Retrieves information from Version 6 DBMS definition files. It is not used in Version 7.</a:Comment>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:ProfileTargetItem Id="o349">
<a:Name>Profile</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:MetaClassTargetItem Id="o350">
<a:Name>Column</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o351">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o352">
<a:ObjectID>3FB3478B-002D-4530-96CE-F94A7ED0F598</a:ObjectID>
<a:Name>ExtColumnDeferOption</a:Name>
<a:Comment>This attribute defines the deferred option of a column constraint check. It is used in &quot;create&quot; and &quot;add&quot; statement items definition.
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o353"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o354">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o355">
<a:Name>Oracle</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtColumnDeferOption&quot; AttributeID=&quot;{3FB3478B-002D-4530-96CE-F94A7ED0F598}&quot; Name=&quot;ExtColumnDeferOption&quot; Caption=&quot;Deferred option of check constraint&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o356">
<a:Name>Reference</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o357">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o358">
<a:ObjectID>FA24D9CF-A8BB-43C7-865E-F46883065518</a:ObjectID>
<a:Name>ExtReferenceDeferOption</a:Name>
<a:Comment>This attribute defines the deferred option of a reference. It is used in &quot;create&quot; and &quot;add&quot; statement items definition.
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o353"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o359">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o360">
<a:Name>Oracle</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtReferenceDeferOption&quot; AttributeID=&quot;{FA24D9CF-A8BB-43C7-865E-F46883065518}&quot; Name=&quot;ExtReferenceDeferOption&quot; Caption=&quot;Deferred option of foreign key constraint&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:TargetCategory Id="o361">
<a:Name>Shared</a:Name>
<a:Code>Shared</a:Code>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o362">
<a:TypePublicName>ExtendedAttributeTypeTargetItem</a:TypePublicName>
<a:Name>Extended Attribute Types</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTypeTargetItem Id="o353">
<a:ObjectID>E3D8ABFD-CC1F-4C8C-A133-9100A2FEFEA6</a:ObjectID>
<a:Name>ExtConstraintDeferred</a:Name>
<a:Comment>List of available options for deferred references. Used in extended attribute &quot;ExtReferenceDeferOption&quot;</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>not deferrable
initially deferred
deferrable initially deferred
initially immediate deferrable</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:TargetCategory>
<o:MetaClassTargetItem Id="o363">
<a:Name>View</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o364">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o365">
<a:ObjectID>0F757C9E-F31E-469D-AE0F-F2FAF215E220</a:ObjectID>
<a:Name>ExtViewForce</a:Name>
<a:Comment>Set to TRUE if you want to create the view regardless of whether the view&#39;s base tables or the referenced object types exist or the owner of the schema containing the view has privileges on them.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.Value>false</a:ExtendedAttributeTargetItem.Value>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o366">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o367">
<a:Name>Oracle</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtViewForce&quot; AttributeID=&quot;{0F757C9E-F31E-469D-AE0F-F2FAF215E220}&quot; Name=&quot;ExtViewForce&quot; Caption=&quot;Force&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
</c:Categories>
</o:ProfileTargetItem>
</c:Categories>
<c:TriggerItems>
<o:TriggerItem Id="o368">
<a:ObjectID>4D4FEE04-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>InsertChildParentExist</a:Name>
<a:Code>InsertChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT()
--  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when inserting a child in &quot;[%CQUALIFIER%]%CHILD%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cpk%REFNO%_%.25L:TABLE%&quot;
if .JOIN(&quot;:new.%FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; then&quot;)
   open  %CURSOR%(.JOIN(&quot;:new.%FK%&quot;, &quot;&quot;, &quot;,&quot;, &quot;);&quot;)
   fetch %CURSOR% into dummy;
   found := %CURSOR%%FOUND;
   close %CURSOR%;
   if not found then
      .ERROR(-20002, &quot;Parent does not exist in &quot;[%PQUALIFIER%]%PARENT%&quot;. Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
   end if;
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>970066241</a:ModificationDate>
<a:Modifier>ihayes</a:Modifier>
<a:Comment>Parent must exist when inserting child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
--  Declaration of InsertChildParentExist constraint for the parent &quot;[%PQUALIFIER%]%PARENT%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cpk%REFNO%_%.25L:TABLE%&quot;
cursor %CURSOR%(.JOIN(&quot;var_%.L26:FK% %.L:HOSTCOLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;) is&quot;)
   select 1
   from   [%PQUALIFIER%]%PARENT%
   where  .JOIN(&quot;%PK% = var_%.L26:FK%&quot;, &quot;and   &quot;)
    and   .JOIN(&quot;var_%.L26:FK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o369">
<a:ObjectID>4D4FEE05-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>InsertTooManyChildren</a:Name>
<a:Code>InsertTooManyChildren</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot exceed the maximum cardinality constraint when inserting the child</a:Comment>
</o:TriggerItem>
<o:TriggerItem Id="o370">
<a:ObjectID>4D4FEE09-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>UpdateChangeColumn</a:Name>
<a:Code>UpdateChangeColumn</a:Code>
<a:Text>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
--  Non modifiable column &quot;%COLUMN%&quot; cannot be modified
if updating(%.q:COLUMN%) and :old.%COLUMN% != :new.%COLUMN% then
   .ERROR(-20001, &quot;Non modifiable column &quot;%COLUMN%&quot; cannot be modified.&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot modify non modifiable column constraint</a:Comment>
<a:Declaration>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o371">
<a:ObjectID>4D4FEE0A-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>UpdateChildParentExist</a:Name>
<a:Code>UpdateChildParentExist</a:Code>
<a:Text>seq := IntegrityPackage.GetNestLevel;
.FOREACH_PARENT()
--  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when updating a child in &quot;[%CQUALIFIER%]%CHILD%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cpk%REFNO%_%.25L:TABLE%&quot;
if .JOIN(&quot;(:new.%FK% is not null)&quot;, &quot;&quot;, &quot; and&quot;, &quot; and (seq = 0) then &quot;)
   open  %CURSOR%(.JOIN(&quot;:new.%FK%&quot;, &quot;&quot;, &quot;,&quot;, &quot;);&quot;)
   fetch %CURSOR% into dummy;
   found := %CURSOR%%FOUND;
   close %CURSOR%;
   if not found then
      .ERROR(-20003, &quot;Parent does not exist in &quot;[%PQUALIFIER%]%PARENT%&quot;. Cannot update child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
   end if;
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Parent must exist when updating a child constraint</a:Comment>
<a:Declaration>seq NUMBER;
.FOREACH_PARENT()
--  Declaration of UpdateChildParentExist constraint for the parent &quot;[%PQUALIFIER%]%PARENT%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cpk%REFNO%_%.25L:TABLE%&quot;
cursor %CURSOR%(.JOIN(&quot;var_%.L26:FK% %.L:HOSTCOLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;) is&quot;)
   select 1
   from   [%PQUALIFIER%]%PARENT%
   where  .JOIN(&quot;%PK% = var_%.L26:FK%&quot;, &quot;and   &quot;)
    and   .JOIN(&quot;var_%.L26:FK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o372">
<a:ObjectID>4D4FEE0B-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>UpdateTooManyChildren</a:Name>
<a:Code>UpdateTooManyChildren</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot exceed the maximum cardinality constraint when updating the child</a:Comment>
</o:TriggerItem>
<o:TriggerItem Id="o373">
<a:ObjectID>4D4FEE0C-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>UpdateChildChangeParent</a:Name>
<a:Code>UpdateChildChangeParent</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
--  Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;(updating(%.q:FK%) and :old.%FK% != :new.%FK%)&quot;, &quot;&quot;, &quot; or&quot;, &quot; then&quot;)
   .ERROR(-20004, &quot;Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot change parent constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o374">
<a:ObjectID>4D4FEE0D-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>UpdateParentRestrict</a:Name>
<a:Code>UpdateParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
--  Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;(updating(%.q:PK%) and :old.%PK% != :new.%PK%)&quot;, &quot;&quot;, &quot; or&quot;, &quot; then&quot;)
.DEFINE &quot;CURSOR&quot; &quot;cfk%REFNO%_%.25L:TABLE%&quot;
   open  %CURSOR%(.JOIN(&quot;:old.%PK%&quot;, &quot;&quot;, &quot;,&quot;, &quot;);&quot;)
   fetch %CURSOR% into dummy;
   found := %CURSOR%%FOUND;
   close %CURSOR%;
   if found then
      .ERROR(-20005, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)
   end if;
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
--  Declaration of UpdateParentRestrict constraint for &quot;[%CQUALIFIER%]%CHILD%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cfk%REFNO%_%.25L:TABLE%&quot;
cursor %CURSOR%(.JOIN(&quot;var_%.L26:PK% %.L:HOSTCOLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;) is&quot;)
   select 1
   from   [%CQUALIFIER%]%CHILD%
   where  .JOIN(&quot;%FK% = var_%.L26:PK%&quot;, &quot;and   &quot;)
    and   .JOIN(&quot;var_%.L26:PK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o375">
<a:ObjectID>4D4FEE0E-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>UpdateParentCascade</a:Name>
<a:Code>UpdateParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
--  Modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; for all children in &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;(updating(%.q:PK%) and :old.%PK% != :new.%PK%)&quot;, &quot;&quot;, &quot; or&quot;, &quot; then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = :new.%PK%&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o376">
<a:ObjectID>4D4FEE0F-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>UpdateParentSetNull</a:Name>
<a:Code>UpdateParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;(updating(%.q:PK%) and :old.%PK% != :new.%PK%)&quot;, &quot;&quot;, &quot; or&quot;, &quot; then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o377">
<a:ObjectID>4D4FEE10-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>UpdateParentSetDefault</a:Name>
<a:Code>UpdateParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot;
.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;(updating(%.q:PK%) and :old.%PK% != :new.%PK%)&quot;, &quot;&quot;, &quot; or&quot;, &quot; then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o378">
<a:ObjectID>4D4FEE13-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>DeleteParentRestrict</a:Name>
<a:Code>DeleteParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
--  Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cfk%REFNO%_%.25L:TABLE%&quot;
open  %CURSOR%(.JOIN(&quot;:old.%PK%&quot;, &quot;&quot;, &quot;,&quot;, &quot;);&quot;)
fetch %CURSOR% into dummy;
found := %CURSOR%%FOUND;
close %CURSOR%;
if found then
   .ERROR(-20006, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
--  Declaration of DeleteParentRestrict constraint for &quot;[%CQUALIFIER%]%CHILD%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cfk%REFNO%_%.25L:TABLE%&quot;
cursor %CURSOR%(.JOIN(&quot;var_%.L26:PK% %.L:HOSTCOLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;) is&quot;)
   select 1
   from   [%CQUALIFIER%]%CHILD%
   where  .JOIN(&quot;%FK% = var_%.L26:PK%&quot;, &quot;and   &quot;)
    and   .JOIN(&quot;var_%.L26:PK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o379">
<a:ObjectID>4D4FEE14-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>DeleteParentCascade</a:Name>
<a:Code>DeleteParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
--  Delete all children in &quot;[%CQUALIFIER%]%CHILD%&quot;
delete [%CQUALIFIER%]%CHILD%
where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o380">
<a:ObjectID>4D4FEE15-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>DeleteParentSetNull</a:Name>
<a:Code>DeleteParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in child &quot;[%CQUALIFIER%]%CHILD%&quot;
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o381">
<a:ObjectID>4D4FEE16-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>DeleteParentSetDefault</a:Name>
<a:Code>DeleteParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot;
.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
--  Set parent code &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o382">
<a:ObjectID>BDD87BBD-9480-11D4-A4A9-00B40080D29C</a:ObjectID>
<a:Name>InsertSequenceColumn</a:Name>
<a:Code>InsertSequenceColumn</a:Code>
<a:Text>.FOREACH_COLUMN(&quot;SQCOLN&quot;)
--  Column &quot;%COLUMN%&quot; uses sequence [%SQNCOWNER%]%SQNC%
select [%SQNCOWNER%]%SQNC%.NEXTVAL INTO :new.%COLUMN% from dual;
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>990197214</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Implements sequences for columns</a:Comment>
<a:Declaration>.FOREACH_COLUMN(&quot;SQCOLN&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
</c:TriggerItems>
<c:TriggerTemplates>
<o:TriggerTemplate Id="o383">
<a:ObjectID>4D4FEE03-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>BeforeInsertTrigger</a:Name>
<a:Code>BeforeInsertTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% before insert
on [%TABLQUALIFIER%]%TABLE% for each row
declare
    integrity_error  exception;
    errno            integer;
    errmsg           char(200);
    dummy            integer;
    found            boolean;
    .DeclInsertChildParentExist

begin
    .InsertChildParentExist
    .InsertSequenceColumn

--  Errors handling
exception
    when integrity_error then
       raise_application_error(errno, errmsg);
end;
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1126626993</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Before insert trigger</a:Comment>
<a:TriggerName>tib_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o368"/>
<o:TriggerItem Ref="o382"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o384">
<a:ObjectID>4D4FEE06-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>AfterInsertTrigger</a:Name>
<a:Code>AfterInsertTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% after insert
on [%TABLQUALIFIER%]%TABLE% for each row
begin
end;
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>After insert trigger</a:Comment>
<a:Time>After</a:Time>
<a:TriggerName>tia_%.L:TABLE%</a:TriggerName>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o385">
<a:ObjectID>4D4FEE07-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>BeforeUpdateTrigger</a:Name>
<a:Code>BeforeUpdateTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% before update
of .INCOLN(&quot;%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;)
on [%TABLQUALIFIER%]%TABLE% for each row
declare
    integrity_error  exception;
    errno            integer;
    errmsg           char(200);
    dummy            integer;
    found            boolean;
    .DeclUpdateChangeColumn
    .DeclUpdateChildParentExist
    .DeclUpdateChildChangeParent
    .DeclUpdateParentRestrict

begin
    .UpdateChangeColumn
    .UpdateChildParentExist
    .UpdateChildChangeParent
    .UpdateParentRestrict

--  Errors handling
exception
    when integrity_error then
       raise_application_error(errno, errmsg);
end;
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Before update trigger</a:Comment>
<a:Event>Update</a:Event>
<a:TriggerName>tub_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o370"/>
<o:TriggerItem Ref="o371"/>
<o:TriggerItem Ref="o373"/>
<o:TriggerItem Ref="o374"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o386">
<a:ObjectID>4D4FEE08-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>AfterUpdateTrigger</a:Name>
<a:Code>AfterUpdateTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% after update
of .INCOLN(&quot;%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;)
on [%TABLQUALIFIER%]%TABLE% for each row
declare
    integrity_error  exception;
    errno            integer;
    errmsg           char(200);
    dummy            integer;
    found            boolean;
    .DeclUpdateParentCascade
    .DeclUpdateParentSetNull
    .DeclUpdateParentSetDefault
begin
    IntegrityPackage.NextNestLevel;
    .UpdateParentCascade
    .UpdateParentSetNull
    .UpdateParentSetDefault
    IntegrityPackage.PreviousNestLevel;

--  Errors handling
exception
    when integrity_error then
       begin
       IntegrityPackage.InitNestLevel;
       raise_application_error(errno, errmsg);
       end;
end;
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>After update trigger</a:Comment>
<a:Time>After</a:Time>
<a:Event>Update</a:Event>
<a:TriggerName>tua_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o375"/>
<o:TriggerItem Ref="o376"/>
<o:TriggerItem Ref="o377"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o387">
<a:ObjectID>4D4FEE11-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>BeforeDeleteTrigger</a:Name>
<a:Code>BeforeDeleteTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% before delete
on [%TABLQUALIFIER%]%TABLE% for each row
declare
    integrity_error  exception;
    errno            integer;
    errmsg           char(200);
    dummy            integer;
    found            boolean;
    .DeclDeleteParentRestrict

begin
    .DeleteParentRestrict

--  Errors handling
exception
    when integrity_error then
       raise_application_error(errno, errmsg);
end;
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Before delete trigger</a:Comment>
<a:Event>Delete</a:Event>
<a:TriggerName>tdb_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o378"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o388">
<a:ObjectID>4D4FEE12-FCA1-11D2-B69E-0008C7EA924D</a:ObjectID>
<a:Name>AfterDeleteTrigger</a:Name>
<a:Code>AfterDeleteTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% after delete
on [%TABLQUALIFIER%]%TABLE% for each row
declare
    integrity_error  exception;
    errno            integer;
    errmsg           char(200);
    dummy            integer;
    found            boolean;
    .DeclDeleteParentCascade
    .DeclDeleteParentSetNull
    .DeclDeleteParentSetDefault

begin
    IntegrityPackage.NextNestLevel;
    .DeleteParentCascade
    .DeleteParentSetNull
    .DeleteParentSetDefault
    IntegrityPackage.PreviousNestLevel;

--  Errors handling
exception
    when integrity_error then
       begin
       IntegrityPackage.InitNestLevel;
       raise_application_error(errno, errmsg);
       end;
end;
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>After delete trigger</a:Comment>
<a:Time>After</a:Time>
<a:Event>Delete</a:Event>
<a:TriggerName>tda_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o379"/>
<o:TriggerItem Ref="o380"/>
<o:TriggerItem Ref="o381"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o389">
<a:ObjectID>43C6DA57-2B77-4DB7-8757-D58A3BDDCA91</a:ObjectID>
<a:Name>InsteadOfDelete</a:Name>
<a:Code>InsteadOfDelete</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% instead of delete
   on [%TABLQUALIFIER%]%TABLE% for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);

begin

--  Errors handling
exception
    when integrity_error then
       raise_application_error(errno, errmsg);
end;
</a:Text>
<a:CreationDate>1088429981</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1126626993</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Instead of delete view trigger</a:Comment>
<a:Time>instead of</a:Time>
<a:Event>delete</a:Event>
<a:TriggerName>%TEMPLATE%_%.L:TABLE%</a:TriggerName>
<a:ViewTrigger>1</a:ViewTrigger>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o390">
<a:ObjectID>733EAAD6-F6C1-48AB-944A-AE7D90FB11F8</a:ObjectID>
<a:Name>InsteadOfInsert</a:Name>
<a:Code>InsteadOfInsert</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% instead of insert
   on [%TABLQUALIFIER%]%TABLE% for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);

begin

--  Errors handling
exception
    when integrity_error then
       raise_application_error(errno, errmsg);
end;
</a:Text>
<a:CreationDate>1088429693</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1126626993</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Instead of insert view trigger</a:Comment>
<a:Time>instead of</a:Time>
<a:TriggerName>%TEMPLATE%_%.L:TABLE%</a:TriggerName>
<a:ViewTrigger>1</a:ViewTrigger>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o391">
<a:ObjectID>094C1801-747E-4A5F-86F2-A48F3BAC05BF</a:ObjectID>
<a:Name>InsteadOfUpdate</a:Name>
<a:Code>InsteadOfUpdate</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% instead of update
   on [%TABLQUALIFIER%]%TABLE% for each row
declare
   integrity_error  exception;
   errno            integer;
   errmsg           char(200);

begin

--  Errors handling
exception
    when integrity_error then
       raise_application_error(errno, errmsg);
end;
</a:Text>
<a:CreationDate>1088429970</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1126626993</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Instead of update view trigger</a:Comment>
<a:Time>instead of</a:Time>
<a:Event>update</a:Event>
<a:TriggerName>%TEMPLATE%_%.L:TABLE%</a:TriggerName>
<a:ViewTrigger>1</a:ViewTrigger>
</o:TriggerTemplate>
</c:TriggerTemplates>
</o:DBMS>

</DBMS>