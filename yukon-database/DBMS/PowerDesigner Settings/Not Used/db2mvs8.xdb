<?xml version="1.0" encoding="UTF-8"?>
<?PowerDesigner AppLocale="UTF16" Code="DB2MVS8" Family="DB2;DB2MVS" Name="IBM DB2 UDB 8 for OS/390" signature="XDB_XML" version="12.0.0.1697"?>
<!-- do not edit this file -->

<DBMS xmlns:a="attribute" xmlns:c="collection" xmlns:o="object">

<o:DBMS Id="o1">
<a:ObjectID>B4A86D92-052C-479D-A956-48679780E02A</a:ObjectID>
<a:Name>IBM DB2 UDB 8 for OS/390</a:Name>
<a:Code>DB2MVS8</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Family>DB2;DB2MVS</a:Family>
<a:CheckGlobalScript>&#39;******************************************************************************
&#39;* Purpose:  This VB-Script holds global definitions shared by all the custom-
&#39;*            checks scripts of the model extension.
&#39;******************************************************************************

Option Explicit &#39; This is to ensure all used variables are defined

Function GetBooleanItem(sItemPath)
   GetBooleanItem = CBool(GetItemValue(ActiveModel.DBMS.TargetObject, sItemPath))
End Function

Function GetItemValue(pCtg, sPath)
   if (pCtg is Nothing) then
      GetItemValue = &quot;&quot;
      Exit Function
   end if
   if (sPath = &quot;&quot;) then
      GetItemValue = &quot;&quot;
      Exit Function
   end if
   dim pos, pSub, sSub, bFound
   pos = InStr(sPath, &quot;\&quot;)
   if (pos = 0) then
      sSub = sPath
   else
      sSub = Left(sPath, pos - 1)
   end if
   For each pSub in pCtg.Categories
      if (pSub.Name = sSub) then 
         bFound = true
         exit for
      end if
   next
   if not (bFound) then
      GetItemValue = &quot;&quot;
      Exit Function
   end if
   if (pos = 0) then
      GetItemValue = pSub.Value
   else
      GetItemValue = GetItemValue(pSub, mid(sPath, pos + 1))
   end if
end function</a:CheckGlobalScript>
<c:Categories>
<o:TargetCategory Id="o2">
<a:Name>General</a:Name>
<a:Comment>Target DBMS identification</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o3">
<a:Name>SqlSupport</a:Name>
<a:Comment>SQL syntax allowed. This does not impact the script generation, but it impacts the SQL Preview</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o4">
<a:Name>Enableconstname</a:Name>
<a:Comment>Determines if constraint names are used during the generation</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o5">
<a:Name>EnableMultiCheck</a:Name>
<a:Comment>Determines if the generation of multiple check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o6">
<a:Name>UniqConstName</a:Name>
<a:Comment>Determines if unique constraint names for objects are authorized or not</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o7">
<a:Name>EnableCheck</a:Name>
<a:Comment>Determines if the generation of check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o8">
<a:Name>Script</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the Script generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o9">
<a:Name>Sql</a:Name>
<a:Comment>Contains sub-categories Syntax, Format, File and Keywords. Each sub-category contains entries whose values define general syntax for the database</a:Comment>
<c:Categories>
<o:TargetCategory Id="o10">
<a:Name>Syntax</a:Name>
<a:Comment>Contains general parameters for SQL syntax</a:Comment>
<c:Categories>
<o:CharacterTargetItem Id="o11">
<a:Name>Terminator</a:Name>
<a:Comment>End of command character</a:Comment>
<a:CharacterTargetItem.Value>;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o12">
<a:Name>BlockTerminator</a:Name>
<a:Comment>End of block character</a:Comment>
</o:StringTargetItem>
<o:CharacterTargetItem Id="o13">
<a:Name>Delimiter</a:Name>
<a:Comment>Field separation character. Example: col1, col2, col3</a:Comment>
<a:CharacterTargetItem.Value>,</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o14">
<a:Name>Quote</a:Name>
<a:Comment>Character used to enclose string values</a:Comment>
<a:CharacterTargetItem.Value>&#39;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o15">
<a:Name>SqlContinue</a:Name>
<a:Comment>Continuation character</a:Comment>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o16">
<a:Name>LineComment</a:Name>
<a:Comment>Characters used to enclose a single line comment</a:Comment>
<a:StringTargetItem.Value>--</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o17">
<a:Name>BlockComment</a:Name>
<a:Comment>Characters used to enclose a multi-line comment</a:Comment>
</o:StringTargetItem>
<o:TextTargetItem Id="o18">
<a:Name>UsingBlockTerm</a:Name>
<a:TextTargetItem.Value>create trigger, end, 1
{
   begin, , 2
   {
      begin, end, 3
      case, end case, 4
      if, end if, 4
      for, end for, 4
      loop, end loop, 4
      repeat, end repeat, 4
      while, end while, 4
   }
}
create procedure, , 1
{
   begin, end, 2
   case, end case, 4
   if, end if, 4
   for, end for, 4
   loop, end loop, 4
   repeat, end repeat, 4
   while, end while, 4
}</a:TextTargetItem.Value>
<a:Comment>List of objects using block definition during reverse.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o19">
<a:Name>Format</a:Name>
<a:Comment>Contains entries that define script formatting</a:Comment>
<c:Categories>
<o:StringTargetItem Id="o20">
<a:Name>IllegalChar</a:Name>
<a:Comment>Invalid characters for names</a:Comment>
<a:StringTargetItem.Value>&quot; +-*/!=&lt;&gt;&#39;&quot;()&quot;.</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o21">
<a:Name>UpperCaseOnly</a:Name>
<a:Comment>Uppercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o22">
<a:Name>LowerCaseOnly</a:Name>
<a:Comment>Lowercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o23">
<a:Name>EnableOwnerPrefix</a:Name>
<a:Comment>Object codes can have a prefix made of the object owner code</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o24">
<a:Name>MaxScriptLen</a:Name>
<a:Comment>Maximum length for a script line</a:Comment>
<a:IntegerTargetItem.Value>72</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o25">
<a:Name>CaseSensitivityUsingQuote</a:Name>
<a:Comment>Determines if the case sensitivity for identifiers is managed using double quotes</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o26">
<a:Name>File</a:Name>
<a:Comment>Contains header, footer and usage text entries used during the generation</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o27">
<a:Name>Header</a:Name>
<a:Comment>Header text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o28">
<a:Name>Footer</a:Name>
<a:Comment>Footer text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o29">
<a:Name>EnableMultiFile</a:Name>
<a:Comment>Multi-script allowed</a:Comment>
</o:BooleanTargetItem>
<o:StringTargetItem Id="o30">
<a:Name>ScriptExt</a:Name>
<a:Comment>Main script extension in database generation</a:Comment>
<a:StringTargetItem.Value>sql</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o31">
<a:Name>TableExt</a:Name>
<a:Comment>Other scripts extension in database generation</a:Comment>
<a:StringTargetItem.Value>tab</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o32">
<a:Name>StartCommand</a:Name>
<a:Comment>Command for executing a script</a:Comment>
</o:StringTargetItem>
<o:TextTargetItem Id="o33">
<a:Name>Usage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter
  (3) Run the script &quot;%NAMESCRIPT%&quot;</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in database generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o34">
<a:Name>Usage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter
  (3) Run the generated scripts</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in database generation</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o35">
<a:Name>TriggerExt</a:Name>
<a:Comment>Script file extension in triggers and procedures generation</a:Comment>
<a:StringTargetItem.Value>trg</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o36">
<a:Name>TrgUsage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start SQL interpreter:
        sqlplus &lt;username&gt;/&lt;password&gt;
  (3) Execute the trigger creation script:
        start %NAMESCRIPT%</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o37">
<a:Name>TrgUsage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start SQL interpreter:
        sqlplus &lt;username&gt;/&lt;password&gt;
  (3) Execute the triggers creation scripts:
        start &lt;script_name&gt;</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o38">
<a:Name>Keywords</a:Name>
<a:Comment>Contains the list of reserved words and functions available in SQL</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o39">
<a:Name>ReservedDefault</a:Name>
<a:TextTargetItem.Value>NULL
USER
CURRENT DATE
CURRENT DEGREE
CURRENT PACKAGESET
CURRENT RULES
CURRENT SERVER
CURRENT SQLID
CURRENT TIME
CURRENT TIMESTAMP
CURRENT TIMEZONE</a:TextTargetItem.Value>
<a:Comment>Reserved default values</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o40">
<a:Name>GroupFunc</a:Name>
<a:TextTargetItem.Value>avg()
count()
count_big()
max()
min()
stddev()
sum()
variance()
var()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions to use with group keywords.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o41">
<a:Name>NumberFunc</a:Name>
<a:TextTargetItem.Value>abs()
absval()
acos()
asin()
atan()
atanh()
atan2()
ceil()
ceiling()
cos()
cosh()
degrees()
exp()
floor()
ln()
log()
log10()
mod()
power()
radians()
rand()
round()
sign()
sin()
sinh()
sqrt()
tan()
tanh()
truncate()
trunc()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used on numbers</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o42">
<a:Name>CharFunc</a:Name>
<a:TextTargetItem.Value>char()
coalesce()
concat()
ifnull()
insert()
lcase()
left()
lower()
locate()
ltrim()
posstr()
repeat()
replace()
right()
rtrim()
space()
strip()
substr()
translate()
ucase()
upper()
value()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for characters and strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o43">
<a:Name>DateFunc</a:Name>
<a:TextTargetItem.Value>current date
current time
current timestamp
current timezone
date()
day()
dayofmonth()
dayofweek()
dayofyear()
days()
hour()
julian_day()
microsecond()
midnight_second()
minute()
month()
quarter()
second()
time()
timestamp()
week()
year()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for dates</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o44">
<a:Name>ConvertFunc</a:Name>
<a:TextTargetItem.Value>decimal()
digits()
double()
double_precision()
float()
hex()
graphic()
integer()
int()
real()
smallint()
timestamp()
varchar()
vargraphic()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used to convert values between hex and integer and handling strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o45">
<a:Name>OtherFunc</a:Name>
<a:TextTargetItem.Value>blob()
clob()
dbclob()
length()
nullif()
raise_error()
rowid()
user</a:TextTargetItem.Value>
<a:Comment>List of other SQL functions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o46">
<a:Name>ListOperators</a:Name>
<a:TextTargetItem.Value>=
&lt;&gt;
&gt;
&lt;
&gt;=
&lt;=
*=
=*
not
in
not in
between
not between
exists
not exists
like
not like
is
is not
= any
&lt;&gt; any
&gt; any
&lt; any
&gt;= any
&lt;= any
= all
&lt;&gt; all
&gt; all
&lt; all
&gt;= all
&lt;= all</a:TextTargetItem.Value>
<a:Comment>List of operators for comparing values, boolean, and various semantic operators</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o47">
<a:Name>Commit</a:Name>
<a:TextTargetItem.Value>commit</a:TextTargetItem.Value>
<a:Comment>Command for validating the transaction by OBDC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o48">
<a:Name>ReservedWord</a:Name>
<a:TextTargetItem.Value>ADD
AFTER
ALL
ALLOCATE
ALLOW
ALTER
AND
ANY
APPLICATION
AS
ASSOCIATE
ASUTIME
AUDIT
AUX
AUXILIARY
BEFORE
BEGIN
BETWEEN
BUFFERPOOL
BY
CALL
CAPTURE
CASCADED
CASE
CAST
CCSID
CHAR
CHARACTER
CHECK
CLOSE
CLUSTER
COLLECTION
COLLID
COLUMN
COMMENT
COMMIT
CONCAT
CONDITION
CONNECT
CONNECTION
CONSTRAINT
CONTAINS
CONTINUE
CREATE
CURRENT
CURRENT_DATE
CURRENT_LC_CTYPE
CURRENT_PATH
CURRENT_TIME
CURRENT_TIMESTAMP
CURSOR
DATA
DATABASE
DAY
DAYS
DBINFO
DB2SQL
DECLARE
DEFAULT
DELETE
DESCRIPTOR
DETERMINISTIC
DISALLOW
DISTINCT
DO
DOUBLE
DROP
DSNHATTR
DSSIZE
DYNAMIC
EDITPROC
ELSE
ELSEIF
ENCODING
END
END-EXEC
ERASE
ESCAPE
EXCEPT
EXECUTE
EXISTS
EXIT
EXTERNAL
FENCED
FETCH
FIELDPROC
FINAL
FOR
FROM
FULL
FUNCTION
GENERAL
GENERATED
GET
GLOBAL
GO
GOTO
GRANT
GROUP
HANDLER
HAVING
HOUR
HOURS
IF
IMMEDIATE
IN
INDEX
INHERIT
INNER
INOUT
INSENSITIVE
INSERT
INTO
IS
ISOBID
JAR
JAVA
JOIN
KEY
LABEL
LANGUAGE
LC_CTYPE
LEAVE
LEFT
LIKE
LOCAL
LOCALE
LOCATOR
LOCATORS
LOCK
LOCKMAX
LOCKSIZE
LONG
LOOP
MICROSECOND
MICROSECONDS
MINUTE
MINUTES
MODIFIES
MONTH
MONTHS
NO
NOT
NULL
NULLS
NUMPARTS
OBID
OF
ON
OPEN
OPTIMIZATION
OPTIMIZE
OR
ORDER
OUT
OUTER
PACKAGE
PARAMETER
PART
PATH
PIECESIZE
PLAN
PRECISION
PREPARE
PRIQTY
PRIVILEGES
PROCEDURE
PROGRAM
PSID
QUERYNO
READS
REFERENCES
RELEASE
RENAME
REPEAT
RESTRICT
RESULT
RESULT_SET_LOCATOR
RETURN
RETURNS
REVOKE
RIGHT
ROLLBACK
RUN
SAVEPOINT
SCHEMA
SCRATCHPAD
SECOND
SECONDS
SECQTY
SECURITY
SELECT
SENSITIVE
SET
SIMPLE
SOME
SOURCE
SPECIFIC
STANDARD
STATIC
STAY
STOGROUP
STORES
STYLE
SUBPAGES
SYNONYM
SYSFUN
SYSIBM
SYSPROC
SYSTEM
TABLE
TABLESPACE
THEN
TO
TRIGGER
UNDO
UNION
UNIQUE
UNTIL
UPDATE
USER
USING
VALIDPROC
VALUES
VARIANT
VCAT
VIEW
VOLUMES
WHEN
WHERE
WHILE
WITH
WLM
YEAR
YEARS</a:TextTargetItem.Value>
<a:Comment>Reserved words</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o49">
<a:Name>Objects</a:Name>
<a:Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:Comment>
<c:Categories>
<o:TargetCategory Id="o50">
<a:Name>Table</a:Name>
<a:Code>TABL</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLE&quot;        // generated code of the table
   &quot;TNAME&quot;        // name of the table
   &quot;TCODE&quot;        // code of the table
   &quot;TLABL&quot;        // comment of the table
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;TABLDEFN&quot;     // complete body of the table definition. Contains definition of columns, checks and keys
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o51">
<a:Name>AddTableCheck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME% ]check (%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script for modifying table constraints within an alter table statement</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o52">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o53">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>T_%.16:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for check of table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o54">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create table [%QUALIFIER%]%TABLE% (
   %TABLDEFN%
)
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a table. Example: create table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o55">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>in %s : category=tablespace, enabledbprefix=yes
in database %s : category=database, default=dsndb04
editproc %s
validproc %s
audit %s : list=none|changes|all, default=none
obid %d
data capture %s : list=none|changes, default=none
with restrict on drop
ccsid %s : list=ascii|ebcdic|unicode, default=ascii</a:TextTargetItem.Value>
<a:Comment>Available options for creating a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o56">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for table options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o57">
<a:Name>TableComment</a:Name>
<a:TextTargetItem.Value>comment on table [%QUALIFIER%]%TABLE% is
%.q254:COMMENT%</a:TextTargetItem.Value>
<a:Comment>Command for adding a table comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o58">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop table [%QUALIFIER%]%TABLE%
</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table. Example: drop table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o59">
<a:Name>DropTableCheck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop check %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o60">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>rename [table ][%OLDQUALIFIER%]%OLDTABL% to %NEWTABL%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o61">
<a:Name>InsertIdentityOff</a:Name>
<a:TextTargetItem.Value>.foreach_item(Columns)
.if ((%.l:ExtGeneratedAs%!=&quot;by default&quot;) and (%Identity%))
alter table %TABLE% alter column %COLUMN% set generated always
;
.endif
.next
</a:TextTargetItem.Value>
<a:Comment>Command for disabling insertion of data into table containing identity column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o62">
<a:Name>InsertIdentityOn</a:Name>
<a:TextTargetItem.Value>.foreach_item(Columns)
.if ((%.l:ExtGeneratedAs%!=&quot;by default&quot;) and (%Identity%))
alter table %TABLE% alter column %COLUMN% set generated by default
;
.endif
.next
</a:TextTargetItem.Value>
<a:Comment>Command for enabling insertion of data into table containing identity column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o63">
<a:Name>AlterTableHeader</a:Name>
<a:Comment>Alter table header</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o64">
<a:Name>AlterTableFooter</a:Name>
<a:Comment>Alter table footer</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o65">
<a:Name>DefineTableCheck</a:Name>
<a:TextTargetItem.Value>[[constraint %CONSTNAME% ]check (%.A:CONSTRAINT%)]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of table check constraints</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o66">
<a:Name>Enable</a:Name>
<a:Comment>Table allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o67">
<a:Name>UniqConstraintName</a:Name>
<a:Comment>Disallows the same name for index and constraint name in the same table.</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o68">
<a:Name>SqlChckQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, CONSTNAME, CONSTRAINT}

select  
   k.tbowner,
   k.tbname,
   k.checkname,
   k.checkcondition
from 
   sysibm.syschecks k
where 1 &lt; (select count(*) from sysibm.syscheckdep r where k.tbowner = r.tbowner and k.tbname  = r.tbname and k.checkname = r.checkname)
[  and k.tbowner = %.q:OWNER%]
[  and k.tbname = %.q:TABLE%]
order by 1, 2, 3</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o69">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, OPTIONS}

select
   t.creator,
   t.name,
   &#39;in &#39; concat case(m.implicit) when &#39;N&#39; then strip(t.dbname) concat &#39;.&#39; concat strip(t.tsname) else &#39;database &#39; concat strip(t.dbname) end
   concat case(t.edproc) when &#39;&#39; then &#39;&#39; else &#39; editproc &#39; concat t.edproc end
   concat case(t.valproc) when &#39;&#39; then &#39;&#39; else &#39; validproc &#39; concat t.valproc end
   concat case(t.auditing) when &#39;A&#39; then &#39; audit all&#39; when &#39;C&#39; then &#39; audit change&#39; else &#39;&#39; end
   concat case(t.datacapture) when &#39;Y&#39; then &#39; data capture changes&#39; else &#39;&#39; end
   concat case(t.clustertype) when &#39;Y&#39; then &#39; with restrict on drop&#39; else &#39;&#39; end
   concat case(t.encoding_scheme) when &#39;A&#39; then &#39; ccsid ascii&#39; when &#39;E&#39; then &#39; ccsid ebcdic&#39; when &#39;U&#39; then &#39; ccsid unicode&#39; else &#39;&#39; end
from
   sysibm.systables t
      join sysibm.systablespace m on (m.name = t.tsname and m.dbid = t.dbid)
where 1=1
[  and t.name = %.q:TABLE%]
[  and t.creator = %.q:OWNER%]
[  and t.dbname=%.q:CATALOG%]
order by 1, 2
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o70">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, TABLE_TYPE, @OBJTLABL}

select
   creator,
   name,
   &#39;TABLE&#39;,
   remarks
from
   sysibm.systables
where type=&#39;T&#39;
   [and name=%.q:TABLE%]
   [and dbname=%.q:CATALOG%]
   [and creator=%.q:OWNER%]
union select
   s.creator,
   s.name,
   &#39;SYNONYM&#39;,
   &#39;&#39;
from
   sysibm.syssynonyms s, sysibm.systables t
where 
   s.tbname=t.name
   and s.tbcreator=t.creator
   [and s.name=%.q:TABLE%]
   [and t.dbname=%.q:CATALOG%]
   [and s.creator=%.q:OWNER%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o71">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o72">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a table.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>ALTER=Alter
DELETE=Delete
INDEX=Index
INSERT=Insert
SELECT=Select
REFERENCES=Refr.
TRIGGER=Trigger
UPDATE=Update</a:MapTargetItem.Value>
<a:List>ALTER
DELETE
INDEX
INSERT
SELECT
REFERENCES
TRIGGER
UPDATE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o73">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{ GRANTEE ID, PERMISSION ...}

select 
s.grantee grantee, 
case s.alterauth when &#39;Y&#39; then &#39;ALTER&#39; else &#39;&#39; end concat &#39;,&#39; concat 
case s.alterauth when &#39;G&#39; then &#39;ALTER+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.deleteauth when &#39;Y&#39; then &#39;DELETE&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.deleteauth when &#39;G&#39; then &#39;DELETE+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.indexauth when &#39;Y&#39; then &#39;INDEX&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.indexauth when &#39;G&#39; then &#39;INDEX+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.insertauth when &#39;Y&#39; then &#39;INSERT&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.insertauth when &#39;G&#39; then &#39;INSERT+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.selectauth when &#39;Y&#39; then &#39;SELECT&#39; else &#39;&#39; end concat &#39;,&#39; concat 
case s.selectauth when &#39;G&#39; then &#39;SELECT+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.referencesauth when &#39;Y&#39; then &#39;REFERENCES&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.referencesauth when &#39;G&#39; then &#39;REFERENCES+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.updateauth when &#39;Y&#39; then &#39;UPDATE&#39; else &#39;&#39; end concat &#39;,&#39; concat 
case s.updateauth when &#39;G&#39; then &#39;UPDATE+&#39; else &#39;&#39; end concat &#39;,&#39; concat 
case s.triggerauth when &#39;Y&#39; then &#39;TRIGGER&#39; else &#39;&#39; end concat &#39;,&#39; concat 
case s.triggerauth when &#39;G&#39; then &#39;TRIGGER+&#39; else &#39;&#39; end
from sysibm.systabauth s
where s.tcreator &lt;&gt; s.grantee 
[and s.ttname = %.q:TABLE%]
[and s.tcreator = %.q:OWNER%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o74">
<a:Name>User</a:Name>
<a:Code>USER</a:Code>
<a:Comment>The following system variables are available:
   &quot;USER&quot;         // generated code of the user
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o75">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>8</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o76">
<a:Name>Enable</a:Name>
<a:Comment>User allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o77">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{USER}

select distinct creator from sysibm.systables
where 1=1
[and dbname = %.q:CATALOG%]
[and UPPER(creator) = %.qU:SCHEMA%]
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o78">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{USER ID, PRIVILEGE ...}

select
s.grantee,
case s.archiveauth when &#39;Y&#39; then &#39;ARCHIVE&#39; when &#39;G&#39; then &#39;ARCHIVE+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.bindaddauth when &#39;Y&#39; then &#39;BINDADD&#39; when &#39;G&#39; then &#39;BINDADD+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.bindagentauth when &#39;Y&#39; then &#39;BINDAGENT&#39; when &#39;G&#39; then &#39;BINDAGENT+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.bsdsauth when &#39;Y&#39; then &#39;BSDS&#39; when &#39;G&#39; then &#39;BSDS+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.createaliasauth when &#39;Y&#39; then &#39;CREATEALIAS&#39; when &#39;G&#39; then &#39;CREATEALIAS+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.createdbaauth when &#39;Y&#39; then &#39;CREATEDBA&#39; when &#39;G&#39; then &#39;CREATEDBA+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.createdbcauth when &#39;Y&#39; then &#39;CREATEDBC&#39; when &#39;G&#39; then &#39;CREATEDBC+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.createsgauth when &#39;Y&#39; then &#39;CREATESG&#39; when &#39;G&#39; then &#39;CREATESG+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.createtmtabauth when &#39;Y&#39; then &#39;CREATETMTAB&#39; when &#39;G&#39; then &#39;CREATETMTAB+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.displayauth when &#39;Y&#39; then &#39;DISPLAY&#39; when &#39;G&#39; then &#39;DISPLAY+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.mon1auth when &#39;Y&#39; then &#39;MONITOR1&#39; when &#39;G&#39; then &#39;MONITOR1+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.mon2auth when &#39;Y&#39; then &#39;MONITOR2&#39; when &#39;G&#39; then &#39;MONITOR2+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.recoverauth when &#39;Y&#39; then &#39;RECOVER&#39; when &#39;G&#39; then &#39;RECOVER+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.stopallauth when &#39;Y&#39; then &#39;STOPALL&#39; when &#39;G&#39; then &#39;STOPALL+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.stospaceauth when &#39;Y&#39; then &#39;STOSPACE&#39; when &#39;G&#39; then &#39;STOSPACE+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.sysadmauth when &#39;Y&#39; then &#39;SYSADM&#39; when &#39;G&#39; then &#39;SYSADM+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.sysctrlauth when &#39;Y&#39; then &#39;SYSCTRL&#39; when &#39;G&#39; then &#39;SYSCTRL+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.sysoprauth when &#39;Y&#39; then &#39;SYSOPR&#39; when &#39;G&#39; then &#39;SYSOPR+&#39; else &#39;&#39; end concat &#39;,&#39;concat 
case s.traceauth when &#39;Y&#39; then &#39;TRACE&#39; when &#39;G&#39; then &#39;TRACE+&#39; else &#39;&#39; end
from sysibm.sysuserauth s
</a:TextTargetItem.Value>
<a:Comment>Query to reverse privileges</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o79">
<a:Name>Index</a:Name>
<a:Code>INDX</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
   &quot;INDEX&quot;        // generated code of the index
   &quot;INDEXNAME&quot;    // index name
   &quot;INDEXCODE&quot;    // index code
   &quot;UNIQUE&quot;       // keyword &quot;unique&quot; when the index is unique
   &quot;INDEXTYPE&quot;    // index type (available only for a few DBMS)
   &quot;INDEXKEY&quot;     // keywords &quot;primary&quot;, &quot;unique&quot; or &quot;foreign&quot; depending on the index origin
   &quot;CIDXLIST&quot;     // list of index columns. Eg: A asc, B desc, C asc
   &quot;CLUSTER&quot;      // keyword &quot;cluster&quot; when the index is cluster
For index columns, the following system variables are available:
   &quot;ASC&quot;          // keywords &quot;ASC&quot; or &quot;DESC&quot; depending on sort order
   &quot;ISASC&quot;        // TRUE if the index column sort is ascending
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o80">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o81">
<a:Name>MaxColIndex</a:Name>
<a:Comment>Maximum number of columns in an index</a:Comment>
<a:IntegerTargetItem.Value>64</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o82">
<a:Name>Enable</a:Name>
<a:Comment>Index allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o83">
<a:Name>EnableAscDesc</a:Name>
<a:Comment>ASC, DESC keywords allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o84">
<a:Name>UniqName</a:Name>
<a:Comment>Unique index name in the database</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o85">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [%INDEXTYPE% ][%UNIQUE% [%WhereNotNull%?where not null ]]index [%QUALIFIER%]%INDEX% on [%TABLQUALIFIER%]%TABLE% (
%CIDXLIST%
)
[%OPTIONS%]

</a:TextTargetItem.Value>
<a:Comment>Command for creating an index. Example: create index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o86">
<a:Name>AddColIndex</a:Name>
<a:TextTargetItem.Value>   %20:COLUMN% [%ASC%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an index column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o87">
<a:Name>IndexType</a:Name>
<a:TextTargetItem.Value>type 2</a:TextTargetItem.Value>
<a:Comment>List of types available for an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o88">
<a:Name>DefIndexType</a:Name>
<a:Comment>Default type for an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o89">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>&lt;usingblock&gt; : composite=yes
{
using vcat %s
using stogroup %s : category=storage, composite=yes
{
priqty %d : default=12
secqty %d
erase %s : default=no, list=yes|no
}
}
freepage %d : default=0
pctfree %d : default=5
gbpcache %s : list=all|changed|system|none, default=changed
define %s : list=yes|no, default=yes
cluster : composite=yes, parenthesis=yes, separator=yes
{
part %d : composite=yes, multiple=yes
{
values : composite=yes, parenthesis=yes, separator=yes
{
&lt;constant&gt; %d : multiple=yes
}
&lt;usingblock&gt; : composite=yes
{
using vcat %s
using stogroup %s : category=storage, composite=yes
{
priqty %d : default=12
secqty %d
erase %s : default=no, list=yes|no
}
}
freepage %d : default=0
pctfree %d : default=5
gbpcache %s : list=all|changed|system|none, default=changed
}
}
bufferpool %s : default=bp0
close %s : default=yes, list=yes|no
defer %s : list=yes|no, default=yes
copy %s : list=yes|no, default=yes
piecesize %d</a:TextTargetItem.Value>
<a:Comment>Default options for creating an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o90">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for index options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o91">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop index [%QUALIFIER%]%INDEX%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an index. Example: drop index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o92">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER, TABLE, OWNER, INDEX, INDEXTYPE, UNIQUE, INDEXKEY, CLUSTER, WhereNotNull}

select 
   tbcreator,
   tbname,
   creator,
   name,
   case indextype when &#39;2&#39; then &#39;type 2&#39; else &#39;type 1&#39; end,
   case uniquerule when &#39;D&#39; then &#39;&#39; else &#39;unique&#39; end, 
   case uniquerule when &#39;P&#39; then &#39;primary&#39; when &#39;U&#39; then &#39;unique&#39; else &#39;&#39; end, 
   case clustering when &#39;Y&#39; then &#39;cluster&#39; else &#39;&#39; end,
   case uniquerule when &#39;N&#39; then &#39;TRUE&#39; else &#39;FALSE&#39; end
from
   sysibm.sysindexes 
where 1=1
[  and tbname=%.q:TABLE%]
[  and tbcreator=%.q:OWNER%]
[  and dbname=%.q:CATALOG%]
order by
   1, 2, 3</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o93">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER ID, TABLE ID, OWNER ID, INDEX ID, CIDXLIST ...}

select
   i.tbcreator,
   i.tbname,
   i.creator,
   i.name,
   k.colname concat case k.ordering when &#39;D&#39; then &#39; desc,&#39; else &#39; asc,&#39; end
from
   sysibm.sysindexes i,
   sysibm.syskeys k
where
   k.ixname=i.name
   and k.ixcreator=i.creator
[  and i.tbname=%.q:TABLE%]
[  and i.creator=%.q:OWNER%]
[  and i.name=%.q:INDEX%]
[  and i.dbname=%.q:CATALOG%]
order by
   1, 2, 3, k.colseq</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o94">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER, TABLE, OWNER, INDEX, OPTIONS EX}

select
   i.tbcreator, i.tbname, i.creator, i.name, 
   case (p.partition)
      when 0 then &#39;%SqlIdxSinglePartDef.&#39; concat rtrim(i.creator) concat rtrim(i.name) concat &#39;0% &#39;
      else &#39; cluster (%SqlIdxMultiPartDef.&#39; concat rtrim(i.creator) concat rtrim(i.name) concat &#39;%) &#39;
   end
   concat &#39; bufferpool &#39; concat i.bpool
   concat &#39; close &#39; concat case i.closerule when &#39;N&#39; then &#39;no&#39; else &#39;yes&#39; end 
   concat  case i.indextype  when &#39;2&#39; then &#39;&#39; else &#39; subpages &#39; concat varchar(int(i.pgsize/256)) end 
   concat  case i.dsetpass when &#39;nopassword&#39; then &#39;&#39; when &#39;&#39; then &#39;&#39; else &#39; password &#39; concat i.dsetpass end 
   concat  case i.piecesize when 0 then &#39;&#39; else &#39; piecesize &#39; concat varchar(i.piecesize) concat &#39; K&#39; end
from
   sysibm.sysindexes i
      left join sysibm.sysindexpart p on (p.ixname=i.name and p.ixcreator=i.creator)
where 1 = 1
[ and i.tbcreator = %.q:OWNER%]
[ and i.tbname = %.q:TABLE%]
[ and i.dbname=%.q:CATALOG%]
order by 1, 2, 3, 4</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o95">
<a:Name>EnableCluster</a:Name>
<a:Comment>Cluster option available for indexes</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o96">
<a:Name>CreateBeforeKey</a:Name>
<a:Comment>Allow to invert generation order of indexes and keys</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o97">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o98">
<a:Name>SqlIdxSinglePartDef</a:Name>
<a:TextTargetItem.Value>{VAR, VAL}

select
   rtrim(i.creator) concat rtrim(i.name) concat varchar(p.partition),
   case p.stortype 
      when &#39;E&#39; then &#39; using vcat &#39; concat p.vcatname 
      when &#39;I&#39; then &#39; using stogroup &#39; concat p.storname 
         concat &#39; priqty &#39; concat varchar(p.pqty * 4)
         concat &#39; secqty &#39; concat varchar(p.sqty * 4)
         concat case i.eraserule when &#39;Y&#39; then &#39; erase yes&#39; when &#39;N&#39; then &#39; erase no&#39; else &#39;&#39; end
      else &#39;&#39; end
   concat &#39; freepage &#39; concat varchar(p.freepage)
   concat &#39; pctfree &#39; concat varchar(p.pctfree)
   concat &#39; gbpcache &#39; concat case p.gbpcache when &#39;A&#39; then &#39;all&#39; when &#39;N&#39; then &#39;none&#39; else &#39;changed&#39; end
   concat case when ((i.clustering = &#39;Y&#39;) and (p.partition = 0)) then &#39; cluster&#39; else &#39;&#39; end
from 
   sysibm.sysindexes i
      left join sysibm.sysindexpart p on (p.ixname=i.name and p.ixcreator=i.creator)
where 1 = 1
[ and i.tbcreator = %.q:OWNER%]
[ and i.tbname = %.q:TABLE%]
[ and i.dbname=%.q:CATALOG%]
order by 1</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o99">
<a:Name>SqlIdxMultiPartDef</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL EX ...}

select
   rtrim(i.creator) concat rtrim(i.name),
   case when (p.partition &gt; 1) then &#39;, &#39; else &#39;&#39; end
   concat &#39;part &#39; concat varchar(p.partition) concat &#39; values(&#39; concat varchar(t.limitkey) concat &#39;)&#39;
   concat &#39; %SqlIdxSinglePartDef.&#39; concat rtrim(i.creator) concat rtrim(i.name) concat varchar(p.partition) concat &#39;%&#39;
from 
   sysibm.sysindexes i
      left join sysibm.sysindexpart p on (p.ixname=i.name and p.ixcreator=i.creator)
      left join sysibm.systablepart t on (t.ixname=i.name and t.ixcreator=i.creator and t.partition=p.partition)
where 1 = 1
[ and i.tbcreator = %.q:OWNER%]
[ and i.tbname = %.q:TABLE%]
[ and i.dbname=%.q:CATALOG%]
order by 1, p.partition</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o100">
<a:Name>Column</a:Name>
<a:Code>COLN</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for columns)
   &quot;COLUMN&quot;       // generated code of the column
   &quot;COLNNO&quot;       // position of the column in the list of columns of the table
   &quot;COLNNAME&quot;     // name of the column
   &quot;COLNCODE&quot;     // code of the column
   &quot;PRIMARY&quot;      // keyword &quot;primary&quot; if the column is primary
   &quot;ISPKEY&quot;       // TRUE if the column is part of the primary key
   &quot;FOREIGN&quot;      // TRUE if the column is part of one foreign key
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o101">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o102">
<a:Name>AddColnChck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME% ]check (%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script for modifying column constraints within an alter table statement</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o103">
<a:Name>AltEnableAddColnChk</a:Name>
<a:Comment>Column check constraint allowed in an alter table statement</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o104">
<a:Name>EnableNotNullWithDflt</a:Name>
<a:Comment>Enables not null with default</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o105">
<a:Name>EnableDefault</a:Name>
<a:Comment>Default values allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o106">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>C_%.16:COLUMN%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for a column check parameter</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o107">
<a:Name>DropColnChck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop check %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a column check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o108">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%20:COLUMN% %22:DATATYPE%[%ExtSubtypeData%? for %ExtSubtypeData% data][ %NOTNULL%][%ExtFieldProcName%? fieldproc %ExtFieldProcName%:[%WITHDEFAULT%? %WITHDEFAULT%[ %DEFAULT%]:[ default %DEFAULT%]]]
[%CONSTDEFN%][%IDENTITY%?[%ExtGeneratedAs%? generated %ExtGeneratedAs%: generated always] as identity[ %OPTIONS%]:[%ExtGeneratedAs%? generated %ExtGeneratedAs%]]</a:TextTargetItem.Value>
<a:Comment>Command for defining a table column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o109">
<a:Name>ColumnComment</a:Name>
<a:TextTargetItem.Value>comment on column [%QUALIFIER%]%TABLE%.%COLUMN% is
%.q254:COMMENT%</a:TextTargetItem.Value>
<a:Comment>Command for adding a column comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o110">
<a:Name>Rename</a:Name>
<a:Comment>Command for renaming a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o111">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add %COLUMN% %DATATYPE%[%ExtSubtypeData%? for %ExtSubtypeData% data][ %NOTNULL%][%ExtFieldProcName%? fieldproc %ExtFieldProcName%:[%WITHDEFAULT%? %WITHDEFAULT%[ %DEFAULT%]:[ default %DEFAULT%]]]
   [%CONSTDEFN%][%IDENTITY%?[%ExtGeneratedAs%? generated %ExtGeneratedAs%: generated always] as identity[ %OPTIONS%]:[%ExtGeneratedAs%? generated %ExtGeneratedAs%]]</a:TextTargetItem.Value>
<a:Comment>Command for adding a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o112">
<a:Name>ModifyColumn</a:Name>
<a:Comment>Command for modifying a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o113">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a column</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o114">
<a:Name>Enable</a:Name>
<a:Comment>Column allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o115">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, DOMAIN, DTTPCODE, LENGTH, PREC, NOTNULL (N=&#39;NOT NULL&#39;, *=NULL), WITHDEFAULT, DEFAULT, IDENTITY, ExtGeneratedAs, @OBJTLABL, NO}

select
   tbcreator,
   tbname,
   name,
   case coltype when &#39;DISTINCT&#39; then typename else &#39;&#39; end,
   case coltype when &#39;DISTINCT&#39; then &#39;&#39; else coltype end,
   case length2 when 0 then length else length2 end,
   scale,
   nulls,
   case(nulls concat default)
      when &#39;NN&#39; then &#39;&#39;
      when &#39;YY&#39; then &#39;&#39;
      when &#39;YN&#39; then &#39;&#39;
      when &#39;NA&#39; then &#39;&#39;
      when &#39;ND&#39; then &#39;&#39;
      when &#39;NI&#39; then &#39;&#39;
      when &#39;NJ&#39; then &#39;&#39;
      else &#39;WITH DEFAULT&#39;
   end,
   case when (default = &#39;1&#39; or default = &#39;5&#39;) then &#39;&#39;&#39;&#39; concat varchar(defaultvalue, 250) concat &#39;&#39;&#39;&#39; else varchar(defaultvalue, 250) end,
   case when (default = &#39;I&#39; or default = &#39;J&#39;) then &#39;identity&#39; else &#39;&#39; end,
   case when (default = &#39;D&#39; or default = &#39;J&#39;) then &#39;by default&#39; when (default = &#39;I&#39; or default = &#39;A&#39;) then &#39;always&#39; else &#39;&#39; end,
   remarks,
   colno
from
   sysibm.syscolumns
where
   colno &gt; 0
   [and tbcreator=%.q:OWNER%]
   [and tbname=%.q:TABLE%]
order by
   1, 2, colno
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o116">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, ExtFieldProcName}

select
   p.tbcreator,
   p.tbname,
   p.name,
   p.fldproc concat
      case(value(p.parmlist, &#39;&#39;)) when &#39;&#39; then &#39;&#39; else &#39;(&#39; concat p.parmlist concat &#39;)&#39; end
from
   sysibm.sysfields p
where
   p.colno &gt; 0
[  and p.tbcreator=%.q:OWNER%]
[  and p.tbname=%.q:TABLE%]
[  and p.name=%.q:COLUMN%]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o117">
<a:Name>EnableIdentity</a:Name>
<a:Comment>Identity keyword entry support. Identity columns are serial counters maintains by the database</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o118">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>&lt;identity_options&gt; : composite=yes, parenthesis=yes, separator=yes
{
start with %d : default=1
increment by %d : default=1
&lt;cache&gt; : composite=yes
{
cache %d : default=20
no cache
}
&lt;cycle&gt; %s : default=no cycle, list=cycle|no cycle
maxvalue %d
minvalue %d
}</a:TextTargetItem.Value>
<a:Comment>Available options for creating a column</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o119">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a column.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>REFERENCES=Refr.
UPDATE=Update</a:MapTargetItem.Value>
<a:List>REFERENCES
UPDATE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o120">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, COLNPERMISSION ID, COLUMN ...}
select 
  s.grantee, 
  case s.privilege 
    when &#39;&#39; then &#39;UPDATE&#39;
    when &#39;R&#39; then &#39;REFERENCES&#39;
    else &#39;&#39;
  end,
  s.colname concat &#39;,&#39;
from SYSIBM.SYSCOLAUTH s
where s.creator &lt;&gt; s.grantee
[and s.tname = %.q:TABLE%]
[and s.creator = %.q:OWNER%]
order by 2</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o121">
<a:Name>SqlChckQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, CONSTNAME, CONSTRAINT}

select  
   d.tbowner,
   d.tbname,
   d.colname,
   d.checkname,
   k.checkcondition
from 
   sysibm.syschecks k,
   sysibm.syscheckdep d
where k.tbowner = d.tbowner and k.tbname  = d.tbname and k.checkname = d.checkname
and 1 = (select count(*) from sysibm.syscheckdep r where d.tbowner = r.tbowner and d.tbname  = r.tbname and d.checkname = r.checkname)
[  and d.tbowner = %.q:OWNER%]
[  and d.tbname = %.q:TABLE%]
[  and d.colname = %.q:COLUMN%]
order by 1, 2, 3   
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o122">
<a:Name>DefineColnChck</a:Name>
<a:TextTargetItem.Value>   [[constraint %CONSTNAME% ]check (%.A:CONSTRAINT%)]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of column check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o123">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, OPTIONS}

select
   d.dcreator,
   d.dname,
   d.dcolname,
   &#39;(&#39;
   concat &#39; start with &#39; concat strip(varchar(s.start), trailing, &#39;.&#39;)
   concat &#39;, increment by &#39; concat strip(varchar(s.increment), trailing, &#39;.&#39;)
   concat case (s.cache) when 0 then &#39;, no cache&#39; else &#39;, cache &#39; concat varchar(s.cache) end
   concat case (s.cycle) when &#39;N&#39; then &#39;, no cycle&#39; when &#39;Y&#39; then &#39;, cycle&#39; else &#39;&#39; end
   concat &#39;, maxvalue &#39; concat strip(varchar(s.maxvalue), trailing, &#39;.&#39;)
   concat &#39;, minvalue &#39; concat strip(varchar(s.minvalue), trailing, &#39;.&#39;)
   concat &#39; )&#39;
from
   sysibm.syssequencesdep d
      join sysibm.syssequences s on (s.sequenceid = d.bsequenceid)
where
   s.seqtype = &#39;I&#39;
[  and d.dcreator = %.q:OWNER%]
[  and d.dname = %.q:TABLE%]
[  and d.dcolname = %.q:COLUMN%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse column physical options</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:BooleanTargetItem Id="o124">
<a:Name>EnableOption</a:Name>
<a:Comment>Physical options allowed  YES/NO</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TargetCategory Id="o125">
<a:Name>Reference</a:Name>
<a:Code>REFR</a:Code>
<a:Comment>The following system variables are available:
   &quot;REFR&quot;         // generated code of the reference
   &quot;REFNAME&quot;      // reference name
   &quot;PARENT&quot;       // generated code of the parent table
   &quot;PNAME&quot;        // name of the parent table
   &quot;PCODE&quot;        // code of the parent table
   &quot;CHILD&quot;        // generated code of the reference
   &quot;CNAME&quot;        // name of the child table
   &quot;CCODE&quot;        // code of the child table
   &quot;PQUALIFIER&quot;   // qualifier of the parent table. See QUALIFIER
   &quot;CQUALIFIER&quot;   // qualifier of the child table. See QUALIFIER
   &quot;REFRNAME&quot;     // Reference name
   &quot;REFRCODE&quot;     // Reference code
   &quot;FKCONSTRAINT&quot; // Reference constraint name (foreign key)
   &quot;PKCONSTRAINT&quot; // constraint name of the parent key used to reference object
   &quot;CKEYCOLUMNS&quot;  // list of parent key columns. Eg: C1, C2, C3
   &quot;FKEYCOLUMNS&quot;  // list of child foreign key columns. Eg:
   &quot;UPDCONST&quot;     // Update declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;DELCONST&quot;     // Delete declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;MINCARD&quot;      // Min cardinality
   &quot;MAXCARD&quot;      // Max cardinality
   &quot;POWNER&quot;       // Parent table owner
   &quot;COWNER&quot;       // child table owner
   &quot;CHCKONCMMT&quot;   // TRUE when check on commit is selected on the reference (ASA 6.0 specific)

For reference joins (couple of column in a reference),
the following system variables are available:
   &quot;CKEYCOLUMN&quot;   // generated code of the parent table column (primary key)
   &quot;FKEYCOLUMN&quot;   // generated code of the child table column (foreign key)
   &quot;PK&quot;           // primary key column generated code
   &quot;PKNAME&quot;       // primary key column name
   &quot;FK&quot;           // foreign key column generated code
   &quot;FKNAME&quot;       // foreign key column name
   &quot;AK&quot;           // alternate key column code (same as PK)
   &quot;AKNAME&quot;       // alternate key column name (same as PKNAME)
   &quot;COLTYPE&quot;      // primary column column datatype
   &quot;DEFAULT&quot;      // foreign key column default value
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o126">
<a:Name>Enable</a:Name>
<a:Comment>Foreign key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o127">
<a:Name>FKAutoIndex</a:Name>
<a:Comment>Foreign key is auto-indexed</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o128">
<a:Name>EnablefKeyName</a:Name>
<a:Comment>Foreign key role allowed in database generation</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o129">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>F_%.6:REFR%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for foreign keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o130">
<a:Name>CheckOnCommit</a:Name>
<a:Comment>Referential integrity test differed after the COMMIT</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o131">
<a:Name>DclDelIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT
CASCADE
SET NULL
NO ACTION</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for delete</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o132">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]foreign key (%FKEYCOLUMNS%)
   references [%PQUALIFIER%]%PARENT%[ (%CKEYCOLUMNS%)]
   [%DELCONST%?on delete %DELCONST%:on delete no action]</a:TextTargetItem.Value>
<a:Comment>Command for defining a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o133">
<a:Name>DclUpdIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for update</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o134">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   [add ][constraint %CONSTNAME% ]foreign key [%R%?[%CONSTNAME% ]](%FKEYCOLUMNS%)
      references [%PQUALIFIER%]%PARENT%[ (%CKEYCOLUMNS%)]
      [%DELCONST%?on delete %DELCONST%:on delete no action]</a:TextTargetItem.Value>
<a:Comment>Command for adding a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o135">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{COWNER ID, CHILD ID, FKCONSTRAINT ID, POWNER ID, PARENT ID, PKCONSTRAINT ID, DELCONST ID, CKEYCOLUMNS ... , FKEYCOLUMNS ...}

select
   r.creator,
   r.tbname,
   r.relname,
   r.reftbcreator,
   r.reftbname,
   r.ixname,
   case r.deleterule when &#39;A&#39; then &#39;&lt;None&gt;&#39; when &#39;C&#39; then &#39;CASCADE&#39; when &#39;R&#39; then &#39;RESTRICT&#39; when &#39;N&#39; then &#39;SET NULL&#39; else &#39;&#39; end,
   case(r.ixname) when &#39;&#39; then c.name else k.colname end concat &#39;,&#39;,
   f.colname concat &#39;,&#39;,
   f.colseq
from
   sysibm.sysrels r
      join sysibm.sysforeignkeys f on (f.creator = r.creator and f.tbname = r.tbname and f.relname = r.relname)
      left outer join sysibm.syskeys k on (r.ixname &lt;&gt; &#39;&#39; and k.ixname = r.ixname and k.ixcreator = r.ixowner and k.colseq = f.colseq)
      left outer join sysibm.syscolumns c on (r.ixname = &#39;&#39; and c.tbname = r.reftbname and c.tbcreator = r.reftbcreator and c.keyseq = f.colseq)
where 1 = 1
[  and r.creator = %.q:OWNER%]
[  and r.tbname = %.q:TABLE%]
order by 1, 2, 3, 10
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o136">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop foreign key %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a foreign key</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o137">
<a:Name>MaxConstLen</a:Name>
<a:Comment>Maximum reference constraint name length</a:Comment>
<a:IntegerTargetItem.Value>8</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o138">
<a:Name>PKey</a:Name>
<a:Code>PKEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o139">
<a:Name>Enable</a:Name>
<a:Comment>Primary key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o140">
<a:Name>PkAutoIndex</a:Name>
<a:Comment>Primary key is auto-indexed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o141">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>P_%.16:PKEY%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for primary keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o142">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]primary key (%PKEYCOLUMNS%)</a:TextTargetItem.Value>
<a:Comment>Command for defining a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o143">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop primary key</a:TextTargetItem.Value>
<a:Comment>Command for dropping a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o144">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   [add ][constraint %CONSTNAME% ]primary key (%PKEYCOLUMNS%)</a:TextTargetItem.Value>
<a:Comment>Command for adding a primary key</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o145">
<a:Name>Key</a:Name>
<a:Code>KEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;COLUMNS&quot;      // List of columns of the key. Eg: &quot;A, B, C&quot;
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o146">
<a:Name>Enable</a:Name>
<a:Comment>UNIQUE constraint allowed for tables</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o147">
<a:Name>UniqConstAutoIndex</a:Name>
<a:Comment>UNIQUE constraint is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o148">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>A_%.16:AKEY%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for alternate keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o149">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]unique (%COLUMNS%)</a:TextTargetItem.Value>
<a:Comment>Command for defining an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o150">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   [add ][constraint %CONSTNAME% ]unique (%COLNLIST%)</a:TextTargetItem.Value>
<a:Comment>Command for adding an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o151">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop unique (%COLNLIST%)</a:TextTargetItem.Value>
<a:Comment>Command for dropping an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o152">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, CONSTNAME ID, ISPKEY ID, COLUMNS ...}

select
   k.tbcreator,
   k.tbname,
   k.constname,
   case k.type when &#39;P&#39; then &#39;TRUE&#39; else &#39;FALSE&#39; end,
   c.colname concat &#39;,&#39;
from
   sysibm.systabconst k,
   sysibm.syskeycoluse c
where 1=1
   and c.tbname = k.tbname
   and c.tbcreator = k.tbcreator
   and c.constname = k.constname
[  and k.tbname=%.q:TABLE%]
[  and k.tbcreator=%.q:OWNER%]
order by
   1, 2, 3, 4, c.colseq</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:IntegerTargetItem Id="o153">
<a:Name>MaxConstLen</a:Name>
<a:Comment>Maximum constraint name length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TargetCategory Id="o154">
<a:Name>Domain</a:Name>
<a:Code>PDMDOMN</a:Code>
<a:Comment>The following system variables are available:
   &quot;DOMAIN&quot;       // generated code of the domain (also available for columns)
SQL Server specific domain system variables:
   &quot;RULENAME&quot;     // name of the rule object associated with the domain
   &quot;DEFAULTNAME&quot;  // name of the default object associated with the domain
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o155">
<a:Name>Enable</a:Name>
<a:Comment>User defined data types allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o156">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create distinct type %DOMAIN% as %DATATYPE%[%ExtSubtypeData%? for %ExtSubtypeData% data] with comparisons
</a:TextTargetItem.Value>
<a:Comment>Command for creating a user defined data type</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o157">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop distinct type %DOMAIN%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a user defined data type</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o158">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o159">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, DOMAIN, DTTPCODE, LENGTH, PREC}

select
   owner,
   name,
   sourcetype,
   length,
   scale
from
   sysibm.sysdatatypes
where
   metatype=&#39;T&#39;
   [and owner=%.q:SCHEMA%]
order by
   owner,
   name</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o160">
<a:Name>EnableCheck</a:Name>
<a:Comment>Allows the creation of checks on the domain</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o161">
<a:Name>EnableDefault</a:Name>
<a:Comment>Allows default value creation on domain</a:Comment>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o162">
<a:Name>Database</a:Name>
<a:Code>DTBS</a:Code>
<a:Comment>The following system variables are available:
   &quot;DATABASE&quot;     // generated code of the database
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o163">
<a:Name>BeforeCreateDatabase</a:Name>
<a:Comment>Creates tablespaces and storages before database</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o164">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create database %DATABASE%
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a database. Example: create database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o165">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>bufferpool %s : default=bp0
indexbp %s : default=bp0
roshare %s : list=owner|read, default=owner
as %s : list=workfile|temp, default=workfile, composite=yes
{
for %s
}
stogroup %s : category=storage, default=sysdflt
ccsid %s : list=ascii|ebcdic|unicode, default=ascii</a:TextTargetItem.Value>
<a:Comment>Available options for creating a database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o166">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop database %DATABASE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a database. Example: drop database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o167">
<a:Name>Enable</a:Name>
<a:Comment>Database allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o168">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{DATABASE}

select name from sysibm.sysdatabase</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o169">
<a:Name>EnableManyDatabases</a:Name>
<a:Comment>Many databases allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o170">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{DATABASE, OPTIONS}           
                              
select
   d.name,
   case (d.bpool) when &#39;&#39; then &#39;&#39; else &#39;bufferpool &#39; concat d.bpool end
   concat case (d.indexbp) when &#39;&#39; then &#39;&#39; else &#39; indexbp &#39; concat d.indexbp end
   concat case(d.roshare) when &#39;O&#39; then &#39; roshare owner &#39; when &#39;R&#39; then &#39; roshare read &#39; else &#39;&#39; end
   concat case(d.type) when &#39;W&#39; then &#39; as workfile &#39; when &#39;T&#39; then &#39; as temp &#39; else &#39;&#39; end
   concat case(ltrim(d.group_member)) when &#39;&#39; then &#39;&#39; else &#39; for &#39; concat d.group_member end 
   concat case(d.stgroup) when &#39;&#39; then &#39;&#39; else &#39; stogroup &#39; concat d.stgroup end
   concat case(d.encoding_scheme) when &#39;A&#39; then &#39; ccsid ascii&#39; when &#39;E&#39; then &#39; ccsid ebcdic&#39; when &#39;U&#39; then &#39; ccsid unicode&#39; else &#39;&#39; end
from 
   sysibm.sysdatabase d
where 1=1
[  and d.name = %.q:DATABASE%]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o171">
<a:Name>Synonym</a:Name>
<a:Code>SYNM</a:Code>
<a:Comment>Manages the synonym object.</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o172">
<a:Name>Enable</a:Name>
<a:Comment>Synonym allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o173">
<a:Name>EnableAlias</a:Name>
<a:Comment>Enable synonym of alias type.</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o174">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create %SYNMTYPE% [%QUALIFIER%]%SYNONYM% for [%BASEQUALIFIER%]%BASEOBJECT%</a:TextTargetItem.Value>
<a:Comment>Command for creating a synonym.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o175">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop %SYNMTYPE% [%QUALIFIER%]%SYNONYM%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a synonym.</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o176">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o177">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, SYNONYM, BASEOWNER, BASEOBJECT, SYNMTYPE }

select 
   s.creator,
   s.name,
   s.tbcreator,
   s.tbname,
   &#39;SYNONYM&#39;
from
   sysibm.syssynonyms s
union select
   t.creator,
   t.name,
   t.tbcreator,
   t.tbname,
   &#39;ALIAS&#39;
from
   sysibm.systables t
where 
   t.type = &#39;A&#39;
order by 1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o178">
<a:Name>Tablespace</a:Name>
<a:Code>TSPC</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLESPACE&quot;   // generated code of the tablespace
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o179">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [%ExtTablespaceType% ]tablespace %TABLESPACE%
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a tablespace. Example: create tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o180">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop tablespace [%TbspDatabase%.]%TABLESPACE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a tablespace. Example: drop tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o181">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>in %s : category=database, default=dsndb04
&lt;usingblock&gt; : composite=yes
{
using vcat %s
using stogroup %s : category=storage, composite=yes
{
priqty %d : default=12
secqty %d
erase %s : default=no, list=yes|no
}
}
freepage %d : default=0
pctfree %d : default=5
gbpcache %s : list=all|changed|system|none, default=changed
trackmod %s : list=yes|no, default=yes
log %s : list=yes|no, default=yes
define %s : list=yes|no, default=yes
dssize %d
numparts %d : composite=yes, separator=yes, parenthesis=yes
{
part %d : composite=yes, multiple=yes
{
&lt;usingblock&gt; : composite=yes
{
using vcat %s
using stogroup %s : category=storage, composite=yes
{
priqty %d : default=12
secqty %d
erase %s : default=no, list=yes|no
}
}
freepage %d : default=0
pctfree %d : default=5
gbpcache %s : list=all|changed|system|none, default=changed
trackmod %s : list=yes|no, default=yes
compress %s : list=yes |no, default=yes
}
}
member cluster
segsize %d
bufferpool %s : default=bp0
locksize %s : default=any, list=any|page|tablespace|table|row|lob
lockmax %s : default=system
close %s : default=yes, list=yes|no
compress %s : list=yes |no, default=yes
ccsid %s : list=ascii|ebcdic|unicode, default=ascii
lockpart %s : list=yes|no, default=no
maxrows %d</a:TextTargetItem.Value>
<a:Comment>Default options for creating a tablespace.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o182">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for tablespace options.</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o183">
<a:Name>Enable</a:Name>
<a:Comment>Tablespace allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o184">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{DATABASE, TABLESPACE, ExtTablespaceType}

select
   dbname,
   name,
   case(type) when &#39;K&#39; then &#39;large&#39; when &#39;L&#39; then &#39;large&#39; when &#39;O&#39; then &#39;lob&#39; else &#39;&#39; end
from
     sysibm.systablespace 
where
   implicit=&#39;N&#39;
   [and dbname=%.q:CATALOG%]
order by
   name</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o185">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{DATABASE, TABLESPACE, OPTIONS EX}

select
   t.dbname,
   t.name,
   case(t.dbname) when &#39;DSNDB04&#39; then &#39;&#39; else &#39; in &#39; concat t.dbname end
   concat case(t.eraserule) when &#39;Y&#39; then &#39; erase yes&#39; else &#39;&#39; end
   concat case(t.log) when &#39;N&#39; then &#39; log no&#39; else &#39;&#39; end
   concat case (t.partitions)
      when 0 then &#39; %SqlTspSinglePartDef.&#39; concat rtrim(t.dbname) concat rtrim(t.name) concat &#39;0%&#39;
      else &#39; numparts &#39; concat varchar(t.partitions) concat &#39; (%SqlTspMultiPartDef.&#39; concat rtrim(t.dbname) concat rtrim(t.name) concat &#39;%)&#39;
   end
   concat case(t.type) when &#39;I&#39; then &#39; member cluster&#39; when &#39;K&#39; then &#39; member cluster&#39; else &#39;&#39;end
   concat case(t.segsize) when 0 then &#39;&#39; else &#39; segsize &#39; concat varchar(t.segsize) end
   concat &#39; bufferpool &#39; concat t.bpool
   concat case(t.lockrule) when &#39;S&#39; then &#39; locksize tablespace&#39; when &#39;T&#39; then &#39; locksize table&#39; when &#39;P&#39; then &#39; locksize page&#39; when &#39;R&#39; then &#39; locksize row&#39; when &#39;L&#39; then &#39; locksize lob&#39; else &#39;&#39; end
   concat case(t.lockmax) when -1 then &#39; lockmax system&#39; when 0 then &#39;&#39; else &#39; lockmax &#39; concat varchar(t.lockmax) end
   concat case(t.closerule) when &#39;N&#39; then &#39; close no&#39; else &#39;&#39; end
   concat case(t.encoding_scheme) when &#39;A&#39; then &#39; ccsid ascii&#39; when &#39;E&#39; then &#39; ccsid ebcdic&#39; when &#39;U&#39; then &#39; ccsid unicode&#39; else &#39;&#39; end
   concat case(t.lockpart) when &#39;Y&#39; then &#39; lockpart yes&#39; else &#39;&#39; end
   concat case(t.maxrows) when 255 then &#39;&#39; else &#39; maxrows &#39; concat varchar(t.maxrows) end
from
   sysibm.systablespace t
where
   t.implicit=&#39;N&#39;
[  and t.name=%.q:TABLESPACE%]
[  and t.dbname=%.q:CATALOG%]
order by
   2, 1</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o186">
<a:Name>SqlTspMultiPartDef</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL EX ...}

select
   rtrim(p.dbname) concat rtrim(p.tsname),
   case when (p.partition &gt; 1) then &#39;, &#39; else &#39;&#39; end
   concat &#39;part &#39; concat varchar(p.partition)
   concat &#39; %SqlTspSinglePartDef.&#39; concat rtrim(p.dbname) concat rtrim(p.tsname) concat varchar(p.partition) concat &#39;%&#39;
from
   sysibm.systablepart p
where 1 = 1
[  and p.dbname=%.q:CATALOG%]
[  and p.tsname=%.q:TABLESPACE%]
</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o187">
<a:Name>SqlTspSinglePartDef</a:Name>
<a:TextTargetItem.Value>{VAR, VAL}

select
   rtrim(p.dbname) concat rtrim(p.tsname) concat varchar(p.partition),
   case(p.stortype) when &#39;E&#39; then &#39; using vcat &#39; concat p.vcatname when &#39;I&#39; then &#39; using stogroup &#39; concat p.storname else &#39;&#39; end
   concat case(p.pqty) when 0 then &#39;&#39; else &#39; priqty &#39; concat varchar(p.pqty) end
   concat case(p.sqty) when 0 then &#39;&#39; else &#39; secqty &#39; concat varchar(p.sqty) end
   concat case(p.freepage) when 0 then &#39;&#39; else &#39; freepage &#39; concat varchar(p.freepage) end
   concat case(p.pctfree) when 5 then &#39;&#39; else &#39; pctfree &#39; concat varchar(p.pctfree) end
   concat case(p.gbpcache) when &#39;A&#39; then &#39; gbpcache all&#39; when &#39;N&#39; then &#39; gbpcache none&#39; when &#39;S&#39; then &#39; gbpcache system&#39; else &#39;&#39; end
   concat case(p.trackmod) when &#39;N&#39; then &#39; trackmod no&#39; else &#39;&#39; end
   concat case(p.compress) when &#39;Y&#39; then &#39; compress yes&#39; else &#39;&#39; end
from
   sysibm.systablepart p
where 1 = 1
[  and p.dbname=%.q:CATALOG%]
[  and p.tsname=%.q:TABLESPACE%]</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o188">
<a:Name>Storage</a:Name>
<a:Code>STOR</a:Code>
<a:Comment>The following system variables are available:
   &quot;STORAGE&quot;      // generated code of the storage
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o189">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create stogroup %STORAGE%
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a storage. Example: create storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o190">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop stogroup %STORAGE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a storage. Example: drop storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o191">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>volumes : composite=yes, separator=yes, parenthesis=yes
{
&lt;volume_id&gt; %d : multiple=yes, default=&#39;*&#39;
}
vcat %s</a:TextTargetItem.Value>
<a:Comment>Default options for creating a storage</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o192">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for storage options</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o193">
<a:Name>Enable</a:Name>
<a:Comment>Storage allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o194">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{STORAGE, OPTIONS}

select 
   name,
   &#39;vcat &#39; concat vcatname
from
   sysibm.sysstogroup
order by
   name</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o195">
<a:Name>View</a:Name>
<a:Code>VIEW</a:Code>
<a:Comment>The following system variables are available:
   &quot;VIEW&quot;         // generated code of the view
   &quot;VIEWNAME&quot;     // view name
   &quot;VIEWCODE&quot;     // view code
   &quot;VIEWCOLN&quot;     // List of columns of the view. Eg: &quot;A, B, C&quot;
   &quot;SQL&quot;          // SQL text of the view. Eg: Select * from T1
   &quot;VIEWCHECK&quot;    // Keyword &quot;with check option&quot; if selected on the view
   &quot;SCRIPT&quot;       // complete view creation order. Eg: create view V1 as select * from T1
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o196">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%ISVIEW%?create view [%QUALIFIER%]%VIEW% [(%VIEWCOLN%) ]as
%SQL%
[%VIEWCHECK%]
:create[%R%? summary] table [%QUALIFIER%]%VIEW% [(%VIEWCOLN%) ]as
( %SQL% )[ %OPTIONS%]
]
</a:TextTargetItem.Value>
<a:Comment>Command for creating a view. Example: create view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o197">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>[%ISVIEW%?drop view [%QUALIFIER%]%VIEW%:drop table [%QUALIFIER%]%VIEW%]
</a:TextTargetItem.Value>
<a:Comment>Command for dropping a view. Example: drop view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o198">
<a:Name>ViewComment</a:Name>
<a:TextTargetItem.Value>comment on table [%QUALIFIER%]%VIEW% is
%.q254:COMMENT%</a:TextTargetItem.Value>
<a:Comment>Command for adding a view comment.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o199">
<a:Name>EnableIndex</a:Name>
<a:TextTargetItem.Value>MATERIALIZED</a:TextTargetItem.Value>
<a:Comment>List of types for which view index is available.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o200">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with no data : composite=yes
{
&lt;identity&gt; %s : list=excluding identity|including identity|excluding identity column attributes|including identity column attributes
&lt;Column_Default&gt; %s : list=including column defaults|excluding column defaults|including defaults|excluding defaults|using type defaults
}
data initially deferred refresh deferred : composite=yes
{
maintained by %s : list=system|user
&lt;Query_Optimization&gt; %s : list=enable query optimization|disable query optimization
}
&lt;Table_options&gt; : composite=yes
{
in %s : category=tablespace, enabledbprefix=yes
in database %s : category=database, default=dsndb04
editproc %s
validproc %s
audit %s : list=none|changes|all, default=none
obid %d
data capture %s : list=none|changes, default=none
with restrict on drop
ccsid %s : list=ascii|ebcdic|unicode, default=ascii
}</a:TextTargetItem.Value>
<a:Comment>Available options for creating a snapshot (or materialized view)</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o201">
<a:Name>ViewCheck</a:Name>
<a:TextTargetItem.Value>with [cascaded ][local ]check option</a:TextTargetItem.Value>
<a:Comment>Option for checking a view</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o202">
<a:Name>Enable</a:Name>
<a:Comment>View allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o203">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, VIEW, COMMENT}

select 
   v.creator,
   v.name,
   t.remarks
from 
   sysibm.sysviews v
   left join sysibm.systables t on (t.name = v.name and t.creator = v.creator)
where 
   v.seqno=1
[  and v.creator=%.q:SCHEMA%]
order by
   v.creator,
   v.name</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o204">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, VIEW ID, SCRIPT ...}

select 
   creator,
   name,
   text,
   seqno
from sysibm.sysviews
   where 1=1
   [and name=%.q:VIEW%]
   [and creator=%.q:OWNER%]
order by
   creator,
   name,
   seqno</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o205">
<a:Name>TypeList</a:Name>
<a:Comment>Defines list of available type
Name is the displayed value
Value is the stored value in the object</a:Comment>
<a:MapTargetItem.Value>View=
Materialized query table=MATERIALIZED</a:MapTargetItem.Value>
<a:List>View
Materialized query table
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o206">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{ GRANTEE ID, PERMISSION ...}

select 
s.grantee grantee, 
case s.alterauth when &#39;Y&#39; then &#39;ALTER&#39; else &#39;&#39; end concat &#39;,&#39; concat 
case s.alterauth when &#39;G&#39; then &#39;ALTER+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.deleteauth when &#39;Y&#39; then &#39;DELETE&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.deleteauth when &#39;G&#39; then &#39;DELETE+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.indexauth when &#39;Y&#39; then &#39;INDEX&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.indexauth when &#39;G&#39; then &#39;INDEX+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.insertauth when &#39;Y&#39; then &#39;INSERT&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.insertauth when &#39;G&#39; then &#39;INSERT+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.selectauth when &#39;Y&#39; then &#39;SELECT&#39; else &#39;&#39; end concat &#39;,&#39; concat 
case s.selectauth when &#39;G&#39; then &#39;SELECT+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.referencesauth when &#39;Y&#39; then &#39;REFERENCES&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.referencesauth when &#39;G&#39; then &#39;REFERENCES+&#39; else &#39;&#39; end  concat &#39;,&#39; concat 
case s.updateauth when &#39;Y&#39; then &#39;UPDATE&#39; else &#39;&#39; end concat &#39;,&#39; concat 
case s.updateauth when &#39;G&#39; then &#39;UPDATE+&#39; else &#39;&#39; end concat &#39;,&#39; concat 
case s.triggerauth when &#39;Y&#39; then &#39;TRIGGER&#39; else &#39;&#39; end concat &#39;,&#39; concat 
case s.triggerauth when &#39;G&#39; then &#39;TRIGGER+&#39; else &#39;&#39; end
from sysibm.systabauth s
where s.tcreator &lt;&gt; s.grantee
[and s.ttname = %.q:VIEW%]
[and s.tcreator = %.q:OWNER%]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o207">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a view.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>ALTER=Alter
DELETE=Delete
INDEX=Index
INSERT=Insert
SELECT=Select
REFERENCES=Refr.
TRIGGER=Trigger
UPDATE=Update</a:MapTargetItem.Value>
<a:List>ALTER
DELETE
INDEX
INSERT
SELECT
REFERENCES
TRIGGER
UPDATE
</a:List>
</o:MapTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o208">
<a:Name>Trigger</a:Name>
<a:Code>TRGR</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
 trigger object specific items
   &quot;ORDER&quot;        // order number of the trigger (to sort the triggers when the DBMS supports more than one trigger of one type)
   &quot;TRIGGER&quot;      // generated code of trigger
   &quot;TRGTYPE&quot;      // trigger type (keywords &quot;beforeinsert&quot;, &quot;afterupdate&quot;, ...)
   &quot;TRGEVENT&quot;     // trigger event (keywords &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;)
   &quot;TRGTIME&quot;      // trigger time (keywords NULL, &quot;before&quot;, &quot;after&quot;)
 inside the body of the trigger, macros redefine variables on objects
   &quot;REFNO&quot;        // reference position in the list of references of the table
 customized error messages management
   &quot;ERRNO&quot;        // error number for standard error
   &quot;ERRMSG&quot;       // error message for standard error
   &quot;MSGTAB&quot;       // name of the table containing user-defined error messages
   &quot;MSGNO&quot;        // in the user-defined error table, name of the column containing the error numbers
   &quot;MSGTXT&quot;       // in the user-defined error table, name of the column containing the error messages
   &quot;SCRIPT&quot;       // body of trigger or procedure
   &quot;TRGDEFN&quot;      // complete body of the trigger definition. Contains variable declarations and body of trigger or procedure
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o209">
<a:Name>Enable</a:Name>
<a:Comment>Trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o210">
<a:Name>EnableMultiTrigger</a:Name>
<a:Comment>Multi trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o211">
<a:Name>DefaultTriggerName</a:Name>
<a:TextTargetItem.Value>%TEMPLATE%_%.L:TABLE%</a:TextTargetItem.Value>
<a:Comment>Default trigger name</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o212">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>8</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o213">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop trigger [%QUALIFIER%]%TRIGGER% restrict</a:TextTargetItem.Value>
<a:Comment>Command for dropping a trigger. Example: drop trigger %TRIGGER%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o214">
<a:Name>UseErrorMsgTable</a:Name>
<a:TextTargetItem.Value>begin atomic
   signal sqlstate &#39;%ERRNO%&#39; (&#39;%ERRMSG%&#39;);
end</a:TextTargetItem.Value>
<a:Comment>Errors handling using an error messages table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o215">
<a:Name>UseErrorMsgText</a:Name>
<a:TextTargetItem.Value>begin atomic
   signal sqlstate &#39;%ERRNO%&#39; (&#39;%ERRMSG%&#39;);
end</a:TextTargetItem.Value>
<a:Comment>Errors handling using fixed error messages</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o216">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create trigger [%QUALIFIER%]%TRIGGER%[%TRGTIME%=before? no cascade][ %TRGTIME%][ %TRGEVENT%[ of %COLUMNS%]] on [%TABLQUALIFIER%]%TABLE%
%TRGDEFN%
</a:TextTargetItem.Value>
<a:Comment>Command for creating a trigger. Example: create trigger on [%QUALIFIER%]%TABLE% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o217">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER, TABLE, OWNER, TRIGGER, TRGTIME (A=After, *=Before), TRGEVENT (U=Update, D=Delete, *=Insert)}

select
   tbowner,
   tbname,
   owner,
   name,
   trigtime,
   trigevent
from 
   sysibm.systriggers
[where schema=%.q:SCHEMA%]
order by 
   1, 2, 3
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o218">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER, TABLE, OWNER, TRIGGER, SCRIPT}

select
   tbowner,
   tbname,
   owner,
   name,
   text
from 
   sysibm.systriggers
where 1=1
[  and schema=%.q:OWNER%]
[  and tbname=%.q:TABLE%]
[  and name=%.q:TRIGGER%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o219">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o220">
<a:Name>Procedure</a:Name>
<a:Code>PROC</a:Code>
<a:Comment>The following system variables are available:
   &quot;PROC&quot;         // generated code of the procedure (also available for trigger when the trigger is implemented with a procedure)
   &quot;FUNC&quot;         // generated code of the procedure if the procedure is a function (with return value)
   &quot;PROCPRMS&quot;     // list of parameters of the procedure (also available for function)
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o221">
<a:Name>Enable</a:Name>
<a:Comment>Procedure allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o222">
<a:Name>EnableFunc</a:Name>
<a:Comment>Function allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o223">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o224">
<a:Name>MaxFuncLen</a:Name>
<a:Comment>Function name length</a:Comment>
<a:IntegerTargetItem.Value>18</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o225">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop procedure [%QUALIFIER%]%PROC% restrict</a:TextTargetItem.Value>
<a:Comment>Command for dropping a procedure. Example: drop procedure %PROC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o226">
<a:Name>DropFunc</a:Name>
<a:TextTargetItem.Value>drop function [%QUALIFIER%]%FUNC% restrict</a:TextTargetItem.Value>
<a:Comment>Command for dropping a function. Example: drop function %FUNC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o227">
<a:Name>CustomProc</a:Name>
<a:TextTargetItem.Value>create procedure [%QUALIFIER%]%PROC% (&lt;type&gt;) 
RESULT SET 0
EXTERNAL NAME %.q:PROC%
LANGUAGE C
PARAMETER STYLE DB2SQL
DETERMINISTIC
NO SQL
</a:TextTargetItem.Value>
<a:Comment>Command for creating a stored procedure</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o228">
<a:Name>CustomFunc</a:Name>
<a:TextTargetItem.Value>create function [%QUALIFIER%]%FUNC% (&lt;type&gt;) 
RETURNS &lt;type&gt;
EXTERNAL NAME %.q:FUNC%
LANGUAGE C
PARAMETER STYLE DB2SQL
DETERMINISTIC
NO SQL
NO EXTERNAL ACTION</a:TextTargetItem.Value>
<a:Comment>Command for creating a function</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o229">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create procedure [%QUALIFIER%]%PROC%[%PROCPRMS%?([%PROCPRMS%])]
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a procedure. Example: create procedure %PROC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o230">
<a:Name>CreateFunc</a:Name>
<a:TextTargetItem.Value>create function [%QUALIFIER%]%FUNC%[%PROCPRMS%?([%PROCPRMS%])]
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a function. Example: create function %FUNC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o231">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o232">
<a:Name>Privilege</a:Name>
<a:Comment>Manages the system privileges for a user, role or group</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o233">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>grant %PRIVLIST% to %USER% [%GRANTOPTION%]</a:TextTargetItem.Value>
<a:Comment>Command for granting privileges.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o234">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>revoke %REVPRIVLIST% from %USER%</a:TextTargetItem.Value>
<a:Comment>Command for revoking privileges.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o235">
<a:Name>System</a:Name>
<a:TextTargetItem.Value>ARCHIVE
BINDADD
BINDAGENT
BSDS
CREATEALIAS
CREATEDBA
CREATEDBC
CREATESG
CREATETMTAB
DISPLAY
MONITOR1
MONITOR2
RECOVER
STOPALL
STOSPACE
SYSADM
SYSCTRL
SYSOPR
TRACE</a:TextTargetItem.Value>
<a:Comment>List of system privileges</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o236">
<a:Name>GrantOption</a:Name>
<a:TextTargetItem.Value>with grant option</a:TextTargetItem.Value>
<a:Comment>Option for the grant statement.</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o237">
<a:Name>Enable</a:Name>
<a:Comment>Privilege allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o238">
<a:Name>Permission</a:Name>
<a:Code>PERM</a:Code>
<a:Comment>Manages the permissions on database objects</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o239">
<a:Name>Enable</a:Name>
<a:Comment>Permission allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o240">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>grant %PERMLIST% on [%QUALIFIER%]%OBJECT% to %GRANTEE% [%GRANTOPTION%]</a:TextTargetItem.Value>
<a:Comment>Command for granting permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o241">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>revoke %REVPERMLIST% on [%QUALIFIER%]%OBJECT% from %GRANTEE%</a:TextTargetItem.Value>
<a:Comment>Command for revoking permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o242">
<a:Name>GrantOption</a:Name>
<a:TextTargetItem.Value>with grant option</a:TextTargetItem.Value>
<a:Comment>Option for the grant statement.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o243">
<a:Name>DataType</a:Name>
<a:Comment>Contains data type translation entries. These entries list the correspondence between internal data types and the target database data types</a:Comment>
<c:Categories>
<o:MapTargetItem Id="o244">
<a:Name>AmcdDataType</a:Name>
<a:Comment>Data types translation table from internal data types to target database data types.
        %n is the length of the data type
        %s is the size of the data type
        %p is the precision of the data type</a:Comment>
<a:MapTargetItem.Value>&lt;UNDEF&gt;=&lt;Undefined&gt;
A%n=CHAR(%n)
VA%n=VARCHAR(%n)
LA=VARCHAR
LA%n=VARCHAR(%n)
LVA=VARCHAR
LVA%n=VARCHAR(%n)
BT=SMALLINT
BT%n=NUMERIC(3, 0)
SI=SMALLINT
I=INTEGER
LI=INTEGER
N=DEC
N%n=DEC(%n)
N%s,%p=DEC(%s, %p)
DC=DEC
DC%n=DEC(%n)
DC%s,%p=DEC(%s, %p)
SF=REAL
F=FLOAT
F%n=FLOAT(%n)
LF=DOUBLE PRECISION
MN=DEC(8, 2)
MN%n=DEC(%n)
MN%s,%p=DEC(%s, %p)
D=DATE
T=TIME
DT=DATE
TS=TIMESTAMP
BL=SMALLINT
NO=DEC(6)
NO%n=DEC(%n)
BIN%n=BLOB(%n)
LBIN=BLOB
LBIN%n=BLOB(%n)
TXT=CLOB
TXT%n=CLOB(%n)
MBT=CHAR
MBT%n=CHAR(%n)
VMBT=VARCHAR(255)
VMBT%n=VARCHAR(%n)
PIC=GRAPHIC
PIC%n=GRAPHIC(%n)
BMP=DBCLOB
BMP%n=DBCLOB(%n)
OLE=BLOB
OLE%n=BLOB(%n)
*=CHAR(10)
XMLCLOB=DB2XML.XMLCLOB
XMLVARCHAR=DB2XML.XMLVARCHAR
XMLFILE=DB2XML.XMLFILE</a:MapTargetItem.Value>
<a:List>&lt;UNDEF&gt;
A%n
VA%n
LA
LA%n
LVA
LVA%n
BT
BT%n
SI
I
LI
N
N%n
N%s,%p
DC
DC%n
DC%s,%p
SF
F
F%n
LF
MN
MN%n
MN%s,%p
D
T
DT
TS
BL
NO
NO%n
BIN%n
LBIN
LBIN%n
TXT
TXT%n
MBT
MBT%n
VMBT
VMBT%n
PIC
PIC%n
BMP
BMP%n
OLE
OLE%n
XMLCLOB
XMLVARCHAR
XMLFILE
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o245">
<a:Name>PhysDataType</a:Name>
<a:Comment>Data types translation table from target database data types to internal data types.</a:Comment>
<a:MapTargetItem.Value>&lt;Undefined&gt;=&lt;UNDEF&gt;
INTEGER=I
INT=I
SMALLINT=SI
NUMERIC=N
NUMERIC(%n)=N%n
NUMERIC(%s, %p)=N%s,%p
DECIMAL=DC
DECIMAL(%n)=DC%n
DECIMAL(%s, %p)=DC%s,%p
DEC=DC
DEC(%n)=DC%n
DEC(%s, %p)=DC%s,%p
FLOAT=F
FLOAT(%n)=F%n
REAL=SF
DOUBLE=LF
DOUBLE PRECISION=LF
ROWID=NO
CHARACTER=A1
CHAR=A1
CHARACTER(%n)=A%n
CHAR(%n)=A%n
CHARACTER VARYING(%n)=VA%n
CHAR VARYING(%n)=VA%n
VARCHAR(%n)=VA%n
LONG VARCHAR=LVA
CHARACTER LARGE OBJECT=TXT
CHAR LARGE OBJECT=TXT
CLOB=TXT
CHARACTER LARGE OBJECT(%n)=TXT%n
CHAR LARGE OBJECT(%n)=TXT%n
CLOB(%n)=TXT%n
DATE=D
TIME=T
TIMESTAMP=TS
GRAPHIC=BIN1
GRAPHIC(%n)=BIN%n
VARGRAPHIC(%n)=BIN%n
BINARY LARGE OBJECT=LBIN
BLOB=LBIN
LONG VARGRAPHIC=LBIN
BINARY LARGE OBJECT(%n)=LBIN%n
BLOB(%n)=LBIN%n
DBCLOB=BMP
DBCLOB(%n)=BMP%n
*=A10
DB2XML.XMLCLOB=XMLCLOB
DB2XML.XMLVARCHAR=XMLVARCHAR
DB2XML.XMLFILE=XMLFILE</a:MapTargetItem.Value>
<a:List>&lt;Undefined&gt;
INTEGER
INT
SMALLINT
NUMERIC
NUMERIC(%n)
NUMERIC(%s, %p)
DECIMAL
DECIMAL(%n)
DECIMAL(%s, %p)
DEC
DEC(%n)
DEC(%s, %p)
FLOAT
FLOAT(%n)
REAL
DOUBLE
DOUBLE PRECISION
ROWID
CHARACTER
CHAR
CHARACTER(%n)
CHAR(%n)
CHARACTER VARYING(%n)
CHAR VARYING(%n)
VARCHAR(%n)
LONG VARCHAR
CHARACTER LARGE OBJECT
CHAR LARGE OBJECT
CLOB
CHARACTER LARGE OBJECT(%n)
CHAR LARGE OBJECT(%n)
CLOB(%n)
DATE
TIME
TIMESTAMP
GRAPHIC
GRAPHIC(%n)
VARGRAPHIC(%n)
BINARY LARGE OBJECT
BLOB
LONG VARGRAPHIC
BINARY LARGE OBJECT(%n)
BLOB(%n)
DBCLOB
DBCLOB(%n)
DB2XML.XMLCLOB
DB2XML.XMLVARCHAR
DB2XML.XMLFILE
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o246">
<a:Name>PhysDttpSize</a:Name>
<a:Comment>Table of storage sizes of target database data type</a:Comment>
<a:MapTargetItem.Value>TIME=3
TIMESTAMP=10
INTEGER=4
SMALLINT=2
CLOB=6
BLOB=6
DBCLOB=6
DATE=4
ROWID=19</a:MapTargetItem.Value>
<a:List>TIME
TIMESTAMP
INTEGER
SMALLINT
CLOB
BLOB
DBCLOB
DATE
ROWID
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o247">
<a:Name>OdbcPhysDataType</a:Name>
<a:Comment>Data types translation table from ODBC data types to target database data types.</a:Comment>
<a:MapTargetItem.Value>TIMESTMP(10)=TIMESTAMP
DECIMAL(5)=DECIMAL
FLOAT(8)=FLOAT
FLOAT(4)=REAL
VARG(%n)=VARGRAPHIC(%n)
BLOB(1048576)=BLOB</a:MapTargetItem.Value>
<a:List>TIMESTMP(10)
DECIMAL(5)
FLOAT(8)
FLOAT(4)
VARG(%n)
BLOB(1048576)
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o248">
<a:Name>PhysOdbcDataType</a:Name>
<a:Comment>Data types translation table from target database data types to ODBC data types.</a:Comment>
<a:MapTargetItem.Value>INT=INTEGER
DEC=DECIMAL
DEC(%n)=DECIMAL(%n)
DEC(%s,%p)=DECIMAL(%s,%p)
VARCHAR(1)=VARCHAR
CHARACTER VARYING=VARCHAR
CHARACTER VARYING(1)=VARCHAR
CHARACTER VARYING(%n)=VARCHAR(%n)
CHAR(1)=CHAR
CHARACTER=CHAR
CHARACTER(1)=CHAR
CHARACTER(%n)=CHAR(%n)</a:MapTargetItem.Value>
<a:List>INT
DEC
DEC(%n)
DEC(%s,%p)
VARCHAR(1)
CHARACTER VARYING
CHARACTER VARYING(1)
CHARACTER VARYING(%n)
CHAR(1)
CHARACTER
CHARACTER(1)
CHARACTER(%n)
</a:List>
</o:MapTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o249">
<a:Name>Odbc</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the ODBC generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o250">
<a:Name>Objects</a:Name>
<c:Categories>
<o:TargetCategory Id="o251">
<a:Name>Qualifier</a:Name>
<a:Comment>Manages the use of qualifier in ODBC reverse engineering</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o252">
<a:Name>Enable</a:Name>
<a:Comment>Allows using the qualifier combo box during ODBC reverse engineering</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o253">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>select name from sysibm.sysdatabase
where 1=1
[and name = %.q:CATALOG%]</a:TextTargetItem.Value>
<a:Comment>Query to retrieve qualifier during ODBC reverse engineering</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o254">
<a:Name>Label</a:Name>
<a:Comment>Label for &lt;All&gt; in qualifier selection list</a:Comment>
<a:StringTargetItem.Value>All databases</a:StringTargetItem.Value>
</o:StringTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:ProfileTargetItem Id="o255">
<a:Name>Profile</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TargetCategory Id="o256">
<a:Name>Shared</a:Name>
<a:Code>Shared</a:Code>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o257">
<a:TypePublicName>ExtendedAttributeTypeTargetItem</a:TypePublicName>
<a:Name>Extended Attribute Types</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTypeTargetItem Id="o258">
<a:ObjectID>1DDB9620-5DD1-42C8-8655-C586EB37D76F</a:ObjectID>
<a:Name>T_ExtSubtypeData</a:Name>
<a:Comment>Subtype of columns:
SBCS  Column holds single-byte data.
MIXED Column holds mixed data.
BIT   Column holds BIT data.
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>bit
sbcs
mixed</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o259">
<a:ObjectID>CD9801AE-8DE8-4D01-8155-56D90FC52AE2</a:ObjectID>
<a:Name>T_ExtGeneratedAs</a:Name>
<a:Comment>List of acceptable value for the generated as column option</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.Value>always</a:ExtendedAttributeTypeTargetItem.Value>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>always
by default</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o260">
<a:ObjectID>4726B977-1B31-4134-9182-3EB483B602B0</a:ObjectID>
<a:Name>T_ExtTablespaceType</a:Name>
<a:Comment>LARGE Identifies that each partition of a partitioned table space has a maximum partition size of 4 GB, which enables the table space to contain more than 64GB of data.
LOB Identifies the table space as LOB table space. A LOB table space is used to hold LOB values.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>large
lob</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:TargetCategory>
<o:MetaClassTargetItem Id="o261">
<a:Name>Index</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o262">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o263">
<a:ObjectID>5FE04311-D408-44F5-8B15-C33B681CADB9</a:ObjectID>
<a:Name>WhereNotNull</a:Name>
<a:Comment>Apply on unique indexes, specify that the uniqueness constraint does not apply to the key value if any column of the key is null.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.Value>false</a:ExtendedAttributeTargetItem.Value>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o264">
<a:Name>Key</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o265">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o266">
<a:Name>Key index existence</a:Name>
<a:Comment>The execution of this check depends on the value of the PKAutoIndex (resp. UniqueAutoIndex) item in the PKey (resp. Key) category.
If AutoIndex is set to True, the check is not executed. Else, the check ensures that an index exists for that key (index can be attached, or with exact same column list).</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that an index exists for all keys.</a:HelpMessage>
<a:OutputMessage>The following keys do not have an index attached:</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   dim bAutoIndex
   if (obj.Primary) then
      bAutoIndex = GetBooleanItem(&quot;Script\Objects\PKey\PkAutoIndex&quot;)
   else
      bAutoIndex = GetBooleanItem(&quot;Script\Objects\Key\UniqConstAutoIndex&quot;)
   end if
   if (bAutoIndex) then
      &#39; If autoIndexed, then we don&#39;t need to check existence of 
      &#39; index as it will not be generated anyway
      %Check% = True
      Exit function
   end if
   &#39; else, we must have an index !
   if (obj.Indexes.Count &gt; 0) then
      %Check% = True
      Exit function
   end if
   &#39; If no attached index, then seek for existing index with same columns
   dim kColList, pCol, pIndex, iColList, kColCount
   kColList = &quot;&quot;
   kColCount = obj.Columns.Count
   For each pCol in obj.Columns
      kColList = kColList &amp; &quot;\&quot; &amp; pCol.ObjectID
   next
   For each pIndex in obj.Table.Indexes
      if (pIndex.IndexColumns.Count = kColCount) then
      &#39; only loop on index having same number of column than key.
         iColList = &quot;&quot;
         For each pCol in pIndex.IndexColumns
            iColList = iColList &amp; &quot;\&quot; &amp; pCol.Column.ObjectID
         next
         if (iColList = kColList) then
            %Check% = True
            Exit Function
         end if
      end if
   next
   &#39; not found
   %Check% = False
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o267">
<a:Name>Column</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o268">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o269">
<a:ObjectID>65681114-F966-4D30-BC16-A6CEF0670718</a:ObjectID>
<a:Name>ExtFieldProcName</a:Name>
<a:Comment>This extended attribute defines the potential field procedure to be used by DB2 as generator/cryptor of values.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o270">
<a:ObjectID>E2AC6C52-CA93-4870-B5B3-9A02246A3119</a:ObjectID>
<a:Name>ExtSubtypeData</a:Name>
<a:Comment>Specify a subtype for a character string column.
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o258"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o271">
<a:ObjectID>E6BBEBF1-5261-4D72-ACF0-699D140608A8</a:ObjectID>
<a:Name>ExtGeneratedAs</a:Name>
<a:Comment>Indicates that DB2 generates values for the column.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o259"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o272">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o273">
<a:Name>Mandatory ROWID column</a:Name>
<a:Comment>A column with the ROWID data type must have the Mandatory check box selected.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that any column with the ROWID data type has the Mandatory check box selected.</a:HelpMessage>
<a:OutputMessage>The following ROWID columns do not have the Mandatory check box selected:</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   if (lcase(obj.Datatype) = &quot;rowid&quot;) then
      if not (obj.Mandatory) then
         %Check% = False
         exit function
      end if
   end if
   %Check% = True
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   obj.Mandatory = True
   outmsg = obj.ShortDescription &amp; &quot; has been set Mandatory&quot;
   %Fix% = True
End Function</a:AutoFixScrpt>
<a:EnableAutoFix>1</a:EnableAutoFix>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o274">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o275">
<a:Name>DB2</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtFieldProcName&quot; AttributeID=&quot;{65681114-F966-4D30-BC16-A6CEF0670718}&quot; Name=&quot;ExtFieldProcName&quot; Caption=&quot;Field procedure name&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtSubtypeData&quot; AttributeID=&quot;{E2AC6C52-CA93-4870-B5B3-9A02246A3119}&quot; Name=&quot;ExtSubtypeData&quot; Caption=&quot;Character subtype&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtGeneratedAs&quot; AttributeID=&quot;{E6BBEBF1-5261-4D72-ACF0-699D140608A8}&quot; Name=&quot;ExtGeneratedAs&quot; Caption=&quot;Generated value&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o276">
<a:Name>Reference</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o277">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o278">
<a:Name>Reflexive and restrict on delete reference</a:Name>
<a:Comment>DB2 does not allow creating reflexive reference with delete restrict referential integrity.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that referential integrity of reflexive references is not Restrict on delete.</a:HelpMessage>
<a:OutputMessage>The following reflexive references must not be declared as Restrict on delete:</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   if (obj.DeleteConstraint = 1) then &#39; 1 is for Restrict
      &#39; Return (!reflexive) state of the reference.
      %Check% = not(obj.ChildTable is obj.ParentTable)
   else
      %Check% = True &#39; not a delete restrict
   end if
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   outmsg = &quot;Automatic correction sets the Delete action of referential integrity to No action (&lt;None&gt;)&quot;
   obj.DeleteConstraint = 0
   %Fix% = True
End Function</a:AutoFixScrpt>
<a:EnableAutoFix>1</a:EnableAutoFix>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o279">
<a:Name>Tablespace</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o280">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o281">
<a:ObjectID>6EB80814-28F4-4585-9AA2-70684C073540</a:ObjectID>
<a:Name>ExtTablespaceType</a:Name>
<a:Comment>Specify Tablespace Type. See type description on Extended Attribute Type T_ExtTablespaceType comment.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o260"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o282">
<a:ObjectID>6822ACDA-CED6-420A-A551-6F0B12709B32</a:ObjectID>
<a:Name>TbspDatabase</a:Name>
<a:Comment>Owning database. See template description.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
<a:ExtendedAttributeTargetItem.Value>%getTbspDatabase%</a:ExtendedAttributeTargetItem.Value>
<a:Template>1</a:Template>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o283">
<a:TypePublicName>TemplateTargetItem</a:TypePublicName>
<a:Name>Templates</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TemplateTargetItem Id="o284">
<a:Name>getTbspDatabase</a:Name>
<a:TemplateTargetItem.Value>.set_value(RetVal, &quot;&quot;)
.foreach_item(Databases)
.if(%RetVal% == &quot;&quot;)
.if(%IsShortcut%)
.set_value(RetVal, %Shortcut.Code%)
.else
.set_value(RetVal, %Code%)
.endif
.endif
.next()
%RetVal%</a:TemplateTargetItem.Value>
<a:Comment>Retrieve the code of the database that owns the current tablespace. Only take first item of what should be a single-valued collection.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o285">
<a:Name>Table</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o286">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o287">
<a:Name>Physical Option Conflict</a:Name>
<a:Comment>Checking that physical options are correct for the database. An error occurs when both tablespace and database options are used by the same table.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that no conflict is detected in table physical options</a:HelpMessage>
<a:OutputMessage>The following tables do not have consistent physical options:</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   if (obj.PhysicalOptions &lt;&gt; &quot;&quot;) then
      dim OptsText, InPos, InDBPos
      OptsText = lcase(Replace(obj.PhysicalOptions, vbCrLf, &quot; &quot;))
      InPos = instr(OptsText, &quot;in &quot;)
      InDBPos = instr(OptsText, &quot;in database &quot;)
      if ((InPos &lt;&gt; 0) and (InDBPos &lt;&gt; 0) and (InDBPos &lt;&gt; InPos)) then
         %Check% = False
         exit function
      end if
   end if
   %Check% = True
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o288">
<a:Name>PhysicalDomain</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o289">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o290">
<a:ObjectID>D65002A1-8D8C-4CE5-BF2E-041DAB4EB9CD</a:ObjectID>
<a:Name>ExtSubtypeData</a:Name>
<a:Comment>Specify a subtype for a character string column.
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o258"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o291">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o292">
<a:Name>DB2</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtSubtypeData&quot; AttributeID=&quot;{D65002A1-8D8C-4CE5-BF2E-041DAB4EB9CD}&quot; Name=&quot;ExtSubtypeData&quot; Caption=&quot;Character subtype&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
</c:Categories>
</o:ProfileTargetItem>
</c:Categories>
<c:TriggerItems>
<o:TriggerItem Id="o293">
<a:ObjectID>A15C3777-9C01-4AB4-AD85-3379ED96D7AE</a:ObjectID>
<a:Name>InsertChildParentExist</a:Name>
<a:Code>InsertChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT()
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Parent must exist when inserting child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
--  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when inserting a child in &quot;[%CQUALIFIER%]%CHILD%&quot;
      (.JOIN(&quot;new_ins.%FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; and&quot;)
      not exists (select 1
                   from  [%PQUALIFIER%]%PARENT%
                   where  .JOIN(&quot;[%PQUALIFIER%]%PARENT%.%PK% = new_ins.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)) or&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o294">
<a:ObjectID>9DDEBAAE-2984-40E5-B159-DC1809D828F4</a:ObjectID>
<a:Name>InsertTooManyChildren</a:Name>
<a:Code>InsertTooManyChildren</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot exceed the maximum cardinality constraint when inserting the child</a:Comment>
</o:TriggerItem>
<o:TriggerItem Id="o295">
<a:ObjectID>F4B1F37D-3E7A-401A-A466-A4386CEAD30B</a:ObjectID>
<a:Name>UpdateChangeColumn</a:Name>
<a:Code>UpdateChangeColumn</a:Code>
<a:Text>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot modify non modifiable column constraint</a:Comment>
<a:Declaration>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
--  Non modifiable column &quot;%COLUMN%&quot; cannot be modified
      (.JOIN(&quot;new_upd.%COLUMN% &lt;&gt; old_upd.%COLUMN%&quot;, &quot;&quot;, &quot; or&quot;, &quot; ) or&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o296">
<a:ObjectID>731569E6-2C24-43C8-9E83-FE9E519D3E91</a:ObjectID>
<a:Name>UpdateChildParentExist</a:Name>
<a:Code>UpdateChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT()
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Parent must exist when updating a child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
--  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when updating a child in &quot;[%CQUALIFIER%]%CHILD%&quot;
      (.JOIN(&quot;new_upd.%FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; and&quot;)
       not exists (select 1
                   from  [%PQUALIFIER%]%PARENT%
                  where  .JOIN(&quot;[%PQUALIFIER%]%PARENT%.%PK% = new_upd.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)) or&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o297">
<a:ObjectID>FE0D9A62-6139-4F12-B96B-907E89FAFD32</a:ObjectID>
<a:Name>UpdateTooManyChildren</a:Name>
<a:Code>UpdateTooManyChildren</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot exceed the maximum cardinality constraint when updating the child</a:Comment>
</o:TriggerItem>
<o:TriggerItem Id="o298">
<a:ObjectID>5E292E81-D43B-4FE9-9733-4188E8730665</a:ObjectID>
<a:Name>UpdateChildChangeParent</a:Name>
<a:Code>UpdateChildChangeParent</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot change parent constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
--  Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;
      (.JOIN(&quot;new_upd.%FK% &lt;&gt; old_upd.%FK%&quot;, &quot;&quot;, &quot; or&quot;, &quot; ) or&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o299">
<a:ObjectID>4221AFA4-3BB9-470D-84E9-F7FBA4DDE832</a:ObjectID>
<a:Name>UpdateParentRestrict</a:Name>
<a:Code>UpdateParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
--  Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;
      (.JOIN(&quot;new_upd.%PK% &lt;&gt; old_upd.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot; and&quot;)
       exists (select 1
               from  [%CQUALIFIER%]%CHILD%
              where  .JOIN(&quot;[%CQUALIFIER%]%CHILD%.%FK% = old_upd.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)) or&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o300">
<a:ObjectID>DFE5EF42-A64B-4917-8105-AFC1A1003570</a:ObjectID>
<a:Name>UpdateParentCascade</a:Name>
<a:Code>UpdateParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
--  Modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; for all children in &quot;[%CQUALIFIER%]%CHILD%&quot;
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;[%CQUALIFIER%]%CHILD%.%FK% = new_upd.%PK%&quot;, &quot;&quot;, &quot;,&quot;)
    where  (.JOIN(&quot;[%CQUALIFIER%]%CHILD%.%FK% = old_upd.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;) and&quot;)
           (.JOIN(&quot;new_upd.%PK% &lt;&gt; old_upd.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;);&quot;)
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
--  Modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; for all children in &quot;[%CQUALIFIER%]%CHILD%&quot;
      (.JOIN(&quot;new_upd.%PK% &lt;&gt; old_upd.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) or&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o301">
<a:ObjectID>F51D63E9-641D-4A59-9C5B-339761F75A05</a:ObjectID>
<a:Name>UpdateParentSetNull</a:Name>
<a:Code>UpdateParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in &quot;[%CQUALIFIER%]%CHILD%&quot;
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;[%CQUALIFIER%]%CHILD%.%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
    where  (.JOIN(&quot;[%CQUALIFIER%]%CHILD%.%FK% = old_upd.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;) and&quot;)
           (.JOIN(&quot;new_upd.%PK% &lt;&gt; old_upd.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot; );&quot;)
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
      (.JOIN(&quot;new_upd.%PK% &lt;&gt; old_upd.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot; ) or&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o302">
<a:ObjectID>4BD214FE-7C21-44A2-919D-883FEC51649A</a:ObjectID>
<a:Name>UpdateParentSetDefault</a:Name>
<a:Code>UpdateParentSetDefault</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;
    update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;[%CQUALIFIER%]%CHILD%.%FK% = [%DEFAULT%?%DEFAULT%:null]&quot;, &quot;&quot;, &quot;,&quot;)
    where  (.JOIN(&quot;[%CQUALIFIER%]%CHILD%.%FK% = old_upd.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;) and&quot;)
           (.JOIN(&quot;new_upd.%PK% &lt;&gt; old_upd.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;);&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
     (.JOIN(&quot;new_upd.%PK% &lt;&gt; old_upd.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) or&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o303">
<a:ObjectID>B43C3C07-763A-4FD9-A60A-2A754B5B7D1E</a:ObjectID>
<a:Name>DeleteParentRestrict</a:Name>
<a:Code>DeleteParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
--  Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;
       exists (select 1
               from  [%CQUALIFIER%]%CHILD%
              where  (.JOIN(&quot;[%CQUALIFIER%]%CHILD%.%FK% = old_del.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)) or&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o304">
<a:ObjectID>08E5A73B-9298-45D0-BBA7-E6104DB64FF2</a:ObjectID>
<a:Name>DeleteParentCascade</a:Name>
<a:Code>DeleteParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
--  Delete all children in &quot;[%CQUALIFIER%]%CHILD%&quot;
delete from [%CQUALIFIER%]%CHILD%
where  .JOIN(&quot;[%CQUALIFIER%]%CHILD%.%FK% = old_del.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o305">
<a:ObjectID>B88E3902-38B9-434E-B18B-2FF4C5687D77</a:ObjectID>
<a:Name>DeleteParentSetNull</a:Name>
<a:Code>DeleteParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in child &quot;[%CQUALIFIER%]%CHILD%&quot;
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
 where  .JOIN(&quot;[%CQUALIFIER%]%CHILD%.%FK% = old_del.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o306">
<a:ObjectID>DF2AE818-6144-4F8D-942A-2F25B0B43F4C</a:ObjectID>
<a:Name>DeleteParentSetDefault</a:Name>
<a:Code>DeleteParentSetDefault</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
--  Set parent code &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = [%DEFAULT%?%DEFAULT%:null]&quot;, &quot;&quot;, &quot;,&quot;)
 where  .JOIN(&quot;[%CQUALIFIER%]%CHILD%.%FK% = old_del.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
</c:TriggerItems>
<c:TriggerTemplates>
<o:TriggerTemplate Id="o307">
<a:ObjectID>1FBB8B90-768C-4041-B7A4-14E171D0B33D</a:ObjectID>
<a:Name>BeforeInsertTrigger</a:Name>
<a:Code>BeforeInsertTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% no cascade before insert
on [%TABLQUALIFIER%]%TABLE% referencing new as new_ins for each row mode db2sql
when (
     .DeclInsertChildParentExist
     .DeclInsertTooManyChildren
     (0=1)
     )
.ERROR(70001, &#39;Cannot create child in [%TABLQUALIFIER%]%TABLE%.&#39;)
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Before insert trigger</a:Comment>
<a:TriggerName>tib_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o293"/>
<o:TriggerItem Ref="o294"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o308">
<a:ObjectID>5079224F-ED50-448B-81D2-5D4380F66459</a:ObjectID>
<a:Name>AfterInsertTrigger</a:Name>
<a:Code>AfterInsertTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% after insert
on [%TABLQUALIFIER%]%TABLE% referencing old as old_ins for each row mode db2sql

begin atomic
end  
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>After insert trigger</a:Comment>
<a:Time>After</a:Time>
<a:TriggerName>tia_%.L:TABLE%</a:TriggerName>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o309">
<a:ObjectID>E279E002-C840-4A5A-88C9-D4040F793F22</a:ObjectID>
<a:Name>BeforeUpdateTrigger</a:Name>
<a:Code>BeforeUpdateTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% no cascade before update
of .INCOLN(&quot;%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;)
on [%TABLQUALIFIER%]%TABLE%
referencing new as new_upd old as old_upd for each row mode db2sql
when (
     .DeclUpdateChangeColumn
     .DeclUpdateChildParentExist
     .DeclUpdateTooManyChildren
     .DeclUpdateChildChangeParent
     .DeclUpdateParentRestrict
     (0=1)
     )
.ERROR(70002, &#39;Unexisting parent or non updatable child. Cannot update [%TABLQUALIFIER%]%TABLE%&#39;)
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Before update trigger</a:Comment>
<a:Event>Update</a:Event>
<a:TriggerName>tub_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o295"/>
<o:TriggerItem Ref="o296"/>
<o:TriggerItem Ref="o297"/>
<o:TriggerItem Ref="o298"/>
<o:TriggerItem Ref="o299"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o310">
<a:ObjectID>FF3CABEF-CB90-46FC-A937-7A59A7289312</a:ObjectID>
<a:Name>AfterUpdateTrigger</a:Name>
<a:Code>AfterUpdateTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% after update
of .INCOLN(&quot;%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;)
on [%TABLQUALIFIER%]%TABLE%
referencing new as new_upd old as old_upd for each row mode db2sql
when (
     .DeclUpdateParentCascade
     .DeclUpdateParentSetNull
     .DeclUpdateParentSetDefault
     (0=1)
     )

begin atomic
    .UpdateParentCascade
    .UpdateParentSetNull
    .UpdateParentSetDefault
end
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>After update trigger</a:Comment>
<a:Time>After</a:Time>
<a:Event>Update</a:Event>
<a:TriggerName>tua_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o300"/>
<o:TriggerItem Ref="o301"/>
<o:TriggerItem Ref="o302"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o311">
<a:ObjectID>AA007B39-B1DA-476C-816E-F833A6A54EDB</a:ObjectID>
<a:Name>BeforeDeleteTrigger</a:Name>
<a:Code>BeforeDeleteTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% no cascade before delete 
on [%TABLQUALIFIER%]%TABLE%
referencing old as old_del for each row mode db2sql
when (
      .DeclDeleteParentRestrict
     (0=1)
     )
.ERROR(70007, &#39;Children still exist. Cannot delete parent [%TABLQUALIFIER%]%TABLE%.&#39;)</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Before delete trigger</a:Comment>
<a:Event>Delete</a:Event>
<a:TriggerName>tdb_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o303"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o312">
<a:ObjectID>186A7CDE-660C-4450-9205-E2D36CC73E51</a:ObjectID>
<a:Name>AfterDeleteTrigger</a:Name>
<a:Code>AfterDeleteTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% after delete 
on [%TABLQUALIFIER%]%TABLE%
referencing old as old_del for each row mode db2sql

begin atomic
    .DeleteParentCascade
    .DeleteParentSetNull
    .DeleteParentSetDefault
end
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1132162350</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>After delete trigger</a:Comment>
<a:Time>After</a:Time>
<a:Event>Delete</a:Event>
<a:TriggerName>tda_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o304"/>
<o:TriggerItem Ref="o305"/>
<o:TriggerItem Ref="o306"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
</c:TriggerTemplates>
</o:DBMS>

</DBMS>