<?xml version="1.0" encoding="UTF-8"?>
<?PowerDesigner AppLocale="Cp1252" Code="ALLBASE" Family="ALLBASE" Name="ALLBASE/SQL G.1 (Not Certified)" signature="XDB_XML" version="11.0.0.0"?>
<!-- do not edit this file -->

<DBMS xmlns:a="attribute" xmlns:c="collection" xmlns:o="object">

<o:DBMS Id="o1">
<a:ObjectID>D4711E2C-2176-44D7-98E5-54FC0E3ACACD</a:ObjectID>
<a:Name>ALLBASE/SQL G.1 (Not Certified)</a:Name>
<a:Code>ALLBASE</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1031818006</a:ModificationDate>
<a:Modifier>psitja</a:Modifier>
<a:Family>ALLBASE</a:Family>
<a:CheckGlobalScript>&#39;******************************************************************************
&#39;* Purpose:  This VB-Script holds global definitions shared by all the custom-
&#39;*            checks scripts of the model extension.
&#39;******************************************************************************

Option Explicit &#39; This is to ensure all used variables are defined

</a:CheckGlobalScript>
<c:Categories>
<o:TargetCategory Id="o2">
<a:Name>General</a:Name>
<a:Comment>Target DBMS identification</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o3">
<a:Name>SqlSupport</a:Name>
<a:Comment>SQL syntax allowed. This does not impact the script generation, but it impacts the SQL Preview</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o4">
<a:Name>EnableCheck</a:Name>
<a:Comment>Determines if the generation of check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o5">
<a:Name>Enableconstname</a:Name>
<a:Comment>Determines if constraint names are used during the generation</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o6">
<a:Name>UniqConstName</a:Name>
<a:Comment>Determines if unique constraint names for objects are authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o7">
<a:Name>Script</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the Script generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o8">
<a:Name>Sql</a:Name>
<a:Comment>Contains sub-categories Syntax, Format, File and Keywords. Each sub-category contains entries whose values define general syntax for the database</a:Comment>
<c:Categories>
<o:TargetCategory Id="o9">
<a:Name>Syntax</a:Name>
<a:Comment>Contains general parameters for SQL syntax</a:Comment>
<c:Categories>
<o:CharacterTargetItem Id="o10">
<a:Name>Terminator</a:Name>
<a:Comment>End of command character</a:Comment>
<a:CharacterTargetItem.Value>;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o11">
<a:Name>BlockTerminator</a:Name>
<a:Comment>End of block character</a:Comment>
</o:StringTargetItem>
<o:CharacterTargetItem Id="o12">
<a:Name>Delimiter</a:Name>
<a:Comment>Field separation character. Example: col1, col2, col3</a:Comment>
<a:CharacterTargetItem.Value>,</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o13">
<a:Name>Quote</a:Name>
<a:Comment>Character used to enclose string values</a:Comment>
<a:CharacterTargetItem.Value>&#39;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o14">
<a:Name>SqlContinue</a:Name>
<a:Comment>Continuation character</a:Comment>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o15">
<a:Name>LineComment</a:Name>
<a:Comment>Characters used to enclose a single line comment</a:Comment>
<a:StringTargetItem.Value>--</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o16">
<a:Name>BlockComment</a:Name>
<a:Comment>Characters used to enclose a multi-line comment</a:Comment>
</o:StringTargetItem>
<o:TextTargetItem Id="o17">
<a:Name>UsingBlockTerm</a:Name>
<a:TextTargetItem.Value>create procedure, end, 1
{
   begin, , 2
   {
      begin, end, 3
   }
}</a:TextTargetItem.Value>
<a:Comment>List of objects using block definition during reverse.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o18">
<a:Name>Format</a:Name>
<a:Comment>Contains entries that define script formatting</a:Comment>
<c:Categories>
<o:StringTargetItem Id="o19">
<a:Name>IllegalChar</a:Name>
<a:Comment>Invalid characters for names</a:Comment>
<a:StringTargetItem.Value>&quot; +-*/!=&lt;&gt;&#39;&quot;()&quot;.</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o20">
<a:Name>UpperCaseOnly</a:Name>
<a:Comment>Uppercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o21">
<a:Name>LowerCaseOnly</a:Name>
<a:Comment>Lowercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o22">
<a:Name>EnableOwnerPrefix</a:Name>
<a:Comment>Object codes can have a prefix made of the object owner code</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o23">
<a:Name>File</a:Name>
<a:Comment>Contains header, footer and usage text entries used during the generation</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o24">
<a:Name>Header</a:Name>
<a:Comment>Header text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o25">
<a:Name>Footer</a:Name>
<a:Comment>Footer text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o26">
<a:Name>EnableMultiFile</a:Name>
<a:Comment>Multi-script allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:StringTargetItem Id="o27">
<a:Name>ScriptExt</a:Name>
<a:Comment>Main script extension in database generation</a:Comment>
<a:StringTargetItem.Value>sql</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o28">
<a:Name>TableExt</a:Name>
<a:Comment>Other scripts extension in database generation</a:Comment>
<a:StringTargetItem.Value>tab</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o29">
<a:Name>StartCommand</a:Name>
<a:Comment>Command for executing a script</a:Comment>
<a:StringTargetItem.Value>start %NAMESCRIPT%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o30">
<a:Name>Usage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter:
        $ isql
          connect to ...
          %STARTCMD%</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in database generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o31">
<a:Name>Usage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter:
        $ isql
        connect to ...
        %STARTCMD% &lt;script_name&gt;</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in database generation</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o32">
<a:Name>TriggerExt</a:Name>
<a:Comment>Script file extension in triggers and procedures generation</a:Comment>
<a:StringTargetItem.Value>trg</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o33">
<a:Name>TrgUsage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start SQL interpreter
         isql
  (3) Execute the triggers creation script</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o34">
<a:Name>TrgUsage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter
          isql
  (3) Execute the triggers creation scripts.</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o35">
<a:Name>Keywords</a:Name>
<a:Comment>Contains the list of reserved words and functions available in SQL</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o36">
<a:Name>ReservedDefault</a:Name>
<a:TextTargetItem.Value>NULL
USER</a:TextTargetItem.Value>
<a:Comment>Reserved default values</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o37">
<a:Name>GroupFunc</a:Name>
<a:TextTargetItem.Value>avg()
count()
max()
min()
sum()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions to use with group keywords.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o38">
<a:Name>NumberFunc</a:Name>
<a:Comment>List of SQL functions used on numbers</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o39">
<a:Name>CharFunc</a:Name>
<a:TextTargetItem.Value>string_length()
substring()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for characters and strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o40">
<a:Name>DateFunc</a:Name>
<a:TextTargetItem.Value>add_months()
current_date
current_time
current_datetime</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for dates</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o41">
<a:Name>ConvertFunc</a:Name>
<a:TextTargetItem.Value>to_char()
to_date()
to_datetime()
to_integer()
to_interval()
to_time()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used to convert values between hex and integer and handling strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o42">
<a:Name>OtherFunc</a:Name>
<a:TextTargetItem.Value>output_device()
output_name()
tid()
user</a:TextTargetItem.Value>
<a:Comment>List of other SQL functions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o43">
<a:Name>ListOperators</a:Name>
<a:TextTargetItem.Value>=
&lt;&gt;
&gt;
&lt;
&gt;=
&lt;=
*=
=*
not
in
not in
between
not between
exists
not exists
like
not like
is
is not
= any
&lt;&gt; any
&gt; any
&lt; any
&gt;= any
&lt;= any
= all
&lt;&gt; all
&gt; all
&lt; all
&gt;= all
&lt;= all</a:TextTargetItem.Value>
<a:Comment>List of operators for comparing values, boolean, and various semantic operators</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o44">
<a:Name>Commit</a:Name>
<a:TextTargetItem.Value>commit</a:TextTargetItem.Value>
<a:Comment>Command for validating the transaction by OBDC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o45">
<a:Name>ReservedWord</a:Name>
<a:TextTargetItem.Value>ADD
ALL
ALTER
AND
ANY
AS
ASC
BETWEEN
BY
CHAR
CHECK
CONNECT
CREATE
CURRENT
DATE
DECIMAL
DEFAULT
DELETE
DESC
DISTINCT
DROP
ELSE
FLOAT
FOR
FROM
GRANT
GROUP
HAVING
IMMEDIATE
IN
INSERT
INTEGER
INTERSECT
INTO
IS
LEVEL
LIKE
NOT
NULL
OF
ON
OPTION
OR
ORDER
PRIOR
PRIVILEGES
PUBLIC
REVOKE
ROWS
SELECT
SESSION
SET
SIZE
SMALLINT
TABLE
THEN
TO
UNION
UNIQUE
UPDATE
USER
VALUES
VARCHAR
VIEW
WHENEVER
WITH</a:TextTargetItem.Value>
<a:Comment>Reserved words</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o46">
<a:Name>Objects</a:Name>
<a:Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:Comment>
<c:Categories>
<o:TargetCategory Id="o47">
<a:Name>Table</a:Name>
<a:Code>TABL</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLE&quot;        // generated code of the table
   &quot;TNAME&quot;        // name of the table
   &quot;TCODE&quot;        // code of the table
   &quot;TLABL&quot;        // comment of the table
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;TABLDEFN&quot;     // complete body of the table definition. Contains definition of columns, checks and keys
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o48">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>20</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o49">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKT_%.U16:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for check of table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o50">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create table [%QUALIFIER%]%TABLE%
(
   %TABLDEFN%
)
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a table. Example: create table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o51">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>unique hash on %s : composite=yes
{
   pages=%d
}
hash on constraint %s : composite=yes
{
   pages=%d
}
clustering on constraint %s
in %s : category=tablespace</a:TextTargetItem.Value>
<a:Comment>Available options for creating a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o52">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for table options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o53">
<a:Name>TableComment</a:Name>
<a:Comment>Command for adding a table comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o54">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop table [%QUALIFIER%]%TABLE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table. Example: drop table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o55">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>rename table [%QUALIFIER%]%OLDTABL% to %NEWTABL%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o56">
<a:Name>AlterTableHeader</a:Name>
<a:Comment>Alter table header</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o57">
<a:Name>AlterTableFooter</a:Name>
<a:Comment>Alter table footer</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o58">
<a:Name>DefineTableCheck</a:Name>
<a:TextTargetItem.Value>check (%.A:CONSTRAINT%)
      [constraint %CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of table check constraints</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o59">
<a:Name>Index</a:Name>
<a:Code>INDX</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
   &quot;INDEX&quot;        // generated code of the index
   &quot;INDEXNAME&quot;    // index name
   &quot;INDEXCODE&quot;    // index code
   &quot;UNIQUE&quot;       // keyword &quot;unique&quot; when the index is unique
   &quot;INDEXTYPE&quot;    // index type (available only for a few DBMS)
   &quot;INDEXKEY&quot;     // keywords &quot;primary&quot;, &quot;unique&quot; or &quot;foreign&quot; depending on the index origin
   &quot;CIDXLIST&quot;     // list of index columns. Eg: A asc, B desc, C asc
   &quot;CLUSTER&quot;      // keyword &quot;cluster&quot; when the index is cluster
For index columns, the following system variables are available:
   &quot;ASC&quot;          // keywords &quot;ASC&quot; or &quot;DESC&quot; depending on sort order
   &quot;ISASC&quot;        // TRUE if the index column sort is ascending
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o60">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>20</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o61">
<a:Name>MaxColIndex</a:Name>
<a:Comment>Maximum number of columns in an index</a:Comment>
<a:IntegerTargetItem.Value>16</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o62">
<a:Name>Enable</a:Name>
<a:Comment>Index allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o63">
<a:Name>EnableAscDesc</a:Name>
<a:Comment>ASC, DESC keywords allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o64">
<a:Name>UniqName</a:Name>
<a:Comment>Unique index name in the database</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o65">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [%UNIQUE%] [%CLUSTER%] index [%QUALIFIER%]%INDEX% on [%TABLQUALIFIER%]%TABLE%
(
   %CIDXLIST%
)</a:TextTargetItem.Value>
<a:Comment>Command for creating an index. Example: create index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o66">
<a:Name>Cluster</a:Name>
<a:Comment>Cluster index keyword (default value: cluster)</a:Comment>
<a:StringTargetItem.Value>clustering</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o67">
<a:Name>AddColIndex</a:Name>
<a:TextTargetItem.Value>%COLUMN% [%ASC%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an index column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o68">
<a:Name>Options</a:Name>
<a:Comment>Default options for creating an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o69">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for index options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o70">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop index [%QUALIFIER%]%INDEX%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an index. Example: drop index %INDEX%</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o71">
<a:Name>Column</a:Name>
<a:Code>COLN</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for columns)
   &quot;COLUMN&quot;       // generated code of the column
   &quot;COLNNO&quot;       // position of the column in the list of columns of the table
   &quot;COLNNAME&quot;     // name of the column
   &quot;COLNCODE&quot;     // code of the column
   &quot;PRIMARY&quot;      // keyword &quot;primary&quot; if the column is primary
   &quot;ISPKEY&quot;       // TRUE if the column is part of the primary key
   &quot;FOREIGN&quot;      // TRUE if the column is part of one foreign key
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o72">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>20</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o73">
<a:Name>EnableDefault</a:Name>
<a:Comment>Default values allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o74">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKC_%.U8:COLUMN%_%.U7:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for a column check parameter</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o75">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%COLUMN% %DATATYPE% [%NOTNULL%] [default %DEFAULT%] 
      [check (%.A:CONSTRAINT%)
      [constraint %CONSTNAME%]]</a:TextTargetItem.Value>
<a:Comment>Command for defining a table column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o76">
<a:Name>ColumnComment</a:Name>
<a:Comment>Command for adding a column comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o77">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>rename column [%QUALIFIER%]%TABLE%.%OLDCOLN% to %NEWCOLN%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o78">
<a:Name>Create</a:Name>
<a:Comment>Command for adding a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o79">
<a:Name>ModifyColumn</a:Name>
<a:Comment>Command for modifying a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o80">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a column</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:IntegerTargetItem Id="o81">
<a:Name>MaxConstLen</a:Name>
<a:Comment>Maximum constraint name length</a:Comment>
<a:IntegerTargetItem.Value>20</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TargetCategory Id="o82">
<a:Name>User</a:Name>
<a:Code>USER</a:Code>
<a:Comment>The following system variables are available:
   &quot;USER&quot;         // generated code of the user
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o83">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>20</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o84">
<a:Name>Enable</a:Name>
<a:Comment>User allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:BooleanTargetItem Id="o85">
<a:Name>EnableOption</a:Name>
<a:Comment>Physical options allowed  YES/NO</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TargetCategory Id="o86">
<a:Name>Reference</a:Name>
<a:Code>REFR</a:Code>
<a:Comment>The following system variables are available:
   &quot;REFR&quot;         // generated code of the reference
   &quot;REFNAME&quot;      // reference name
   &quot;PARENT&quot;       // generated code of the parent table
   &quot;PNAME&quot;        // name of the parent table
   &quot;PCODE&quot;        // code of the parent table
   &quot;CHILD&quot;        // generated code of the reference
   &quot;CNAME&quot;        // name of the child table
   &quot;CCODE&quot;        // code of the child table
   &quot;PQUALIFIER&quot;   // qualifier of the parent table. See QUALIFIER
   &quot;CQUALIFIER&quot;   // qualifier of the child table. See QUALIFIER
   &quot;REFRNAME&quot;     // Reference name
   &quot;REFRCODE&quot;     // Reference code
   &quot;FKCONSTRAINT&quot; // Reference constraint name (foreign key)
   &quot;PKCONSTRAINT&quot; // constraint name of the parent key used to reference object
   &quot;CKEYCOLUMNS&quot;  // list of parent key columns. Eg: C1, C2, C3
   &quot;FKEYCOLUMNS&quot;  // list of child foreign key columns. Eg:
   &quot;UPDCONST&quot;     // Update declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;DELCONST&quot;     // Delete declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;MINCARD&quot;      // Min cardinality
   &quot;MAXCARD&quot;      // Max cardinality
   &quot;POWNER&quot;       // Parent table owner
   &quot;COWNER&quot;       // child table owner
   &quot;CHCKONCMMT&quot;   // TRUE when check on commit is selected on the reference (ASA 6.0 specific)

For reference joins (couple of column in a reference),
the following system variables are available:
   &quot;CKEYCOLUMN&quot;   // generated code of the parent table column (primary key)
   &quot;FKEYCOLUMN&quot;   // generated code of the child table column (foreign key)
   &quot;PK&quot;           // primary key column generated code
   &quot;PKNAME&quot;       // primary key column name
   &quot;FK&quot;           // foreign key column generated code
   &quot;FKNAME&quot;       // foreign key column name
   &quot;AK&quot;           // alternate key column code (same as PK)
   &quot;AKNAME&quot;       // alternate key column name (same as PKNAME)
   &quot;COLTYPE&quot;      // primary column column datatype
   &quot;DEFAULT&quot;      // foreign key column default value
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o87">
<a:Name>Enable</a:Name>
<a:Comment>Foreign key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o88">
<a:Name>FKAutoIndex</a:Name>
<a:Comment>Foreign key is auto-indexed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o89">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>FK_%.U17:REFR%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for foreign keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o90">
<a:Name>CheckOnCommit</a:Name>
<a:Comment>Referential integrity test differed after the COMMIT</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o91">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>foreign key (%FKEYCOLUMNS%)
      references [%PQUALIFIER%]%PARENT%[ (%CKEYCOLUMNS%)]
      [constraint %CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o92">
<a:Name>DclUpdIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for update</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o93">
<a:Name>DclDelIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for delete</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o94">
<a:Name>PKey</a:Name>
<a:Code>PKEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o95">
<a:Name>Enable</a:Name>
<a:Comment>Primary key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o96">
<a:Name>PkAutoIndex</a:Name>
<a:Comment>Primary key is auto-indexed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o97">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>PK_%.U17:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for primary keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o98">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>primary key (%PKEYCOLUMNS%)
      [constraint %CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a primary key</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o99">
<a:Name>Key</a:Name>
<a:Code>KEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;COLUMNS&quot;      // List of columns of the key. Eg: &quot;A, B, C&quot;
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o100">
<a:Name>Enable</a:Name>
<a:Comment>UNIQUE constraint allowed for tables</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o101">
<a:Name>UniqConstAutoIndex</a:Name>
<a:Comment>UNIQUE constraint is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o102">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>AK_%.U8:AKEY%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for alternate keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o103">
<a:Name>SqlAkeyIndex</a:Name>
<a:Comment>SQL query to obtain the alternate key indexes of a table by ODBC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o104">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>unique (%COLUMNS%)
      [constraint %CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an alternate key</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o105">
<a:Name>Tablespace</a:Name>
<a:Code>TSPC</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLESPACE&quot;   // generated code of the tablespace
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o106">
<a:Name>Enable</a:Name>
<a:Comment>Tablespace allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o107">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create dbefileset %TABLESPACE%</a:TextTargetItem.Value>
<a:Comment>Command for creating a tablespace. Example: create tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o108">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop dbefileset %TABLESPACE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a tablespace. Example: drop tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o109">
<a:Name>Options</a:Name>
<a:Comment>Default options for creating a tablespace.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o110">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for tablespace options.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o111">
<a:Name>Storage</a:Name>
<a:Code>STOR</a:Code>
<a:Comment>The following system variables are available:
   &quot;STORAGE&quot;      // generated code of the storage
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o112">
<a:Name>Enable</a:Name>
<a:Comment>Storage allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o113">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create dbefile %STORAGE%
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a storage. Example: create storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o114">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop dbefile %STORAGE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a storage. Example: drop storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o115">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>&lt;composite&gt; :  composite=yes, separator=yes, parenthesis=no
{
with pages=%d
name=%s
increment=%d
maxpages=%d
type=%s : list=table | index | mixed
}</a:TextTargetItem.Value>
<a:Comment>Default options for creating a storage</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o116">
<a:Name>DefOptions</a:Name>
<a:TextTargetItem.Value>;
add dbefile %STORAGE% to dbefileset &lt;dbefilesetname&gt;</a:TextTargetItem.Value>
<a:Comment>Default values for storage options</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o117">
<a:Name>Database</a:Name>
<a:Code>DTBS</a:Code>
<a:Comment>The following system variables are available:
   &quot;DATABASE&quot;     // generated code of the database
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o118">
<a:Name>Create</a:Name>
<a:Comment>Command for creating a database. Example: create database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o119">
<a:Name>Options</a:Name>
<a:Comment>Available options for creating a database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o120">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for database options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o121">
<a:Name>OpenDatabase</a:Name>
<a:Comment>Command for opening a database. Example: open database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o122">
<a:Name>CloseDatabase</a:Name>
<a:Comment>Command for closing a database. Example: close database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o123">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a database. Example: drop database %DATABASE%</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o124">
<a:Name>View</a:Name>
<a:Code>VIEW</a:Code>
<a:Comment>The following system variables are available:
   &quot;VIEW&quot;         // generated code of the view
   &quot;VIEWNAME&quot;     // view name
   &quot;VIEWCODE&quot;     // view code
   &quot;VIEWCOLN&quot;     // List of columns of the view. Eg: &quot;A, B, C&quot;
   &quot;SQL&quot;          // SQL text of the view. Eg: Select * from T1
   &quot;VIEWCHECK&quot;    // Keyword &quot;with check option&quot; if selected on the view
   &quot;SCRIPT&quot;       // complete view creation order. Eg: create view V1 as select * from T1
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o125">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create view [%QUALIFIER%]%VIEW% [(%VIEWCOLN%)] as
%SQL%
[%VIEWCHECK%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a view. Example: create view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o126">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop view [%QUALIFIER%]%VIEW%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a view. Example: drop view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o127">
<a:Name>ViewComment</a:Name>
<a:Comment>Command for adding a view comment.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o128">
<a:Name>ViewCheck</a:Name>
<a:TextTargetItem.Value>with check option</a:TextTargetItem.Value>
<a:Comment>Option for checking a view</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o129">
<a:Name>Trigger</a:Name>
<a:Code>TRGR</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
 trigger object specific items
   &quot;ORDER&quot;        // order number of the trigger (to sort the triggers when the DBMS supports more than one trigger of one type)
   &quot;TRIGGER&quot;      // generated code of trigger
   &quot;TRGTYPE&quot;      // trigger type (keywords &quot;beforeinsert&quot;, &quot;afterupdate&quot;, ...)
   &quot;TRGEVENT&quot;     // trigger event (keywords &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;)
   &quot;TRGTIME&quot;      // trigger time (keywords NULL, &quot;before&quot;, &quot;after&quot;)
 inside the body of the trigger, macros redefine variables on objects
   &quot;REFNO&quot;        // reference position in the list of references of the table
 customized error messages management
   &quot;ERRNO&quot;        // error number for standard error
   &quot;ERRMSG&quot;       // error message for standard error
   &quot;MSGTAB&quot;       // name of the table containing user-defined error messages
   &quot;MSGNO&quot;        // in the user-defined error table, name of the column containing the error numbers
   &quot;MSGTXT&quot;       // in the user-defined error table, name of the column containing the error messages
   &quot;SCRIPT&quot;       // body of trigger or procedure
   &quot;TRGDEFN&quot;      // complete body of the trigger definition. Contains variable declarations and body of trigger or procedure
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o130">
<a:Name>Enable</a:Name>
<a:Comment>Trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o131">
<a:Name>EnableMultiTrigger</a:Name>
<a:Comment>Multi trigger allowed</a:Comment>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o132">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>20</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o133">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop rule %TRIGGER%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a trigger. Example: drop trigger %TRIGGER%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o134">
<a:Name>UseErrorMsgTable</a:Name>
<a:TextTargetItem.Value>errno  = %ERRNO%;
select %MSGTXT%
into   :errmsg
from   %MSGTAB%
where  %MSGNO% = %ERRNO%;
raise error :errno message :errmsg;</a:TextTargetItem.Value>
<a:Comment>Errors handling using an error messages table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o135">
<a:Name>UseErrorMsgText</a:Name>
<a:TextTargetItem.Value>errno  = %ERRNO%;
errmsg = %.q:ERRMSG%;
raise error :errno message :errmsg;</a:TextTargetItem.Value>
<a:Comment>Errors handling using fixed error messages</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o136">
<a:Name>Procedure</a:Name>
<a:Code>PROC</a:Code>
<a:Comment>The following system variables are available:
   &quot;PROC&quot;         // generated code of the procedure (also available for trigger when the trigger is implemented with a procedure)
   &quot;FUNC&quot;         // generated code of the procedure if the procedure is a function (with return value)
   &quot;PROCPRMS&quot;     // list of parameters of the procedure (also available for function)
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o137">
<a:Name>Enable</a:Name>
<a:Comment>Procedure allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o138">
<a:Name>EnableFunc</a:Name>
<a:Comment>Function allowed</a:Comment>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o139">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>20</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o140">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop procedure %PROC%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a procedure. Example: drop procedure %PROC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o141">
<a:Name>CustomProc</a:Name>
<a:TextTargetItem.Value>create procedure %PROC%(&lt;arg&gt; &lt;type&gt;) as
declare &lt;var&gt; &lt;type&gt;;
begin

end</a:TextTargetItem.Value>
<a:Comment>Command for creating a stored procedure</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o142">
<a:Name>DataType</a:Name>
<a:Comment>Contains data type translation entries. These entries list the correspondence between internal data types and the target database data types</a:Comment>
<c:Categories>
<o:MapTargetItem Id="o143">
<a:Name>AmcdDataType</a:Name>
<a:Comment>Data types translation table from internal data types to target database data types.
        %n is the length of the data type
        %s is the size of the data type
        %p is the precision of the data type</a:Comment>
<a:MapTargetItem.Value>&lt;UNDEF&gt; = &lt;Undefined&gt;
A%n     = CHAR(%n)
VA%n    = VARCHAR(%n)
LA      = LONG VARBINARY(1)
LA%n    = LONG VARBINARY(%n)
LVA     = LONG VARBINARY(1)
LVA%n   = LONG VARBINARY(%n)
BT      = SMALLINT
BT%n    = SMALLINT
SI      = SMALLINT
I       = INTEGER
LI      = INTEGER
N       = NUMERIC
N%n     = NUMERIC(%n)
N%s,%p  = NUMERIC(%s,%p)
DC      = DECIMAL
DC%n    = DECIMAL(%n)
DC%s,%p = DECIMAL(%s,%p)
SF      = REAL
F       = FLOAT
F%n     = FLOAT(%n)
LF      = DOUBLE PRECISION
MN      = DEC
MN%n    = DEC(%n)
MN%s,%p = DEC(%s,%p)
D       = DATE
T       = TIME
DT      = DATETIME
TS      = INTERVAL
BL      = SMALLINT
NO      = DECIMAL(6)
NO%n    = DECIMAL(%n)
BIN%n   = VARBINARY(%n)
LBIN    = LONG VARBINARY(3996)
LBIN%n  = LONG VARBINARY(%n)
TXT     = LONG VARBINARY(3996)
TXT%n   = LONG VARBINARY(%n)
MBT     = CHAR
MBT%n   = CHAR(%n)
VMBT    = VARCHAR(255)
VMBT%n  = VARCHAR(%n)
PIC     = LONG VARBINARY(3996)
PIC%n   = LONG VARBINARY(%n)
BMP     = LONG VARBINARY(3996)
BMP%n   = LONG VARBINARY(%n)
OLE     = LONG VARBINARY(3996)
OLE%n   = LONG VARBINARY(%n)
*       = CHAR(10)</a:MapTargetItem.Value>
<a:List>&lt;UNDEF&gt;
A%n
VA%n
LA
LA%n
LVA
LVA%n
BT
BT%n
SI
I
LI
N
N%n
N%s,%p
DC
DC%n
DC%s,%p
SF
F
F%n
LF
MN
MN%n
MN%s,%p
D
T
DT
TS
BL
NO
NO%n
BIN%n
LBIN
LBIN%n
TXT
TXT%n
MBT
MBT%n
VMBT
VMBT%n
PIC
PIC%n
BMP
BMP%n
OLE
OLE%n
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o144">
<a:Name>PhysDataType</a:Name>
<a:Comment>Data types translation table from target database data types to internal data types.</a:Comment>
<a:MapTargetItem.Value>&lt;Undefined&gt;=&lt;UNDEF&gt;
CHAR=A1
CHAR(%n)=A%n
CHARACTER=A1
CHARACTER(%n)=A%n
VARCHAR(%n)=VA%n
SMALLINT=SI
INTEGER=I
INT=I
NUMERIC=N
NUMERIC(%n)=N%n
NUMERIC(%s,%p)=N%s,%p
DEC=DC
DEC(%n)=DC%n
DEC(%s,%p)=DC%s,%p
DECIMAL=DC
DECIMAL(%n)=DC%n
DECIMAL(%s,%p)=DC%s,%p
REAL=SF
FLOAT=F
FLOAT(%n)=F%n
DOUBLE PRECISION=LF
DATE=D
TIME=T
DATETIME=DT
INTERVAL=TS
BINARY(%n)=BIN%n
VARBINARY(%n)=BIN%n
LONG BINARY(%n)=LA%n
LONG VARBINARY(%n)=LVA%n
*=A10</a:MapTargetItem.Value>
<a:List>&lt;Undefined&gt;
CHAR
CHAR(%n)
CHARACTER
CHARACTER(%n)
VARCHAR(%n)
SMALLINT
INTEGER
INT
NUMERIC
NUMERIC(%n)
NUMERIC(%s,%p)
DEC
DEC(%n)
DEC(%s,%p)
DECIMAL
DECIMAL(%n)
DECIMAL(%s,%p)
REAL
FLOAT
FLOAT(%n)
DOUBLE PRECISION
DATE
TIME
DATETIME
INTERVAL
BINARY(%n)
VARBINARY(%n)
LONG BINARY(%n)
LONG VARBINARY(%n)
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o145">
<a:Name>PhysDttpSize</a:Name>
<a:Comment>Table of storage sizes of target database data type</a:Comment>
<a:MapTargetItem.Value>DATE=16
TIME=16
DATETIME=16
INTERVAL=16</a:MapTargetItem.Value>
<a:List>DATE
TIME
DATETIME
INTERVAL
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o146">
<a:Name>HostDataType</a:Name>
<a:Comment>Data types translation from database data type to procedure data type</a:Comment>
<a:MapTargetItem.Value>CHAR=char
CHAR(%n)=char(%n)
VARCHAR(%n)=varchar(%n)
SMALLINT=smallint
INTEGER=integer
INT=integer
NUMERIC=decimal
NUMERIC(%n)=decimal(%n)
NUMERIC(%s,%p)=decimal(%s,%p)
DEC=decimal
DEC(%n)=decimal(%n)
DEC(%s,%p)=decimal(%s,%p)
DECIMAL=decimal
DECIMAL(%n)=decimal(%n)
DECIMAL(%s,%p)=decimal(%s,%p)
FLOAT=float
FLOAT(%n)=float(%n)
REAL=real
DOUBLE PRECISION=double precision
DATE=date
TIME=time
DATETIME=datetime
INTERVAL=interval
BINARY(%n)=binary(%n)
VARBINARY(%n)=varbinary(%n)
LONG BINARY(%n)=long binary(%n)
LONG VARBINARY(%n)=long varbinary(%n)</a:MapTargetItem.Value>
<a:List>CHAR
CHAR(%n)
VARCHAR(%n)
SMALLINT
INTEGER
INT
NUMERIC
NUMERIC(%n)
NUMERIC(%s,%p)
DEC
DEC(%n)
DEC(%s,%p)
DECIMAL
DECIMAL(%n)
DECIMAL(%s,%p)
FLOAT
FLOAT(%n)
REAL
DOUBLE PRECISION
DATE
TIME
DATETIME
INTERVAL
BINARY(%n)
VARBINARY(%n)
LONG BINARY(%n)
LONG VARBINARY(%n)
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o147">
<a:Name>PhysOdbcDataType</a:Name>
<a:Comment>Data types translation table from target database data types to ODBC data types.</a:Comment>
<a:MapTargetItem.Value>INT=INTEGER
DEC=DECIMAL
DEC(%n)=DECIMAL(%n)
DEC(%s,%p)=DECIMAL(%s,%p)</a:MapTargetItem.Value>
<a:List>INT
DEC
DEC(%n)
DEC(%s,%p)
</a:List>
</o:MapTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:ProfileTargetItem Id="o148">
<a:Name>Profile</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TargetCategory Id="o149">
<a:Name>Shared</a:Name>
<a:Code>Shared</a:Code>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TargetCategory>
</c:Categories>
</o:ProfileTargetItem>
</c:Categories>
<c:TriggerItems>
<o:TriggerItem Id="o150">
<a:ObjectID>A3665FA5-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>InsertChildParentExist</a:Name>
<a:Code>InsertChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT()
--  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when inserting a child in &quot;[%CQUALIFIER%]%CHILD%&quot;
select count(*)
into   :numrows
from   [%PQUALIFIER%]%PARENT%
where  .JOIN(&quot;%PK% = :new_%.16L:FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

if (:numrows = 0) then
   .ERROR(-20002, &quot;Parent does not exist in &quot;[%PQUALIFIER%]%PARENT%&quot;. Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
endif;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Parent must exist when inserting child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o151">
<a:ObjectID>A3665FA6-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>InsertTooManyChildren</a:Name>
<a:Code>InsertTooManyChildren</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
--  The cardinality of Parent &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; cannot exceed %MAXCARD%
select count(*)
into   :maxcard
from   [%CQUALIFIER%]%CHILD% T
where  .JOIN(&quot;:new_%.16L:FK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot; and&quot;)
       .JOIN(&quot;T.%FK% = :new_%.16L:FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

if (:maxcard &gt; %MAXCARD%) then
   .ERROR(-20007, &quot;The maximum cardinality of a child has been exceeded! Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
endif;
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot exceed the maximum cardinality constraint when inserting the child</a:Comment>
<a:Declaration>declare  maxcard  integer;
.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o152">
<a:ObjectID>A3665FA8-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>UpdateChangeColumn</a:Name>
<a:Code>UpdateChangeColumn</a:Code>
<a:Text>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
--  Non modifiable column &quot;%COLUMN%&quot; cannot be modified
if (:old_%.16L:COLUMN% != :new_%.16L:COLUMN%) then
   .ERROR(-20001, &quot;Non modifiable column &quot;%COLUMN%&quot; cannot be modified.&quot;)
endif;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot modify non modifiable column constraint</a:Comment>
<a:Declaration>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o153">
<a:ObjectID>A3665FA9-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>UpdateChildParentExist</a:Name>
<a:Code>UpdateChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT()
--  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when updating a child in &quot;[%CQUALIFIER%]%CHILD%&quot;
select count(*)
into   :numrows
from   [%PQUALIFIER%]%PARENT%
where  .JOIN(&quot;%PK% = :new_%.16L:FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

if (:numrows = 0) then
   .ERROR(-20003, &quot;&quot;[%PQUALIFIER%]%PARENT%&quot; does not exist. Cannot modify child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
endif;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Parent must exist when updating a child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o154">
<a:ObjectID>A3665FAA-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>UpdateTooManyChildren</a:Name>
<a:Code>UpdateTooManyChildren</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
--  The cardinality of Parent &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; cannot exceed %MAXCARD%
select count(*)
into   :maxcard
from   [%CQUALIFIER%]%CHILD% T
where  .JOIN(&quot;:new_%.16L:FK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot; and&quot;)
       .JOIN(&quot;T.%FK% = :new_%.16L:FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

if (:maxcard &gt; %MAXCARD%) then
   .ERROR(-20007, &quot;The maximum cardinality of a child has been exceeded! Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
endif;
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot exceed the maximum cardinality constraint when updating the child</a:Comment>
<a:Declaration>declare  maxcard  integer;
.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o155">
<a:ObjectID>A3665FAB-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>UpdateChildChangeParent</a:Name>
<a:Code>UpdateChildChangeParent</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
--  Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;
if (.JOIN(&quot;:old_%.16L:FK% != :new_%.16L:FK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   .ERROR(-20004, &quot;Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
endif;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot change parent constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o156">
<a:ObjectID>A3665FAC-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>UpdateParentRestrict</a:Name>
<a:Code>UpdateParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
--  Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;
if (.JOIN(&quot;:old_%.16L:PK% != :new_%.16L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   select count(*)
   into   :numrows
   from   [%CQUALIFIER%]%CHILD%
   where  .JOIN(&quot;%FK% = :old_%.16L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

   if (:numrows &gt; 0) then
      .ERROR(-20005, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)
   endif;
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o157">
<a:ObjectID>A3665FAD-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>UpdateParentCascade</a:Name>
<a:Code>UpdateParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
--  Modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; for all children in &quot;[%CQUALIFIER%]%CHILD%&quot;
if (.JOIN(&quot;:old_%.16L:PK% != :new_%.16L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = :new_%.16L:PK%&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = :old_%.16L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o158">
<a:ObjectID>A3665FAE-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>UpdateParentSetNull</a:Name>
<a:Code>UpdateParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in &quot;[%CQUALIFIER%]%CHILD%&quot;
if (.JOIN(&quot;:old_%.16L:PK% != :new_%.16L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = :old_%.16L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o159">
<a:ObjectID>A3665FAF-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>UpdateParentSetDefault</a:Name>
<a:Code>UpdateParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot; 
.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;
if (.JOIN(&quot;:old_%.16L:PK% != :new_%.16L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = :old_%.16L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o160">
<a:ObjectID>A3665FB1-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>DeleteParentRestrict</a:Name>
<a:Code>DeleteParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
--  Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;
select count(*)
into   :numrows
from   [%CQUALIFIER%]%CHILD%
where  .JOIN(&quot;%FK% = :old_%.16L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

if (:numrows &gt; 0) then
   .ERROR(-20006, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)
endif;

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o161">
<a:ObjectID>A3665FB2-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>DeleteParentCascade</a:Name>
<a:Code>DeleteParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
--  Delete all children in &quot;[%CQUALIFIER%]%CHILD%&quot;
delete [%CQUALIFIER%]%CHILD%
where  .JOIN(&quot;%FK% = :old_%.16L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o162">
<a:ObjectID>A3665FB3-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>DeleteParentSetNull</a:Name>
<a:Code>DeleteParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in child &quot;[%CQUALIFIER%]%CHILD%&quot;
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
where  .JOIN(&quot;%FK% = :old_%.16L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o163">
<a:ObjectID>A3665FB4-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>DeleteParentSetDefault</a:Name>
<a:Code>DeleteParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot; 
.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
where  .JOIN(&quot;%FK% = :old_%.16L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
</c:TriggerItems>
<c:TriggerTemplates>
<o:TriggerTemplate Id="o164">
<a:ObjectID>A3665FA4-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>InsertProc</a:Name>
<a:Code>InsertProc</a:Code>
<a:Text>--  Insert procedure &quot;%PROC%&quot; for table &quot;[%TABLQUALIFIER%]%TABLE%&quot;
create procedure %PROC%(.FKCOLN(&quot;new_%.16L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;) as&quot;)
begin
    declare  errno    integer;
    declare  errmsg   varchar(255);
    declare  numrows  integer;
    .DeclInsertChildParentExist
    .DeclInsertTooManyChildren

    .InsertChildParentExist
    .InsertTooManyChildren

end;</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Insert procedure</a:Comment>
<a:Time/>
<a:Event>InsertProc</a:Event>
<a:TriggerName>pi_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o150"/>
<o:TriggerItem Ref="o151"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o165">
<a:ObjectID>A3665FA7-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>UpdateProc</a:Name>
<a:Code>UpdateProc</a:Code>
<a:Text>--  Update procedure &quot;%PROC%&quot; for table &quot;[%TABLQUALIFIER%]%TABLE%&quot;
create procedure %PROC%(.INCOLN(&quot;old_%.16L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;,&quot;)
                        .INCOLN(&quot;new_%.16L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;) as&quot;)
begin
    declare  errno    integer;
    declare  errmsg   varchar(255);
    declare  numrows  integer;
    .DeclUpdateChangeColumn
    .DeclUpdateChildParentExist
    .DeclUpdateTooManyChildren
    .DeclUpdateChildChangeParent
    .DeclUpdateParentRestrict
    .DeclUpdateParentCascade
    .DeclUpdateParentSetNull
    .DeclUpdateParentSetDefault

    .UpdateChangeColumn
    .UpdateChildParentExist
    .UpdateTooManyChildren
    .UpdateChildChangeParent
    .UpdateParentRestrict
    .UpdateParentCascade
    .UpdateParentSetNull
    .UpdateParentSetDefault

end;</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update procedure</a:Comment>
<a:Time/>
<a:Event>UpdateProc</a:Event>
<a:TriggerName>pu_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o152"/>
<o:TriggerItem Ref="o153"/>
<o:TriggerItem Ref="o154"/>
<o:TriggerItem Ref="o155"/>
<o:TriggerItem Ref="o156"/>
<o:TriggerItem Ref="o157"/>
<o:TriggerItem Ref="o158"/>
<o:TriggerItem Ref="o159"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o166">
<a:ObjectID>A3665FB0-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>DeleteProc</a:Name>
<a:Code>DeleteProc</a:Code>
<a:Text>--  Delete procedure &quot;%PROC%&quot; for table &quot;[%TABLQUALIFIER%]%TABLE%&quot;
create procedure %PROC%(.PKCOLN(&quot;old_%.16L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;) as&quot;)
begin
    declare  errno    integer;
    declare  errmsg   varchar(255);
    declare  numrows  integer;
    .DeclDeleteParentRestrict
    .DeclDeleteParentCascade
    .DeclDeleteParentSetNull
    .DeclDeleteParentSetDefault

    .DeleteParentRestrict
    .DeleteParentCascade
    .DeleteParentSetNull
    .DeleteParentSetDefault

end;</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete procedure</a:Comment>
<a:Time/>
<a:Event>DeleteProc</a:Event>
<a:TriggerName>pd_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o160"/>
<o:TriggerItem Ref="o161"/>
<o:TriggerItem Ref="o162"/>
<o:TriggerItem Ref="o163"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o167">
<a:ObjectID>A3665FB5-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>InsertTrigger</a:Name>
<a:Code>InsertTrigger</a:Code>
<a:Text>-- Insert trigger &quot;%TRIGGER%&quot; for table &quot;[%TABLQUALIFIER%]%TABLE%&quot;
create rule %TRIGGER% after insert on [%TABLQUALIFIER%]%TABLE%
referencing new as new_ins
   execute procedure %PROC%(.FKCOLN(&quot;new_ins.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;);&quot;)</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Insert trigger</a:Comment>
<a:Time/>
<a:TriggerName>ti_%.L:TABLE%</a:TriggerName>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o168">
<a:ObjectID>A3665FB6-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>UpdateTrigger</a:Name>
<a:Code>UpdateTrigger</a:Code>
<a:Text>--  Update trigger &quot;%TRIGGER%&quot; for table &quot;[%TABLQUALIFIER%]%TABLE%&quot;
create rule %TRIGGER% after update on [%TABLQUALIFIER%]%TABLE%
referencing new as new_upd old as old_upd
   execute procedure %PROC%(.INCOLN(&quot;old_upd.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;,&quot;) 
                            .INCOLN(&quot;new_upd.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;);&quot;)</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update trigger</a:Comment>
<a:Time/>
<a:Event>Update</a:Event>
<a:TriggerName>tu_%.L:TABLE%</a:TriggerName>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o169">
<a:ObjectID>A3665FB7-B46D-11D3-8FEE-0080C7B619A2</a:ObjectID>
<a:Name>DeleteTrigger</a:Name>
<a:Code>DeleteTrigger</a:Code>
<a:Text>--  Delete trigger &quot;%TRIGGER%&quot; for table &quot;[%TABLQUALIFIER%]%TABLE%&quot;
create rule %TRIGGER% after delete on [%TABLQUALIFIER%]%TABLE%
referencing old as old_del
   execute procedure %PROC%(.PKCOLN(&quot;old_del.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;);&quot;)</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete trigger</a:Comment>
<a:Time/>
<a:Event>Delete</a:Event>
<a:TriggerName>td_%.L:TABLE%</a:TriggerName>
</o:TriggerTemplate>
</c:TriggerTemplates>
</o:DBMS>

</DBMS>