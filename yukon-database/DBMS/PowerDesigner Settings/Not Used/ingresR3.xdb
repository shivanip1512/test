<?xml version="1.0" encoding="UTF-8"?>
<?PowerDesigner AppLocale="UTF16" Code="INGRESR3" Family="INGRES" Name="Ingres R3 3.0.1" signature="XDB_XML" version="12.0.0.1642"?>
<!-- do not edit this file -->

<DBMS xmlns:a="attribute" xmlns:c="collection" xmlns:o="object">

<o:DBMS Id="o1">
<a:ObjectID>D0D98A32-613A-49C6-81DF-E8E3FFB0BF11</a:ObjectID>
<a:Name>Ingres R3 3.0.1</a:Name>
<a:Code>INGRESR3</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1109757513</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Family>INGRES</a:Family>
<a:CheckGlobalScript>&#39;******************************************************************************
&#39;* Purpose:  This VB-Script holds global definitions shared by all the custom-
&#39;*            checks scripts of the model extension.
&#39;******************************************************************************

Option Explicit &#39; This is to ensure all used variables are defined

</a:CheckGlobalScript>
<c:Categories>
<o:TargetCategory Id="o2">
<a:Name>General</a:Name>
<a:Comment>Target DBMS identification</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o3">
<a:Name>SqlSupport</a:Name>
<a:Comment>SQL syntax allowed. This does not impact the script generation, but it impacts the SQL Preview</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o4">
<a:Name>EnableCheck</a:Name>
<a:Comment>Determines if the generation of check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o5">
<a:Name>Enableconstname</a:Name>
<a:Comment>Determines if constraint names are used during the generation</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o6">
<a:Name>UniqConstName</a:Name>
<a:Comment>Determines if unique constraint names for objects are authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o7">
<a:Name>EnableMultiCheck</a:Name>
<a:Comment>Determines if the generation of multiple check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o8">
<a:Name>EnableIntegrity</a:Name>
<a:Comment>Allows integrity constraints in the DBMS. This controls whether generation parameters for primary, foreign, and alternate keys are grayed or available</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o9">
<a:Name>Script</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the Script generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o10">
<a:Name>Sql</a:Name>
<a:Comment>Contains sub-categories Syntax, Format, File and Keywords. Each sub-category contains entries whose values define general syntax for the database</a:Comment>
<c:Categories>
<o:TargetCategory Id="o11">
<a:Name>Syntax</a:Name>
<a:Comment>Contains general parameters for SQL syntax</a:Comment>
<c:Categories>
<o:CharacterTargetItem Id="o12">
<a:Name>Terminator</a:Name>
<a:Comment>End of command character</a:Comment>
<a:CharacterTargetItem.Value>;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o13">
<a:Name>BlockTerminator</a:Name>
<a:Comment>End of block character</a:Comment>
</o:StringTargetItem>
<o:CharacterTargetItem Id="o14">
<a:Name>Delimiter</a:Name>
<a:Comment>Field separation character. Example: col1, col2, col3</a:Comment>
<a:CharacterTargetItem.Value>,</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o15">
<a:Name>Quote</a:Name>
<a:Comment>Character used to enclose string values</a:Comment>
<a:CharacterTargetItem.Value>&#39;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o16">
<a:Name>SqlContinue</a:Name>
<a:Comment>Continuation character</a:Comment>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o17">
<a:Name>LineComment</a:Name>
<a:Comment>Characters used to enclose a single line comment</a:Comment>
<a:StringTargetItem.Value>--</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o18">
<a:Name>BlockComment</a:Name>
<a:Comment>Characters used to enclose a multi-line comment</a:Comment>
<a:StringTargetItem.Value>/* */</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o19">
<a:Name>UseBlockTerm</a:Name>
<a:Comment>Use end of block character by default</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o20">
<a:Name>UsingBlockTerm</a:Name>
<a:TextTargetItem.Value>create procedure,;,  1
{
   begin, end, 3
}
</a:TextTargetItem.Value>
<a:Comment>List of objects using block definition during reverse.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o21">
<a:Name>Format</a:Name>
<a:Comment>Contains entries that define script formatting</a:Comment>
<c:Categories>
<o:StringTargetItem Id="o22">
<a:Name>IllegalChar</a:Name>
<a:Comment>Invalid characters for names</a:Comment>
<a:StringTargetItem.Value>&quot; +-*/!=&lt;&gt;&#39;&quot;()&quot;.</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o23">
<a:Name>UpperCaseOnly</a:Name>
<a:Comment>Uppercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o24">
<a:Name>LowerCaseOnly</a:Name>
<a:Comment>Lowercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o25">
<a:Name>EnableOwnerPrefix</a:Name>
<a:Comment>Object codes can have a prefix made of the object owner code</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o26">
<a:Name>File</a:Name>
<a:Comment>Contains header, footer and usage text entries used during the generation</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o27">
<a:Name>Header</a:Name>
<a:Comment>Header text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o28">
<a:Name>Footer</a:Name>
<a:Comment>Footer text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o29">
<a:Name>EnableMultiFile</a:Name>
<a:Comment>Multi-script allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:StringTargetItem Id="o30">
<a:Name>ScriptExt</a:Name>
<a:Comment>Main script extension in database generation</a:Comment>
<a:StringTargetItem.Value>sql</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o31">
<a:Name>TableExt</a:Name>
<a:Comment>Other scripts extension in database generation</a:Comment>
<a:StringTargetItem.Value>tab</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o32">
<a:Name>StartCommand</a:Name>
<a:Comment>Command for executing a script</a:Comment>
</o:StringTargetItem>
<o:TextTargetItem Id="o33">
<a:Name>Usage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter
  (3) Run the database creation script:
        %NAMESCRIPT%</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in database generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o34">
<a:Name>Usage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter
  (3) Run the database creation scripts</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in database generation</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o35">
<a:Name>Keywords</a:Name>
<a:Comment>Contains the list of reserved words and functions available in SQL</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o36">
<a:Name>ReservedDefault</a:Name>
<a:TextTargetItem.Value>User
Current User
Null
</a:TextTargetItem.Value>
<a:Comment>Reserved default values</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o37">
<a:Name>GroupFunc</a:Name>
<a:TextTargetItem.Value>any()
avg()
count()
max()
min()
sum()
stddev_pop()
stddev_samp()
var_pop()
var_samp()
regr_count(indep_parm,dep_parm)
covar_pop(indep_parm,dep_parm)
covar_samp(indep_parm,dep_parm)
corr(indep_parm,dep_parm)
regr_r2(indep_parm,dep_parm)
regr_slope(indep_parm,dep_parm)
regr_intercept(indep_parm,dep_parm)
regr_sxx(indep_parm,dep_parm)
regr_syy(indep_parm,dep_parm)
regr_sxy(indep_parm,dep_parm)
regr_avgx(indep_parm,dep_parm)
regr_avgy(indep_parm,dep_parm)
</a:TextTargetItem.Value>
<a:Comment>List of SQL functions to use with group keywords.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o38">
<a:Name>NumberFunc</a:Name>
<a:TextTargetItem.Value>abs(n)
atan(n)
cos(n)
exp(n)
log(n)
ln(n)
mod(n,b)
power(x,y)
sin(n)
sqrt(n)
</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used on numbers</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o39">
<a:Name>CharFunc</a:Name>
<a:TextTargetItem.Value>charextract(c1,n)
concat(c1,c2)
left(c1,len)
length(c1)
locate(c1,c2)
lowercase(c1)
lower(c1)
pad(c1)
right(c1,len)
shift(c1,nshift)
size(c1)
soundex(c1)
squeeze(c1)
substring(c1 from loc[FOR len])
substring(c1 from n1 [for n2])
trim(c1)
notrim(c1)
uppercase(c1)
upper(c1)</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for characters and strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o40">
<a:Name>DateFunc</a:Name>
<a:TextTargetItem.Value>interval(unit,date_interval)
_date(s)
_date4(s)</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for dates</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o41">
<a:Name>ConvertFunc</a:Name>
<a:TextTargetItem.Value>byte(expr [, len])
c(expr [, len])
char(expr [, len])
date(expr)
decimal(expr [, precision [, scale]])
dow(expr)
float4(expr)
float8(expr)
hex(expr)
int1(expr)
int2(expr)
int4(expr)
long_byte(expr)
long_varchar (expr)
money(expr)
nchar(expr [, len])
nvarchar(expr [, len])
object_key(expr)
table_key(expr)
text(expr [, len])
unhex(expr)
varbyte(expr [, len])
varchar(expr [, len])</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used to convert values between hex and integer and handling strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o42">
<a:Name>OtherFunc</a:Name>
<a:TextTargetItem.Value>ifnull(v1,v2)</a:TextTargetItem.Value>
<a:Comment>List of other SQL functions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o43">
<a:Name>ListOperators</a:Name>
<a:TextTargetItem.Value>=
&lt;&gt;
&gt;
&lt;
&gt;=
&lt;=
*=
=*
not
in
not in
between
not between
exists
not exists
like
not like
is
is not
= any
&lt;&gt; any
&gt; any
&lt; any
&gt;= any
&lt;= any
= all
&lt;&gt; all
&gt; all
&lt; all
&gt;= all
&lt;= all</a:TextTargetItem.Value>
<a:Comment>List of operators for comparing values, boolean, and various semantic operators</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o44">
<a:Name>Commit</a:Name>
<a:TextTargetItem.Value>commit</a:TextTargetItem.Value>
<a:Comment>Command for validating the transaction by OBDC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o45">
<a:Name>ReservedWord</a:Name>
<a:TextTargetItem.Value>ADD
ALL
ALTER
AND
ANY
AS
ASC
BETWEEN
BY
CHAR
CHECK
CONNECT
CREATE
CURRENT
DATE
DECIMAL
DEFAULT
DELETE
DESC
DISTINCT
DROP
ELSE
FLOAT
FOR
FROM
GRANT
GROUP
HAVING
IMMEDIATE
IN
INSERT
INTEGER
INTERSECT
INTO
IS
LEVEL
LIKE
NOT
NULL
OF
ON
OPTION
OR
ORDER
PRIOR
PRIVILEGES
PUBLIC
REVOKE
ROWS
SELECT
SESSION
SET
SIZE
SMALLINT
TABLE
THEN
TO
UNION
UNIQUE
UPDATE
USER
VALUES
VARCHAR
VIEW
WHENEVER
WITH</a:TextTargetItem.Value>
<a:Comment>Reserved words</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o46">
<a:Name>Objects</a:Name>
<a:Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:Comment>
<c:Categories>
<o:TargetCategory Id="o47">
<a:Name>Table</a:Name>
<a:Code>TABL</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLE&quot;        // generated code of the table
   &quot;TNAME&quot;        // name of the table
   &quot;TCODE&quot;        // code of the table
   &quot;TLABL&quot;        // comment of the table
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;TABLDEFN&quot;     // complete body of the table definition. Contains definition of columns, checks and keys
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o48">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>32</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o49">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKT_%.U26:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for check of table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o50">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create table [%QUALIFIER%]%TABLE% (
   %TABLDEFN%
)
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a table. Example: create table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o51">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with : composite=yes, separator=yes
{
   location = : composite=yes, parenthesis=yes, separator=yes
   {
      &lt;location_name&gt; %s
   }
   &lt;journaling&gt; %s : default=journaling, list=journaling|nojournaling
   &lt;duplicates&gt; %s : default=duplicates, list=duplicates|noduplicates
   page_size = %d
   label_granularity = %s : default=table, list=table|row|system_default
   security_audit = : composite=yes, parenthesis=yes
   {
      &lt;audit_option_list&gt; %s
   }
   security_audit_key = : composite=yes, parenthesis=yes
   {
      &lt;column&gt; %s
   }
   nopartition
   partition = : composite=yes, parenthesis=yes
   {
      &lt;partitioning-scheme&gt; %s
   }
   &lt;Index_options&gt; : composite=yes, separator=yes
   {
      structure = %s : list=btree|isam|hash|rtree
      key = : composite=yes, parenthesis=yes, separator=yes
      {
         &lt;column&gt; %s
      }
      fillfactor = %d
      minpages = %d
      maxpages = %d
      leaffill= %d
      nonleaffill= %d
      allocation = %d
      extend = %d
      compression = %s : list= (key)|(nokey)|(data)|(nodata)|(hidata)
      nocompression
      priority = %s
   }
}</a:TextTargetItem.Value>
<a:Comment>Available options for creating a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o52">
<a:Name>TableComment</a:Name>
<a:TextTargetItem.Value>comment on table [%QUALIFIER%]%TABLE% is
%.q:COMMENT%</a:TextTargetItem.Value>
<a:Comment>Command for adding a table comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o53">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop table [%QUALIFIER%]%TABLE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table. Example: drop table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o54">
<a:Name>DefineTableCheck</a:Name>
<a:TextTargetItem.Value>[[constraint %CONSTNAME% ]check (%.A:CONSTRAINT%)]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of table check constraints</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o55">
<a:Name>Enable</a:Name>
<a:Comment>Table allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o56">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, TABLE_TYPE}

select
   t.relowner,
   t.relid,
   case(mod(t.relstat, 2) + mod((t.relstat/16384), 2) + mod((t.relstat2/16), 2)) when 0 then &#39;TABLE&#39; else &#39;SYSTEM_TABLE&#39; end,
   &#39;&#39;
from
   &quot;$ingres&quot;.iirelation t
where 1 = 1
   and mod((t.relstat/32), 2) = 0
   and mod((t.relstat/128), 2) = 0
   and mod((t.relstat2), 2) = 0
   and mod((t.relstat2/32768), 2) = 0
[  and t.relowner = %.q:SCHEMA%]
order by 3, 1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o57">
<a:Name>SqlChckQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, CONSTNAME ID, CONSTRAINT ...}

select
   c.schema_name,
   c.table_name,
   c.constraint_name,
   substring(c.text_segment from locate(lower(c.text_segment), &#39;check&#39;) + 5)
from
   iiconstraints c
where
   c.constraint_type = &#39;C&#39;
[  and c.schema_name = %.q:OWNER%]
[  and c.table_name = %.q:TABLE%]
order by
   c.schema_name,
   c.table_name,
   c.text_sequence
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o58">
<a:Name>AddTableCheck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME% ]check (%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script for modifying table constraints within an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o59">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, OPTIONS}

select 
   t.table_owner,
   t.table_name,
   &#39;with &#39;
   || &#39;location = (&#39; || varchar(location_name) || &#39;)&#39;
   || case (t.is_journalled) when &#39;Y&#39; then &#39;, journaling &#39; else &#39;, nojournaling &#39; end
   || case (t.duplicate_rows) when &#39;D&#39; then &#39;, duplicates &#39; else &#39;, noduplicates &#39; end
   || &#39;, page_size = &#39; || varchar(t.table_pagesize)
   || &#39;, structure = &#39; || varchar(t.storage_structure)
   || case (t.is_compressed) when &#39;Y&#39; then &#39;, compression &#39; else &#39;, nocompression &#39; end
from 
   iitables t 
where  t.table_type=&#39;T&#39;
[  and t.table_owner = %.q:OWNER%]
[  and t.table_name = %.q:TABLE%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o60">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, COMMENT ...}

select
   c.object_owner,
   c.object_name,
   c.long_remark
from
   iidb_comments c
where  object_type = &#39;T&#39;
[  and c.object_owner = %.q:OWNER%]
[  and c.object_name = %.q:TABLE%]
order by
   c.object_owner,
   c.object_name,
   c.text_sequence</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o61">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

select 
   a.permit_user, 
   case(locate(lower(a.permit_type), &#39; with grant option&#39;)) 
      when (size(a.permit_type) + 1) then varchar(trim(a.permit_type))
      else varchar(trim(left(a.permit_type, (locate(lower(a.permit_type), &#39; with grant option&#39;)))) || &#39;+&#39;)
   end || &#39;, &#39;
from 
   iiaccess a
where  a.system_use = &#39;U&#39;
   and a.table_name = %.q:TABLE% 
[  and a.table_owner = %.q:OWNER%]
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o62">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a table.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>Insert=Ins.
Update=Upd.
Delete=Del.
References=Ref.
Copy_into=Cpyinto
Copy_from=Cpyfrom
All=All</a:MapTargetItem.Value>
<a:List>Insert
Update
Delete
References
Copy_into
Copy_from
All
</a:List>
</o:MapTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o63">
<a:Name>Index</a:Name>
<a:Code>INDX</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
   &quot;INDEX&quot;        // generated code of the index
   &quot;INDEXNAME&quot;    // index name
   &quot;INDEXCODE&quot;    // index code
   &quot;UNIQUE&quot;       // keyword &quot;unique&quot; when the index is unique
   &quot;INDEXTYPE&quot;    // index type (available only for a few DBMS)
   &quot;INDEXKEY&quot;     // keywords &quot;primary&quot;, &quot;unique&quot; or &quot;foreign&quot; depending on the index origin
   &quot;CIDXLIST&quot;     // list of index columns. Eg: A asc, B desc, C asc
   &quot;CLUSTER&quot;      // keyword &quot;cluster&quot; when the index is cluster
For index columns, the following system variables are available:
   &quot;ASC&quot;          // keywords &quot;ASC&quot; or &quot;DESC&quot; depending on sort order
   &quot;ISASC&quot;        // TRUE if the index column sort is ascending
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o64">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>32</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o65">
<a:Name>MaxColIndex</a:Name>
<a:Comment>Maximum number of columns in an index</a:Comment>
<a:IntegerTargetItem.Value>16</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o66">
<a:Name>Enable</a:Name>
<a:Comment>Index allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o67">
<a:Name>EnableAscDesc</a:Name>
<a:Comment>ASC, DESC keywords allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o68">
<a:Name>UniqName</a:Name>
<a:Comment>Unique index name in the database</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o69">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [%UNIQUE%?%UNIQUE% :[%R%?global ]]index %INDEX% on %TABLE% (
   %CIDXLIST%
)[%R%? %UNIQUE%][ %OPTIONS%]
</a:TextTargetItem.Value>
<a:Comment>Command for creating an index. Example: create index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o70">
<a:Name>AddColIndex</a:Name>
<a:TextTargetItem.Value>%COLUMN% [%ASC%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an index column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o71">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with : composite=yes, separator=yes
{
   structure = %s : list=btree|isam|hash|rtree
   key = : composite=yes, parenthesis=yes, separator=yes
   {
      &lt;column&gt; %s
   }
   fillfactor = %d
   minpages = %d
   maxpages = %d
   leaffill= %d
   nonleaffill= %d
   location = : composite=yes, parenthesis=yes, separator=yes
   {
      &lt;location_name&gt; %s
   }
   allocation = %d
   extend = %d
   compression = %s : list= (key)|(nokey)|(data)|(nodata)|(hidata)
   nocompression
   &lt;persistence&gt; %s : list=persistence|nopersistence
   unique_scope = %s : list=statement|row
   range = %s
   page_size = %d
   priority = %s
}
</a:TextTargetItem.Value>
<a:Comment>Default options for creating an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o72">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop index %INDEX%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an index. Example: drop index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o73">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER ID, TABLE ID, OWNER ID, INDEX ID, UNIQUE ID, INDEXTYPE ID, CIDXLIST ...}

select
   i.base_owner,
   i.base_name,
   i.index_owner,
   i.index_name,
   case when(i.unique_rule = &#39;U&#39;) then &#39;unique&#39; else &#39;&#39; end,
   i.storage_structure,
   case when(c.key_sequence = 1) then &#39;&#39; else &#39;, &#39; end
   + c.column_name 
   + case when(c.sort_direction = &#39;A&#39;) then &#39;&#39; else &#39; desc&#39; end
from 
   iiindexes i
   join iiindex_columns c on (i.index_owner = c.index_owner and i.index_name = c.index_name)
where 
   i.system_use = &#39;U&#39;
[  and i.base_owner = %.q:OWNER%]
[  and i.base_name = %.q:TABLE%]
order by 
   i.base_owner,
   i.base_name,
   i.index_owner,
   i.index_name,
   c.key_sequence</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o74">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o75">
<a:Name>IndexType</a:Name>
<a:TextTargetItem.Value>HASH
BTREE
ISAM
HEAP</a:TextTargetItem.Value>
<a:Comment>List of types available for an index</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o76">
<a:Name>Column</a:Name>
<a:Code>COLN</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for columns)
   &quot;COLUMN&quot;       // generated code of the column
   &quot;COLNNO&quot;       // position of the column in the list of columns of the table
   &quot;COLNNAME&quot;     // name of the column
   &quot;COLNCODE&quot;     // code of the column
   &quot;PRIMARY&quot;      // keyword &quot;primary&quot; if the column is primary
   &quot;ISPKEY&quot;       // TRUE if the column is part of the primary key
   &quot;FOREIGN&quot;      // TRUE if the column is part of one foreign key
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o77">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>32</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o78">
<a:Name>EnableDefault</a:Name>
<a:Comment>Default values allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o79">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKC_%.U17:COLUMN%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for a column check parameter</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o80">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%20:COLUMN% %20:DATATYPE%[.Z:[%NOTNULL%? %NOTNULL%:[ with %NULL%]][%NotDefault%? not default:[%WITHDEFAULT%? with default[ %DEFAULT%]:[%DEFAULT%? default[ %DEFAULT%]]]]]
[%CONSTDEFN%]
</a:TextTargetItem.Value>
<a:Comment>Command for defining a table column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o81">
<a:Name>ColumnComment</a:Name>
<a:TextTargetItem.Value>comment on column [%QUALIFIER%]%TABLE%.%COLUMN% is
%.q:COMMENT%</a:TextTargetItem.Value>
<a:Comment>Command for adding a column comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o82">
<a:Name>Create</a:Name>
<a:Comment>Command for adding a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o83">
<a:Name>ModifyColumn</a:Name>
<a:Comment>Command for modifying a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o84">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a column</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o85">
<a:Name>Enable</a:Name>
<a:Comment>Column allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o86">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, DATATYPE, NOTNULL, DEFAULT, NotDefault}

select
   table_owner,
   table_name,
   column_name,
   case
      when (column_internal_datatype = &#39;INTEGER&#39;)  then case(column_length) 
         when 1 then &#39;TINYINT&#39;
         when 2 then &#39;SMALLINT&#39;
         when 4 then &#39;INTEGER&#39;
         when 8 then &#39;BIGINT&#39;
      end
      when (column_internal_datatype = &#39;FLOAT&#39;)  then case(column_length) 
         when 4 then &#39;REAL&#39;
         when 8 then &#39;FLOAT&#39;
      end
      when (column_length = 0) or (column_internal_datatype = &#39;TABLE_KEY&#39;) or (column_internal_datatype = &#39;OBJECT_KEY&#39;) then
         trim(column_internal_datatype)
      else
         trim(column_internal_datatype) 
         + &#39;(&#39; 
         + trim(varchar(column_length)) 
         + case when (column_scale != 0) then &#39;,&#39; + trim(varchar(column_scale)) else &#39;&#39; end
         + &#39;)&#39;
      end,
   case when (column_nulls = &#39;N&#39;) then &#39;not null&#39; else &#39;null&#39; end,
   case when (column_has_default = &#39;Y&#39;) then column_default_val else &#39;&#39; end,
   case when (column_has_default = &#39;N&#39;) then &#39;True&#39; else &#39;False&#39; end
from iicolumns
where 1=1
[  and table_owner = %.q:OWNER%]
[  and table_name = %.q:TABLE%]
order by    
   table_owner,
   table_name,
   column_sequence
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o87">
<a:Name>EnableNotNullWithDflt</a:Name>
<a:Comment>Enables not null with default</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o88">
<a:Name>DefineColnChck</a:Name>
<a:TextTargetItem.Value>   [[constraint %CONSTNAME%] check (%.A:CONSTRAINT%)]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of column check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o89">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, COLUMN ID, COMMENT ...}

select
   c.object_owner,
   c.object_name,
   c.subobject_name,
   c.long_remark
from
   iidb_subcomments c
where  subobject_type = &#39;C&#39;
[  and c.object_owner = %.q:OWNER%]
[  and c.object_name = %.q:TABLE%]
[  and c.subobject name = %.q:COLUMN%]
order by
   c.object_owner,
   c.object_name,
   c.subobject_name,
   c.text_sequence</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:IntegerTargetItem Id="o90">
<a:Name>MaxConstLen</a:Name>
<a:Comment>Maximum constraint name length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o91">
<a:Name>EnableOption</a:Name>
<a:Comment>Physical options allowed  YES/NO</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TargetCategory Id="o92">
<a:Name>Reference</a:Name>
<a:Code>REFR</a:Code>
<a:Comment>The following system variables are available:
   &quot;REFR&quot;         // generated code of the reference
   &quot;REFNAME&quot;      // reference name
   &quot;PARENT&quot;       // generated code of the parent table
   &quot;PNAME&quot;        // name of the parent table
   &quot;PCODE&quot;        // code of the parent table
   &quot;CHILD&quot;        // generated code of the reference
   &quot;CNAME&quot;        // name of the child table
   &quot;CCODE&quot;        // code of the child table
   &quot;PQUALIFIER&quot;   // qualifier of the parent table. See QUALIFIER
   &quot;CQUALIFIER&quot;   // qualifier of the child table. See QUALIFIER
   &quot;REFRNAME&quot;     // Reference name
   &quot;REFRCODE&quot;     // Reference code
   &quot;FKCONSTRAINT&quot; // Reference constraint name (foreign key)
   &quot;PKCONSTRAINT&quot; // constraint name of the parent key used to reference object
   &quot;CKEYCOLUMNS&quot;  // list of parent key columns. Eg: C1, C2, C3
   &quot;FKEYCOLUMNS&quot;  // list of child foreign key columns. Eg:
   &quot;UPDCONST&quot;     // Update declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;DELCONST&quot;     // Delete declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;MINCARD&quot;      // Min cardinality
   &quot;MAXCARD&quot;      // Max cardinality
   &quot;POWNER&quot;       // Parent table owner
   &quot;COWNER&quot;       // child table owner
   &quot;CHCKONCMMT&quot;   // TRUE when check on commit is selected on the reference (ASA 6.0 specific)

For reference joins (couple of column in a reference),
the following system variables are available:
   &quot;CKEYCOLUMN&quot;   // generated code of the parent table column (primary key)
   &quot;FKEYCOLUMN&quot;   // generated code of the child table column (foreign key)
   &quot;PK&quot;           // primary key column generated code
   &quot;PKNAME&quot;       // primary key column name
   &quot;FK&quot;           // foreign key column generated code
   &quot;FKNAME&quot;       // foreign key column name
   &quot;AK&quot;           // alternate key column code (same as PK)
   &quot;AKNAME&quot;       // alternate key column name (same as PKNAME)
   &quot;COLTYPE&quot;      // primary column column datatype
   &quot;DEFAULT&quot;      // foreign key column default value
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o93">
<a:Name>Enable</a:Name>
<a:Comment>Foreign key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o94">
<a:Name>FKAutoIndex</a:Name>
<a:Comment>Foreign key is auto-indexed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o95">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>FK_%.U8:CHILD%_%.U9:REFR%_%.U8:PARENT%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for foreign keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o96">
<a:Name>CheckOnCommit</a:Name>
<a:Comment>Referential integrity test differed after the COMMIT</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o97">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME%] foreign key (%FKEYCOLUMNS%) references %PARENT%[ (%CKEYCOLUMNS%)][
   on update %UPDCONST%][
   on delete %DELCONST%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o98">
<a:Name>DclUpdIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT
CASCADE
SET NULL</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for update</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o99">
<a:Name>DclDelIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT
CASCADE
SET NULL</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for delete</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o100">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add[ constraint %CONSTNAME%] foreign key (%FKEYCOLUMNS%) references %PARENT%[ (%CKEYCOLUMNS%)]
     [%DELCONST%? on delete %DELCONST%: on delete no action][%UPDCONST%? on update %UPDCONST%: on update no action]</a:TextTargetItem.Value>
<a:Comment>Command for adding a foreign key</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o101">
<a:Name>PKey</a:Name>
<a:Code>PKEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o102">
<a:Name>Enable</a:Name>
<a:Comment>Primary key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o103">
<a:Name>PkAutoIndex</a:Name>
<a:Comment>Primary key is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o104">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>PK_%.U27:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for primary keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o105">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]primary key (%PKEYCOLUMNS%)[ %OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o106">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with : composite=yes, separator=yes
{
   &lt;index_specification&gt; : composite=yes
   {
      no index
      index = base table structure
      index = %s
   }
   structure = %s : list=btree|isam|hash|rtree
   fillfactor = %d
   minpages = %d
   maxpages = %d
   leaffill= %d
   nonleaffill= %d
   allocation = %d
   extend = %d
   location = : composite=yes, parenthesis=yes, separator=yes
   {
      &lt;location_name&gt; %s
   }
}

</a:TextTargetItem.Value>
<a:Comment>Available options for creating a primary key</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o107">
<a:Name>Key</a:Name>
<a:Code>KEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;COLUMNS&quot;      // List of columns of the key. Eg: &quot;A, B, C&quot;
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o108">
<a:Name>Enable</a:Name>
<a:Comment>UNIQUE constraint allowed for tables</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o109">
<a:Name>UniqConstAutoIndex</a:Name>
<a:Comment>UNIQUE constraint is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o110">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>AK_%.U18:AKEY%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for alternate keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o111">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]unique (%COLUMNS%)[ %OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o112">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, CONSTNAME, ISPKEY, COLUMNS}

select
   k.schema_name,
   k.table_name,
   k.constraint_name,
   case when (constraint_type = &#39;P&#39;) then &#39;True&#39; else &#39;False&#39; end,
   case
      when (lower(left(k.text_segment,  7)) = &#39; unique&#39;) then 
         substring(k.text_segment from 9 for length(k.text_segment) - 9)
      when (lower(left(k.text_segment, 12)) = &#39; primary key&#39;) then 
         substring(k.text_segment from 14 for length(k.text_segment) - 14 )
      else k.text_segment
   end
from
   iiconstraints k
where
   k.constraint_type in (&#39;P&#39;, &#39;U&#39;)
   and k.text_sequence = 1
[  and k.schema_name = %.q:OWNER%]
[  and k.table_name = %.q:TABLE%]
order by
   k.schema_name,
   k.table_name</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o113">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with : composite=yes, separator=yes
{
   &lt;index_specification&gt; : composite=yes
   {
      no index
      index = base table structure
      index = %s
   }
   structure = %s : list=btree|isam|hash|rtree
   fillfactor = %d
   minpages = %d
   maxpages = %d
   leaffill= %d
   nonleaffill= %d
   allocation = %d
   extend = %d
   location = : composite=yes, parenthesis=yes, separator=yes
   {
      &lt;location_name&gt; %s
   }
}

</a:TextTargetItem.Value>
<a:Comment>Available options for an alternate key</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o114">
<a:Name>View</a:Name>
<a:Code>VIEW</a:Code>
<a:Comment>The following system variables are available:
   &quot;VIEW&quot;         // generated code of the view
   &quot;VIEWNAME&quot;     // view name
   &quot;VIEWCODE&quot;     // view code
   &quot;VIEWCOLN&quot;     // List of columns of the view. Eg: &quot;A, B, C&quot;
   &quot;SQL&quot;          // SQL text of the view. Eg: Select * from T1
   &quot;VIEWCHECK&quot;    // Keyword &quot;with check option&quot; if selected on the view
   &quot;SCRIPT&quot;       // complete view creation order. Eg: create view V1 as select * from T1
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o115">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [.O:[view][table]] [%QUALIFIER%]%VIEW% [(%VIEWCOLN%)] as
%SQL%
[%VIEWCHECK%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a view. Example: create view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o116">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop view %VIEW%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a view. Example: drop view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o117">
<a:Name>ViewComment</a:Name>
<a:Comment>Command for adding a view comment.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o118">
<a:Name>ViewCheck</a:Name>
<a:TextTargetItem.Value>with check option</a:TextTargetItem.Value>
<a:Comment>Option for checking a view</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o119">
<a:Name>Enable</a:Name>
<a:Comment>View allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o120">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, VIEW, COMMENT}

select
   t.table_owner,
   t.table_name,
   &#39;&#39;
from
   iitables t
where t.table_type = &#39;V&#39;
[  and t.table_owner = %.q:OWNER%]</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o121">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, VIEW ID, SCRIPT ...}

select
   v.table_owner,
   v.table_name,
   v.text_segment
from
   iiviews v
where v.view_dml = &#39;S&#39;
[  and v.table_owner = %.q:OWNER%]
[  and v.table_name = %.q:VIEW%]
order by
   v.table_owner,
   v.table_name,
   v.text_sequence</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o122">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a view.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>Select=Sel.
Insert=Ins.
Update=Upd.
Delete=Del.</a:MapTargetItem.Value>
<a:List>Select
Insert
Update
Delete
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o123">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

select 
   a.permit_user, 
   case(locate(lower(a.permit_type), &#39; with grant option&#39;)) 
      when (size(a.permit_type) + 1) then varchar(trim(a.permit_type))
      else varchar(trim(left(a.permit_type, (locate(lower(a.permit_type), &#39; with grant option&#39;)))) || &#39;+&#39;)
   end || &#39;, &#39;
from 
   iiaccess a
where  a.system_use = &#39;U&#39;
   and a.table_name = %.q:TABLE% 
[  and a.table_owner = %.q:OWNER%]
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o124">
<a:Name>User</a:Name>
<a:Code>USER</a:Code>
<a:Comment>The following system variables are available:
   &quot;USER&quot;         // generated code of the user
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o125">
<a:Name>Enable</a:Name>
<a:Comment>User allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o126">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{USER}

select schema_name from iischema</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o127">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create user %USER%
[with[.Z:
[%PASSWORD%? password = %.q:PASSWORD%:[%ExternalPassword%? external_password: nopassword]
][, ][%ExpireDate%? expire_date = %.q:ExpireDate%: noexpire_date
][, ][%Profile%? profile= %.q:Profile%: noprofile
]
]]
</a:TextTargetItem.Value>
<a:Comment>Command for creating a user

][, ][%LimitingSecurityLabel%? limiting_security_label = %.q:LimitingSecurityLabel%: nolimiting_security_label
][, ][%DefaultGroup%? group = %DefaultGroup%: nogroup
not supported ?
</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o128">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop user %USER%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a user</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o129">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o130">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>32</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o131">
<a:Name>Group</a:Name>
<a:Code>GRPE</a:Code>
<a:Comment>Manages the group object.</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o132">
<a:Name>Enable</a:Name>
<a:Comment>Group allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o133">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create group %GROUP%[%R%? with users = (%USERS%)]</a:TextTargetItem.Value>
<a:Comment>Command for creating a group.
Do not generate membership at this time, use the &quot;Bind&quot; item instead.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o134">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop group %GROUP%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a group.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o135">
<a:Name>SqlListQuery</a:Name>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o136">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>alter group %GROUP% add users (%USERS%)</a:TextTargetItem.Value>
<a:Comment>Command for adding a member to a group</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o137">
<a:Name>Unbind</a:Name>
<a:TextTargetItem.Value>alter group %GROUP% drop users (%USERS%)</a:TextTargetItem.Value>
<a:Comment>Command for removing a member from a group</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o138">
<a:Name>SqlListChildrenQuery</a:Name>
<a:Comment>SQL query to list members of the group</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o139">
<a:Name>SqlPermQuery</a:Name>
<a:Comment>Query to reverse privileges</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o140">
<a:Name>BeforeDrop</a:Name>
<a:TextTargetItem.Value>alter group %GROUP% drop all
;
</a:TextTargetItem.Value>
<a:Comment>Commands executed before drop statement</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o141">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>32</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o142">
<a:Name>Permission</a:Name>
<a:Code>PERM</a:Code>
<a:Comment>Manages the permissions on database objects</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o143">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%R%?[%@CLSSCODE%=SQNC?grant %PERMLIST% on sequence [%QUALIFIER%]%OBJECT% to %GRANTEE%[ %GRANTOPTION%]]
[%@CLSSCODE%=PROC?grant %PERMLIST% on procedure [%QUALIFIER%]%OBJECT% to %GRANTEE%[ %GRANTOPTION%]]
[%@CLSSCODE%=VIEW?grant %PERMLIST% on view [%QUALIFIER%]%OBJECT% to %GRANTEE%[ %GRANTOPTION%]]
[%@CLSSCODE%=TABL?grant %PERMLIST% on [table ][%QUALIFIER%]%OBJECT% to %GRANTEE%[ %GRANTOPTION%]]
:grant %PERMLIST% on %.L:@CLSSNAME% [%QUALIFIER%]%OBJECT% to %GRANTEE%[ %GRANTOPTION%]]</a:TextTargetItem.Value>
<a:Comment>Command for granting permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o144">
<a:Name>Drop</a:Name>
<a:Comment>Command for revoking permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o145">
<a:Name>SqlListQuery</a:Name>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o146">
<a:Name>Enable</a:Name>
<a:Comment>Permission allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o147">
<a:Name>GrantOption</a:Name>
<a:TextTargetItem.Value>with grant option</a:TextTargetItem.Value>
<a:Comment>Option for the grant statement.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o148">
<a:Name>Privilege</a:Name>
<a:Comment>Manages the system privileges for a user, role or group</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o149">
<a:Name>System</a:Name>
<a:TextTargetItem.Value>access
create_procedure
create_sequence
create_table
db_admin
lockmode
query_cost_limit
query_cpu_limit
query_io_limit
query_page_limit
query_row_limit
update_syscat
select_syscat
connect_time_limit
idle_time_limit
session_priority
table_statistics
noaccess
nocreate_procedure
nocreate_sequence
nocreate_table
nodb_admin
nolockmode
noquery_cost_limit
noquery_cpu_limit
noquery_io_limit
noquery_page_limit
noquery_row_limit
noupdate_syscat
noselect_syscat
noconnect_time_limit
noidle_time_limit
nosession_priority
notable_statistics
</a:TextTargetItem.Value>
<a:Comment>List of system privileges</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o150">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>grant %PRIVLIST% on database %DATABASE% to %USER%</a:TextTargetItem.Value>
<a:Comment>Command for granting privileges.</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o151">
<a:Name>Enable</a:Name>
<a:Comment>Privilege allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o152">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>revoke %PRIVLIST% on database %DATABASE% from %USER% cascade </a:TextTargetItem.Value>
<a:Comment>Command for revoking privileges.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o153">
<a:Name>Procedure</a:Name>
<a:Code>PROC</a:Code>
<a:Comment>The following system variables are available:
   &quot;PROC&quot;         // generated code of the procedure (also available for trigger when the trigger is implemented with a procedure)
   &quot;FUNC&quot;         // generated code of the procedure if the procedure is a function (with return value)
   &quot;PROCPRMS&quot;     // list of parameters of the procedure (also available for function)
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o154">
<a:Name>Enable</a:Name>
<a:Comment>Procedure allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o155">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create procedure [%QUALIFIER%]%PROC%[(%PROCPRMS%)] as
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a procedure. Example: create procedure %PROC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o156">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop procedure [%QUALIFIER%]%PROC%
</a:TextTargetItem.Value>
<a:Comment>Command for dropping a procedure. Example: drop procedure %PROC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o157">
<a:Name>CustomProc</a:Name>
<a:TextTargetItem.Value>create procedure [%QUALIFIER%]%PROC% (IN &lt;arg&gt; &lt;type&gt;)
begin

end
/</a:TextTargetItem.Value>
<a:Comment>Command for creating a stored procedure</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o158">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, PROC}

select
   p.procedure_owner,
   p.procedure_name
from
   iiprocedures p
where 1=1
   and not exists (select 1 from iirule r where r.rule_dbp_name = p.procedure_name)
   and p.text_sequence = 1
[  and p.procedure_owner = %.q:SCHEMA%]
order by
   p.procedure_owner,
   p.procedure_name</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o159">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>32</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o160">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, PROC ID, SCRIPT  ...}

select
   p.procedure_owner,
   p.procedure_name,
   p.text_segment
from
   iiprocedures p
where 1=1
   and not exists (select 1 from iirule r where r.rule_dbp_name = p.procedure_name)
[  and p.procedure_owner = %.q:OWNER%]
[  and p.procedure_name = %.q:PROC%]
order by
   p.procedure_owner,
   p.procedure_name,
   p.text_sequence
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o161">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:MapTargetItem Id="o162">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a procedure.
The first column is the SQL name of permission (eg: EXECUTE)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>Execute=Exec.</a:MapTargetItem.Value>
<a:List>Execute
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o163">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

select 
   case(a.permit_user) when &#39;&#39; then &#39;public&#39; else a.permit_user end, 
   &#39;execute&#39; || case(locate(lower(a.text_segment), &#39; with grant option&#39;)) when (size(a.text_segment) + 1) then &#39;&#39; else &#39;+&#39; end
from 
   iiproc_access a
where a.object_type = &#39;P&#39;
   and a.object_name = %.q:PROC% 
[  and a.object_owner = %.q:OWNER%]
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o164">
<a:Name>Trigger</a:Name>
<a:Code>TRGR</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
 trigger object specific items
   &quot;ORDER&quot;        // order number of the trigger (to sort the triggers when the DBMS supports more than one trigger of one type)
   &quot;TRIGGER&quot;      // generated code of trigger
   &quot;TRGTYPE&quot;      // trigger type (keywords &quot;beforeinsert&quot;, &quot;afterupdate&quot;, ...)
   &quot;TRGEVENT&quot;     // trigger event (keywords &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;)
   &quot;TRGTIME&quot;      // trigger time (keywords NULL, &quot;before&quot;, &quot;after&quot;)
 inside the body of the trigger, macros redefine variables on objects
   &quot;REFNO&quot;        // reference position in the list of references of the table
 customized error messages management
   &quot;ERRNO&quot;        // error number for standard error
   &quot;ERRMSG&quot;       // error message for standard error
   &quot;MSGTAB&quot;       // name of the table containing user-defined error messages
   &quot;MSGNO&quot;        // in the user-defined error table, name of the column containing the error numbers
   &quot;MSGTXT&quot;       // in the user-defined error table, name of the column containing the error messages
   &quot;SCRIPT&quot;       // body of trigger or procedure
   &quot;TRGDEFN&quot;      // complete body of the trigger definition. Contains variable declarations and body of trigger or procedure
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o165">
<a:Name>Enable</a:Name>
<a:Comment>Trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o166">
<a:Name>EnableMultiTrigger</a:Name>
<a:Comment>Multi trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o167">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create rule [%QUALIFIER%]%TRIGGER% after %TRGEVENT% [%TABLQUALIFIER%]%TABLE%
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a trigger. Example: create trigger on [%QUALIFIER%]%TABLE% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o168">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop rule [%QUALIFIER%]%TRIGGER% </a:TextTargetItem.Value>
<a:Comment>Command for dropping a trigger. Example: drop trigger %TRIGGER%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o169">
<a:Name>Event</a:Name>
<a:TextTargetItem.Value>insert into
delete from
update on
update of</a:TextTargetItem.Value>
<a:Comment>Extended trigger events list.</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o170">
<a:Name>EventDelimiter</a:Name>
<a:Comment>Events separation character.</a:Comment>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o171">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o172">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>32</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o173">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER, TABLE, OWNER, TRIGGER, TRGEVENT}

select
   r.relowner,
   r.relid,
   i.rule_owner,
   i.rule_name,
   case(i.rule_statement) when 1 then &#39;delete&#39; when 2 then &#39;insert&#39; when 4 then &#39;update&#39; else &#39;&#39; end
from
   iirelation  r
   join iirule i on (i.rule_tabbase = r.reltid and i.rule_tabidx = r.reltidx and mod((i.rule_flags/8), 2) = 0)
where 1 = 1
[  and r.relowner = %.q:SCHEMA%]
[  and r.relid = %.q:TABLE%]
union select
   r.relowner,
   r.relid,
   i.rule_dbp_owner,
   i.rule_dbp_name,
   case(i.rule_statement) when 1 then &#39;deleteproc&#39; when 2 then &#39;insertproc&#39; when 4 then &#39;updateproc&#39; else &#39;&#39; end
from
   iirelation  r
   join iirule i on (i.rule_tabbase = r.reltid and i.rule_tabidx = r.reltidx and mod((i.rule_flags/8), 2) = 0)
where 1 = 1
[  and r.relowner = %.q:SCHEMA%]
[  and r.relid = %.q:TABLE%]
order by 1, 2, 3, 4
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o174">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER ID, TABLE ID, OWNER ID, TRIGGER ID, SCRIPT ...}

select
   r.relowner,
   r.relid,
   i.rule_dbp_owner,
   i.rule_dbp_name,
   p.text_segment,
   p.text_sequence
from
   iirelation        r
   join iirule       i on (r.reltid=i.rule_tabbase and r.reltidx=i.rule_tabidx and mod((i.rule_flags/8), 2) = 0)
   join iiprocedures p on (p.procedure_name = i.rule_dbp_name and p.procedure_owner = i.rule_dbp_owner)
where 1=1
[  and r.relowner = %.q:TABLOWNER%]
[  and r.relid = %.q:TABLE%]
[  and i.rule_dbp_owner = %.q:OWNER%]
[  and r.rule_dbp_name = %.q:TRIGGER%]
union select
   r.relowner,
   r.relid,
   i.rule_owner,
   i.rule_name,
   q.txt,
   q.seq
from
   iirelation     r
   join iirule    i on (r.reltid=i.rule_tabbase and r.reltidx=i.rule_tabidx and mod((i.rule_flags/8), 2) = 0)
   join iiqrytext q on (q.txtid1=i.rule_qryid1 and q.txtid2=i.rule_qryid2)
where 1=1
[  and r.relowner = %.q:TABLOWNER%]
[  and r.relid = %.q:TABLE%]
[  and i.rule_owner = %.q:OWNER%]
[  and r.rule_name = %.q:TRIGGER%]
order by 1, 2, 3, 4, 6
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o175">
<a:Name>UseErrorMsgTable</a:Name>
<a:TextTargetItem.Value>select %MSGTXT% into errmsg
   from  %MSGTAB%
   where %MSGNO% = %ERRNO%;
raise error %ERRNO% errmsg;
</a:TextTargetItem.Value>
<a:Comment>Errors handling using an error messages table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o176">
<a:Name>UseErrorMsgText</a:Name>
<a:TextTargetItem.Value>raise error %ERRNO% 
   &#39;%ERRMSG%&#39;;
</a:TextTargetItem.Value>
<a:Comment>Errors handling using fixed error messages</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o177">
<a:Name>Sequence</a:Name>
<a:Code>SQNC</a:Code>
<a:Comment>The following system variables are available:
   &quot;SQNC&quot;         // generated code of the sequence
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o178">
<a:Name>Enable</a:Name>
<a:Comment>Sequence allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o179">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create sequence [%QUALIFIER%]%SQNC%[ %OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command to create a sequence</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o180">
<a:Name>Drop</a:Name>
<a:Comment>Command to drop a sequence</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o181">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>as %s
start with %d
start_with %d
restart with %d
restart_with %d
increment by %d
increment_by %d
maxvalue %d
&lt;nomaxvalue&gt; %s : list=no maxvalue|nomaxvalue
minvalue %d
&lt;nominvalue&gt; %s : list=no minvalue|nominvalue
cache %d
&lt;nocache&gt; %s : list=no cache|nocache
cycle
&lt;nocycle&gt; %s : list=no cycle|nocycle
order
&lt;noorder&gt; %s : list=no order|noorder
</a:TextTargetItem.Value>
<a:Comment>Options for creating a sequence</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o182">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o183">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, SQNC}

select
   s.seq_owner,
   s.seq_name
from
   iisequence s
order by 
   s.seq_owner,
   s.seq_name
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o184">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a sequence.
The first column is the SQL name of permission
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>Next=Next</a:MapTargetItem.Value>
<a:List>Next
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o185">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

select 
   case(a.permit_user) when &#39;&#39; then &#39;public&#39; else a.permit_user end, 
   &#39;next&#39; || case(locate(lower(a.text_segment), &#39; with grant option&#39;)) when (size(a.text_segment) + 1) then &#39;&#39; else &#39;+&#39; end
from 
   iipermits a
where a.object_type = &#39;S&#39;
   and a.object_name = %.q:SQNC% 
[  and a.object_owner = %.q:OWNER%]
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o186">
<a:Name>Role</a:Name>
<a:Code>ROLE</a:Code>
<a:Comment>Manages the role object.</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o187">
<a:Name>Enable</a:Name>
<a:Comment>Role allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o188">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create role %ROLE%
[with[.Z:
[%PASSWORD%? password = %.q:PASSWORD%:[%ExternalPassword%? external_password: nopassword]
][, ][%ExpireDate%? expire_date = %.q:ExpireDate%: noexpire_date
][, ][%Profile%? profile= %.q:Profile%: noprofile
]
]]
</a:TextTargetItem.Value>
<a:Comment>Command for creating a role.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o189">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a role.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o190">
<a:Name>Bind</a:Name>
<a:Comment>Command for assigning a role to a user or another role</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o191">
<a:Name>Unbind</a:Name>
<a:Comment>Command for unassiging a role from a user or another role</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o192">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>32</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o193">
<a:Name>Synonym</a:Name>
<a:Code>SYNM</a:Code>
<a:Comment>Manages the synonym object.</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o194">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create synonym [%QUALIFIER%]%SYNONYM% for [%BASEQUALIFIER%]%BASEOBJECT%</a:TextTargetItem.Value>
<a:Comment>Command for creating a synonym.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o195">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop synonym [%QUALIFIER%]%SYNONYM%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a synonym.</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o196">
<a:Name>Enable</a:Name>
<a:Comment>Synonym allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o197">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>32</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o198">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, SYNONYM, BASEOWNER, BASEOBJECT}

select
   s.synonym_owner,
   s.synonym_name,
   s.table_owner,
   s.table_name
from
   iisynonyms s
where 1 = 1
[  and s.synonym_owner = %.q:SCHEMA%]</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o199">
<a:Name>DataType</a:Name>
<a:Comment>Contains data type translation entries. These entries list the correspondence between internal data types and the target database data types</a:Comment>
<c:Categories>
<o:MapTargetItem Id="o200">
<a:Name>AmcdDataType</a:Name>
<a:Comment>Data types translation table from internal data types to target database data types.
        %n is the length of the data type
        %s is the size of the data type
        %p is the precision of the data type</a:Comment>
<a:MapTargetItem.Value>&lt;UNDEF&gt;=&lt;Undefined&gt;
A=Char
A%n=Char(%n)
VA=Varchar
VA%n=Varchar(%n)
LA=Clob
LVA=Long Varchar
BT=Tinyint
SI=Smallint
I=Integer
LI=Bigint
N=Numeric
N%n=Numeric(%n)
N%s,%p=Numeric(%s,%p)
DC=Decimal
DC%n=Decimal(%n)
DC%s,%p=Decimal(%s,%p)
SF=Float4
F=Float
LF=Float
MN=money
D=Date
T=Date
DT=Date
TS=Date
BL=Smallint
NO=Table_key
BIN%n=Byte
BIN%n=Byte(%n)
LBIN=Long Byte
TXT=Text
MBT=NChar
MBT%n=NChar(%n)
VMBT=NVarchar
VMBT%n=NVarchar(%n)
PIC=Byte Varying
PIC%n=Byte Varying(%n)
BMP=Byte Varying
BMP%n=Byte Varying(%n)
OLE=Byte Varying
OLE%n=Byte Varying(%n)
*=Char(10)</a:MapTargetItem.Value>
<a:List>&lt;UNDEF&gt;
A
A%n
VA
VA%n
LA
LVA
BT
SI
I
LI
N
N%n
N%s,%p
DC
DC%n
DC%s,%p
SF
F
LF
MN
D
T
DT
TS
BL
NO
BIN%n
BIN%n
LBIN
TXT
MBT
MBT%n
VMBT
VMBT%n
PIC
PIC%n
BMP
BMP%n
OLE
OLE%n
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o201">
<a:Name>PhysDataType</a:Name>
<a:Comment>Data types translation table from target database data types to internal data types.</a:Comment>
<a:MapTargetItem.Value>&lt;Undefined&gt;=&lt;UNDEF&gt;
Char(%n)=A%n
Character=A
Character(%n)=A%n
C=A
C(%n)=A%n
Varchar=VA
Varchar(%n)=VA%n
Text=TXT
Character Varying=VA
Character Varying(%n)=VA%n
Clob=LVA
Character Large Object=LVA
Char Large Object=LVA
Long Varchar=LVA
Tinyint=BT
Integer1=BT
Smallint=SI
Integer2=SI
Integer=I
Integer4=I
Bigint=LI
Integer8=LI
Numeric=N
Numeric(%n)=N%n
Numeric(%s,%p)=N%s,%p
Decimal=DC
Decimal(%n)=DC%n
Decimal(%s,%p)=DC%s,%p
Float=F
Float8=F
Double Precision=F
Float4=SF
Real=SF
Date=D
Money=MN
Object_Key=NO
Table_Key=NO
Byte=BIN
Byte(%n)=BIN%n
Byte Varying=PIC
Byte Varying(%n)=PIC%n
Long Byte=LBIN
Blob=LBIN
Binary Large Object=LBIN
Nchar=MBT
Nchar(%n)=MBT%n
Nvarchar=VMBT
Nvarchar(%n)=VMBT%n
Long Nvarchar=LVA
Nclob=LVA
Nchar Large Object=LVA
National Character Large Object=LVA
*=A10</a:MapTargetItem.Value>
<a:List>&lt;Undefined&gt;
Char(%n)
Character
Character(%n)
C
C(%n)
Varchar
Varchar(%n)
Text
Character Varying
Character Varying(%n)
Clob
Character Large Object
Char Large Object
Long Varchar
Tinyint
Integer1
Smallint
Integer2
Integer
Integer4
Bigint
Integer8
Numeric
Numeric(%n)
Numeric(%s,%p)
Decimal
Decimal(%n)
Decimal(%s,%p)
Float
Float8
Double Precision
Float4
Real
Date
Money
Object_Key
Table_Key
Byte
Byte(%n)
Byte Varying
Byte Varying(%n)
Long Byte
Blob
Binary Large Object
Nchar
Nchar(%n)
Nvarchar
Nvarchar(%n)
Long Nvarchar
Nclob
Nchar Large Object
National Character Large Object
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o202">
<a:Name>PhysDttpSize</a:Name>
<a:Comment>Table of storage sizes of target database data type</a:Comment>
</o:MapTargetItem>
<o:MapTargetItem Id="o203">
<a:Name>PhysOdbcDataType</a:Name>
<a:Comment>Data types translation table from target database data types to ODBC data types.</a:Comment>
<a:MapTargetItem.Value>character varying(%n)=VARCHAR(%n)
character varying=VARCHAR
Character(%n)=CHAR(%n)
Character=CHAR
Blob=LONG BYTE
binary large object=LONG BYTE
clob=LONG VARCHAR
character large object=LONG VARCHAR
char large object=LONG VARCHAR
Tinyint=INTEGER1
Integer2=SMALLINT
Integer4=INTEGER
Bigint=INTEGER
Integer8=INTEGER
Numeric(%s,%p)=DECIMAL(%s,%p)
Numeric(%n)=DECIMAL(%n)
Numeric=DECIMAL
Float8=FLOAT
Double Precision=FLOAT
Float4=REAL</a:MapTargetItem.Value>
<a:List>character varying(%n)
character varying
Character(%n)
Character
Blob
binary large object
clob
character large object
char large object
Tinyint
Integer2
Integer4
Bigint
Integer8
Numeric(%s,%p)
Numeric(%n)
Numeric
Float8
Double Precision
Float4
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o204">
<a:Name>OdbcPhysDataType</a:Name>
<a:Comment>Data types translation table from ODBC data types to target database data types.</a:Comment>
<a:MapTargetItem.Value>VARCHAR(1)=Varchar
TEXT(1)=Text
CHAR(1)=Char
DECIMAL(5)=Decimal
C(1)=C
BYTE(1)=Byte
BYTE VARYING(1)=Byte Varying</a:MapTargetItem.Value>
<a:List>VARCHAR(1)
TEXT(1)
CHAR(1)
DECIMAL(5)
C(1)
BYTE(1)
BYTE VARYING(1)
</a:List>
</o:MapTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:ProfileTargetItem Id="o205">
<a:Name>Profile</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TargetCategory Id="o206">
<a:Name>Shared</a:Name>
<a:Code>Shared</a:Code>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TargetCategory>
<o:MetaClassTargetItem Id="o207">
<a:Name>Column</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o208">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o209">
<a:ObjectID>D0AAECFC-4E83-4656-BE72-E3EBFF9B5C4A</a:ObjectID>
<a:Name>NotDefault</a:Name>
<a:Comment>Indicates the column needs a value. This generates the &quot;not default&quot; clause in the sql statement.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o210">
<a:Name>User</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o211">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o212">
<a:ObjectID>6179DC94-FE43-4551-89A6-7CD340281F67</a:ObjectID>
<a:Name>DefaultGroup</a:Name>
<a:Comment>Specifies the default group the user belongs to.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o213">
<a:ObjectID>110DF8AE-F976-4CE8-A783-6773C6D7B5B7</a:ObjectID>
<a:Name>ExpireDate</a:Name>
<a:Comment>Specifies an optional expiration date associated with each user. Any valid date can be used. Once the expiration date is reached, the user is no longer able to log on. If the expire_date clause is omitted, the default is noexpire_date.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o214">
<a:ObjectID>ABFC1E59-C118-4D81-8473-E9D4221ADF44</a:ObjectID>
<a:Name>LimitingSecurityLabel</a:Name>
<a:Comment>Allows a security administrator to restrict the highest security label with which users can connect to Ingres when enforcing mandatory access control (MAC).</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o215">
<a:ObjectID>EB083712-FB13-4D18-9A29-1641D1F3A163</a:ObjectID>
<a:Name>Profile</a:Name>
<a:Comment>Allows a profile to be specified for a particular user. If the profile clause is omitted, the default is noprofile.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o216">
<a:ObjectID>6F626CEF-AC21-43C3-A990-0EABA9BBDFBD</a:ObjectID>
<a:Name>ExternalPassword</a:Name>
<a:Comment>Allows a user&#39;s password to be authenticated externally to Ingres. The password is passed to an external authentication server for authentication.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o217">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o218">
<a:Name>Ingres</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Name=&quot;DefaultGroup&quot; Caption=&quot;Default group&quot; Attribute=&quot;DefaultGroup&quot; AttributeID=&quot;{6179DC94-FE43-4551-89A6-7CD340281F67}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;ExpireDate&quot; Caption=&quot;Expiration date&quot; Attribute=&quot;ExpireDate&quot; AttributeID=&quot;{110DF8AE-F976-4CE8-A783-6773C6D7B5B7}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;LimitingSecurityLabel&quot; Caption=&quot;Limiting security label&quot; Attribute=&quot;LimitingSecurityLabel&quot; AttributeID=&quot;{ABFC1E59-C118-4D81-8473-E9D4221ADF44}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;Profile&quot; Caption=&quot;Profile&quot; Attribute=&quot;Profile&quot; AttributeID=&quot;{EB083712-FB13-4D18-9A29-1641D1F3A163}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;ExternalPassword&quot; Caption=&quot;External password&quot; Attribute=&quot;ExternalPassword&quot; AttributeID=&quot;{6F626CEF-AC21-43C3-A990-0EABA9BBDFBD}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
</c:Categories>
</o:ProfileTargetItem>
</c:Categories>
<c:TriggerItems>
<o:TriggerItem Id="o219">
<a:ObjectID>D880DE67-F78A-421D-93DC-C702FA12627B</a:ObjectID>
<a:Name>DeleteParentCascade</a:Name>
<a:Code>DeleteParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
/*  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when inserting a child in &quot;[%CQUALIFIER%]%CHILD%&quot; */
delete from [%CQUALIFIER%]%CHILD%
   where  .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109758445</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o220">
<a:ObjectID>319A2333-36ED-4B1A-976B-37D5DD60BE37</a:ObjectID>
<a:Name>DeleteParentRestrict</a:Name>
<a:Code>DeleteParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
/*  The cardinality of Parent &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; cannot exceed %MAXCARD% */
select count(*) into numrows
   from   [%CQUALIFIER%]%CHILD%
   where  .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

if (numrows &gt; 0) then
   .ERROR(-1006, &quot;Children still exist in [%CQUALIFIER%]%CHILD%. Cannot delete parent [%PQUALIFIER%]%PARENT%.&quot;)
endif;

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109758494</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o221">
<a:ObjectID>C2A740ED-7251-4DD1-896E-9F74FD17FD0B</a:ObjectID>
<a:Name>DeleteParentSetDefault</a:Name>
<a:Code>DeleteParentSetDefault</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot; */
update [%CQUALIFIER%]%CHILD%
   set   .JOIN(&quot;%FK% = [%DEFAULT%?%DEFAULT%:null]&quot;, &quot;&quot;, &quot;,&quot;)
   where .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759188</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o222">
<a:ObjectID>3E8F6575-7211-4B69-9547-1B26B109B3C5</a:ObjectID>
<a:Name>DeleteParentSetNull</a:Name>
<a:Code>DeleteParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in child &quot;[%CQUALIFIER%]%CHILD%&quot; */
update [%CQUALIFIER%]%CHILD%
   set   .JOIN(&quot;%FK% = null&quot;, &quot;&quot;, &quot;,&quot;)
   where .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR
</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759281</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o223">
<a:ObjectID>3F7D17E0-C65F-4EF1-BB5F-64C653031C8E</a:ObjectID>
<a:Name>InsertChildParentExist</a:Name>
<a:Code>InsertChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT()
/*  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when inserting a child in &quot;[%CQUALIFIER%]%CHILD%&quot; */
if .JOIN(&quot;new_%.14L:FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; then&quot;)
   select count(*) into  numrows
      from  [%PQUALIFIER%]%PARENT%
      where .JOIN(&quot;%PK% = new_%.14L:FK%&quot;, &quot;and   &quot;,&quot;&quot;, &quot;;&quot;)
   if (numrows = 0) then
      .ERROR(1002, &quot;Parent does not exist in [%PQUALIFIER%]%PARENT%. Cannot create child in [%CQUALIFIER%]%CHILD%.&quot;)
   endif;
endif;

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759376</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Parent must exist when inserting child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o224">
<a:ObjectID>953BA056-6941-424F-A77D-F4106D2907DB</a:ObjectID>
<a:Name>InsertTooManyChildren</a:Name>
<a:Code>InsertTooManyChildren</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
/*  The cardinality of Parent &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; cannot exceed %MAXCARD% */
if .JOIN(&quot;new_%.14L:FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; then&quot;)
   select count(*) into cardinality
      from   [%CQUALIFIER%]%CHILD% 
      where .JOIN(&quot;%FK% = new_%.14L:FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)  
   if (cardinality &gt;= %MAXCARD%) then
      .ERROR(-1007, &quot;Child Maximum cardinality exceeded! Cannot create child in [%CQUALIFIER%]%CHILD%.&quot;)
   endif;
endif;

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759397</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot exceed the maximum cardinality constraint when inserting the child</a:Comment>
<a:Declaration>define  cardinality integer;
.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o225">
<a:ObjectID>C3AD6D2C-046C-4145-8ED3-DAF0FEC0013A</a:ObjectID>
<a:Name>UpdateChangeColumn</a:Name>
<a:Code>UpdateChangeColumn</a:Code>
<a:Text>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
/*  Non modifiable column &quot;%COLUMN%&quot; cannot be modified */
if (old_%.14L:COLUMN% != new_%.14L:COLUMN%) then
   .ERROR(-1001, &quot;Non modifiable column [%QUALIFIER%]%TABLE%.%COLUMN% cannot be modified.&quot;)
endif;

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759458</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot modify non modifiable column constraint</a:Comment>
<a:Declaration>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o226">
<a:ObjectID>721AE354-EC57-4ED9-BEC8-E01472C71F0F</a:ObjectID>
<a:Name>UpdateChildChangeParent</a:Name>
<a:Code>UpdateChildChangeParent</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
/*  Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; */
if (.JOIN(&quot;old_%.14L:FK% != new_%.14L:FK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   .ERROR(-1004, &quot;Cannot modify parent code of [%PQUALIFIER%]%PARENT% in child [%CQUALIFIER%]%CHILD%.&quot;)
endif;

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759480</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot change parent constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o227">
<a:ObjectID>5CCB223D-F49E-45E9-8E91-C61AE1C29750</a:ObjectID>
<a:Name>UpdateChildParentExist</a:Name>
<a:Code>UpdateChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT()
/*  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when updating a child in &quot;[%CQUALIFIER%]%CHILD%&quot; */
if .JOIN(&quot;new_%.14L:FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; then&quot;)
   select count(*) into numrows
      from  [%PQUALIFIER%]%PARENT%
      where .JOIN(&quot;%PK% = new_%.14L:FK%&quot;, &quot;and   &quot;,&quot;&quot;, &quot;;&quot;)
   if (numrows = 0) then
      .ERROR(-1003, &quot;[%PQUALIFIER%]%PARENT% does not exist. Cannot modify child in [%CQUALIFIER%]%CHILD%.&quot;)
   endif;
endif;

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759517</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Parent must exist when updating a child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o228">
<a:ObjectID>9FC42C72-0D84-4490-B5E9-3CCD0DDB04F7</a:ObjectID>
<a:Name>UpdateParentCascade</a:Name>
<a:Code>UpdateParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
/*  Modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; for all children in &quot;[%CQUALIFIER%]%CHILD%&quot; */
if (.JOIN(&quot;old_%.14L:PK% != new_%.14L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   update [%CQUALIFIER%]%CHILD%
      set   .JOIN(&quot;%FK% = new_%.14L:PK%&quot;, &quot;&quot;, &quot;,&quot;)
      where .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
endif;

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759536</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o229">
<a:ObjectID>55826D22-9561-45D2-9A47-78A0D45F9CDA</a:ObjectID>
<a:Name>UpdateParentRestrict</a:Name>
<a:Code>UpdateParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
/*  Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot; */
if (.JOIN(&quot;old_%.14L:PK% != new_%.14L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   select count(*) into numrows
      from  [%CQUALIFIER%]%CHILD%
      where .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
   if (numrows &gt; 0) then
      .ERROR(-1005, &quot;Children still exist in [%CQUALIFIER%]%CHILD%. Cannot modify parent code in [%PQUALIFIER%]%PARENT%.&quot;)
   endif;
endif;

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759569</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o230">
<a:ObjectID>BEBD7186-163E-4340-960F-90D2E08DB9D8</a:ObjectID>
<a:Name>UpdateParentSetDefault</a:Name>
<a:Code>UpdateParentSetDefault</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot; */
if (.JOIN(&quot;old_%.14L:PK% != new_%.14L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   update [%CQUALIFIER%]%CHILD%
      set   .JOIN(&quot;%FK% = [%DEFAULT%?%DEFAULT%:null]&quot;, &quot;&quot;, &quot;,&quot;)
      where .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
endif;

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759617</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o231">
<a:ObjectID>0248FD04-0DD2-4FB6-A156-1D28AE35CFB2</a:ObjectID>
<a:Name>UpdateParentSetNull</a:Name>
<a:Code>UpdateParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in &quot;[%CQUALIFIER%]%CHILD%&quot; */
if (.JOIN(&quot;old_%.14L:PK% != new_%.14L:PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;) then&quot;)
   update [%CQUALIFIER%]%CHILD%
      set   .JOIN(&quot;%FK% = null&quot;, &quot;&quot;, &quot;,&quot;)
      where .JOIN(&quot;%FK% = old_%.14L:PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
endif;

.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759636</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o232">
<a:ObjectID>D0DB99A0-33DE-4FBF-B26C-91865FFF1F42</a:ObjectID>
<a:Name>UpdateTooManyChildren</a:Name>
<a:Code>UpdateTooManyChildren</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
/*  The cardinality of Parent &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; cannot exceed %MAXCARD% */
if .JOIN(&quot;new_%.14L:FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; then&quot;)
   select count(*) into cardinality
      from  [%CQUALIFIER%]%CHILD%
      where .JOIN(&quot;%FK% = new_%.14L:FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)  
   if (cardinality &gt;= %MAXCARD%) then
      .ERROR(-1007, &quot;Child maximum cardinality exceeded! Cannot modify child in [%CQUALIFIER%]%CHILD%.&quot;)
   endif;
endif;
.ENDFOR</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109759666</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot exceed the maximum cardinality constraint when updating the child</a:Comment>
<a:Declaration>define  cardinality integer;
.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
</c:TriggerItems>
<c:TriggerTemplates>
<o:TriggerTemplate Id="o233">
<a:ObjectID>7F9F0B35-F126-4D0E-A1DE-2209AEF65382</a:ObjectID>
<a:Name>DeleteProc</a:Name>
<a:Code>DeleteProc</a:Code>
<a:Text>create procedure [%QUALIFIER%]%PROC%(.PKCOLN(&quot;old_%.14L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;)&quot;)
as
declare
    .DeclDeleteParentRestrict
    .DeclDeleteParentCascade
    .DeclDeleteParentSetNull
    .DeclDeleteParentSetDefault
    errmsg     = char(255) not null;
    numrows    = integer;

begin
    .DeleteParentRestrict
    .DeleteParentCascade
    .DeleteParentSetNull
    .DeleteParentSetDefault
end
</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109760456</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete procedure</a:Comment>
<a:Time/>
<a:Event>DeleteProc</a:Event>
<a:TriggerName>pd_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o219"/>
<o:TriggerItem Ref="o220"/>
<o:TriggerItem Ref="o221"/>
<o:TriggerItem Ref="o222"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o234">
<a:ObjectID>817DBF5A-D9D3-441F-A616-D60D54DF7774</a:ObjectID>
<a:Name>DeleteTrigger</a:Name>
<a:Code>DeleteTrigger</a:Code>
<a:Text>create rule [%QUALIFIER%]%TRIGGER% after delete on [%TABLQUALIFIER%]%TABLE%
referencing old as old_del
   for each row execute procedure [%QUALIFIER%]%PROC%(.PKCOLN(&quot;old_%.14L:COLUMN% = old_del.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;)&quot;)</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109694048</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete trigger</a:Comment>
<a:Time/>
<a:Event>Delete</a:Event>
<a:TriggerName>td_%.L:TABLE%</a:TriggerName>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o235">
<a:ObjectID>A114FED7-BDC3-4283-9F37-6DE10A227CCA</a:ObjectID>
<a:Name>InsertProc</a:Name>
<a:Code>InsertProc</a:Code>
<a:Text>create procedure [%QUALIFIER%]%PROC%(.FKCOLN(&quot;new_%.14L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;)&quot;)
as
declare
    .DeclInsertChildParentExist
    .DeclInsertTooManyChildren
    errmsg     = char(255) not null;
    numrows    = integer;

begin
    .InsertChildParentExist
    .InsertTooManyChildren
end
</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109760468</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Insert procedure</a:Comment>
<a:Time/>
<a:Event>InsertProc</a:Event>
<a:TriggerName>pi_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o223"/>
<o:TriggerItem Ref="o224"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o236">
<a:ObjectID>90BD82EF-CB9F-4FC6-A663-5E6BB2292703</a:ObjectID>
<a:Name>InsertTrigger</a:Name>
<a:Code>InsertTrigger</a:Code>
<a:Text>create rule [%QUALIFIER%]%TRIGGER% after insert into [%TABLQUALIFIER%]%TABLE%
referencing new as new_ins
   for each row execute procedure [%QUALIFIER%]%PROC%(.FKCOLN(&quot;new_%.14L:COLUMN% = new_ins.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;)&quot;)
</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109694301</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Insert trigger</a:Comment>
<a:Time/>
<a:TriggerName>ti_%.L:TABLE%</a:TriggerName>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o237">
<a:ObjectID>6B117171-A34B-445F-85C6-4D94653D5ACB</a:ObjectID>
<a:Name>UpdateProc</a:Name>
<a:Code>UpdateProc</a:Code>
<a:Text>create procedure [%QUALIFIER%]%PROC%(.INCOLN(&quot;old_%.14L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;,&quot;)
                        .INCOLN(&quot;new_%.14L:COLUMN% %COLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;)&quot;)
as
declare
    .DeclUpdateChangeColumn
    .DeclUpdateChildParentExist
    .DeclUpdateTooManyChildren
    .DeclUpdateChildChangeParent
    .DeclUpdateParentRestrict
    .DeclUpdateParentCascade
    .DeclUpdateParentSetNull
    .DeclUpdateParentSetDefault
    errmsg     = char(255) not null;
    numrows    = integer;

begin
    .UpdateChangeColumn
    .UpdateChildParentExist
    .UpdateTooManyChildren
    .UpdateChildChangeParent
    .UpdateParentRestrict
    .UpdateParentCascade
    .UpdateParentSetNull
    .UpdateParentSetDefault
end
</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109760482</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update procedure</a:Comment>
<a:Time/>
<a:Event>UpdateProc</a:Event>
<a:TriggerName>pu_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o225"/>
<o:TriggerItem Ref="o226"/>
<o:TriggerItem Ref="o227"/>
<o:TriggerItem Ref="o228"/>
<o:TriggerItem Ref="o229"/>
<o:TriggerItem Ref="o230"/>
<o:TriggerItem Ref="o231"/>
<o:TriggerItem Ref="o232"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o238">
<a:ObjectID>B2A5D7D3-A3C9-4D6D-B9CD-6F300C31093A</a:ObjectID>
<a:Name>UpdateTrigger</a:Name>
<a:Code>UpdateTrigger</a:Code>
<a:Text>create rule [%QUALIFIER%]%TRIGGER% after update of [%TABLQUALIFIER%]%TABLE%
referencing new as new_upd old as old_upd
   for each row execute procedure [%QUALIFIER%]%PROC%(.INCOLN(&quot;old_%.14L:COLUMN% = old_upd.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;,&quot;)
                                          .INCOLN(&quot;new_%.14L:COLUMN% = new_upd.%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;, &quot;)&quot;)
</a:Text>
<a:CreationDate>1109692416</a:CreationDate>
<a:Creator>mledier</a:Creator>
<a:ModificationDate>1109696305</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update trigger</a:Comment>
<a:Time/>
<a:Event>Update</a:Event>
<a:TriggerName>tu_%.L:TABLE%</a:TriggerName>
</o:TriggerTemplate>
</c:TriggerTemplates>
</o:DBMS>

</DBMS>