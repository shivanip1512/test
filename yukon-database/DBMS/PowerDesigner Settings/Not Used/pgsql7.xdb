<?xml version="1.0" encoding="UTF-8"?>
<?PowerDesigner AppLocale="UTF16" Code="PGSQL73" Family="ANSI" Name="PostgreSQL 7.3" signature="XDB_XML" version="12.0.0.1642"?>
<!-- do not edit this file -->

<DBMS xmlns:a="attribute" xmlns:c="collection" xmlns:o="object">

<o:DBMS Id="o1">
<a:ObjectID>510023D3-F07A-4932-B759-33C7D13522EA</a:ObjectID>
<a:Name>PostgreSQL 7.3</a:Name>
<a:Code>PGSQL73</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1063353502</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Family>ANSI</a:Family>
<a:CheckGlobalScript>&#39;******************************************************************************
&#39;* Purpose:  This VB-Script holds global definitions shared by all the custom-
&#39;*            checks scripts of the model extension.
&#39;******************************************************************************

Option Explicit &#39; This is to ensure all used variables are defined

</a:CheckGlobalScript>
<c:Categories>
<o:TargetCategory Id="o2">
<a:Name>General</a:Name>
<a:Comment>Target DBMS identification</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o3">
<a:Name>SqlSupport</a:Name>
<a:Comment>SQL syntax allowed. This does not impact the script generation, but it impacts the SQL Preview</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o4">
<a:Name>EnableCheck</a:Name>
<a:Comment>Determines if the generation of check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o5">
<a:Name>Enableconstname</a:Name>
<a:Comment>Determines if constraint names are used during the generation</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o6">
<a:Name>UniqConstName</a:Name>
<a:Comment>Determines if unique constraint names for objects are authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o7">
<a:Name>Script</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the Script generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o8">
<a:Name>Sql</a:Name>
<a:Comment>Contains sub-categories Syntax, Format, File and Keywords. Each sub-category contains entries whose values define general syntax for the database</a:Comment>
<c:Categories>
<o:TargetCategory Id="o9">
<a:Name>Syntax</a:Name>
<a:Comment>Contains general parameters for SQL syntax</a:Comment>
<c:Categories>
<o:CharacterTargetItem Id="o10">
<a:Name>Terminator</a:Name>
<a:Comment>End of command character</a:Comment>
<a:CharacterTargetItem.Value>;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o11">
<a:Name>BlockTerminator</a:Name>
<a:Comment>End of block character</a:Comment>
</o:StringTargetItem>
<o:CharacterTargetItem Id="o12">
<a:Name>Delimiter</a:Name>
<a:Comment>Field separation character. Example: col1, col2, col3</a:Comment>
<a:CharacterTargetItem.Value>,</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o13">
<a:Name>Quote</a:Name>
<a:Comment>Character used to enclose string values</a:Comment>
<a:CharacterTargetItem.Value>&#39;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o14">
<a:Name>SqlContinue</a:Name>
<a:Comment>Continuation character</a:Comment>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o15">
<a:Name>LineComment</a:Name>
<a:Comment>Characters used to enclose a single line comment</a:Comment>
<a:StringTargetItem.Value>--</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o16">
<a:Name>BlockComment</a:Name>
<a:Comment>Characters used to enclose a multi-line comment</a:Comment>
<a:StringTargetItem.Value>/* */</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o17">
<a:Name>UseBlockTerm</a:Name>
<a:Comment>Use end of block character by default</a:Comment>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o18">
<a:Name>Format</a:Name>
<a:Comment>Contains entries that define script formatting</a:Comment>
<c:Categories>
<o:StringTargetItem Id="o19">
<a:Name>IllegalChar</a:Name>
<a:Comment>Invalid characters for names</a:Comment>
<a:StringTargetItem.Value>&quot; +-*/!=&lt;&gt;&#39;&quot;()&quot;.</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o20">
<a:Name>UpperCaseOnly</a:Name>
<a:Comment>Uppercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o21">
<a:Name>LowerCaseOnly</a:Name>
<a:Comment>Lowercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o22">
<a:Name>EnableOwnerPrefix</a:Name>
<a:Comment>Object codes can have a prefix made of the object owner code</a:Comment>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o23">
<a:Name>File</a:Name>
<a:Comment>Contains header, footer and usage text entries used during the generation</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o24">
<a:Name>Header</a:Name>
<a:Comment>Header text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o25">
<a:Name>Footer</a:Name>
<a:Comment>Footer text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o26">
<a:Name>EnableMultiFile</a:Name>
<a:Comment>Multi-script allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:StringTargetItem Id="o27">
<a:Name>ScriptExt</a:Name>
<a:Comment>Main script extension in database generation</a:Comment>
<a:StringTargetItem.Value>sql</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o28">
<a:Name>TableExt</a:Name>
<a:Comment>Other scripts extension in database generation</a:Comment>
<a:StringTargetItem.Value>tab</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o29">
<a:Name>StartCommand</a:Name>
<a:Comment>Command for executing a script</a:Comment>
</o:StringTargetItem>
<o:TextTargetItem Id="o30">
<a:Name>Usage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter
  (3) Run the database creation script:
        %NAMESCRIPT%</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in database generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o31">
<a:Name>Usage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter
  (3) Run the database creation scripts</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in database generation</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o32">
<a:Name>Keywords</a:Name>
<a:Comment>Contains the list of reserved words and functions available in SQL</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o33">
<a:Name>ReservedDefault</a:Name>
<a:TextTargetItem.Value>CURRENT_USER
SESSION_USER
USER
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
NULL</a:TextTargetItem.Value>
<a:Comment>Reserved default values</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o34">
<a:Name>GroupFunc</a:Name>
<a:TextTargetItem.Value>avg()
count()
max()
min()
sum()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions to use with group keywords.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o35">
<a:Name>NumberFunc</a:Name>
<a:TextTargetItem.Value>abs()
degrees()
exp()
ln()
log()
pi()
pow()
radians()
round()
sqrt()
cbrt()
trunc()
float()
float4()
integer()
</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used on numbers</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o36">
<a:Name>CharFunc</a:Name>
<a:TextTargetItem.Value>char()
char_length()
character_length()
initcap()
lower()
lpad()
ltrim()
octet_length()
position()
rpad()
rtrim()
substr()
substring()
text()
textpos()
translate()
trim()
upper()
varchar()
</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for characters and strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o37">
<a:Name>DateFunc</a:Name>
<a:TextTargetItem.Value>abstime()
age()
date_part()
date_trunc()
interval()
isfinite()
reltime()
timestamp()
</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for dates</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o38">
<a:Name>ConvertFunc</a:Name>
<a:TextTargetItem.Value>to_char()
to_date()
to_timestamp()
to_number()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used to convert values between hex and integer and handling strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o39">
<a:Name>OtherFunc</a:Name>
<a:TextTargetItem.Value>coalesce()
nullif()
area()
box()
center()
circle()
diameter()
height()
isclosed()
isoldpath()
isopen()
length()
lseg()
npoint()
path()
pclose()
point()
polygon()
popen()
radius()
revertpoly()
upgradepath()
upgradepoly()
width()
broadcast()
host()
masklen()
netmask()
</a:TextTargetItem.Value>
<a:Comment>List of other SQL functions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o40">
<a:Name>ListOperators</a:Name>
<a:TextTargetItem.Value>-
!
!!
#
%
&amp;
*
*=
/
@
^
|
|/
||
||/
~
+
&lt;
&lt; all
&lt; any
&lt;&lt;
&lt;=
&lt;= all
&lt;= any
&lt;&gt;
&lt;&gt; all
&lt;&gt; any
=
= all
= any
=*
&gt;
&gt; all
&gt; any
&gt;=
&gt;= all
&gt;= any
&gt;&gt;
and
between
exists
in
is
is not
like
not
not between
not exists
not in
not like
or</a:TextTargetItem.Value>
<a:Comment>List of operators for comparing values, boolean, and various semantic operators</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o41">
<a:Name>Commit</a:Name>
<a:TextTargetItem.Value>commit</a:TextTargetItem.Value>
<a:Comment>Command for validating the transaction by OBDC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o42">
<a:Name>ReservedWord</a:Name>
<a:TextTargetItem.Value>ALL
ANALYSE
ANALYZE
AND
ANY
AS
ASC
AUTHORIZATION
BETWEEN
BIGINT
BINARY
BIT
BOOLEAN
BOTH
CASE
CAST
CHAR
CHARACTER
CHECK
COALESCE
COLLATE
COLUMN
CONSTRAINT
CONVERT
CREATE
CROSS
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_USER
DEC
DECIMAL
DEFAULT
DEFERRABLE
DESC
DISTINCT
DO
ELSE
END
EXCEPT
EXISTS
EXTRACT
FALSE
FLOAT
FOR
FOREIGN
FREEZE
FROM
FULL
GRANT
GROUP
HAVING
ILIKE
IN
INITIALLY
INNER
INT
INTEGER
INTERSECT
INTERVAL
INTO
IS
ISNULL
JOIN
LEADING
LEFT
LIKE
LIMIT
LOCALTIME
LOCALTIMESTAMP
NATURAL
NCHAR
NEW
NONE
NOT
NOTNULL
NULL
NULLIF
NUMERIC
OFF
OFFSET
OLD
ON
ONLY
OR
ORDER
OUTER
OVERLAPS
OVERLAY
PLACING
POSITION
PRIMARY
REAL
REFERENCES
RIGHT
ROW
SELECT
SESSION_USER
SETOF
SIMILAR
SMALLINT
SOME
SUBSTRING
TABLE
THEN
TIME
TIMESTAMP
TO
TRAILING
TREAT
TRIM
TRUE
UNION
UNIQUE
USER
USING
VARCHAR
VERBOSE
WHEN
WHERE</a:TextTargetItem.Value>
<a:Comment>Reserved words</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o43">
<a:Name>Objects</a:Name>
<a:Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:Comment>
<c:Categories>
<o:TargetCategory Id="o44">
<a:Name>Table</a:Name>
<a:Code>TABL</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLE&quot;        // generated code of the table
   &quot;TNAME&quot;        // name of the table
   &quot;TCODE&quot;        // code of the table
   &quot;TLABL&quot;        // comment of the table
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;TABLDEFN&quot;     // complete body of the table definition. Contains definition of columns, checks and keys
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o45">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>31</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o46">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKT_%.U26:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for check of table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o47">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create table %TABLE% (
%TABLDEFN%
)</a:TextTargetItem.Value>
<a:Comment>Command for creating a table. Example: create table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o48">
<a:Name>Options</a:Name>
<a:Comment>Available options for creating a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o49">
<a:Name>TableComment</a:Name>
<a:TextTargetItem.Value>comment on table %TABLE% is
%.q:COMMENT%</a:TextTargetItem.Value>
<a:Comment>Command for adding a table comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o50">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop table %TABLE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table. Example: drop table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o51">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>alter table %OLDTABL% 
   rename to %NEWTABL%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o52">
<a:Name>AlterTableHeader</a:Name>
<a:Comment>Alter table header</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o53">
<a:Name>AlterTableFooter</a:Name>
<a:Comment>Alter table footer</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o54">
<a:Name>DefineTableCheck</a:Name>
<a:TextTargetItem.Value>check (%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of table check constraints</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o55">
<a:Name>Enable</a:Name>
<a:Comment>Table allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o56">
<a:Name>AddTableCheck</a:Name>
<a:TextTargetItem.Value>alter table %TABLE%
   add check (%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script for modifying table constraints within an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o57">
<a:Name>DropTableCheck</a:Name>
<a:TextTargetItem.Value>alter table %TABLE%
   delete check</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o58">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, TABLE_TYPE}

select
   u.usename,
   t.relname,
   case substring(t.relname from 1 for 3)
      when &#39;pg_&#39; then &#39;SYSTEM TABLE&#39; else &#39;TABLE&#39;
   end::varchar
from
   pg_catalog.pg_class t,
   pg_catalog.pg_shadow u
where t.relkind = &#39;r&#39;
   and t.relowner = u.usesysid
[  and u.usename = %.q:SCHEMA%]
order by 1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o59">
<a:Name>Index</a:Name>
<a:Code>INDX</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
   &quot;INDEX&quot;        // generated code of the index
   &quot;INDEXNAME&quot;    // index name
   &quot;INDEXCODE&quot;    // index code
   &quot;UNIQUE&quot;       // keyword &quot;unique&quot; when the index is unique
   &quot;INDEXTYPE&quot;    // index type (available only for a few DBMS)
   &quot;INDEXKEY&quot;     // keywords &quot;primary&quot;, &quot;unique&quot; or &quot;foreign&quot; depending on the index origin
   &quot;CIDXLIST&quot;     // list of index columns. Eg: A asc, B desc, C asc
   &quot;CLUSTER&quot;      // keyword &quot;cluster&quot; when the index is cluster
For index columns, the following system variables are available:
   &quot;ASC&quot;          // keywords &quot;ASC&quot; or &quot;DESC&quot; depending on sort order
   &quot;ISASC&quot;        // TRUE if the index column sort is ascending
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o60">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>31</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o61">
<a:Name>MaxColIndex</a:Name>
<a:Comment>Maximum number of columns in an index</a:Comment>
<a:IntegerTargetItem.Value>16</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o62">
<a:Name>Enable</a:Name>
<a:Comment>Index allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o63">
<a:Name>EnableAscDesc</a:Name>
<a:Comment>ASC, DESC keywords allowed</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o64">
<a:Name>UniqName</a:Name>
<a:Comment>Unique index name in the database</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o65">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [%UNIQUE%] index %INDEX% on %TABLE%[ using %INDEXTYPE%] (
%CIDXLIST%
)</a:TextTargetItem.Value>
<a:Comment>Command for creating an index. Example: create index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o66">
<a:Name>AddColIndex</a:Name>
<a:TextTargetItem.Value>%COLUMN%</a:TextTargetItem.Value>
<a:Comment>Command for defining an index column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o67">
<a:Name>Options</a:Name>
<a:Comment>Default options for creating an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o68">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop index %INDEX%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an index. Example: drop index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o69">
<a:Name>IndexType</a:Name>
<a:TextTargetItem.Value>BTREE
RTREE
HASH</a:TextTargetItem.Value>
<a:Comment>List of types available for an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o70">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, INDEX ID, UNIQUE ID, CIDXLIST ...}

select
   u.usename,
   t.relname,
   i.relname,
   case (x.indisunique)
      when true then &#39;unique&#39; else &#39;&#39;
   end::varchar,
   a.attname || &#39;,&#39;::varchar
from
   pg_user u,
   pg_class t,
   pg_class i,
   pg_index x,
   pg_attribute a
where 1=1
   and t.relowner=u.usesysid
   and x.indrelid=t.oid
   and x.indexrelid=i.oid
   and a.attrelid=i.oid
   and x.indisprimary is false
[  and u.usename=%.q:OWNER%]
[  and t.relname=%.q:TABLE%]
order by 
   u.usename,
   t.relname,
   i.relname,
   a.attnum
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o71">
<a:Name>Sequence</a:Name>
<a:Code>SQNC</a:Code>
<a:Comment>The following system variables are available:
   &quot;SQNC&quot;         // generated code of the sequence
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o72">
<a:Name>Enable</a:Name>
<a:Comment>Sequence allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o73">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create sequence %SQNC%
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command to create a sequence</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o74">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop sequence %SQNC%</a:TextTargetItem.Value>
<a:Comment>Command to drop a sequence</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o75">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>increment %d
minvalue %d
maxvalue %d
start %d
cache %d
cycle
</a:TextTargetItem.Value>
<a:Comment>Options for creating a sequence</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o76">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for sequence options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o77">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{SQNC}

select 
   s.relname 
from 
   pg_class s
where 
   s.relkind = &#39;S&#39;
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o78">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{SQNC, OPTIONS}

select 
   s.sequence_name,
   (&#39;increment &#39; || (increment_by::varchar))::varchar
from 
   [%QUALIFIER%]%SQNC% s
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o79">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>rename %OLDNAME% to %NEWNAME%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a sequence</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o80">
<a:Name>Column</a:Name>
<a:Code>COLN</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for columns)
   &quot;COLUMN&quot;       // generated code of the column
   &quot;COLNNO&quot;       // position of the column in the list of columns of the table
   &quot;COLNNAME&quot;     // name of the column
   &quot;COLNCODE&quot;     // code of the column
   &quot;PRIMARY&quot;      // keyword &quot;primary&quot; if the column is primary
   &quot;ISPKEY&quot;       // TRUE if the column is part of the primary key
   &quot;FOREIGN&quot;      // TRUE if the column is part of one foreign key
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o81">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>31</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o82">
<a:Name>EnableDefault</a:Name>
<a:Comment>Default values allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o83">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKC_%.U17:COLUMN%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for a column check parameter</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o84">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%20:COLUMN% [%IDENTITY%?SERIAL:%20:DATATYPE%][ %NOTNULL%][ %NULL%][ default %DEFAULT%] 
      [[constraint %CONSTNAME% ]check (%.A:CONSTRAINT%)]</a:TextTargetItem.Value>
<a:Comment>Command for defining a table column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o85">
<a:Name>ColumnComment</a:Name>
<a:TextTargetItem.Value>comment on column %TABLE%.%COLUMN% is
%.q:COMMENT%
</a:TextTargetItem.Value>
<a:Comment>Command for adding a column comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o86">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>alter table %TABLE%
   rename %OLDCOLN% to %NEWCOLN%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o87">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table %TABLE%
   add[ column] %COLUMN% %DATATYPE%</a:TextTargetItem.Value>
<a:Comment>Command for adding a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o88">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a column
Not yet supported. Should be
alter table %TABLE% drop[ column] %COLUMN% [restrict | cascade]
</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o89">
<a:Name>Enable</a:Name>
<a:Comment>Column allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o90">
<a:Name>ModifyColnDflt</a:Name>
<a:TextTargetItem.Value>alter table %TABLE%
   alter[ column] %COLUMN% [%DEFAULT%?set default %DEFAULT%:drop default]</a:TextTargetItem.Value>
<a:Comment>Command for modifying a column default in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o91">
<a:Name>EnableIdentity</a:Name>
<a:Comment>Identity keyword entry support. Identity columns are serial counters maintains by the database</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o92">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, DTTPCODE, LENGTH, PREC, ISMAND, DEFAULT}

select 
   u.usename,
   t.relname,
   c.attname,
   d.typname,
   case(c.atttypmod &gt;&gt; 16) when 0 then (c.atttypmod - ((c.atttypmod &gt;&gt; 16)&lt;&lt;16) - 4) else (c.atttypmod &gt;&gt; 16) end,
   case(c.atttypmod &gt;&gt; 16) when 0 then 0 else (c.atttypmod - 65536 * (c.atttypmod / 65536) - 4) end,
   c.attnotnull,
   case(c.atthasdef) 
      when true then (select adsrc::varchar from pg_attrdef f where f.adrelid = t.oid and f.adnum = c.attnum)::varchar
      else &#39;&#39; end::varchar
from
   pg_catalog.pg_type d,
   pg_catalog.pg_attribute c,
   pg_catalog.pg_class t,
   pg_catalog.pg_shadow u
where t.relkind = &#39;r&#39;
   and t.relowner = u.usesysid
   and c.attrelid = t.oid
   and c.attnum &gt; 0
   and c.attisdropped is false
   and d.oid = c.atttypid
[  and u.usename = %.q:OWNER%]
[  and t.relname = %.q:TABLE%]
order by 1, 2, c.attnum</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:IntegerTargetItem Id="o93">
<a:Name>MaxConstLen</a:Name>
<a:Comment>Maximum constraint name length</a:Comment>
<a:IntegerTargetItem.Value>31</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o94">
<a:Name>EnableOption</a:Name>
<a:Comment>Physical options allowed  YES/NO</a:Comment>
</o:BooleanTargetItem>
<o:TargetCategory Id="o95">
<a:Name>Reference</a:Name>
<a:Code>REFR</a:Code>
<a:Comment>The following system variables are available:
   &quot;REFR&quot;         // generated code of the reference
   &quot;REFNAME&quot;      // reference name
   &quot;PARENT&quot;       // generated code of the parent table
   &quot;PNAME&quot;        // name of the parent table
   &quot;PCODE&quot;        // code of the parent table
   &quot;CHILD&quot;        // generated code of the reference
   &quot;CNAME&quot;        // name of the child table
   &quot;CCODE&quot;        // code of the child table
   &quot;PQUALIFIER&quot;   // qualifier of the parent table. See QUALIFIER
   &quot;CQUALIFIER&quot;   // qualifier of the child table. See QUALIFIER
   &quot;REFRNAME&quot;     // Reference name
   &quot;REFRCODE&quot;     // Reference code
   &quot;FKCONSTRAINT&quot; // Reference constraint name (foreign key)
   &quot;PKCONSTRAINT&quot; // constraint name of the parent key used to reference object
   &quot;CKEYCOLUMNS&quot;  // list of parent key columns. Eg: C1, C2, C3
   &quot;FKEYCOLUMNS&quot;  // list of child foreign key columns. Eg:
   &quot;UPDCONST&quot;     // Update declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;DELCONST&quot;     // Delete declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;MINCARD&quot;      // Min cardinality
   &quot;MAXCARD&quot;      // Max cardinality
   &quot;POWNER&quot;       // Parent table owner
   &quot;COWNER&quot;       // child table owner
   &quot;CHCKONCMMT&quot;   // TRUE when check on commit is selected on the reference (ASA 6.0 specific)

For reference joins (couple of column in a reference),
the following system variables are available:
   &quot;CKEYCOLUMN&quot;   // generated code of the parent table column (primary key)
   &quot;FKEYCOLUMN&quot;   // generated code of the child table column (foreign key)
   &quot;PK&quot;           // primary key column generated code
   &quot;PKNAME&quot;       // primary key column name
   &quot;FK&quot;           // foreign key column generated code
   &quot;FKNAME&quot;       // foreign key column name
   &quot;AK&quot;           // alternate key column code (same as PK)
   &quot;AKNAME&quot;       // alternate key column name (same as PKNAME)
   &quot;COLTYPE&quot;      // primary column column datatype
   &quot;DEFAULT&quot;      // foreign key column default value
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o96">
<a:Name>Enable</a:Name>
<a:Comment>Foreign key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o97">
<a:Name>FKAutoIndex</a:Name>
<a:Comment>Foreign key is auto-indexed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o98">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>FK_%.U8:CHILD%_%.U9:REFR%_%.U8:PARENT%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for foreign keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o99">
<a:Name>CheckOnCommit</a:Name>
<a:Comment>Referential integrity test differed after the COMMIT</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o100">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]foreign key (%FKEYCOLUMNS%)
   references %PARENT%[ (%CKEYCOLUMNS%)]
  [ on delete %DELCONST%][ on update %UPDCONST%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o101">
<a:Name>DclUpdIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT
CASCADE
SET NULL
SET DEFAULT
NONE</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for update</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o102">
<a:Name>DclDelIntegrity</a:Name>
<a:TextTargetItem.Value>RESTRICT
CASCADE
SET NULL
SET DEFAULT
NONE</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for delete</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o103">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table %TABLE%
   add [constraint %CONSTNAME% ]foreign key (%FKEYCOLUMNS%)
      references %PARENT%[ (%CKEYCOLUMNS%)]
     [ on delete %DELCONST%][ on update %UPDCONST%]
</a:TextTargetItem.Value>
<a:Comment>Command for adding a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o104">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{POWNER, PARENT, COWNER, CHILD, CONSTNAME, UPDCONST, DELCONST, FKEYCOLUMNS, CKEYCOLUMNS}

select
   u.usename,
   p.relname,
   v.usename,
   c.relname,
   k.conname,
   case(k.confupdtype)
      when &#39;r&#39; then &#39;restrict&#39;
      when &#39;c&#39; then &#39;cascade&#39;
      when &#39;n&#39; then &#39;set null&#39;
      when &#39;d&#39; then &#39;set default&#39;
      when &#39;a&#39; then &#39;no action&#39;
   end::varchar,
   case(k.confdeltype)
      when &#39;r&#39; then &#39;restrict&#39;
      when &#39;c&#39; then &#39;cascade&#39;
      when &#39;n&#39; then &#39;set null&#39;
      when &#39;d&#39; then &#39;set default&#39;
      when &#39;a&#39; then &#39;no action&#39;
   end::varchar,
   substring(pg_get_constraintdef(k.oid), 1 + length(&#39;FOREIGN KEY (&#39;), strpos(pg_get_constraintdef(k.oid), &#39;) REFERENCES &#39;) - length(&#39;FOREIGN KEY (&#39;) - 1)::varchar,
   substring(pg_get_constraintdef(k.oid), strpos(pg_get_constraintdef(k.oid), &#39;) REFERENCES &#39;||p.relname) + 1 + length(&#39;) REFERENCES &#39;||p.relname), strpos(pg_get_constraintdef(k.oid), &#39;) ON &#39;) - (strpos(pg_get_constraintdef(k.oid), &#39;) REFERENCES &#39;||p.relname) + 1 + length(&#39;) REFERENCES &#39;||p.relname)))::varchar
from 
   pg_catalog.pg_constraint k,
   pg_catalog.pg_class p,
   pg_catalog.pg_class c,
   pg_catalog.pg_shadow u,
   pg_catalog.pg_shadow v
where 1=1
   and k.contype = &#39;f&#39;
   and k.conrelid = c.oid
   and k.confrelid = p.oid
   and u.usesysid=p.relowner
   and v.usesysid=c.relowner
[  and v.usename=%.q:OWNER%]
[  and c.relname=%.q:TABLE%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o105">
<a:Name>PKey</a:Name>
<a:Code>PKEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o106">
<a:Name>Enable</a:Name>
<a:Comment>Primary key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o107">
<a:Name>PkAutoIndex</a:Name>
<a:Comment>Primary key is auto-indexed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o108">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>PK_%.U27:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for primary keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o109">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]primary key (%PKEYCOLUMNS%)</a:TextTargetItem.Value>
<a:Comment>Command for defining a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o110">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table %TABLE%
   add [constraint %CONSTNAME% ]primary key (%PKEYCOLUMNS%)
</a:TextTargetItem.Value>
<a:Comment>Command for adding a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o111">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>&lt;checktime&gt; %s : list=initially immediate|initially deferred, default=initially immediate
&lt;deferrable&gt; %s : list=deferrable|not deferrable, default=not deferrable</a:TextTargetItem.Value>
<a:Comment>Available options for creating a primary key</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o112">
<a:Name>Key</a:Name>
<a:Code>KEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;COLUMNS&quot;      // List of columns of the key. Eg: &quot;A, B, C&quot;
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o113">
<a:Name>Enable</a:Name>
<a:Comment>UNIQUE constraint allowed for tables</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o114">
<a:Name>UniqConstAutoIndex</a:Name>
<a:Comment>UNIQUE constraint is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o115">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>AK_%.U18:AKEY%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for alternate keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o116">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]unique (%COLUMNS%)</a:TextTargetItem.Value>
<a:Comment>Command for defining an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o117">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table %TABLE%
   [constraint %CONSTNAME% ]unique (%COLUMNS%)</a:TextTargetItem.Value>
<a:Comment>Command for adding an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o118">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>&lt;checktime&gt; %s : list=initially immediate|initially deferred, default=initially immediate
&lt;deferrable&gt; %s : list=deferrable|not deferrable, default=not deferrable
</a:TextTargetItem.Value>
<a:Comment>Available options for an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o119">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, CONSTNAME ID, ISPKEY ID, COLUMNS ...}

select
   u.usename,
   t.relname,
   i.relname,
   x.indisprimary,
   a.attname || &#39;,&#39;::varchar
from
   pg_user u,
   pg_class t,
   pg_class i,
   pg_index x,
   pg_attribute a
where 1=1
   and t.relowner=u.usesysid
   and x.indrelid=t.oid
   and x.indexrelid=i.oid
   and a.attrelid=i.oid
   and x.indisprimary is true
[  and u.usename=%.q:OWNER%]
[  and t.relname=%.q:TABLE%]
order by 
   u.usename,
   t.relname,
   i.relname,
   a.attnum
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o120">
<a:Name>Database</a:Name>
<a:Code>DTBS</a:Code>
<a:Comment>The following system variables are available:
   &quot;DATABASE&quot;     // generated code of the database
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o121">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create database %DATABASE%</a:TextTargetItem.Value>
<a:Comment>Command for creating a database. Example: create database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o122">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with location = %s</a:TextTargetItem.Value>
<a:Comment>Available options for creating a database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o123">
<a:Name>OpenDatabase</a:Name>
<a:Comment>Command for opening a database. Example: open database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o124">
<a:Name>CloseDatabase</a:Name>
<a:Comment>Command for closing a database. Example: close database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o125">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop database %DATABASE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a database. Example: drop database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o126">
<a:Name>Enable</a:Name>
<a:Comment>Database allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o127">
<a:Name>View</a:Name>
<a:Code>VIEW</a:Code>
<a:Comment>The following system variables are available:
   &quot;VIEW&quot;         // generated code of the view
   &quot;VIEWNAME&quot;     // view name
   &quot;VIEWCODE&quot;     // view code
   &quot;VIEWCOLN&quot;     // List of columns of the view. Eg: &quot;A, B, C&quot;
   &quot;SQL&quot;          // SQL text of the view. Eg: Select * from T1
   &quot;VIEWCHECK&quot;    // Keyword &quot;with check option&quot; if selected on the view
   &quot;SCRIPT&quot;       // complete view creation order. Eg: create view V1 as select * from T1
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o128">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create view %VIEW% as
%SQL%</a:TextTargetItem.Value>
<a:Comment>Command for creating a view. Example: create view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o129">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop view %VIEW%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a view. Example: drop view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o130">
<a:Name>ViewComment</a:Name>
<a:TextTargetItem.Value>comment on view %VIEW% is
%.q:COMMENT%
</a:TextTargetItem.Value>
<a:Comment>Command for adding a view comment.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o131">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, VIEW}

select
   u.usename,
   t.relname
from
   pg_catalog.pg_class t,
   pg_catalog.pg_shadow u
where t.relkind = &#39;v&#39;
   and t.relowner = u.usesysid
[  and u.usename = %.q:SCHEMA%]
order by 1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o132">
<a:Name>Enable</a:Name>
<a:Comment>View allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o133">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, VIEW, SQL}

select
   u.usename,
   v.relname,
   pg_get_viewdef(v.oid)::varchar
from
   pg_catalog.pg_class v,
   pg_catalog.pg_shadow u
where 
   (v.relkind = &#39;v&#39;::&quot;char&quot;)
   and v.relowner = u.usesysid
[  and u.usename = %.q:OWNER%]
[  and v.relname = %.q:VIEW%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o134">
<a:Name>Domain</a:Name>
<a:Code>PDMDOMN</a:Code>
<a:Comment>The following system variables are available:
   &quot;DOMAIN&quot;       // generated code of the domain (also available for columns)
SQL Server specific domain system variables:
   &quot;RULENAME&quot;     // name of the rule object associated with the domain
   &quot;DEFAULTNAME&quot;  // name of the default object associated with the domain
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o135">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create type %DOMAIN% (
   input=%ExtTypeInput%,
   output=%ExtTypeOutput%,
   internallength=%ExtTypeLength%[,
   default=%DEFAULT%][,
   element=%ExtTypeElement%][,
   delimiter=%.q:ExtTypeDelimiter%][,
   send=%ExtTypeSend%][,
   receive=%ExtTypeReceive%][%ExtTypePassedByValue%?, passedbyvalue]
)</a:TextTargetItem.Value>
<a:Comment>Command for creating a user defined data type</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o136">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o137">
<a:Name>Enable</a:Name>
<a:Comment>User defined data types allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o138">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop type %DOMAIN%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a user defined data type</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o139">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, DOMAIN, DTTPCODE}

select
   u.usename,
   d.typname,
   t.typname
from
   pg_catalog.pg_shadow u,
   pg_catalog.pg_type d,
   pg_catalog.pg_type t
where
   d.typbasetype &lt;&gt; 0
   and u.usesysid = d.typowner
[  and u.usename = %.q:SCHEMA%]
order by 1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o140">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o141">
<a:Name>Procedure</a:Name>
<a:Code>PROC</a:Code>
<a:Comment>The following system variables are available:
   &quot;PROC&quot;         // generated code of the procedure (also available for trigger when the trigger is implemented with a procedure)
   &quot;FUNC&quot;         // generated code of the procedure if the procedure is a function (with return value)
   &quot;PROCPRMS&quot;     // list of parameters of the procedure (also available for function)
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o142">
<a:Name>Enable</a:Name>
<a:Comment>Procedure allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o143">
<a:Name>EnableFunc</a:Name>
<a:Comment>Function allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o144">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>31</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o145">
<a:Name>MaxFuncLen</a:Name>
<a:Comment>Function name length</a:Comment>
<a:IntegerTargetItem.Value>31</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o146">
<a:Name>DropFunc</a:Name>
<a:TextTargetItem.Value>drop function %FUNC% ( &lt;type&gt; )</a:TextTargetItem.Value>
<a:Comment>Command for dropping a function. Example: drop function %FUNC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o147">
<a:Name>CustomFunc</a:Name>
<a:TextTargetItem.Value>CREATE FUNCTION %FUNC% ( &lt;type&gt; )
    RETURNS &lt;type&gt;
    AS &#39;%SCRIPT%&#39;
    LANGUAGE &#39;%ProcLanguage%&#39;
;</a:TextTargetItem.Value>
<a:Comment>Command for creating a function</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o148">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, PROC, FUNC}

select
   u.usename,
   p.proname,
   case(pronargs) when 0 then &#39;&#39; else p.proname end
from
   pg_catalog.pg_proc p,
   pg_catalog.pg_language l,
   pg_catalog.pg_shadow u
where 
   l.oid = p.prolang
   and p.proowner = u.usesysid
   and l.lanname &lt;&gt; &#39;internal&#39;
[  and u.usename = %.q:SCHEMA%]</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o149">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, PROC, ProcLanguage, TRGDEFN}

select
   u.usename,
   p.proname,
   l.lanname,
   p.prosrc::varchar
from
   pg_catalog.pg_proc p,
   pg_catalog.pg_language l,
   pg_catalog.pg_shadow u
where 
   l.oid = p.prolang
   and p.proowner = u.usesysid
   and l.lanname &lt;&gt; &#39;internal&#39;
[  and u.usename = %.q:OWNER%]
[  and p.proname = %.q:PROC%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o150">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create procedure %PROC%[(%PROCPRMS%)]
as %.q:TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a procedure. Example: create procedure %PROC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o151">
<a:Name>CreateFunc</a:Name>
<a:TextTargetItem.Value>create function %FUNC%[(%PROCPRMS%)]
as %.q:TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a function. Example: create function %FUNC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o152">
<a:Name>User</a:Name>
<a:Code>USER</a:Code>
<a:Comment>The following system variables are available:
   &quot;USER&quot;         // generated code of the user
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o153">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>31</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o154">
<a:Name>Enable</a:Name>
<a:Comment>User allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o155">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{USER}

select usename from pg_catalog.pg_user
[where UPPER(usename) = %.qU:SCHEMA%]</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o156">
<a:Name>Trigger</a:Name>
<a:Code>TRGR</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
 trigger object specific items
   &quot;ORDER&quot;        // order number of the trigger (to sort the triggers when the DBMS supports more than one trigger of one type)
   &quot;TRIGGER&quot;      // generated code of trigger
   &quot;TRGTYPE&quot;      // trigger type (keywords &quot;beforeinsert&quot;, &quot;afterupdate&quot;, ...)
   &quot;TRGEVENT&quot;     // trigger event (keywords &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;)
   &quot;TRGTIME&quot;      // trigger time (keywords NULL, &quot;before&quot;, &quot;after&quot;)
 inside the body of the trigger, macros redefine variables on objects
   &quot;REFNO&quot;        // reference position in the list of references of the table
 customized error messages management
   &quot;ERRNO&quot;        // error number for standard error
   &quot;ERRMSG&quot;       // error message for standard error
   &quot;MSGTAB&quot;       // name of the table containing user-defined error messages
   &quot;MSGNO&quot;        // in the user-defined error table, name of the column containing the error numbers
   &quot;MSGTXT&quot;       // in the user-defined error table, name of the column containing the error messages
   &quot;SCRIPT&quot;       // body of trigger or procedure
   &quot;TRGDEFN&quot;      // complete body of the trigger definition. Contains variable declarations and body of trigger or procedure
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o157">
<a:Name>EnableMultiTrigger</a:Name>
<a:Comment>Multi trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o158">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop trigger %TRIGGER% on [%QUALIFIER%]%TABLE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a trigger. Example: drop trigger %TRIGGER%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o159">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, TRIGGER, TRGEVENT, TRGTIME}

select
   u.usename,
   t.relname,
   g.tgname, 
   case (g.tgtype &amp; 28) 
      when 4 then &#39;insert&#39; when 8 then &#39;delete&#39; when 16 then &#39;update&#39;
      when 12 then &#39;insert or delete&#39; when 20 then &#39;insert or update&#39; when 24 then &#39;delete or update&#39; 
      when 28 then &#39;insert or delete or update&#39; else &#39;&#39; end::varchar,
   case (g.tgtype &amp; 2) 
      when 2 then &#39;before&#39; when 0 then &#39;after&#39; else &#39;&#39; end::varchar
from
   pg_catalog.pg_trigger g,
   pg_catalog.pg_class t,
   pg_catalog.pg_shadow u
where t.relkind = &#39;r&#39;
   and t.relowner = u.usesysid
   and g.tgrelid = t.oid
[  and u.usename = %.q:SCHEMA%]
order by 1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o160">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, TRIGGER, TRGEVENT, TRGTIME, TRGDEFN}

select
   u.usename,
   t.relname,
   g.tgname,
   case (g.tgtype &amp; 28) 
      when 4 then &#39;insert&#39; when 8 then &#39;delete&#39; when 16 then &#39;update&#39;
      when 12 then &#39;insert or delete&#39; when 20 then &#39;insert or update&#39; when 24 then &#39;delete or update&#39; 
      when 28 then &#39;insert or delete or update&#39; else &#39;&#39; end::varchar,
   case (g.tgtype &amp; 2) 
      when 2 then &#39;before&#39; when 0 then &#39;after&#39; else &#39;&#39; end::varchar,
   (case(g.tgtype &amp; 1) when 1 then &#39; for each row&#39; else &#39; for each statement&#39; end
   ||&#39; execute procedure &#39; || p.proname)::varchar
from
   pg_catalog.pg_proc p,
   pg_catalog.pg_trigger g,
   pg_catalog.pg_class t,
   pg_catalog.pg_shadow u
where t.relkind = &#39;r&#39;
   and t.relowner = u.usesysid
   and g.tgrelid = t.oid
   and g.tgfoid = p.oid
[  and u.usename = %.q:SCHEMA%]
[  and t.relname = %.q:TABLE%]
[  and g.tgname = %.q:TRIGGER%]
order by 1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o161">
<a:Name>UseErrorMsgTable</a:Name>
<a:TextTargetItem.Value>let errno  = %ERRNO%;
select %MSGTXT%
into   errmsg
from   %MSGTAB%
where  %MSGNO% = %ERRNO%;
raise exception -746, 0, errmsg;</a:TextTargetItem.Value>
<a:Comment>Errors handling using an error messages table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o162">
<a:Name>UseErrorMsgText</a:Name>
<a:TextTargetItem.Value>let errno  = %ERRNO%;
let errmsg = &quot;%ERRMSG%&quot;;
raise exception -746, 0, errmsg;</a:TextTargetItem.Value>
<a:Comment>Errors handling using fixed error messages</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o163">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create trigger %TRIGGER% %TRGTIME% %TRGEVENT% on [%QUALIFIER%]%TABLE%
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a trigger. Example: create trigger on [%QUALIFIER%]%TABLE% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o164">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o165">
<a:Name>DefaultTriggerName</a:Name>
<a:TextTargetItem.Value>%TEMPLATE%_%.L:TABLE%</a:TextTargetItem.Value>
<a:Comment>Default trigger name</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o166">
<a:Name>Enable</a:Name>
<a:Comment>Trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:StringTargetItem Id="o167">
<a:Name>EventDelimiter</a:Name>
<a:Comment>Events separation character.</a:Comment>
<a:StringTargetItem.Value>or</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o168">
<a:Name>Time</a:Name>
<a:TextTargetItem.Value>before
after</a:TextTargetItem.Value>
<a:Comment>Extended trigger times list.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o169">
<a:Name>Event</a:Name>
<a:TextTargetItem.Value>insert
delete
update</a:TextTargetItem.Value>
<a:Comment>Extended trigger events list.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o170">
<a:Name>DataType</a:Name>
<a:Comment>Contains data type translation entries. These entries list the correspondence between internal data types and the target database data types</a:Comment>
<c:Categories>
<o:MapTargetItem Id="o171">
<a:Name>AmcdDataType</a:Name>
<a:Comment>Data types translation table from internal data types to target database data types.
        %n is the length of the data type
        %s is the size of the data type
        %p is the precision of the data type</a:Comment>
<a:MapTargetItem.Value>&lt;UNDEF&gt;=&lt;Undefined&gt;
A%n=CHAR(%n)
VA%n=VARCHAR(%n)
LA=VARCHAR(1)
LA%n=VARCHAR(%n)
LVA=VARCHAR(1)
LVA%n=VARCHAR(%n)
BT=INT2
BT%n=INT2
SI=INT2
I=INT4
LI=INT8
N=NUMERIC
N%n=NUMERIC(%n)
N%s,%p=NUMERIC(%s,%p)
DC=DECIMAL
DC%n=DECIMAL(%n)
DC%s,%p=DECIMAL(%s,%p)
SF=FLOAT4
F=FLOAT8
F%n=FLOAT8
LF=FLOAT8
MN=MONEY
MN%n=MONEY
MN%s,%p=MONEY
D=DATE
T=TIME
DT=DATE
TS=DATE
BL=BOOL
NO=SERIAL
NO%n=SERIAL
BIN%n=CHAR(%n)
LBIN=CHAR
LBIN%n=CHAR(%n)
TXT=TEXT
TXT%n=TEXT
MBT=CHAR
MBT%n=CHAR(%n)
VMBT=VARCHAR(254)
VMBT%n=VARCHAR(%n)
PIC=CHAR(254)
PIC%n=CHAR(%n)
BMP=CHAR(254)
BMP%n=CHAR(%n)
OLE=CHAR(254)
OLE%n=CHAR(%n)
*=CHAR(10)</a:MapTargetItem.Value>
<a:List>&lt;UNDEF&gt;
A%n
VA%n
LA
LA%n
LVA
LVA%n
BT
BT%n
SI
I
LI
N
N%n
N%s,%p
DC
DC%n
DC%s,%p
SF
F
F%n
LF
MN
MN%n
MN%s,%p
D
T
DT
TS
BL
NO
NO%n
BIN%n
LBIN
LBIN%n
TXT
TXT%n
MBT
MBT%n
VMBT
VMBT%n
PIC
PIC%n
BMP
BMP%n
OLE
OLE%n
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o172">
<a:Name>PhysDataType</a:Name>
<a:Comment>Data types translation table from target database data types to internal data types.</a:Comment>
<a:MapTargetItem.Value>&lt;Undefined&gt;=&lt;UNDEF&gt;
DECIMAL=DC
DECIMAL(%n)=DC%n
DECIMAL(%s,%p)=DC%s,%p
FLOAT4=F%7
FLOAT8=F%16
INT2=SI
INT4=I
INT8=LI
NUMERIC=N
NUMERIC(%n)=N%n
NUMERIC(%s,%p)=N%s,%p
SERIAL=NO
MONEY=MN
CHAR=A1
CHAR(%n)=A%n
TEXT=TXT
VARCHAR(%n)=VA%n
TIMESTAMP=TS
TIMESTAMP WITH TIME ZONE=TS
INTERVAL=DT
DATE=D
TIME=T
TIME WITH TIME ZONE=T
BOOL=BL
POINT=
LINE=
LSEG=
BOX=
PATH=
POLYGON=
CIRCLE=
CIDR=
INET=
*=A10</a:MapTargetItem.Value>
<a:List>&lt;Undefined&gt;
DECIMAL
DECIMAL(%n)
DECIMAL(%s,%p)
FLOAT4
FLOAT8
INT2
INT4
INT8
NUMERIC
NUMERIC(%n)
NUMERIC(%s,%p)
SERIAL
MONEY
CHAR
CHAR(%n)
TEXT
VARCHAR(%n)
TIMESTAMP
TIMESTAMP WITH TIME ZONE
INTERVAL
DATE
TIME
TIME WITH TIME ZONE
BOOL
POINT
LINE
LSEG
BOX
PATH
POLYGON
CIRCLE
CIDR
INET
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o173">
<a:Name>PhysDttpSize</a:Name>
<a:Comment>Table of storage sizes of target database data type</a:Comment>
</o:MapTargetItem>
<o:MapTargetItem Id="o174">
<a:Name>OdbcPhysDataType</a:Name>
<a:Comment>Data types translation table from ODBC data types to target database data types.</a:Comment>
<a:MapTargetItem.Value>bpchar(%n)=char(%n)</a:MapTargetItem.Value>
<a:List>bpchar(%n)
</a:List>
</o:MapTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:ProfileTargetItem Id="o175">
<a:Name>Profile</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TargetCategory Id="o176">
<a:Name>Shared</a:Name>
<a:Code>Shared</a:Code>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o177">
<a:TypePublicName>ExtendedAttributeTypeTargetItem</a:TypePublicName>
<a:Name>Extended Attribute Types</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTypeTargetItem Id="o178">
<a:ObjectID>844EAA94-E205-41DD-A9F7-6A7D0AB5D736</a:ObjectID>
<a:Name>ProcLanguageList</a:Name>
<a:Comment>Predefined list of language that the function is implemented in. (See also Extended Attribute ProcLanguage.)</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.Value>sql</a:ExtendedAttributeTypeTargetItem.Value>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>sql
c
internal</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:TargetCategory>
<o:MetaClassTargetItem Id="o179">
<a:Name>PhysicalDomain</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o180">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o181">
<a:ObjectID>59BE3133-F8E9-42F2-9236-7B7A70CB97D4</a:ObjectID>
<a:Name>ExtTypeInput</a:Name>
<a:Comment>The name of a function, created by CREATE FUNCTION, which converts data from its external form to the type&#39;s internal form.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o182">
<a:ObjectID>83FEB362-6D06-4272-BDAF-7634A3997C98</a:ObjectID>
<a:Name>ExtTypeOutput</a:Name>
<a:Comment>The name of a function, created by CREATE FUNCTION, which converts data from its internal form to a form suitable for display.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o183">
<a:ObjectID>4D99EF29-5806-466A-BEAD-C5545B01FF76</a:ObjectID>
<a:Name>ExtTypeLength</a:Name>
<a:Comment>A literal value, which specifies the internal length of the new type.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>10</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o184">
<a:ObjectID>B764FDF3-C960-45B4-B9AF-3259D1CC0605</a:ObjectID>
<a:Name>ExtTypeElement</a:Name>
<a:Comment>The type being created is an array; this specifies the type of the array elements.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o185">
<a:ObjectID>FF137D50-1801-4028-BBD7-4C98AFA1DE86</a:ObjectID>
<a:Name>ExtTypeDelimiter</a:Name>
<a:Comment>The delimiter character for the array.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o186">
<a:ObjectID>8F10592A-5478-4233-813A-4854879D6DAE</a:ObjectID>
<a:Name>ExtTypeSend</a:Name>
<a:Comment>The name of a function, created by CREATE FUNCTION, which converts data of this type into a form suitable for transmission to another machine.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o187">
<a:ObjectID>65C3A631-0B3C-44B1-817A-E23F655BA9F7</a:ObjectID>
<a:Name>ExtTypeReceive</a:Name>
<a:Comment>The name of a function, created by CREATE FUNCTION, which converts data of this type from a form suitable for transmission from another machine to internal form.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o188">
<a:ObjectID>1E119281-6A4E-4005-859E-BA96D1F0C707</a:ObjectID>
<a:Name>ExtTypePassedByValue</a:Name>
<a:Comment>indicates that operators and functions which use this data type should be passed an argument by value rather than by reference.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.Value>FALSE</a:ExtendedAttributeTargetItem.Value>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o189">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o190">
<a:Name>PostgreSQL</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtTypeLength&quot; AttributeID=&quot;{4D99EF29-5806-466A-BEAD-C5545B01FF76}&quot; Name=&quot;ExtTypeLength&quot; Caption=&quot;Length&quot; GrayHiddenAttributes=&quot;No&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtTypeElement&quot; AttributeID=&quot;{B764FDF3-C960-45B4-B9AF-3259D1CC0605}&quot; Name=&quot;ExtTypeElement&quot; Caption=&quot;Array Element type&quot; GrayHiddenAttributes=&quot;No&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtTypeDelimiter&quot; AttributeID=&quot;{FF137D50-1801-4028-BBD7-4C98AFA1DE86}&quot; Name=&quot;ExtTypeDelimiter&quot; Caption=&quot;Array delimiter&quot; GrayHiddenAttributes=&quot;No&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtTypePassedByValue&quot; AttributeID=&quot;{1E119281-6A4E-4005-859E-BA96D1F0C707}&quot; Name=&quot;ExtTypePassedByValue&quot; Caption=&quot;By Value&quot; GrayHiddenAttributes=&quot;No&quot; /&gt;
   &lt;Separator Name=&quot;Separator1&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtTypeInput&quot; AttributeID=&quot;{59BE3133-F8E9-42F2-9236-7B7A70CB97D4}&quot; Name=&quot;ExtTypeInput&quot; Caption=&quot;Input function&quot; GrayHiddenAttributes=&quot;No&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtTypeOutput&quot; AttributeID=&quot;{83FEB362-6D06-4272-BDAF-7634A3997C98}&quot; Name=&quot;ExtTypeOutput&quot; Caption=&quot;Output function&quot; GrayHiddenAttributes=&quot;No&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtTypeSend&quot; AttributeID=&quot;{8F10592A-5478-4233-813A-4854879D6DAE}&quot; Name=&quot;ExtTypeSend&quot; Caption=&quot;Send function&quot; GrayHiddenAttributes=&quot;No&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtTypeReceive&quot; AttributeID=&quot;{65C3A631-0B3C-44B1-817A-E23F655BA9F7}&quot; Name=&quot;ExtTypeReceive&quot; Caption=&quot;Receive function&quot; GrayHiddenAttributes=&quot;No&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o191">
<a:Name>Procedure</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o192">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o193">
<a:ObjectID>410E077F-C401-4FFB-A3E7-6CDC3DA7BF7B</a:ObjectID>
<a:Name>ProcLanguage</a:Name>
<a:Comment>The name of the language that the function is implemented in. May be SQL, C, internal, or the
name of a user-defined procedural language. (See also extended attribute type ProcLanguageList.)</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<a:ExtendedAttributeTargetItem.Value>sql</a:ExtendedAttributeTargetItem.Value>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o178"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o194">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o195">
<a:Name>PostgreSQL</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;GroupBox Name=&quot;GroupBox1&quot;   Caption=&quot;Language&quot; ControlAsLabel=&quot;No&quot; &gt;
      &lt;StaticText Name=&quot;StaticText1&quot; Caption=&quot;Choose here the name of the language that the function is implemented in.&quot; /&gt;
      &lt;StaticText Name=&quot;StaticText3&quot; Caption=&quot;May be SQL, C, internal, or the name of a user-defined procedural language.&quot; /&gt;
      &lt;ExtendedAttribute Name=&quot;ProcLanguage&quot; Caption=&quot;Language&quot; Attribute=&quot;ProcLanguage&quot; AttributeID=&quot;{410E077F-C401-4FFB-A3E7-6CDC3DA7BF7B}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;/GroupBox&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
</c:Categories>
</o:ProfileTargetItem>
<o:TargetCategory Id="o196">
<a:Name>Odbc</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the ODBC generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o197">
<a:Name>Objects</a:Name>
<a:Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:Comment>
<c:Categories>
<o:TargetCategory Id="o198">
<a:Name>Qualifier</a:Name>
<a:Comment>Manages the use of qualifier in ODBC reverse engineering</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o199">
<a:Name>Enable</a:Name>
<a:Comment>Allows using the qualifier combo box during ODBC reverse engineering</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o200">
<a:Name>SqlListQuery</a:Name>
<a:Comment>Query to retrieve qualifier during ODBC reverse engineering</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o201">
<a:Name>Label</a:Name>
<a:Comment>Label for &lt;All&gt; in qualifier selection list</a:Comment>
<a:StringTargetItem.Value>All catalogs</a:StringTargetItem.Value>
</o:StringTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:DBMS>

</DBMS>