<?xml version="1.0" encoding="UTF-8"?>
<?PowerDesigner AppLocale="UTF16" Code="MSSQLSRV2005" Family="SQL SERVER;MICROSOFT" Name="Microsoft SQL Server 2005" signature="XDB_XML" version="12.0.0.1692"?>
<!-- do not edit this file -->

<DBMS xmlns:a="attribute" xmlns:c="collection" xmlns:o="object">

<o:DBMS Id="o1">
<a:ObjectID>030105E8-1DFA-4990-B2C8-DEB36D9D8D09</a:ObjectID>
<a:Name>Microsoft SQL Server 2005</a:Name>
<a:Code>MSSQLSRV2005</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1131622028</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Family>SQL SERVER;MICROSOFT</a:Family>
<a:CheckGlobalScript>&#39;******************************************************************************
&#39;* Purpose:  This VB-Script holds global definitions shared by all the custom-
&#39;*            checks scripts of the model extension.
&#39;******************************************************************************

Option Explicit &#39; This is to ensure all used variables are defined

function GetDatatypeName(sDatatype)
   if (instr(sDatatype, &quot;(&quot;) &gt; 0) then
      GetDatatypeName = lcase(rtrim(left(sDatatype, instr(sDatatype, &quot;(&quot;) - 1)))
   else
      GetDatatypeName = lCase(sDatatype)
   end if
end function

Function CanSetNameCode(pObj, sName, sCode)
   CanSetNameCode = (pObj.CanSetAttribute(&quot;Name&quot;, sName, &quot;&quot;) and pObj.CanSetAttribute(&quot;Code&quot;, sCode, &quot;&quot;))
End Function

Function C2Bool(v)
   if (IsObject(v)) then
      C2Bool = not(v is Nothing)
   elseif (CStr(v) = &quot;&quot;) then
      C2Bool = False
   else
      C2Bool = CBool(v)
   end if
end Function</a:CheckGlobalScript>
<c:Categories>
<o:TargetCategory Id="o2">
<a:Name>General</a:Name>
<a:Comment>Target DBMS identification</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o3">
<a:Name>SqlSupport</a:Name>
<a:Comment>SQL syntax allowed. This does not impact the script generation, but it impacts the SQL Preview</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o4">
<a:Name>EnableMultiCheck</a:Name>
<a:Comment>Determines if the generation of multiple check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o5">
<a:Name>EnableCheck</a:Name>
<a:Comment>Determines if the generation of check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o6">
<a:Name>Enableconstname</a:Name>
<a:Comment>Determines if constraint names are used during the generation</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o7">
<a:Name>UniqConstName</a:Name>
<a:Comment>Determines if unique constraint names for objects are authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o8">
<a:Name>Script</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the Script generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o9">
<a:Name>Sql</a:Name>
<a:Comment>Contains sub-categories Syntax, Format, File and Keywords. Each sub-category contains entries whose values define general syntax for the database</a:Comment>
<c:Categories>
<o:TargetCategory Id="o10">
<a:Name>Syntax</a:Name>
<a:Comment>Contains general parameters for SQL syntax</a:Comment>
<c:Categories>
<o:CharacterTargetItem Id="o11">
<a:Name>Terminator</a:Name>
<a:Comment>End of command character</a:Comment>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o12">
<a:Name>BlockTerminator</a:Name>
<a:Comment>End of block character</a:Comment>
<a:StringTargetItem.Value>go</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:CharacterTargetItem Id="o13">
<a:Name>Delimiter</a:Name>
<a:Comment>Field separation character. Example: col1, col2, col3</a:Comment>
<a:CharacterTargetItem.Value>,</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o14">
<a:Name>Quote</a:Name>
<a:Comment>Character used to enclose string values</a:Comment>
<a:CharacterTargetItem.Value>&#39;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o15">
<a:Name>SqlContinue</a:Name>
<a:Comment>Continuation character</a:Comment>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o16">
<a:Name>BlockComment</a:Name>
<a:Comment>Characters used to enclose a multi-line comment</a:Comment>
<a:StringTargetItem.Value>/*   */</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o17">
<a:Name>LineComment</a:Name>
<a:Comment>Characters used to enclose a single line comment</a:Comment>
<a:StringTargetItem.Value>--</a:StringTargetItem.Value>
</o:StringTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o18">
<a:Name>Format</a:Name>
<a:Comment>Contains entries that define script formatting</a:Comment>
<c:Categories>
<o:StringTargetItem Id="o19">
<a:Name>IllegalChar</a:Name>
<a:Comment>Invalid characters for names</a:Comment>
<a:StringTargetItem.Value>&quot; +-*/\!=%&lt;&gt;&#39;&quot;()&quot;.</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o20">
<a:Name>UpperCaseOnly</a:Name>
<a:Comment>Uppercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o21">
<a:Name>LowerCaseOnly</a:Name>
<a:Comment>Lowercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o22">
<a:Name>EnableOwnerPrefix</a:Name>
<a:Comment>Object codes can have a prefix made of the object owner code</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o23">
<a:Name>File</a:Name>
<a:Comment>Contains header, footer and usage text entries used during the generation</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o24">
<a:Name>Header</a:Name>
<a:Comment>Header text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o25">
<a:Name>Footer</a:Name>
<a:Comment>Footer text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o26">
<a:Name>EnableMultiFile</a:Name>
<a:Comment>Multi-script allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:StringTargetItem Id="o27">
<a:Name>ScriptExt</a:Name>
<a:Comment>Main script extension in database generation</a:Comment>
<a:StringTargetItem.Value>sql</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o28">
<a:Name>TableExt</a:Name>
<a:Comment>Other scripts extension in database generation</a:Comment>
<a:StringTargetItem.Value>tab</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o29">
<a:Name>StartCommand</a:Name>
<a:Comment>Command for executing a script</a:Comment>
<a:StringTargetItem.Value>isql %NAMESCRIPT%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o30">
<a:Name>Usage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Run the database creation script:
        isql -U&lt;username&gt; -P&lt;password&gt;  &lt; %NAMESCRIPT%</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in database generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o31">
<a:Name>Usage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Run the database creation scripts one by one:
        isql -U&lt;username&gt; -P&lt;password&gt;  &lt; &lt;script_name&gt;</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in database generation</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o32">
<a:Name>TriggerExt</a:Name>
<a:Comment>Script file extension in triggers and procedures generation</a:Comment>
<a:StringTargetItem.Value>trg</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o33">
<a:Name>TrgUsage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Run the trigger creation script:
        isql -U&lt;username&gt; -P&lt;password&gt;  &lt; %NAMESCRIPT%</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o34">
<a:Name>TrgUsage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Run the trigger creation scripts:
        isql -U&lt;username&gt; -P&lt;password&gt;  &lt; &lt;script_name&gt;</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o35">
<a:Name>Keywords</a:Name>
<a:Comment>Contains the list of reserved words and functions available in SQL</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o36">
<a:Name>ReservedDefault</a:Name>
<a:TextTargetItem.Value>user
null
current_user
session_user
system_user
current_timestamp
getdate()
user_id()
user_name()
db_id()
db_name()
host_id()
host_name()
newid()
suser_id()
suser_name()
suser_sname()</a:TextTargetItem.Value>
<a:Comment>Reserved default values</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o37">
<a:Name>GroupFunc</a:Name>
<a:TextTargetItem.Value>avg()
count()
max()
min()
sum()
var()
varp()
stdev()
stdevp()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions to use with group keywords.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o38">
<a:Name>NumberFunc</a:Name>
<a:TextTargetItem.Value>abs()
acos()
asin()
atan()
atn2()
ceiling()
cos()
cot()
degrees()
exp()
floor()
log()
log10()
pi()
power()
radians()
rand()
round()
sign()
sin()
square()
sqrt()
tan()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used on numbers</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o39">
<a:Name>CharFunc</a:Name>
<a:TextTargetItem.Value>ascii()
char()
charindex()
difference()
left()
len()
lower()
ltrim()
nchar()
patindex()
replace()
quotename()
replicate()
reverse()
right()
rtrim()
soundex()
space()
str()
stuff()
substring()
textptr()
textvalid()
unicode()
upper()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for characters and strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o40">
<a:Name>DateFunc</a:Name>
<a:TextTargetItem.Value>dateadd()
datediff()
datename()
datepart()
getdate()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for dates</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o41">
<a:Name>ConvertFunc</a:Name>
<a:TextTargetItem.Value>cast()
convert()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used to convert values between hex and integer and handling strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o42">
<a:Name>OtherFunc</a:Name>
<a:TextTargetItem.Value>coalesce()
col_length()
col_name()
columnproperty()
cursor_status()
datalength()
databaseproperty()
db_id()
db_name()
file_id()
file_name()
filegroup_id()
filegroup_name()
getainsinull()
getchecksum()
host_id()
host_name()
ident_incr()
ident_seed()
index_col()
indexproperty()
is_member()
is_srvrolemember()
isdate()
isnull()
isnumeric()
newid()
nullif()
object_id()
object_name()
objectproperty()
parsename()
permissions()
stats_date()
suser_id()
suser_name()
suser_sid()
suser_sname()
trigger_nestlevel()
typeproperty()
user_id()
user_name()</a:TextTargetItem.Value>
<a:Comment>List of other SQL functions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o43">
<a:Name>ListOperators</a:Name>
<a:TextTargetItem.Value>=
!=
&lt;&gt;
&gt;
!&gt;
&lt;
!&lt;
&gt;=
&lt;=
*=
=*
not
in
not in
between
not between
exists
not exists
like
not like
is
is not
= any
&lt;&gt; any
&gt; any
&lt; any
&gt;= any
&lt;= any
= all
&lt;&gt; all
&gt; all
&lt; all
&gt;= all
&lt;= all</a:TextTargetItem.Value>
<a:Comment>List of operators for comparing values, boolean, and various semantic operators</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o44">
<a:Name>Commit</a:Name>
<a:TextTargetItem.Value>commit</a:TextTargetItem.Value>
<a:Comment>Command for validating the transaction by OBDC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o45">
<a:Name>ReservedWord</a:Name>
<a:TextTargetItem.Value>ADD
ALL
ALTER
AND
ANY
AS
ASC
AUTHORIZATION
BACKUP
BEGIN
BETWEEN
BREAK
BROWSE
BULK
BY
CASCADE
CASE
CHECK
CHECKPOINT
CLOSE
CLUSTERED
COALESCE
COLLATE
COLUMN
COMMIT
COMPUTE
CONSTRAINT
CONTAINS
CONTAINSTABLE
CONTINUE
CONVERT
CREATE
CROSS
CURRENT
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_USER
CURSOR
DATABASE
DBCC
DEALLOCATE
DECLARE
DEFAULT
DELETE
DENY
DESC
DISK
DISTINCT
DISTRIBUTED
DOUBLE
DROP
DUMMY
DUMP
ELSE
END
ERRLVL
ESCAPE
EXCEPT
EXEC
EXECUTE
EXISTS
EXIT
FETCH
FILE
FILLFACTOR
FOR
FOREIGN
FREETEXT
FREETEXTTABLE
FROM
FULL
FUNCTION
GOTO
GRANT
GROUP
HAVING
HOLDLOCK
IDENTITY
IDENTITY_INSERT
IDENTITYCOL
IF
IN
INDEX
INNER
INSERT
INTERSECT
INTO
IS
JOIN
KEY
KILL
LEFT
LIKE
LINENO
LOAD
NATIONAL
NOCHECK
NONCLUSTERED
NOT
NULL
NULLIF
OF
OFF
OFFSETS
ON
OPEN
OPENDATASOURCE
OPENQUERY
OPENROWSET
OPENXML
OPTION
OR
ORDER
OUTER
OVER
PERCENT
PLAN
PRECISION
PRIMARY
PRINT
PROC
PROCEDURE
PUBLIC
RAISERROR
READ
READTEXT
RECONFIGURE
REFERENCES
REPLICATION
RESTORE
RESTRICT
RETURN
REVOKE
RIGHT
ROLLBACK
ROWCOUNT
ROWGUIDCOL
RULE
SAVE
SCHEMA
SELECT
SESSION_USER
SET
SETUSER
SHUTDOWN
SOME
STATISTICS
SYSTEM_USER
TABLE
TEXTSIZE
THEN
TO
TOP
TRAN
TRANSACTION
TRIGGER
TRUNCATE
TSEQUAL
UNION
UNIQUE
UPDATE
UPDATETEXT
USE
USER
VALUES
VARYING
VIEW
WAITFOR
WHEN
WHERE
WHILE
WITH
WRITETEXT
</a:TextTargetItem.Value>
<a:Comment>Reserved words</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o46">
<a:Name>Objects</a:Name>
<a:Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:Comment>
<c:Categories>
<o:TargetCategory Id="o47">
<a:Name>Table</a:Name>
<a:Code>TABL</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLE&quot;        // generated code of the table
   &quot;TNAME&quot;        // name of the table
   &quot;TCODE&quot;        // code of the table
   &quot;TLABL&quot;        // comment of the table
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;TABLDEFN&quot;     // complete body of the table definition. Contains definition of columns, checks and keys
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o48">
<a:Name>Enable</a:Name>
<a:Comment>Table allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o49">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o50">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKT_%.U26:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for check of table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o51">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create table [%QUALIFIER%]%TABLE% (
   %TABLDEFN%
)
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a table. Example: create table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o52">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>on %s   : category=storage, default=&quot;DEFAULT&quot;
textimage_on %s : category=storage, default=&quot;DEFAULT&quot;
</a:TextTargetItem.Value>
<a:Comment>Available options for creating a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o53">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for table options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o54">
<a:Name>TableComment</a:Name>
<a:TextTargetItem.Value>[%QUALIFIER%?[.O:[execute ][exec ]]sp_addextendedproperty [%R%?[N]]&#39;MS_Description&#39;, 
   [%R%?[N]]%.q:COMMENT%,
   [%R%?[N]]&#39;user&#39;, [%R%?[N]]%.q:OWNER%, [%R%?[N]]&#39;table&#39;, [%R%?[N]]%.q:TABLE%
:declare @Cmt%TABLE% varchar(128)
select @Cmt%TABLE% = user_name()
[.O:[execute ][exec ]]sp_addextendedproperty [%R%?[N]]&#39;MS_Description&#39;, 
   [%R%?[N]]%.q:COMMENT%,
   [%R%?[N]]&#39;user&#39;, [%R%?[N]]@Cmt%TABLE%, [%R%?[N]]&#39;table&#39;, [%R%?[N]]%.q:TABLE%
]
</a:TextTargetItem.Value>
<a:Comment>Command for adding a table comment using an extended property of MS SQL Server 2000 to store object description: &quot;MS_Description&quot;.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o55">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
            from  sysobjects
           where  id = object_id(&#39;[%QUALIFIER%]%TABLE%&#39;)
            and   type = &#39;U&#39;)
   drop table [%QUALIFIER%]%TABLE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table. Example: drop table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o56">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_rename %OLDTABL%, %NEWTABL%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o57">
<a:Name>AlterTableHeader</a:Name>
<a:Comment>Alter table header</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o58">
<a:Name>AlterTableFooter</a:Name>
<a:Comment>Alter table footer</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o59">
<a:Name>DropTableCheck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o60">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a table.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>SELECT=Select
INSERT=Insert
DELETE=Delete
UPDATE=Update
REFERENCES=Refr.</a:MapTargetItem.Value>
<a:List>SELECT
INSERT
DELETE
UPDATE
REFERENCES
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o61">
<a:Name>DefineTableCheck</a:Name>
<a:TextTargetItem.Value>[[constraint %CONSTNAME% ]check [%ExtCktNotForReplication%?not for replication ](%.A:CONSTRAINT%)]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of table check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o62">
<a:Name>AddTableCheck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%[%R%?[ with nocheck]]
   add [constraint %CONSTNAME% ]check [%ExtCktNotForReplication%?not for replication ](%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script for modifying table constraints within an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o63">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, OPTIONS ...}

select 
   u.name,
   t.name,
   case(i.indid) when 0 then &#39;on &#39; + f.groupname when 1 then &#39;on &#39; + f.groupname else &#39;&#39; end
   + case(i.indid) when 255 then &#39; textimage_on &#39; + f.groupname else &#39;&#39; end
from 
   [%CATALOG%.]sys.sysobjects         t 
   join [%CATALOG%.]sys.schemas       u on (u.schema_id = t.uid)
   join [%CATALOG%.]sys.sysindexes    i on (i.id = t.id and i.indid in (0, 1, 255))
   join [%CATALOG%.]sys.sysfilegroups f on (f.groupid = i.groupid)
where t.type = &#39;U&#39;
[  and u.name = %.q:OWNER%]
[  and t.name = %.q:TABLE%]
order by 1, 2, i.indid</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o64">
<a:Name>SqlChckQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, CONSTNAME, ExtCktNotForReplication, CONSTRAINT}

select
   u.name,
   t.name,
   o.name,
   case (k.status &amp; 0x00200000) when 0 then &#39;false&#39; else &#39;true&#39; end,
   m.text
from
   [%CATALOG%.]sys.sysconstraints k
   join [%CATALOG%.]sys.sysobjects  t on (t.id = k.id)
   join [%CATALOG%.]sys.schemas     u on (u.schema_id = t.uid)
   join [%CATALOG%.]sys.sysobjects  o on (o.id = k.constid and o.xtype = &#39;C&#39;)
   join [%CATALOG%.]sys.syscomments m on (m.id = o.id)
where k.colid=0
[  and t.name = %.q:TABLE%]
[  and u.name = %.q:OWNER%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o65">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

select
   v.name,
   case (s.action) when 193 then &#39;SELECT&#39; when 195 then &#39;INSERT&#39; when 196 then &#39;DELETE&#39;
                   when 197 then &#39;UPDATE&#39; when 26  then &#39;REFERENCES&#39; end +
   case (s.protecttype) when 204 then &#39;+&#39; when 205 then &#39;&#39; when 206 then &#39;-&#39; end + &#39;,&#39;
from
   [%CATALOG%.]sys.sysprotects s
   join [%CATALOG%.]sys.schemas     v on (v.schema_id = t.uid)
   join [%CATALOG%.]sys.sysobjects  o on (o.id = s.id)
   join [%CATALOG%.]sys.schemas     u on (u.schema_id = t.uid)
where
   (s.columns IS NULL or s.columns = 1)
[  and o.name = %.q:TABLE%]
[  and u.name = %.q:OWNER%]
order by 1
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o66">
<a:Name>InsertIdentityOn</a:Name>
<a:TextTargetItem.Value>set identity_insert [%QUALIFIER%]%@OBJTCODE% on</a:TextTargetItem.Value>
<a:Comment>Command for enabling insertion of data into table containing identity column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o67">
<a:Name>InsertIdentityOff</a:Name>
<a:TextTargetItem.Value>set identity_insert [%QUALIFIER%]%@OBJTCODE% off</a:TextTargetItem.Value>
<a:Comment>Command for disabling insertion of data into table containing identity column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o68">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o69">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, TABLE_TYPE, COMMENT}

select
   u.name,
   o.name,
   case (o.type) when &#39;S&#39; then &#39;SYSTEM TABLE&#39; else &#39;TABLE&#39; end,
   (select convert(varchar(8000), value) from ::fn_listextendedproperty(NULL, &#39;user&#39;, u.name, &#39;table&#39;, o.name, null, null) where name = &#39;MS_Description&#39;)
from
   [%CATALOG%.]sys.sysobjects o
   join [%CATALOG%.]sys.schemas  u on (u.schema_id = o.uid)
where
   o.type in (&#39;U&#39;, &#39;S&#39;)
[  and u.name = %.q:OWNER%]
order by 1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o70">
<a:Name>Alter</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%[%R%? with nocheck] add %TABLDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for modifying a table.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o71">
<a:Name>Index</a:Name>
<a:Code>INDX</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
   &quot;INDEX&quot;        // generated code of the index
   &quot;INDEXNAME&quot;    // index name
   &quot;INDEXCODE&quot;    // index code
   &quot;UNIQUE&quot;       // keyword &quot;unique&quot; when the index is unique
   &quot;INDEXTYPE&quot;    // index type (available only for a few DBMS)
   &quot;INDEXKEY&quot;     // keywords &quot;primary&quot;, &quot;unique&quot; or &quot;foreign&quot; depending on the index origin
   &quot;CIDXLIST&quot;     // list of index columns. Eg: A asc, B desc, C asc
   &quot;CLUSTER&quot;      // keyword &quot;cluster&quot; when the index is cluster
For index columns, the following system variables are available:
   &quot;ASC&quot;          // keywords &quot;ASC&quot; or &quot;DESC&quot; depending on sort order
   &quot;ISASC&quot;        // TRUE if the index column sort is ascending
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o72">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o73">
<a:Name>MaxColIndex</a:Name>
<a:Comment>Maximum number of columns in an index</a:Comment>
<a:IntegerTargetItem.Value>16</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o74">
<a:Name>Enable</a:Name>
<a:Comment>Index allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o75">
<a:Name>EnableAscDesc</a:Name>
<a:Comment>ASC, DESC keywords allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o76">
<a:Name>UniqName</a:Name>
<a:Comment>Unique index name in the database</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o77">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [%XML%?[%XMLPrimary%?primary ]xml :[%UNIQUE% ][%CLUSTER%?clustered :[%R%?[nonclustered ]]]]index %INDEX% on [%TABLQUALIFIER%]%TABLE% (
%CIDXLIST%
)
[%OPTIONS%]
</a:TextTargetItem.Value>
<a:Comment>Command for creating an index. Example: create index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o78">
<a:Name>Cluster</a:Name>
<a:Comment>Cluster index keyword (default value: cluster)</a:Comment>
<a:StringTargetItem.Value>clustered</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o79">
<a:Name>AddColIndex</a:Name>
<a:TextTargetItem.Value>%COLUMN%[%R%? %ASC%:[%Index.XML%?: %ASC%]]</a:TextTargetItem.Value>
<a:Comment>Command for defining an index column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o80">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with : composite=yes, separator=yes, parenthesis=no
{
pad_index=%s : list=on|off
fillfactor=%d : default=10
sort_in_tempdb=%s : list=on|off
ignore_dup_key=%s : list=on|off
statistics_norecompute=%s : list=on|off
drop_existing=%s : list=on|off
online=%s : list=on|off
allow_row_locks=%s : list=on|off
allow_page_locks=%s : list=on|off
maxdop=%s
}
on %s : category=storage, composite=yes, parenthesis=yes
{
   &lt;partition_columns&gt; %s
}
using xml index %s : composite=yes
{
   for %s : list=value|path|property
}</a:TextTargetItem.Value>
<a:Comment>Default options for creating an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o81">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for index options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o82">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
            from  sysindexes
           where  id    = object_id(&#39;[%QUALIFIER%]%TABLE%&#39;)
            and   name  = %.q:INDEX%
            and   indid &gt; 0
            and   indid &lt; 255)
   drop index [%QUALIFIER%]%TABLE%.%INDEX%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an index. Example: drop index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o83">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, INDEX, OPTIONS}

select
   u.name,
   o.name,
   i.name,
   case(i.ignore_dup_key + i.fill_factor + i.is_padded) when 0 then &#39;&#39; else &#39;with &#39; + replace(ltrim(&#39;&#39;
       + case(i.ignore_dup_key) when 0 then &#39;&#39; else &#39;ignore_dup_key=on&#39; end
       + case(i.fill_factor) when 0 then &#39;&#39; else &#39; fillfactor=&#39; + convert(varchar, i.fill_factor) end
       + case(i.is_padded) when 0 then &#39;&#39; else &#39; pad_index=on&#39; end), &#39; &#39;, &#39;, &#39;)
   end
   + case(i.data_space_id) when 0 then &#39;&#39; else &#39; on &#39; + (select f.name from [%CATALOG%.]sys.filegroups f where f.data_space_id=i.data_space_id) end
   + case(isnull(x.using_xml_index_id, 0)) when 0 then &#39;&#39; else 
      &#39; using xml index &#39; + (select p.name from [%CATALOG%.]sys.xml_indexes p where p.object_id = o.object_id and p.index_id = x.using_xml_index_id)
      + &#39; for &#39; + case(x.secondary_type) when &#39;P&#39; then &#39;path &#39; when &#39;V&#39; then &#39;value&#39; when &#39;R&#39; then &#39;property&#39; else &#39;&#39; end
     end
from
   [%CATALOG%.]sys.objects      o
   join [%CATALOG%.]sys.schemas u on (u.schema_id = o.schema_id)
   join [%CATALOG%.]sys.indexes i on (i.object_id = o.object_id)
   left outer join [%CATALOG%.]sys.xml_indexes x on (x.object_id = o.object_id and x.index_id = i.index_id and i.type = 3 and x.using_xml_index_id is not null)
where 
   i.index_id &gt; 0
   and o.type = &#39;U&#39;
[  and o.name = %.q:TABLE%]
[  and u.name=%.q:OWNER%]
[  and i.name=%.q:INDEX%]
order by 1, 2, 3</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o84">
<a:Name>SqlSysIndexQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, INDEX}

select
   u.name,
   o.name,
   i.name
from
   sysindexes i,
   sysobjects o,
   sysusers u
where
   i.id = o.id and u.uid = o.uid
   and o.type = &#39;U&#39;
   and (i.status &amp; 6144) &gt;0
   [and o.name = %.q:TABLE%]
   [and u.name=%.q:OWNER%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to list system indexes created by the database</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o85">
<a:Name>EnableCluster</a:Name>
<a:Comment>Cluster option available for indexes</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o86">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, INDEX ID, CLUSTER ID, UNIQUE ID, XML ID, XMLPrimary ID, CIDXLIST ...}

select
   u.name,
   o.name, 
   i.name, 
   case(i.type) when 1 then &#39;clustered&#39; else &#39;&#39; end,
   case(i.is_unique) when 1 then &#39;unique&#39; else &#39;&#39; end,
   case(i.type) when 3 then &#39;true&#39; else &#39;false&#39; end,
   case(i.type) when 3 then case when ((select p.using_xml_index_id from [%CATALOG%.]sys.xml_indexes p where p.object_id = o.object_id and p.index_id = i.index_id) is null) then &#39;true&#39; else &#39;false&#39; end else &#39;&#39; end,
   case(x.index_column_id) when 1 then &#39;&#39; else &#39;, &#39; end
   + c.name 
   + case(x.is_descending_key) when 1 then &#39; desc&#39; else &#39;&#39; end
from 
   [%CATALOG%.]sys.objects o
   join [%CATALOG%.]sys.schemas       u on (u.schema_id = o.schema_id)
   join [%CATALOG%.]sys.indexes       i on (i.object_id = o.object_id)
   join [%CATALOG%.]sys.index_columns x on (x.object_id = o.object_id and x.index_id = i.index_id)
   join [%CATALOG%.]sys.columns       c on (c.object_id = o.object_id and c.column_id = x.column_id)
where i.index_id &gt; 0
[  and o.name = %.q:TABLE%]
[  and u.name = %.q:SCHEMA%]
order by
   1, 2, 3, x.index_column_id
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o87">
<a:Name>Default</a:Name>
<a:Code>DFLT</a:Code>
<a:Comment>The following system variables are available:
   &quot;DEFAULT&quot;      // generated code of the default
   &quot;VALUE&quot;        // value of the default object
   &quot;BOUND_OBJECT&quot; // the generated code (including qualifier and parent) of the object which is bound to the default
   &quot;SCRIPT&quot;       // the create default body
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o88">
<a:Name>Enable</a:Name>
<a:Comment>Defaults allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o89">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create default [%QUALIFIER%]%DEFAULT%
    as %VALUE%
</a:TextTargetItem.Value>
<a:Comment>Command for creating a default.
Example: create default %DEFAULT% as %VALUE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o90">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_bindefault [%QUALIFIER%]%DEFAULT%, %.q:BOUND_OBJECT%
</a:TextTargetItem.Value>
<a:Comment>Command for binding a default object to a domain or a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o91">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, DEFAULT, SCRIPT}

select
   u.name,
   o.name,
   t.text
from 
   [%CATALOG%.]sys.sysobjects       o
   join [%CATALOG%.]sys.schemas     u on (u.schema_id = o.uid)
   join [%CATALOG%.]sys.syscomments t on (t.id = o.id)
where
   o.type = &#39;D&#39;
   and (o.parent_obj is null or o.parent_obj = 0)
[  and u.name = %.q:SCHEMA%]
order by
   1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o92">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
   from  sysobjects where type = &#39;D&#39;
   and name = %.q:DEFAULT%[ and user_name(uid) = %.q:OWNER%]
   )
   drop default [%QUALIFIER%]%DEFAULT%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a default</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o93">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o94">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, DEFAULT, BOUND_OBJECT}

select
   u.name,
   o.name,
   d.name
from
   [%CATALOG%.]sys.sysobjects o
   join [%CATALOG%.]sys.schemas  u on (u.schema_id = o.uid)
   join [%CATALOG%.]sys.systypes d on (d.tdefault = o.id)
where
   o.type = &#39;D&#39; 
[  and o.name = %.q:DEFAULT%]
[  and u.name = %.q:OWNER%]
union select 
   u.name,
   o.name,
   v.name + &#39;.&#39; + t.name + &#39;.&#39; + c.name
from
   [%CATALOG%.]sys.sysobjects o
   join [%CATALOG%.]sys.schemas    u on (u.schema_id = o.uid)
   join [%CATALOG%.]sys.syscolumns c on (c.cdefault = o.id)
   join [%CATALOG%.]sys.sysobjects t on (t.id = c.id)
   join [%CATALOG%.]sys.schemas    v on (v.schema_id = t.uid)
where
   o.type = &#39;D&#39;
[  and o.name = %.q:DEFAULT%]
[  and u.name = %.q:OWNER%]
order by
   1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o95">
<a:Name>Unbind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_unbindefault %.q:BOUND_OBJECT%</a:TextTargetItem.Value>
<a:Comment>Command for unbinding a default value from an object (domain or column)</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o96">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o97">
<a:Name>Column</a:Name>
<a:Code>COLN</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for columns)
   &quot;COLUMN&quot;       // generated code of the column
   &quot;COLNNO&quot;       // position of the column in the list of columns of the table
   &quot;COLNNAME&quot;     // name of the column
   &quot;COLNCODE&quot;     // code of the column
   &quot;PRIMARY&quot;      // keyword &quot;primary&quot; if the column is primary
   &quot;ISPKEY&quot;       // TRUE if the column is part of the primary key
   &quot;FOREIGN&quot;      // TRUE if the column is part of one foreign key
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o98">
<a:Name>Enable</a:Name>
<a:Comment>Column allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o99">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o100">
<a:Name>EnableIdentity</a:Name>
<a:Comment>Identity keyword entry support. Identity columns are serial counters maintains by the database</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o101">
<a:Name>AlterTableAddDefault</a:Name>
<a:TextTargetItem.Value>[[ constraint %ExtDeftConstName%] default %DEFAULT% ]for %COLUMN%</a:TextTargetItem.Value>
<a:Comment>Command for defining the default value of a column in an alter statement</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o102">
<a:Name>EnableDefault</a:Name>
<a:Comment>Default values allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o103">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKC_%.U17:COLUMN%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for a column check parameter</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o104">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%20:COLUMN% [%COMPUTE%?AS (%COMPUTE%):%20:DATATYPE%[.Z:[ collate %ExtCollation%][%ExtRowGuidCol%? RowGuidCol][%IDENTITY%? %IDENTITY%[[(%ExtIdentitySeedInc%)][%ExtIdtNotForReplication%? not for replication]]:[%ExtNullConstName%? constraint %ExtNullConstName%][ %NULL%][ %NOTNULL%]][[%ExtDeftConstName%? constraint %ExtDeftConstName%] default %DEFAULT%]]
   [%CONSTDEFN%]]
</a:TextTargetItem.Value>
<a:Comment>Command for defining a table column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o105">
<a:Name>DefineColnChck</a:Name>
<a:TextTargetItem.Value>[[constraint %CONSTNAME% ]check [%ExtCkcNotForReplication%?not for replication ](%.A:CONSTRAINT%)]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of column check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o106">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_rename &quot;%TABLE%.%OLDCOLN%&quot;, %NEWCOLN%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o107">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add %COLUMN% [%COMPUTE%?AS (%COMPUTE%):%DATATYPE%[.Z:[ collate %ExtCollation%][%ExtRowGuidCol%? RowGuidCol][%IDENTITY%? %IDENTITY%[[(%ExtIdentitySeedInc%)][%ExtIdtNotForReplication%? not for replication]]:[%ExtNullConstName%? constraint %ExtNullConstName%][ %NULL%][ %NOTNULL%]][[%ExtDeftConstName%? constraint %ExtDeftConstName%] default %DEFAULT%]]
   [%CONSTDEFN%]]
</a:TextTargetItem.Value>
<a:Comment>Command for adding a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o108">
<a:Name>ModifyColumn</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   alter column %COLUMN% %DATATYPE% %NOTNULL%</a:TextTargetItem.Value>
<a:Comment>Command for modifying a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o109">
<a:Name>DropDefaultConstraint</a:Name>
<a:TextTargetItem.Value>[%ExtDeftConstName%?alter table [%QUALIFIER%]%TABLE%
   drop constraint %ExtDeftConstName%]</a:TextTargetItem.Value>
<a:Comment>Command for dropping constraint linked to a column defined with default value.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o110">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop column %COLUMN%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o111">
<a:Name>ModifyColnDflt</a:Name>
<a:Comment>Command for modifying a column default in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o112">
<a:Name>ModifyColnChck</a:Name>
<a:Comment>Command for modifying a column check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o113">
<a:Name>DropColnChck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a column check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o114">
<a:Name>AltEnableAddColnChk</a:Name>
<a:Comment>Column check constraint allowed in an alter table statement</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o115">
<a:Name>SqlChckQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, CONSTNAME, ExtCkcNotForReplication, CONSTRAINT}

select
   u.name,
   t.name,
   c.name,
   o.name,
   case (k.status &amp; 0x00200000) when 0 then &#39;false&#39; else &#39;true&#39; end,
   replace(m.text, &#39;[&#39; + c.name + &#39;]&#39;, c.name)
from
   [%CATALOG%.]sys.sysconstraints   k
   join [%CATALOG%.]sys.syscolumns  c on (c.id = k.id and c.colid = k.colid)
   join [%CATALOG%.]sys.sysobjects  t on (t.id = c.id)
   join [%CATALOG%.]sys.schemas     u on (u.schema_id = t.uid)
   join [%CATALOG%.]sys.sysobjects  o on (o.id = k.constid and o.xtype = &#39;C&#39;)
   join [%CATALOG%.]sys.syscomments m on (m.id = o.id)
where k.colid &gt; 0
[  and u.name = %.q:OWNER%]
[  and t.name = %.q:TABLE%]
[  and c.name = %.q:COLUMN%]
order by u.name, t.name, c.name, o.name</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object check constraints</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o116">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a column.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>SELECT=Select
UPDATE=Update
REFERENCES=Refr.</a:MapTargetItem.Value>
<a:List>SELECT
UPDATE
REFERENCES
</a:List>
</o:MapTargetItem>
<o:BooleanTargetItem Id="o117">
<a:Name>EnableBindRule</a:Name>
<a:Comment>Allows the binding of business rule to a column for check parameters</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o118">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_bindrule %RULE%, &quot;%TABLE%.%COLUMN%&quot;</a:TextTargetItem.Value>
<a:Comment>Command for binding a rule to a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o119">
<a:Name>Unbind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_unbindrule %TABLE%.%COLUMN%</a:TextTargetItem.Value>
<a:Comment>Command for unbinding a rule from a column</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o120">
<a:Name>EnableComputedColn</a:Name>
<a:Comment>Computed columns allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o121">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, BITMAPCOLN ID, COLNPERMISSION ...}

select
   v.name,
   convert(integer, s.columns),
   case (s.action) when 193 then &#39;SELECT&#39; when 197 then &#39;UPDATE&#39; when 26 then &#39;REFERENCES&#39; end +
   case (s.protecttype) when 204 then &#39;+&#39; else &#39;&#39; end + &#39;,&#39;
from
   [%CATALOG%.]sys.sysprotects s
   join [%CATALOG%.]sys.sysusers    v on (v.uid = s.uid)
   join [%CATALOG%.]sys.sysobjects  o on (o.id = s.id)
   join [%CATALOG%.]sys.sysusers    u on (u.uid = o.uid)
where
  s.columns &gt; 1
[  and o.name = %.q:TABLE%]
[  and u.name = %.q:OWNER%]
order by 1
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o122">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, S, COLUMN, DTTPCODE, LENGTH, SIZE, PREC, COMPUTE, NOTNULL, IDENTITY, DOMAIN, DEFAULT, ExtIdentitySeedInc, COMMENT, ExtCollation, ExtIdtNotForReplication, ExtDeftConstName, ExtRowGuidCol}

select
    u.name,
    o.name,
    c.column_id,
    c.name,
    t.name,
    c.precision,
    case when c.system_type_id in (99, 231, 239) then (c.max_length/2) else c.max_length end,
    c.scale,
    case(c.is_computed) when 1 then convert(varchar(8000), (select z.definition from [%CATALOG%.]sys.computed_columns z where z.object_id = c.object_id and z.column_id = c.column_id)) else &#39;&#39; end,
    case(c.is_nullable) when 1 then &#39;NULL&#39; else &#39;NOTNULL&#39; end,
    case(c.is_identity) when 1 then &#39;identity&#39; else &#39;&#39; end,
    case when(c.user_type_id &lt;&gt; c.system_type_id) then (select d.name from [%CATALOG%.]sys.types d where d.user_type_id = c.user_type_id) else &#39;&#39; end,
    convert(varchar(8000), d.definition),
    case (c.is_identity) when 1 then convert(varchar, i.seed_value) + &#39;, &#39; + convert(varchar, i.increment_value) else &#39;&#39; end,
    (select convert(varchar(8000), value) from ::fn_listextendedproperty(NULL, &#39;user&#39;, u.name, &#39;table&#39;, o.name, &#39;column&#39;, c.name) where name = &#39;MS_Description&#39;),
    c.collation_name,
    case (i.is_not_for_replication) when 1 then &#39;true&#39; else &#39;false&#39; end,
    d.name,
    case(c.is_rowguidcol) when 1 then &#39;true&#39; else &#39;false&#39; end
from
    [%CATALOG%.]sys.columns      c
    join [%CATALOG%.]sys.objects o on (o.object_id = c.object_id)
    join [%CATALOG%.]sys.schemas u on (u.schema_id = o.schema_id)
    join [%CATALOG%.]sys.types   t on (t.user_type_id = c.system_type_id)
    left outer join [%CATALOG%.]sys.identity_columns i on (i.object_id = c.object_id and i.column_id = c.column_id)
    left outer join [%CATALOG%.]sys.default_constraints d on (d.object_id = c.default_object_id)
where 
   o.type in (&#39;U&#39;, &#39;S&#39;, &#39;V&#39;)
[  and u.name = %.q:OWNER%]
[  and o.name=%.q:TABLE%]
order by 1, 2, 3
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o123">
<a:Name>ColumnComment</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_addextendedproperty [%R%?[N]]&#39;MS_Description&#39;, 
   [%R%?[N]]%.q:COMMENT%,
   [%R%?[N]]&#39;user&#39;, [%R%?[N]]%.q:OWNER%, [%R%?[N]]&#39;table&#39;, [%R%?[N]]%.q:TABLE%, [%R%?[N]]&#39;column&#39;, [%R%?[N]]%.q:COLUMN%</a:TextTargetItem.Value>
<a:Comment>Command for adding a column comment using an extended property of MS SQL Server 2000 to store object description: &quot;MS_Description&quot;.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o124">
<a:Name>AddColnChck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME% ]check [%ExtCkcNotForReplication%?not for replication ](%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script for modifying column constraints within an alter table statement</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:IntegerTargetItem Id="o125">
<a:Name>MaxConstLen</a:Name>
<a:Comment>Maximum constraint name length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TargetCategory Id="o126">
<a:Name>User</a:Name>
<a:Code>USER</a:Code>
<a:Comment>The following system variables are available:
   &quot;USER&quot;         // generated code of the user
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o127">
<a:Name>Enable</a:Name>
<a:Comment>User allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o128">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o129">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{USER, Stereotype, SchemaOwner}

select
   s.name,
   Case when (s.schema_id = s.principal_id) then &#39;&#39; else &#39;Schema&#39; end,
   Case when (s.schema_id = s.principal_id) then &#39;&#39; else u.name end
from 
   [%CATALOG%.]sys.schemas s
   join [%CATALOG%.]sys.sysusers u on (u.uid = s.principal_id and u.issqlrole = 0)
[where UPPER(u.name) = %.qU:SCHEMA%]
order by 1
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o130">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o131">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%Stereotype%=Schema?create schema %USER%[ authorization %SchemaOwner%]:[%R%?[exec ]][execute ]sp_grantdbaccess %USER%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a user</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o132">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>[%Stereotype%=Schema?drop schema %USER%:[%R%?[exec ]][execute ]sp_revokedbaccess %USER%]</a:TextTargetItem.Value>
<a:Comment>Command for dropping a user</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o133">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{USER ID, PRIVILEGE ...}

select
   u.name,
   case (s.action) when 178 then &#39;CREATE FUNCTION&#39;  when 198 then &#39;CREATE TABLE&#39;     when 203 then &#39;CREATE DATABASE&#39;
                   when 207 then &#39;CREATE VIEW&#39;      when 222 then &#39;CREATE PROCEDURE&#39; when 228 then &#39;BACKUP DATABASE&#39;
                   when 233 then &#39;CREATE DEFAULT&#39;   when 235 then &#39;BACKUP LOG&#39;       when 236 then &#39;CREATE RULE&#39; end +
   case (s.protecttype) when 204 then &#39;+&#39; when 205 then &#39;&#39; when 206 then &#39;-&#39; end + &#39;,&#39;
from
   [%CATALOG%.]sys.sysprotects s
   join [%CATALOG%.]sys.sysusers u on (s.uid = u.uid and u.issqlrole &lt;&gt; 1)
where 
   s.id = 0
order by 1
</a:TextTargetItem.Value>
<a:Comment>Query to reverse privileges</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:BooleanTargetItem Id="o134">
<a:Name>EnableOption</a:Name>
<a:Comment>Physical options allowed  YES/NO</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TargetCategory Id="o135">
<a:Name>Reference</a:Name>
<a:Code>REFR</a:Code>
<a:Comment>The following system variables are available:
   &quot;REFR&quot;         // generated code of the reference
   &quot;REFNAME&quot;      // reference name
   &quot;PARENT&quot;       // generated code of the parent table
   &quot;PNAME&quot;        // name of the parent table
   &quot;PCODE&quot;        // code of the parent table
   &quot;CHILD&quot;        // generated code of the reference
   &quot;CNAME&quot;        // name of the child table
   &quot;CCODE&quot;        // code of the child table
   &quot;PQUALIFIER&quot;   // qualifier of the parent table. See QUALIFIER
   &quot;CQUALIFIER&quot;   // qualifier of the child table. See QUALIFIER
   &quot;REFRNAME&quot;     // Reference name
   &quot;REFRCODE&quot;     // Reference code
   &quot;FKCONSTRAINT&quot; // Reference constraint name (foreign key)
   &quot;PKCONSTRAINT&quot; // constraint name of the parent key used to reference object
   &quot;CKEYCOLUMNS&quot;  // list of parent key columns. Eg: C1, C2, C3
   &quot;FKEYCOLUMNS&quot;  // list of child foreign key columns. Eg:
   &quot;UPDCONST&quot;     // Update declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;DELCONST&quot;     // Delete declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;MINCARD&quot;      // Min cardinality
   &quot;MAXCARD&quot;      // Max cardinality
   &quot;POWNER&quot;       // Parent table owner
   &quot;COWNER&quot;       // child table owner
   &quot;CHCKONCMMT&quot;   // TRUE when check on commit is selected on the reference (ASA 6.0 specific)

For reference joins (couple of column in a reference),
the following system variables are available:
   &quot;CKEYCOLUMN&quot;   // generated code of the parent table column (primary key)
   &quot;FKEYCOLUMN&quot;   // generated code of the child table column (foreign key)
   &quot;PK&quot;           // primary key column generated code
   &quot;PKNAME&quot;       // primary key column name
   &quot;FK&quot;           // foreign key column generated code
   &quot;FKNAME&quot;       // foreign key column name
   &quot;AK&quot;           // alternate key column code (same as PK)
   &quot;AKNAME&quot;       // alternate key column name (same as PKNAME)
   &quot;COLTYPE&quot;      // primary column column datatype
   &quot;DEFAULT&quot;      // foreign key column default value
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o136">
<a:Name>Enable</a:Name>
<a:Comment>Foreign key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o137">
<a:Name>FKAutoIndex</a:Name>
<a:Comment>Foreign key is auto-indexed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o138">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>FK_%.U8:CHILD%_%.U9:REFR%_%.U8:PARENT%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for foreign keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o139">
<a:Name>CheckOnCommit</a:Name>
<a:Comment>Referential integrity test differed after the COMMIT</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o140">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>[%USE_SP_FKEY%?[%R%?[exec ]][execute ]sp_dropkey &#39;foreign&#39;, [%QUALIFIER%?&#39;%QUALIFIER%%TABLE%&#39;:%.q:TABLE%], [%PQUALIFIER%?&#39;%PQUALIFIER%%PARENT%&#39;:%.q:PARENT%]
:alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Command for dropping a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o141">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]foreign key (%FKEYCOLUMNS%)
   references [%PQUALIFIER%]%PARENT%[ (%CKEYCOLUMNS%)][.Z:
      [%R%?[on update [%UPDCONST%?%UPDCONST%:no action ]]:[%UPDCONST%?[%UPDCONST%=RESTRICT?:on update %UPDCONST% ]]][%R%?[on delete [%DELCONST%?%DELCONST%:no action ]]:[%DELCONST%?[%DELCONST%=RESTRICT?:on delete %DELCONST% ]]]
      [%ExtFkNotForReplication%?not for replication]]</a:TextTargetItem.Value>
<a:Comment>Command for defining a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o142">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%USE_SP_FKEY%?[%R%?[exec ]][execute ]sp_foreignkey [%QUALIFIER%?&#39;%QUALIFIER%%TABLE%&#39;:%.q:TABLE%], [%PQUALIFIER%?&#39;%PQUALIFIER%%PARENT%&#39;:%.q:PARENT%], %FKEYCOLUMNS% 
:alter table [%QUALIFIER%]%TABLE%[%R%?[ with nocheck]]
   add [constraint %CONSTNAME% ]foreign key (%FKEYCOLUMNS%)
      references [%PQUALIFIER%]%PARENT%[ (%CKEYCOLUMNS%)][.Z:
         [%R%?[on update [%UPDCONST%?%UPDCONST%:no action ]]:[%UPDCONST%?[%UPDCONST%=RESTRICT?:on update %UPDCONST% ]]][%R%?[on delete [%DELCONST%?%DELCONST%:no action ]]:[%DELCONST%?[%DELCONST%=RESTRICT?:on delete %DELCONST% ]]]
         [%ExtFkNotForReplication%?not for replication]]]</a:TextTargetItem.Value>
<a:Comment>Command for adding a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o143">
<a:Name>DclUpdIntegrity</a:Name>
<a:TextTargetItem.Value>NO ACTION
RESTRICT
CASCADE</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for update</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o144">
<a:Name>DclDelIntegrity</a:Name>
<a:TextTargetItem.Value>NO ACTION
RESTRICT
CASCADE</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for delete</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o145">
<a:Name>UseSpFornKey</a:Name>
<a:Comment>Use sp_foreignkey command to create foreign key</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o146">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{COWNER, CHILD, FKCONSTRAINT, ExtFkNotForReplication, UPDCONST, DELCONST, POWNER, PARENT}

select
   u.name,
   c.name,
   o.name,
   case (o.status &amp; 0XC00) when 0 then &#39;false&#39; else &#39;true&#39; end,
   case(o.status &amp; 0x2000) when 0 then &#39;restrict&#39; else &#39;cascade&#39; end,
   case(o.status &amp; 0x1000) when 0 then &#39;restrict&#39; else &#39;cascade&#39; end,
   v.name,
   p.name
from
   [%CATALOG%.]sys.sysreferences r
   join [%CATALOG%.]sys.sysobjects o on (o.id = r.constid and o.type = &#39;F&#39;)
   join [%CATALOG%.]sys.sysobjects c on (c.id = r.fkeyid)
   join [%CATALOG%.]sys.schemas    u on (u.schema_id = c.uid)
   join [%CATALOG%.]sys.sysobjects p on (p.id = r.rkeyid)
   join [%CATALOG%.]sys.schemas    v on (v.schema_id = p.uid)
where 1 = 1
[  and u.name = %.q:SCHEMA%]
[  and c.name = %.q:TABLE%]

</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o147">
<a:Name>SqlListChildrenQuery</a:Name>
<a:TextTargetItem.Value>{COWNER, CHILD, FKCONSTRAINT, FKEYCOLUMN, CKEYCOLUMN}

select
   u.name,
   t.name,
   o.name,
   c.name,
   p.name
from
   [%CATALOG%.]sys.sysforeignkeys j
      join [%CATALOG%.]sys.sysobjects o on (o.id = j.constid and o.type = &#39;F&#39;)
      join [%CATALOG%.]sys.syscolumns p on (p.id = j.rkeyid and p.colid = j.rkey)
      join [%CATALOG%.]sys.syscolumns c on (c.id = j.fkeyid and c.colid = j.fkey)
      join [%CATALOG%.]sys.sysobjects t on (t.id = j.fkeyid)
      join [%CATALOG%.]sys.schemas    u on (u.schema_id = t.uid)
where 1 = 1
[  and o.name = %.q:FKCONSTRAINT%]
[  and u.name = %.q:COWNER%]
[  and t.name = %.q:TABLE%]
order by 1, 2, 3, j.keyno
</a:TextTargetItem.Value>
<a:Comment>SQL query to list reference joins</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o148">
<a:Name>Permission</a:Name>
<a:Code>PERM</a:Code>
<a:Comment>Manages the permissions on database objects</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o149">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>grant %PERMLIST% on [%QUALIFIER%]%OBJECT% to %GRANTEE% [%GRANTOPTION%]</a:TextTargetItem.Value>
<a:Comment>Command for granting permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o150">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>revoke %REVPERMLIST% on [%QUALIFIER%]%OBJECT% from %GRANTEE%</a:TextTargetItem.Value>
<a:Comment>Command for revoking permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o151">
<a:Name>GrantOption</a:Name>
<a:TextTargetItem.Value>with grant option</a:TextTargetItem.Value>
<a:Comment>Option for the grant statement.</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o152">
<a:Name>RevokeInherited</a:Name>
<a:Comment>Allow to revoke an inherited permission from a group or a role.</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o153">
<a:Name>PKey</a:Name>
<a:Code>PKEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o154">
<a:Name>Enable</a:Name>
<a:Comment>Primary key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o155">
<a:Name>PkAutoIndex</a:Name>
<a:Comment>Primary key is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o156">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>PK_%.U27:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for primary keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o157">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with : composite=yes, separator=yes, parenthesis=no
{
fillfactor= %d : default=0
&lt;sorted_data&gt; %s : list=sorted_data | sorted_data_reorg
}
on %s : category=storage</a:TextTargetItem.Value>
<a:Comment>Available options for creating a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o158">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for primary key options</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o159">
<a:Name>UseSpPrimKey</a:Name>
<a:Comment>Use the sp_primarykey command to generate primary key</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o160">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>[%USE_SP_PKEY%?[%R%?[exec ]][execute ]sp_dropkey &#39;primary&#39;, [%QUALIFIER%?&#39;%QUALIFIER%%TABLE%&#39;:%.q:TABLE%]
:alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Command for dropping a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o161">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]primary key [%CLUSTER%?[%R%?[clustered ]]:nonclustered ](%PKEYCOLUMNS%)
      [%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o162">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%USE_SP_PKEY%?[%R%?[exec ]][execute ]sp_primarykey [%QUALIFIER%?&#39;%QUALIFIER%%TABLE%&#39;:%.q:TABLE%], %PKEYCOLUMNS%
:alter table [%QUALIFIER%]%TABLE%[%R%?[ with nocheck]]
   add [constraint %CONSTNAME% ]primary key [%CLUSTER%?[%R%?[clustered ]]:nonclustered ](%PKEYCOLUMNS%)
      [%OPTIONS%]]</a:TextTargetItem.Value>
<a:Comment>Command for adding a primary key</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o163">
<a:Name>EnableCluster</a:Name>
<a:Comment>Cluster option available for primary keys</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o164">
<a:Name>Privilege</a:Name>
<a:Comment>Manages the system privileges for a user, role or group</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o165">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>grant %PRIVLIST% to %USER%</a:TextTargetItem.Value>
<a:Comment>Command for granting privileges.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o166">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>revoke %REVPRIVLIST% from %USER%</a:TextTargetItem.Value>
<a:Comment>Command for revoking privileges.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o167">
<a:Name>System</a:Name>
<a:TextTargetItem.Value>BACKUP DATABASE
BACKUP LOG
CREATE DATABASE
CREATE DEFAULT
CREATE FUNCTION
CREATE PROCEDURE
CREATE RULE
CREATE TABLE
CREATE VIEW</a:TextTargetItem.Value>
<a:Comment>List of system privileges</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o168">
<a:Name>RevokeInherited</a:Name>
<a:Comment>Allows to revoke an inherited privilege from a group or a role.</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o169">
<a:Name>Key</a:Name>
<a:Code>KEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;COLUMNS&quot;      // List of columns of the key. Eg: &quot;A, B, C&quot;
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o170">
<a:Name>Enable</a:Name>
<a:Comment>UNIQUE constraint allowed for tables</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o171">
<a:Name>UniqConstAutoIndex</a:Name>
<a:Comment>UNIQUE constraint is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o172">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>AK_%.U18:AKEY%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for alternate keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o173">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with : composite=yes, separator=yes, parenthesis=no
{
fillfactor= %d : default=0
&lt;sorted_data&gt; %s : list=sorted_data | sorted_data_reorg
}
on %s : category=storage</a:TextTargetItem.Value>
<a:Comment>Available options for an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o174">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for alternate key options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o175">
<a:Name>SqlAkeyIndex</a:Name>
<a:TextTargetItem.Value>{INDEX}

select
   o.name
from
   [%CATALOG%.]sys.sysobjects      o
   join [%CATALOG%.]sys.schemas    u on (u.schema_id = o.uid)
   join [%CATALOG%.]sys.sysindexes i on (i.id = o.parent_obj and i.name = o.name)
where o.xtype=&#39;UQ&#39; and o.type = &#39;U&#39;
   [and o.name = %.q:TABLE%]
   [and u.name=%.q:OWNER%]</a:TextTargetItem.Value>
<a:Comment>SQL query to obtain the alternate key indexes of a table by ODBC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o176">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o177">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]unique [%CLUSTER%?clustered :[%R%?[nonclustered ]]](%COLUMNS%)
      [%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o178">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%[%R%?[ with nocheck]]
   add [constraint %CONSTNAME% ]unique [%CLUSTER%?clustered :[%R%?[nonclustered ]]](%COLUMNS%)
      [%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for adding an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o179">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, CONSTNAME ID, ISPKEY ID, CLUSTER ID, COLUMNS ...}

select
   u.name,
   o.name,
   k.name,
   case (k.xtype) when &#39;PK&#39; then 1 else 0 end,
   case (i.indid) when 1 then &#39;YES&#39; else &#39;NO&#39; end,
   c.name + &#39;, &#39;
from
   [%CATALOG%.]sys.sysobjects k
   join [%CATALOG%.]sys.sysobjects   o on (o.type = &#39;U&#39; and o.id = k.parent_obj)
   join [%CATALOG%.]sys.schemas      u on (u.schema_id = o.uid)
   join [%CATALOG%.]sys.sysindexes   i on (i.id = o.id and i.name = k.name)
   join [%CATALOG%.]sys.sysindexkeys x on (x.id = o.id and x.indid = i.indid)
   join [%CATALOG%.]sys.syscolumns   c on (c.id=x.id and c.colid=x.colid)
where k.type = &#39;K&#39;
[  and u.name=%.q:OWNER%]
[  and o.name=%.q:TABLE%]
order by u.name, o.name, x.indid, x.keyno</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o180">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, CONSTNAME, OPTIONS}

select
   u.name,
   o.name,
   k.name,
   case ((i.status &amp; 512) + i.OrigFillFactor) when 0 then &#39;&#39; else &#39;with &#39; + replace(ltrim(&#39;&#39;
      + case (i.OrigFillFactor) when 0 then &#39;&#39; else &#39; fillfactor=&#39; + convert(varchar, i.OrigFillFactor) end
      + case when (i.status&amp;512&lt;&gt; 0) then case (i.status&amp;8192) when 0 then &#39; sorted_data&#39; else &#39; sorted_data_reorg&#39; end else &#39;&#39; end
      ), &#39; &#39;, &#39;, &#39;) + &#39; &#39; end
   + &#39;on &#39; + (select f.groupname from [%CATALOG%.]sys.sysfilegroups f where f.groupid=i.groupid)
from
   [%CATALOG%.]sys.sysobjects k
   join [%CATALOG%.]sys.sysobjects   o on (o.type = &#39;U&#39; and o.id = k.parent_obj)
   join [%CATALOG%.]sys.schemas      u on (u.schema_id = o.uid)
   join [%CATALOG%.]sys.sysindexes   i on (i.id = o.id and i.name = k.name)
where
   k.type=&#39;K&#39;
[  and u.name=%.q:OWNER%]
[  and o.name=%.q:TABLE%]
[  and k.name=%.q:CONSTNAME%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o181">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o182">
<a:Name>EnableCluster</a:Name>
<a:Comment>Cluster option available for alternate keys</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o183">
<a:Name>Domain</a:Name>
<a:Code>PDMDOMN</a:Code>
<a:Comment>The following system variables are available:
   &quot;DOMAIN&quot;       // generated code of the domain (also available for columns)
SQL Server specific domain system variables:
   &quot;RULENAME&quot;     // name of the rule object associated with the domain
   &quot;DEFAULTNAME&quot;  // name of the default object associated with the domain
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o184">
<a:Name>Enable</a:Name>
<a:Comment>User defined data types allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o185">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o186">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_addtype %DOMAIN%, %.q:DATATYPE% [%NOTNULL%?, %.q:NOTNULL%]

</a:TextTargetItem.Value>
<a:Comment>Command for creating a user defined data type</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o187">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists(select 1 from systypes where name=%.q:DOMAIN%)
   [%R%?[exec ]][execute ]sp_droptype %DOMAIN%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a user defined data type</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o188">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, DOMAIN, DTTPCODE, LENGTH, PREC, NOTNULL}

select
   u.name,
   d.name,
   i.name,
   isnull(d.prec, d.length),
   d.scale,
   case(d.allownulls) when 0 then &#39;NOTNULL&#39; else &#39;NULL&#39; end
from
   [%CATALOG%.]sys.systypes      d
   join [%CATALOG%.]sys.schemas  u on (u.schema_id = d.uid)
   join [%CATALOG%.]sys.systypes i on (i.type = d.type and i.usertype &lt; 100 and i.usertype not in (0, 18, 80))
where 
   d.usertype &gt;= 100
[  and u.name = %.q:SCHEMA%]
order by 1
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o189">
<a:Name>EnableBindRule</a:Name>
<a:Comment>Allows the binding of a business rule to a domain</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o190">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_bindrule %RULE%, %DOMAIN%</a:TextTargetItem.Value>
<a:Comment>Command for binding a rule to a domain</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o191">
<a:Name>Unbind</a:Name>
<a:TextTargetItem.Value>if exists(select 1 from systypes where name=%.q:DOMAIN%)
   [%R%?[exec ]][execute ]sp_unbindrule %DOMAIN%</a:TextTargetItem.Value>
<a:Comment>Command for unbinding a rule from a domain</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o192">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o193">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, DOMAIN, RULENAME}

select
   u.name,
   d.name,
   convert(char(20), d.domain)
from
   [%CATALOG%.]sys.systypes     d
   join [%CATALOG%.]sys.schemas u on (u.schema_id = d.uid)
where 
   d.domain &lt;&gt; 0 
   and d.usertype &gt;= 100
[  and u.name = %.q:OWNER%]
[  and d.name = %.q:DOMAIN%]
order by 1
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o194">
<a:Name>Rule</a:Name>
<a:Code>RULE</a:Code>
<a:Comment>The following system variables are available:
   &quot;RULE&quot;         // generated code of the rule
   &quot;RULENAME&quot;     // rule name
   &quot;RULECODE&quot;     // rule code
   &quot;RULECEXPR&quot;    // rule client expression
   &quot;RULESEXPR&quot;    // rule server expression
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o195">
<a:Name>MaxDefaultLen</a:Name>
<a:Comment>Length of name of default</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:StringTargetItem Id="o196">
<a:Name>UddtDefaultName</a:Name>
<a:Comment>Name of default for domain</a:Comment>
<a:StringTargetItem.Value>D_%.28:DOMAIN%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o197">
<a:Name>ColnDefaultName</a:Name>
<a:Comment>Name of default for column</a:Comment>
<a:StringTargetItem.Value>D_%.19:COLUMN%_%.8:TABLE%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:IntegerTargetItem Id="o198">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:StringTargetItem Id="o199">
<a:Name>UddtRuleName</a:Name>
<a:Comment>Name of rules for domains</a:Comment>
<a:StringTargetItem.Value>R_%.28:DOMAIN%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o200">
<a:Name>ColnRuleName</a:Name>
<a:Comment>Name of rules for columns</a:Comment>
<a:StringTargetItem.Value>R_%.19:COLUMN%_%.8:TABLE%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o201">
<a:Name>Enable</a:Name>
<a:Comment>Rule allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o202">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create rule [%S%.]%RULE% as
      %RULESEXPR%
</a:TextTargetItem.Value>
<a:Comment>Command for adding a rule</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o203">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1 from sysobjects where id=object_id(%.q:RULE%) and type=&#39;R&#39;)
   drop rule  %RULE%
</a:TextTargetItem.Value>
<a:Comment>Command for dropping a rule</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o204">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, @OBJTNAME ID, @OBJTCODE ID, SCRIPT ...}

select
   u.name,
   r.name,
   convert(char(20), r.id),
   ltrim(substring(t.text, (charindex(&#39;as&#39;, lower(t.text), charindex(lower(r.name), lower(t.text)) + len(r.name))+ 2), len(t.text) - 2))
from
   [%CATALOG%.]sys.sysobjects       r
   join [%CATALOG%.]sys.schemas     u on (u.schema_id = r.uid)
   join [%CATALOG%.]sys.syscomments t on (t.id=r.id and t.texttype in (0, 2))
where
   r.type=&#39;R&#39;
[  and u.name = %.q:SCHEMA%]
order by
   1, 2, t.number, t.colid</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o205">
<a:Name>Database</a:Name>
<a:Code>DTBS</a:Code>
<a:Comment>The following system variables are available:
   &quot;DATABASE&quot;     // generated code of the database
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o206">
<a:Name>Enable</a:Name>
<a:Comment>Database allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o207">
<a:Name>BeforeCreateDatabase</a:Name>
<a:Comment>Creates tablespaces and storages before database</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o208">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create database %DATABASE%
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a database. Example: create database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o209">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>on : composite=yes
{
primary
&lt;filelist&gt; : composite=yes, separator=yes
{
&lt;filespec&gt; : composite=yes, multiple=yes, parenthesis=yes, separator=yes
{
name= %s
filename= %s : squoted=yes
size= %s
maxsize= %s
filegrowth= %s
}
filegroup %s : composite=yes, multiple=yes, parenthesis=yes, separator=yes
{
name= %s
filename= %s : squoted=yes
size= %s
maxsize= %s
filegrowth= %s
}
}
log on : composite=yes, separator=yes
{
&lt;filespec&gt; : composite=yes, multiple=yes, parenthesis=yes, separator=yes
{
name= %s
filename= %s : squoted=yes
size= %s
maxsize= %s
filegrowth= %s
}
}
collate %s
with : composite=yes
{
db_chaining %s : list=ON|OFF
trustworthy %s : list=ON|OFF
}
}
for : composite=yes
{
attach : composite=yes
{
with %s : list=enable_broker|new_broker|error_broker_conversations
}
attach_rebuild_log
}
as snapshot of %s</a:TextTargetItem.Value>
<a:Comment>Available options for creating a database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o210">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for database options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o211">
<a:Name>OpenDatabase</a:Name>
<a:TextTargetItem.Value>use %DATABASE%</a:TextTargetItem.Value>
<a:Comment>Command for opening a database. Example: open database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o212">
<a:Name>CloseDatabase</a:Name>
<a:Comment>Command for closing a database. Example: close database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o213">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop database %DATABASE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a database. Example: drop database %DATABASE%</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o214">
<a:Name>Tablespace</a:Name>
<a:Code>TSPC</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLESPACE&quot;   // generated code of the tablespace
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o215">
<a:Name>Create</a:Name>
<a:Comment>Command for creating a tablespace. Example: create tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o216">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a tablespace. Example: drop tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o217">
<a:Name>Options</a:Name>
<a:Comment>Default options for creating a tablespace.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o218">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for tablespace options.</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o219">
<a:Name>Enable</a:Name>
<a:Comment>Tablespace allowed</a:Comment>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o220">
<a:Name>Storage</a:Name>
<a:Code>STOR</a:Code>
<a:Comment>The following system variables are available:
   &quot;STORAGE&quot;      // generated code of the storage
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o221">
<a:Name>AfterCreate</a:Name>
<a:TextTargetItem.Value>%usedb(Database)%
</a:TextTargetItem.Value>
<a:Comment>Commands executed after create statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o222">
<a:Name>AfterDrop</a:Name>
<a:TextTargetItem.Value>%usedb(Database)%
</a:TextTargetItem.Value>
<a:Comment>Commands executed after drop statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o223">
<a:Name>BeforeCreate</a:Name>
<a:TextTargetItem.Value>%usedb(master)%

alter database %DATABASE% add filegroup %STORAGE%
go</a:TextTargetItem.Value>
<a:Comment>Commands executed before create statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o224">
<a:Name>BeforeDrop</a:Name>
<a:TextTargetItem.Value>%usedb(master)%</a:TextTargetItem.Value>
<a:Comment>Commands executed before drop statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o225">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%OPTIONS%?alter database %DATABASE% add
   %OPTIONS%
   to filegroup %STORAGE%
]</a:TextTargetItem.Value>
<a:Comment>Command for creating a storage. Example: create storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o226">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter database %DATABASE%
   remove filegroup %STORAGE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a storage. Example: drop storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o227">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>file : composite=yes, separator=yes
{
   &lt;definition&gt; : composite=yes, parenthesis=yes, separator=yes, multiple=yes
   {
      name = %s
      filename = %s : squoted=yes
      size = %s
      maxsize = %s
      filegrowth = %s
   }
}

</a:TextTargetItem.Value>
<a:Comment>Default options for creating a storage</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o228">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for storage options</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o229">
<a:Name>Enable</a:Name>
<a:Comment>Storage allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o230">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{DATABASE ID, STORAGE ID, OPTIONS ...}

select 
   db_name(), 
   g.groupname,
   case when (f.fileid=(select min(x.fileid) from sysfiles x where x.groupid = g.groupid)) 
      then &#39;file (&#39;
      else &#39;, (&#39;
   end
   + &#39; name = &#39; + rtrim(f.name)
   + &#39;, filename = &#39;&#39;&#39; + rtrim(f.filename) + &#39;&#39;&#39;&#39;
   + &#39;, size = &#39; + rtrim(f.size)
   + &#39;, maxsize = &#39; + case when (f.maxsize = -1) then &#39;unlimited&#39; else rtrim(f.maxsize) end
   + &#39;, filegrowth = &#39; + rtrim(f.growth)
   + &#39;)&#39;
from 
   sysfilegroups g
   join sysfiles f on (f.groupid = g.groupid)
order by 1, 2, f.fileid</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o231">
<a:Name>View</a:Name>
<a:Code>VIEW</a:Code>
<a:Comment>The following system variables are available:
   &quot;VIEW&quot;         // generated code of the view
   &quot;VIEWNAME&quot;     // view name
   &quot;VIEWCODE&quot;     // view code
   &quot;VIEWCOLN&quot;     // List of columns of the view. Eg: &quot;A, B, C&quot;
   &quot;SQL&quot;          // SQL text of the view. Eg: Select * from T1
   &quot;VIEWCHECK&quot;    // Keyword &quot;with check option&quot; if selected on the view
   &quot;SCRIPT&quot;       // complete view creation order. Eg: create view V1 as select * from T1
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o232">
<a:Name>Enable</a:Name>
<a:Comment>View allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o233">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create view [%QUALIFIER%]%VIEW%[ (%VIEWCOLN%)][%VIEWSTYLE%=WithOptions? %OPTIONS%] as
%SQL%
[%VIEWCHECK%]
</a:TextTargetItem.Value>
<a:Comment>Command for creating a view. Example: create view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o234">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
            from  sysobjects
           where  id = object_id(&#39;[%QUALIFIER%]%VIEW%&#39;)
            and   type = &#39;V&#39;)
   drop view [%QUALIFIER%]%VIEW%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a view. Example: drop view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o235">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a view.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>SELECT=Select
INSERT=Insert
DELETE=Delete
UPDATE=Update</a:MapTargetItem.Value>
<a:List>SELECT
INSERT
DELETE
UPDATE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o236">
<a:Name>ViewComment</a:Name>
<a:Comment>Command for adding a view comment.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o237">
<a:Name>ViewCheck</a:Name>
<a:TextTargetItem.Value>with check option</a:TextTargetItem.Value>
<a:Comment>Option for checking a view</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o238">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, VIEW}

select
   u.name,
   o.name
from
   [%CATALOG%.]sys.sysobjects   o
   join [%CATALOG%.]sys.schemas u on (u.schema_id = o.uid)
where o.type = &#39;V&#39;
[  and u.name = %.q:SCHEMA%]
order by 1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o239">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, VIEW ID, SCRIPT ...}

select
   u.name,
   v.name,
   case when (t.encrypted = 1) then &#39;&#39; else t.text end
from
   [%CATALOG%.]sys.views            v
   join [%CATALOG%.]sys.schemas     u on (u.schema_id = v.schema_id)
   join [%CATALOG%.]sys.syscomments t on (t.id = v.object_id)
where 1 = 1
[  and u.name=%.q:OWNER%]
[  and v.name=%.q:VIEW%]
order by t.id, t.number, t.colid
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o240">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

select 
   v.name,
   case (s.action) when 193 then &#39;SELECT&#39; when 195 then &#39;INSERT&#39; when 196 then &#39;DELETE&#39; when 197 then &#39;UPDATE&#39; end +
   case (s.protecttype) when 204 then &#39;+&#39; when 205 then &#39;&#39; when 206 then &#39;-&#39; end + &#39;,&#39;
from 
   [%CATALOG%.]sys.sysprotects s
   join [%CATALOG%.]sys.sysusers    v on (v.uid = s.uid)
   join [%CATALOG%.]sys.sysobjects  o on (o.id = s.id)
   join [%CATALOG%.]sys.sysusers    u on (u.uid = o.uid)
where 1 = 1
[  and o.name = %.q:VIEW%]
[  and u.name = %.q:OWNER%]
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o241">
<a:Name>SqlColnListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, VIEW ID, VIEWCOLN ...}

select
   u.name,
   o.name,
   c.name + &#39;,&#39;
from
   [%CATALOG%.]sys.sysobjects o
   join [%CATALOG%.]sys.schemas    u on (u.schema_id = o.uid)
   join [%CATALOG%.]sys.syscolumns c on (c.id = o.id)
where
   o.type = &#39;V&#39;
[  and u.name = %.q:OWNER%]
[  and o.name = %.q:VIEW%]
order by 1, 2, c.colid
</a:TextTargetItem.Value>
<a:Comment>SQL query to list view columns</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o242">
<a:Name>ReversedQueries</a:Name>
<a:TextTargetItem.Value>SqlColnListQuery</a:TextTargetItem.Value>
<a:Comment>Additional attributes queries to be called by ODBC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o243">
<a:Name>EnableIndex</a:Name>
<a:TextTargetItem.Value>VIEW</a:TextTargetItem.Value>
<a:Comment>List of types for which view index is available.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o244">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with : composite = yes, separator=yes
{
   encryption
   schemabinding
   view_metadata
}</a:TextTargetItem.Value>
<a:Comment>Available options for creating a snapshot (or materialized view)</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o245">
<a:Name>ViewStyle</a:Name>
<a:TextTargetItem.Value>WithOptions</a:TextTargetItem.Value>
<a:Comment>Command for defining a specific view</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o246">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, VIEW, VIEWSTYLE, OPTIONS}

select
   u.name,
   v.name,
   &#39;WithOptions&#39;,
   &#39;with &#39; 
   + case when (t.encrypted = 1) then &#39;encryption, &#39; else &#39;&#39; end
   + case when (v.has_opaque_metadata = 1) then &#39;view_metadata, &#39; else &#39;&#39; end
   + case when (d.referenced_minor_id = 0) then &#39;schemabinding&#39; else &#39;&#39; end
from
   [%CATALOG%.]sys.views            v
   join [%CATALOG%.]sys.schemas     u on (u.schema_id = v.schema_id)
   left outer join [%CATALOG%.]sys.syscomments t on (t.id = v.object_id and t.encrypted = 1)
   left outer join [%CATALOG%.]sys.sql_dependencies d on (d.object_id = v.object_id and d.referenced_minor_id = 0)
where (v.has_opaque_metadata = 1) or (d.referenced_minor_id = 0) or (t.encrypted = 1)
[  and u.name=%.q:OWNER%]
[  and v.name=%.q:VIEW%]
order by t.id, t.number, t.colid
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o247">
<a:Name>Trigger</a:Name>
<a:Code>TRGR</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
 trigger object specific items
   &quot;ORDER&quot;        // order number of the trigger (to sort the triggers when the DBMS supports more than one trigger of one type)
   &quot;TRIGGER&quot;      // generated code of trigger
   &quot;TRGTYPE&quot;      // trigger type (keywords &quot;beforeinsert&quot;, &quot;afterupdate&quot;, ...)
   &quot;TRGEVENT&quot;     // trigger event (keywords &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;)
   &quot;TRGTIME&quot;      // trigger time (keywords NULL, &quot;before&quot;, &quot;after&quot;)
 inside the body of the trigger, macros redefine variables on objects
   &quot;REFNO&quot;        // reference position in the list of references of the table
 customized error messages management
   &quot;ERRNO&quot;        // error number for standard error
   &quot;ERRMSG&quot;       // error message for standard error
   &quot;MSGTAB&quot;       // name of the table containing user-defined error messages
   &quot;MSGNO&quot;        // in the user-defined error table, name of the column containing the error numbers
   &quot;MSGTXT&quot;       // in the user-defined error table, name of the column containing the error messages
   &quot;SCRIPT&quot;       // body of trigger or procedure
   &quot;TRGDEFN&quot;      // complete body of the trigger definition. Contains variable declarations and body of trigger or procedure
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o248">
<a:Name>Enable</a:Name>
<a:Comment>Trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o249">
<a:Name>EnableMultiTrigger</a:Name>
<a:Comment>Multi trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o250">
<a:Name>DefaultTriggerName</a:Name>
<a:TextTargetItem.Value>%TEMPLATE%_%.L:TABLE%</a:TextTargetItem.Value>
<a:Comment>Default trigger name</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o251">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o252">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
          from sysobjects
          where id = object_id(&#39;[%QUALIFIER%]%TRIGGER%&#39;)
          and type = &#39;TR&#39;)
   drop trigger [%QUALIFIER%]%TRIGGER%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a trigger. Example: drop trigger %TRIGGER%</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o253">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o254">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER, TABLE, OWNER, TRIGGER, TRGEVENT}

select
   ub.name,
   tb.name,
   ur.name,
   tr.name,
   case (tr.status &amp; 0x400) when 0 then &#39;&#39; else &#39;insert,&#39; end +
   case (tr.status &amp; 0x200) when 0 then &#39;&#39; else &#39;update,&#39; end +
   case (tr.status &amp; 0x100) when 0 then &#39;&#39; else &#39;delete,&#39; end
from
   [%CATALOG%.]sys.sysobjects tr
   join [%CATALOG%.]sys.sysobjects tb on (tb.id = tr.parent_obj)
   join [%CATALOG%.]sys.schemas    ur on (ur.schema_id = tr.uid)
   join [%CATALOG%.]sys.schemas    ub on (ub.schema_id = tb.uid)
where 
   tr.type = &#39;TR&#39;
[  and ub.name =%.q:TABLOWNER%]
[  and ur.name =%.q:SCHEMA%]
[  and tb.name = %.q:TABLE%]
order by
   1, 2, 3, 4</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o255">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER ID, TABLE ID, OWNER ID, TRIGGER ID, SCRIPT ...}

select
   ub.name,
   tb.name,
   ur.name,
   tr.name,
   cm.text
from
   [%CATALOG%.]sys.sysobjects tr
   join [%CATALOG%.]sys.sysobjects  tb on (tb.id = tr.parent_obj)
   join [%CATALOG%.]sys.schemas     ur on (ur.schema_id = tr.uid)
   join [%CATALOG%.]sys.schemas     ub on (ub.schema_id = tb.uid)
   join [%CATALOG%.]sys.syscomments cm on (cm.id = tr.id)
where 
   tr.type = &#39;TR&#39;
[  and ub.name =%.q:TABLOWNER%]
[  and ur.name =%.q:SCHEMA%]
[  and tb.name = %.q:TABLE%]
[  and tr.name =%.q:TRIGGER%]
order by
   1, 2, 3, 4, cm.number, cm.colid
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o256">
<a:Name>UseErrorMsgTable</a:Name>
<a:TextTargetItem.Value>begin
   select @errno  = %ERRNO%,
          @errmsg = %MSGTXT%
   from   %MSGTAB%
   where  %MSGNO% = %ERRNO%
   goto error
end</a:TextTargetItem.Value>
<a:Comment>Errors handling using an error messages table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o257">
<a:Name>UseErrorMsgText</a:Name>
<a:TextTargetItem.Value>begin
   select @errno  = %ERRNO%,
          @errmsg = %.q:ERRMSG%
   goto error
end</a:TextTargetItem.Value>
<a:Comment>Errors handling using fixed error messages</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o258">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create trigger [%QUALIFIER%]%TRIGGER% on [%TABLQUALIFIER%]%TABLE%[%R%? with encryption] for %TRGEVENT%
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a trigger. Example: create trigger on [%QUALIFIER%]%TABLE% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o259">
<a:Name>EventDelimiter</a:Name>
<a:Comment>Events separation character.</a:Comment>
<a:StringTargetItem.Value>,</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o260">
<a:Name>ViewTime</a:Name>
<a:TextTargetItem.Value>Instead of</a:TextTargetItem.Value>
<a:Comment>Time list available from trigger on view.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o261">
<a:Name>Procedure</a:Name>
<a:Code>PROC</a:Code>
<a:Comment>The following system variables are available:
   &quot;PROC&quot;         // generated code of the procedure (also available for trigger when the trigger is implemented with a procedure)
   &quot;FUNC&quot;         // generated code of the procedure if the procedure is a function (with return value)
   &quot;PROCPRMS&quot;     // list of parameters of the procedure (also available for function)
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o262">
<a:Name>Enable</a:Name>
<a:Comment>Procedure allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o263">
<a:Name>EnableFunc</a:Name>
<a:Comment>Function allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o264">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o265">
<a:Name>MaxFuncLen</a:Name>
<a:Comment>Function name length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o266">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
          from sysobjects
          where  id = object_id(&#39;[%QUALIFIER%]%PROC%&#39;)
          and type = &#39;P&#39;)
   drop procedure [%QUALIFIER%]%PROC%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a procedure. Example: drop procedure %PROC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o267">
<a:Name>DropFunc</a:Name>
<a:TextTargetItem.Value>if exists (select 1
          from sysobjects
          where  id = object_id(&#39;[%QUALIFIER%]%FUNC%&#39;)
          and type in (&#39;IF&#39;, &#39;FN&#39;, &#39;TF&#39;))
   drop function [%QUALIFIER%]%FUNC%
</a:TextTargetItem.Value>
<a:Comment>Command for dropping a function. Example: drop function %FUNC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o268">
<a:Name>CustomProc</a:Name>
<a:TextTargetItem.Value>create procedure [%QUALIFIER%]%PROC% &lt;@arg&gt; &lt;type&gt; as
declare &lt;@var&gt; &lt;type&gt;
begin

end
</a:TextTargetItem.Value>
<a:Comment>Command for creating a stored procedure</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o269">
<a:Name>CustomFunc</a:Name>
<a:TextTargetItem.Value>create function [%QUALIFIER%]%FUNC% (&lt;arg&gt; &lt;type&gt;)
RETURNS &lt;type&gt;
begin

end
</a:TextTargetItem.Value>
<a:Comment>Command for creating a function</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o270">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o271">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, PROC, FUNC}

select
   u.name,
   case(p.type) when &#39;P&#39; then p.name else null end,
   case(p.type) when &#39;P&#39; then null else p.name end
from
   [%CATALOG%.]sys.sysobjects p
   join [%CATALOG%.]sys.schemas u on (u.schema_id = p.uid)
where
   p.type in (&#39;IF&#39;, &#39;FN&#39;, &#39;TF&#39;, &#39;P&#39;)
[  and u.name=%.q:SCHEMA%]
order by
   1,2,3
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o272">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, PROC ID, SCRIPT ...}

select
   u.name,
   p.name,
   t.text
from
   [%CATALOG%.]sys.sysobjects       p
   join [%CATALOG%.]sys.schemas     u on (u.schema_id = p.uid)
   join [%CATALOG%.]sys.syscomments t on (t.id = p.id)
where
   p.type in (&#39;P&#39;, &#39;IF&#39;, &#39;FN&#39;, &#39;TF&#39;)
[  and u.name=%.q:OWNER%]
[  and p.name=%.q:PROC%]
order by
   t.id, t.number, t.colid
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o273">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a procedure.
The first column is the SQL name of permission (eg: EXECUTE)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>EXECUTE=Execute</a:MapTargetItem.Value>
<a:List>EXECUTE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o274">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [.O:[procedure ][proc ]][%QUALIFIER%]%PROC%[ %PROCPRMS%] as
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a procedure. Example: create procedure %PROC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o275">
<a:Name>CreateFunc</a:Name>
<a:TextTargetItem.Value>create function [%QUALIFIER%]%FUNC%[%PROCPRMS%?([%PROCPRMS%])]
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a function. Example: create function %FUNC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o276">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

select 
   v.name,
   case (s.action) when 224 then &#39;EXECUTE&#39; end +
   case (s.protecttype) when 204 then &#39;+&#39; when 205 then &#39;&#39; when 206 then &#39;-&#39; end + &#39;,&#39;
from 
   [%CATALOG%.]sys.sysprotects s
   join [%CATALOG%.]sys.sysusers    v on (v.uid = s.uid)
   join [%CATALOG%.]sys.sysobjects  o on (o.id = s.id)
   join [%CATALOG%.]sys.sysusers    u on (u.uid = o.uid)
where 1 = 1
[  and o.name = %.q:PROC%]
[  and u.name = %.q:OWNER%]
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o277">
<a:Name>Role</a:Name>
<a:Code>ROLE</a:Code>
<a:Comment>Manages the role object.</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o278">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_addrole %ROLE%</a:TextTargetItem.Value>
<a:Comment>Command for creating a role.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o279">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_droprole %ROLE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a role.</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o280">
<a:Name>Enable</a:Name>
<a:Comment>Role allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o281">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_addrolemember %ROLE%, %USER%</a:TextTargetItem.Value>
<a:Comment>Command for assigning a role to a user or another role</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o282">
<a:Name>Unbind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_droprolemember %ROLE%, %USER%</a:TextTargetItem.Value>
<a:Comment>Command for unassiging a role from a user or another role</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o283">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{ ROLE }

select name from [%CATALOG%.]sys.sysusers where issqlrole = 1
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o284">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{ROLE ID, PRIVILEGE ...}

select
   u.name,
   case (s.action) when 178 then &#39;CREATE FUNCTION&#39;  when 198 then &#39;CREATE TABLE&#39;     when 203 then &#39;CREATE DATABASE&#39;
                   when 207 then &#39;CREATE VIEW&#39;      when 222 then &#39;CREATE PROCEDURE&#39; when 228 then &#39;BACKUP DATABASE&#39;
                   when 233 then &#39;CREATE DEFAULT&#39;   when 235 then &#39;BACKUP LOG&#39;       when 236 then &#39;CREATE RULE&#39; end +
   case (s.protecttype) when 204 then &#39;+&#39; when 205 then &#39;&#39; when 206 then &#39;-&#39; end + &#39;,&#39;
from
   [%CATALOG%.]sys.sysprotects s
   join [%CATALOG%.]sys.sysusers u on (s.uid = u.uid and u.issqlrole = 1)
where 
   s.id = 0
order by 1
</a:TextTargetItem.Value>
<a:Comment>Query to reverse privileges</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o285">
<a:Name>SqlListChildrenQuery</a:Name>
<a:TextTargetItem.Value>{ROLE, MEMBER}

select
   r.name,
   m.name
from
   [%CATALOG%.]sys.sysmembers x
   join [%CATALOG%.]sys.sysusers r on (r.uid = x.groupuid)
   join [%CATALOG%.]sys.sysusers m on (m.uid = x.memberuid)
</a:TextTargetItem.Value>
<a:Comment>SQL query to list assigned ids to the role.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o286">
<a:Name>Synonym</a:Name>
<a:Code>SYNM</a:Code>
<a:Comment>Manages the synonym object.</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o287">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create synonym [%QUALIFIER%]%SYNONYM% for [%BASEQUALIFIER%]%BASEOBJECT%</a:TextTargetItem.Value>
<a:Comment>Command for creating a synonym.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o288">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop synonym [%QUALIFIER%]%SYNONYM%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a synonym.</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o289">
<a:Name>Enable</a:Name>
<a:Comment>Synonym allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o290">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, SYNONYM, BASEOWNER, BASEOBJECT}

select
   user_name(s.schema_id),
   s.name,
   user_name(o.uid),
   o.name
from 
   sys.synonyms s
   join sysobjects o on (o.id = object_id(s.base_object_name))
where s.type = &#39;SN&#39;
[  and user_name(s.schema_id)=%.q:OWNER%]</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o291">
<a:Name>EnableSynonym</a:Name>
<a:Comment>Synonym supported</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o292">
<a:Name>DataType</a:Name>
<a:Comment>Contains data type translation entries. These entries list the correspondence between internal data types and the target database data types</a:Comment>
<c:Categories>
<o:MapTargetItem Id="o293">
<a:Name>AmcdDataType</a:Name>
<a:Comment>Data types translation table from internal data types to target database data types.
        %n is the length of the data type
        %s is the size of the data type
        %p is the precision of the data type</a:Comment>
<a:MapTargetItem.Value>&lt;UNDEF&gt;=&lt;Undefined&gt;
A%n=char(%n)
VA%n=varchar(%n)
LA=varchar(1)
LA%n=varchar(%n)
LVA=varchar(1)
LVA%n=varchar(%n)
BT=tinyint
BT%n=tinyint
SI=smallint
I=int
LI=bigint
N=numeric
N%n=numeric(%n)
N%s,%p=numeric(%s,%p)
DC=decimal
DC%n=decimal(%n)
DC%s,%p=decimal(%s,%p)
SF=real
F=float
F%n=float(%n)
LF=double precision
MN=money
MN%n=money
MN%s,%p=money
D=datetime
T=datetime
DT=datetime
TS=timestamp
BL=bit
NO=numeric
NO%n=numeric(%n)
BIN%n=binary(%n)
LBIN=ntext
LBIN%n=varbinary(%n)
TXT=text
TXT%n=text
MBT=nchar(1)
MBT%n=nchar(%n)
VMBT=nvarchar(255)
VMBT%n=nvarchar(%n)
PIC=image
PIC%n=image
BMP=image
BMP%n=image
OLE=image
OLE%n=image
*=char(10)</a:MapTargetItem.Value>
<a:List>&lt;UNDEF&gt;
A%n
VA%n
LA
LA%n
LVA
LVA%n
BT
BT%n
SI
I
LI
N
N%n
N%s,%p
DC
DC%n
DC%s,%p
SF
F
F%n
LF
MN
MN%n
MN%s,%p
D
T
DT
TS
BL
NO
NO%n
BIN%n
LBIN
LBIN%n
TXT
TXT%n
MBT
MBT%n
VMBT
VMBT%n
PIC
PIC%n
BMP
BMP%n
OLE
OLE%n
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o294">
<a:Name>PhysDataType</a:Name>
<a:Comment>Data types translation table from target database data types to internal data types.</a:Comment>
<a:MapTargetItem.Value>&lt;Undefined&gt;=&lt;UNDEF&gt;
char(%n)=A%n
character(%n)=A%n
varchar(%n)=VA%n
char varying(%n)=VA%n
character varying(%n)=VA%n
sysname=VMBT128
uniqueidentifier=VA36
tinyint=BT
smallint=SI
int=I
integer=I
bigint=LI
numeric=N
numeric(%n)=N%n
numeric(%s,%p)=N%s,%p
decimal=DC
decimal(%n)=DC%n
decimal(%s,%p)=DC%s,%p
dec=DC
dec(%n)=DC%n
dec(%s,%p)=DC%s,%p
real=SF
float=F
float(%n)=F%n
double precision=LF
money=MN
smallmoney=MN
datetime=DT
smalldatetime=DT
timestamp=TS
bit=BL
binary(%n)=BIN%n
ntext=LBIN
varbinary(%n)=BIN%n
binary varying(%n)=BIN%n
text=TXT
nchar(%n)=MBT%n
nvarchar(%n)=VMBT%n
image=PIC
xml=XML
*=A10</a:MapTargetItem.Value>
<a:List>&lt;Undefined&gt;
char(%n)
character(%n)
varchar(%n)
char varying(%n)
character varying(%n)
sysname
uniqueidentifier
tinyint
smallint
int
integer
bigint
numeric
numeric(%n)
numeric(%s,%p)
decimal
decimal(%n)
decimal(%s,%p)
dec
dec(%n)
dec(%s,%p)
real
float
float(%n)
double precision
money
smallmoney
datetime
smalldatetime
timestamp
bit
binary(%n)
ntext
varbinary(%n)
binary varying(%n)
text
nchar(%n)
nvarchar(%n)
image
xml
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o295">
<a:Name>PhysDttpSize</a:Name>
<a:Comment>Table of storage sizes of target database data type</a:Comment>
<a:MapTargetItem.Value>smallmoney=4
datetime=8
smalldatetime=4
timestamp=8
uniqueidentifier=16</a:MapTargetItem.Value>
<a:List>smallmoney
datetime
smalldatetime
timestamp
uniqueidentifier
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o296">
<a:Name>OdbcPhysDataType</a:Name>
<a:Comment>Data types translation table from ODBC data types to target database data types.</a:Comment>
<a:MapTargetItem.Value>nvarchar(128)=sysname
numeric(18)=numeric
decimal(18)=decimal
float(24)=real
float(53)=float
sql_variant(8016)=sql_variant</a:MapTargetItem.Value>
<a:List>nvarchar(128)
numeric(18)
decimal(18)
float(24)
float(53)
sql_variant(8016)
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o297">
<a:Name>PhysOdbcDataType</a:Name>
<a:Comment>Data types translation table from target database data types to ODBC data types.</a:Comment>
<a:MapTargetItem.Value>int=integer
character varying=varchar
character varying(%n)=varchar(%n)
dec=decimal
dec(%n)=decimal(%n)
dec(%s,%p)=decimal(%s,%p)
char varying=varchar
char varying(%n)=varchar(%n)</a:MapTargetItem.Value>
<a:List>int
character varying
character varying(%n)
dec
dec(%n)
dec(%s,%p)
char varying
char varying(%n)
</a:List>
</o:MapTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:ProfileTargetItem Id="o298">
<a:Name>Profile</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TargetCategory Id="o299">
<a:Name>Shared</a:Name>
<a:Code>Shared</a:Code>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o300">
<a:TypePublicName>ExtendedAttributeTypeTargetItem</a:TypePublicName>
<a:Name>Extended Attribute Types</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTypeTargetItem Id="o301">
<a:ObjectID>B9F09C64-B72D-44CE-BFCC-401F64E5393E</a:ObjectID>
<a:Name>WithOptionList</a:Name>
<a:Comment>This type contains the list of available parameters for the view extended attribute: WithOption</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>encryption
schemabinding
view_metadata</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o302">
<a:ObjectID>892519C4-6998-4423-AAA5-7436D604C981</a:ObjectID>
<a:Name>DimensionOptionTypes</a:Name>
<a:Comment>The UNIQUE_NAME options indicates that member names are unique within the dimension.

The UNIQUE_KEY option indicates that member keys are unique within the dimension.

The NOTRELATEDTOFACTTABLE option indicates that non-leaf members cannot be associated to fact table data.

The ALLOWSIBLINGSWITHSAMENAME option of the dimension determines whether children of a single member in a hierarchy can have identical names. </a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>UNIQUE_NAME
UNIQUE_KEY
NOTRELATEDTOFACTTABLE
ALLOWSIBLINGSWITHSAMENAME</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o303">
<a:ObjectID>B00A7542-F40D-4C47-8AB2-AF77813CDDA7</a:ObjectID>
<a:Name>LevelHidesValues</a:Name>
<a:Comment>The option BLANK_NAME hides a level member having an empty name.

The option PARENT_NAME hides a level member when the member name is identical to that of its parent.

The option ONLY_CHILD_AND_BLANK_NAME hides a level member when it is the only child of its parent and its name is null or an empty string.

The option ONLY_CHILD_AND_PARENT_NAME hides a level member when it is the only child of its parent and its name is the same as its parent&#39;s name.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>ONLY_CHILD_AND_BLANK_NAME
ONLY_CHILD_AND_PARENT_NAME
BLANK_NAME
PARENT_NAME</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o304">
<a:ObjectID>722A1296-3BA4-4E6F-8A3D-151C016E016E</a:ObjectID>
<a:Name>LevelOptions</a:Name>
<a:Comment>The UNIQUE option indicates that the members of a level are unique.

The UNIQUE_NAME option indicates that the members of a level are uniquely identified by their member name column.

The UNIQUE_KEY  option indicates that the members of a level are uniquely identified by their member key column.

The NOTRELATEDTOFACTTABLE option indicates that level members cannot be associated to fact table data.

The SORTBYNAME option indicates that level members are ordered by their names.

The SORTBYKEY option indicates that level members are ordered by their keys.

The SORTBYPROPERTY options indicates that members are ordered by their property &lt;property names&gt;.
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>UNIQUE
UNIQUE_NAME
UNIQUE_KEY
NOTRELATEDTOFACTTABLE
SORTBYNAME
SORTBYKEY 
SORTBYPROPERTY &lt;property name&gt;</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o305">
<a:ObjectID>A49388C5-4F64-48E7-BCCE-F4F290528FAA</a:ObjectID>
<a:Name>LevelRootValues</a:Name>
<a:Comment>ROOT_IF_PARENT_IS_BLANK:
Only members with a null, a zero, or an empty string in their parent key column are treated as root members.

ROOT_IF_PARENT_IS_MISSING:
Only members with parents that cannot be found are treated as root members.

ROOT_IF_PARENT_IS_SELF:
Only members with themselves as parents are treated as root members.

ROOT_IF_PARENT_IS_BLANK_OR_SELF_OR_MISSING:
Members are treated as root members if they meet one or more of the conditions specified by ROOT_IF_PARENT_IS_BLANK, ROOT_IF_PARENT_IS_SELF, or ROOT_IF_PARENT_IS_MISSING.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>ROOT_IF_PARENT_IS_BLANK
ROOT_IF_PARENT_IS_MISSING
ROOT_IF_PARENT_IS_SELF
ROOT_IF_PARENT_IS_BLANK_OR_SELF_OR_MISSING</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o306">
<a:ObjectID>3C5ABE1B-EEBC-4C6E-85B4-7C550131DB66</a:ObjectID>
<a:Name>LevelTypes</a:Name>
<a:Comment>- ALL indicates the top (All) level of a dimension (the one that precalculates all the members of all lower levels).
- YEAR indicates that a level refers to years. It must be used in a dimension whose type is Time dimension.
- QUARTER indicates that a level refers to (calendar) quarters. It must be used in a dimension whose type is Time dimension.
- MONTH indicates that a level refers to months. Must be used in a dimension whose type is Time dimension.
- WEEK indicates that a level refers to weeks. It must be used in a dimension whose type is Time dimension.
- DAY indicates that a level refers to days. It must be used in a dimension whose type is Time dimension.
- DAYOFWEEK indicates that a level refers to days of the week. It must be used in a dimension whose type is Time dimension.
- DATE indicates that a level refers to dates. It must be used in a dimension whose type is Time dimension.
- HOUR indicates that a level refers to hours. It must be used in a dimension whose type is Time dimension.
- MINUTE indicates that a level refers to minutes. It must be used in a dimension whose type is Time dimension.
- SECOND indicates that a level refers to seconds. It must be used in a dimension whose type is Time dimension.



</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>ALL
YEAR
QUARTER
MONTH
WEEK
DAY
DAYOFWEEK
DATE
HOUR
MINUTE
SECOND</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o307">
<a:ObjectID>28FA3E91-E3BA-4D09-8A5E-A5C288A1DEE3</a:ObjectID>
<a:Name>MeasureFunction</a:Name>
<a:Comment>SUM uses the Sum function for aggregation 
MIN uses the Min function for aggregation 
MAX uses the Max function for aggregation 
COUNT uses the Count function for aggregation 
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.Value>SUM</a:ExtendedAttributeTypeTargetItem.Value>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>SUM
MIN
MAX
COUNT</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o308">
<a:ObjectID>EBD43463-F22E-4428-8452-3DFEE6620E0D</a:ObjectID>
<a:Name>OLEDBTypes</a:Name>
<a:Comment>Predefined OLE DB data types.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>DBTYPE_I1
DBTYPE_I2
DBTYPE_I4
DBTYPE_I8
DBTYPE_UI1
DBTYPE_UI2
DBTYPE_UI4
DBTYPE_UI8
DBTYPE_R4
DBTYPE_R8
DBTYPE_CY
DBTYPE_DECIMAL
DBTYPE_NUMERIC
DBTYPE_DATE</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o309">
<a:ObjectID>D82CB336-84E5-499D-BBDA-CE744EF3DB8E</a:ObjectID>
<a:Name>SubTypes</a:Name>
<a:Comment>PARENT_CHILD indicates that the level is a parent-child level.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>PARENT_CHILD</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o310">
<a:ObjectID>31B52E04-3C94-44C6-B6C7-7ECEA00F9EF8</a:ObjectID>
<a:Name>TimeTypes</a:Name>
<a:Comment>TIME indicates that a dimension refers to time (year, month, week, day, and so on). The only valid levels in a time dimension are those defined in the LevelTypes enumeration.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>TIME</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
<o:ExtendedAttributeTypeTargetItem Id="o311">
<a:ObjectID>D5E028AC-6D39-4D78-ADC1-EF44176D9BD8</a:ObjectID>
<a:Name>CubeOptions</a:Name>
<a:Comment>The DEFER_DATA option causes the query to be parsed locally and executed only when necessary to retrieve data to satisfy a user request. DEFER_DATA is used to specify that a local cube be defined in the ROLAP storage mode.

The ATTEMPT_DEFER option causes PivotTable Service to attempt to parse the query and defer data loading if successful, or, if the query cannot be parsed, to process the specified query immediately as if the PASSTHROUGH had been specified.

The PASSTHROUGH option causes the SELECT clause to be passed directly to the source database without modification by PivotTable Service. If PASSTHROUGH is not specified, PivotTable Service parses the query and formulates a set of queries equivalent to the original that is optimized for the source database and index structures. This set of queries is often more efficient than the specified query.

The ATTEMPT_ANALYSIS option causes PivotTable Service to attempt to parse the query and formulate an optimized set of queries. If the query cannot be parsed, PivotTable Services processes the query immediately as if the PASSTHROUGH had been specified.


</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTypeTargetItem.ListOfValues>DEFER_DATA
ATTEMPT_DEFER
PASSTHROUGH
ATTEMPT_ANALYSIS</a:ExtendedAttributeTypeTargetItem.ListOfValues>
</o:ExtendedAttributeTypeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o312">
<a:TypePublicName>TemplateTargetItem</a:TypePublicName>
<a:Name>Templates</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TemplateTargetItem Id="o313">
<a:Name>usedb</a:Name>
<a:TemplateTargetItem.Value>.if(%.l:@1%==master)
use master
go
.elsif(%*@1%)
use %*@1.Code%
go
.endif(\n)</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:TargetCategory>
<o:MetaClassTargetItem Id="o314">
<a:Name>Table</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:EnableSelectionGeneration>1</a:EnableSelectionGeneration>
<c:Categories>
<o:TypedCategoryTargetItem Id="o315">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o316">
<a:Name>Table Timestamp Uniqueness</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that a table has no more than one timestamp column.</a:HelpMessage>
<a:OutputMessage>The following tables have more than one timestamp column:</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   dim pCol, bTSFound
   bTSFound = false
   for each pCol in obj.Columns
      if GetDatatypeName(pCol.datatype) = &quot;timestamp&quot; then
         if (bTSFound) then
            %Check% = false
            exit function
         end if
         bTSFound = true
      end if
   next
   %Check% = True
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o317">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o318">
<a:ObjectID>1C6A48DF-8ECD-48B7-93FF-975F64ABCCC1</a:ObjectID>
<a:Name>ExtCktNotForReplication</a:Name>
<a:Comment>Specifies that &quot;NOT FOR REPLICATION&quot; keywords are used to prevent the TABLE CHECK constraint from being enforced during the distribution process used by replication.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.Value>false</a:ExtendedAttributeTargetItem.Value>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o319">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o320">
<a:Name>Microsoft</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Name=&quot;ExtCktNotForReplication&quot; Caption=&quot;Do not validate check constraints during replication&quot; Attribute=&quot;ExtCktNotForReplication&quot; AttributeID=&quot;{1C6A48DF-8ECD-48B7-93FF-975F64ABCCC1}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o321">
<a:Name>Column</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o322">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o323">
<a:Name>Identity Seed and Increment validity</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that the values given to the extended attribute containing Seed and Increment values of identity column are correct.</a:HelpMessage>
<a:OutputMessage>The following identity columns have inconsistent Seed or Increment value:</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   if (obj.Identity) then
      dim SeedInc
      SeedInc = CStr(obj.GetExtendedAttribute(&quot;ExtIdentitySeedInc&quot;))
      if (SeedInc &lt;&gt; &quot;&quot;) then
         Dim Pos
         Pos = InStr(SeedInc, &quot;,&quot;)
         if (Pos = 0) then &#39; need both increment and seed
            %Check% = False
            exit function
         end if
         if not IsNumeric(left(SeedInc, Pos - 1)) then &#39; Seed value is not numeric
            %Check% = False
            exit function
         end if
         if not IsNumeric(mid(SeedInc, Pos + 1)) then &#39; Increment value is not numeric
            %Check% = False
            exit function
         end if
      end if
   end if
   %Check% = True
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o324">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o325">
<a:ObjectID>0E6DF720-2E9D-4887-A054-D4E0BE049925</a:ObjectID>
<a:Name>ExtIdentitySeedInc</a:Name>
<a:Comment>This attribute is composed of two integer parts, separated with a comma.
First part is the value to be assigned to the first row in the table (Seed).
Second part is the increment to add to the seed value for successive rows in the table.
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o326">
<a:ObjectID>DBCC2550-2E14-483D-B8CB-92FEC0228EAF</a:ObjectID>
<a:Name>ExtDeftConstName</a:Name>
<a:Comment>Contains the name of the constraint that is used to apply a default value to the column. If empty, the &quot;constraint&quot; keyword is not generated.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o327">
<a:ObjectID>51BFCE09-B00F-4938-9581-18E244126563</a:ObjectID>
<a:Name>ExtCkcNotForReplication</a:Name>
<a:Comment>Specifies that &quot;NOT FOR REPLICATION&quot; keywords are used to prevent the CHECK constraint from being enforced during the distribution process used by replication.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.Value>false</a:ExtendedAttributeTargetItem.Value>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o328">
<a:ObjectID>B5955B6D-A5DF-415E-A106-73D9521B2689</a:ObjectID>
<a:Name>ExtIdtNotForReplication</a:Name>
<a:Comment>Indicates that the IDENTITY property should not be enforced when a replication login inserts data into the table.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.Value>false</a:ExtendedAttributeTargetItem.Value>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o329">
<a:ObjectID>BD3B8539-4CDF-4A38-9A3D-6EC5E4D8D391</a:ObjectID>
<a:Name>ExtNullConstName</a:Name>
<a:Comment>Contains the name of the constraint that is used to apply a mandatory property of the column. If empty, the &quot;constraint&quot; keyword is not generated.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o330">
<a:ObjectID>A0A25FE3-6358-495A-95F9-8A6A4207D7CC</a:ObjectID>
<a:Name>ExtCollation</a:Name>
<a:Comment>A single string that specifies the collation name for a SQL collation.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o331">
<a:ObjectID>49F1CDB4-FD80-483E-B2E8-E3357E724BCF</a:ObjectID>
<a:Name>ExtRowGuidCol</a:Name>
<a:Comment>Indicates that the new column is a row global unique identifier column. Only one unique identifier column per table can be designated as the ROWGUIDCOL column.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.Value>false</a:ExtendedAttributeTargetItem.Value>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o332">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o333">
<a:Name>Microsoft</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtRowGuidCol&quot; AttributeID=&quot;{49F1CDB4-FD80-483E-B2E8-E3357E724BCF}&quot; Name=&quot;ExtRowGuidCol&quot; Caption=&quot;Row global unique identifier&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtCkcNotForReplication&quot; AttributeID=&quot;{51BFCE09-B00F-4938-9581-18E244126563}&quot; Name=&quot;ExtCkcNotForReplication&quot; Caption=&quot;Do not validate check constraints during replication&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtDeftConstName&quot; AttributeID=&quot;{DBCC2550-2E14-483D-B8CB-92FEC0228EAF}&quot; Name=&quot;ExtDeftConstName&quot; Caption=&quot;Default constraint name&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtNullConstName&quot; AttributeID=&quot;{BD3B8539-4CDF-4A38-9A3D-6EC5E4D8D391}&quot; Name=&quot;ExtNullConstName&quot; Caption=&quot;Not null constraint name&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;ExtCollation&quot; AttributeID=&quot;{A0A25FE3-6358-495A-95F9-8A6A4207D7CC}&quot; Name=&quot;ExtCollation&quot; Caption=&quot;Collation name&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;GroupBox Name=&quot;Identity&quot;   Caption=&quot;Identity column&quot; ControlAsLabel=&quot;No&quot; &gt;
      &lt;ExtendedAttribute Attribute=&quot;ExtIdentitySeedInc&quot; AttributeID=&quot;{0E6DF720-2E9D-4887-A054-D4E0BE049925}&quot; Name=&quot;ExtIdentitySeedInc&quot; Caption=&quot;Identity seed and increment&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
      &lt;ExtendedAttribute Attribute=&quot;ExtIdtNotForReplication&quot; AttributeID=&quot;{B5955B6D-A5DF-415E-A106-73D9521B2689}&quot; Name=&quot;ExtIdtNotForReplication&quot; Caption=&quot;Identity value not replicated&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;/GroupBox&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o334">
<a:Name>Cube</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:EnableSelectionGeneration>1</a:EnableSelectionGeneration>
<c:Categories>
<o:TypedCategoryTargetItem Id="o335">
<a:TypePublicName>GeneratedFileTargetItem</a:TypePublicName>
<a:Name>Generated Files</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:GeneratedFileTargetItem Id="o336">
<a:Name>Create</a:Name>
<a:TemplateTargetItem.Value>%CreateCube%</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:GeneratedFileTargetItem>
<o:GeneratedFileTargetItem Id="o337">
<a:Name>Populate</a:Name>
<a:TemplateTargetItem.Value>%InsertCube%</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:GeneratedFileTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o338">
<a:TypePublicName>TemplateTargetItem</a:TypePublicName>
<a:Name>Templates</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TemplateTargetItem Id="o339">
<a:Name>CreateCube</a:Name>
<a:TemplateTargetItem.Value>.set_value(CubeName, %GeneratedName%,new)
CREATE CUBE %GeneratedName%
(\n
.foreach_item(CubeDimensionAssociations,,)
   %CubeDimensionAssocationDef%
.next(,\n)
.if ((%Fact%) &amp;&amp; (%Fact.Measures.IsEmpty% == false))
   .foreach_item(Fact.Measures,&quot;,\n&quot;)
      .if (%Formula% == false)
   %MeasureDef%
      .endif
   .next(,\n)
   .foreach_item(Fact.Measures,&quot;,\n&quot;)
      .if (%Formula% == true)
   %CommandDef%
      .endif
   .next(,\n)
.endif

)</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o340">
<a:Name>InsertCube</a:Name>
<a:TemplateTargetItem.Value>.if (%DefaultMapping%)
   .set_value(_columns,&quot;&quot;,new)
INSERT INTO %GeneratedName% (
   .foreach_item(CubeDimensionAssociations,\n,)
   .if (%Hierarchy%)
      .foreach_item(Hierarchy.Attributes)
         .ifnot (%SourceMaps.IsEmpty%)
   %Dimension.GeneratedName%.%GeneratedName%
            .if (%_columns%)
               .set_value(_columns, &quot;%_columns%,\n&quot;)
               .set_value(_columns, %_columns% %SourceMaps.First.SourceFeature.FullCode%)
            .else
               .set_value(_columns, %SourceMaps.First.SourceFeature.FullCode%)
            .endif
         .endif
      .next(&quot;,\n&quot;)
   .elsif (%Dimension.DimensionHierarchies.IsEmpty% == false%)
      .foreach_item(Dimension.DimensionHierarchies)
         .foreach_item(Attributes)
            .ifnot (%SourceMaps.IsEmpty%)
   %Dimension.GeneratedName%.%Outer.GeneratedName%.%GeneratedName%
               .if (%_columns%)
                  .set_value(_columns, &quot;%_columns%,\n&quot;)
               .endif
               .set_value(_columns, %_columns% %SourceMaps.First.SourceFeature.FullCode%)
            .endif
         .next(&quot;,\n&quot;)
      .next(&quot;,\n&quot;)
   .else
      .foreach_item(Dimension.Attributes)
         .ifnot (%SourceMaps.IsEmpty%)
   %Dimension.GeneratedName%.%GeneratedName%
            .if (%_columns%)
               .set_value(_columns, &quot;%_columns%,\n&quot;)
            .endif
               .set_value(_columns, [%_columns%]%SourceMaps.First.SourceFeature.FullCode%)
          .endif
      .next(&quot;,\n&quot;)
   .endif
   .next(&quot;,\n&quot;)
   .if (%Fact%)
      .foreach_item(Fact.Measures,&quot;,\n&quot;)
   %GeneratedName%
      .next(&quot;,\n&quot;)
   .endif
)
[\
OPTIONS %Options%
]\
SELECT\n
.replace(\\n,&quot;\n   &quot;)
   %_columns%
.endreplace(\n)
FROM\n
   .foreach_item(DefaultMapping.CubeSources, &quot;   &quot;, \n)
.if (%Owner%)
%Owner.GeneratedName%
.endif(.)
%GeneratedName%
   .next(&quot;, &quot;)
   .foreach_item(DefaultMapping.CubeSourceLinks, &quot;WHERE\n&quot;)
      .foreach_item(Joins)
   %ParentTableColumn.FullCode% = %ChildTableColumn.FullCode%
      .next(&quot; AND \n&quot;)
   .next(&quot; AND \n&quot;)
.endif</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o341">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o342">
<a:ObjectID>D84F7805-9521-4696-9EC5-96989A2E6ED7</a:ObjectID>
<a:Name>Options</a:Name>
<a:Comment>Passthrough and advanced query processing options.
Used in the &quot;insert into&quot; statement to populate the cube.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o311"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o343">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o344">
<a:Name>Microsoft</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Name=&quot;Options&quot; Caption=&quot;Options&quot; Attribute=&quot;Options&quot; AttributeID=&quot;{D84F7805-9521-4696-9EC5-96989A2E6ED7}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o345">
<a:Name>CubeDimensionAssociation</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o346">
<a:TypePublicName>TemplateTargetItem</a:TypePublicName>
<a:Name>Templates</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TemplateTargetItem Id="o347">
<a:Name>CubeDimensionAssocationDef</a:Name>
<a:TemplateTargetItem.Value>%Dimension.DimensionDef%,\n
.if (%Hierarchy%)
      %Hierarchy.HierarchyAllLevelDef%
.elsif (%Dimension.DimensionHierarchies.IsEmpty% == false)
   .foreach_item(Dimension.DimensionHierarchies,, \n)
   %HierarchyDef%,
      %HierarchyAllLevelDef%
   .next(&quot;,\n&quot;)
.else
      %Dimension.AllLevelDef%
.endif</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o348">
<a:Name>FactMeasure</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o349">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o350">
<a:ObjectID>E6E0F5DB-EC9F-4E54-BD66-364F4F0403F3</a:ObjectID>
<a:Name>Format</a:Name>
<a:Comment>Format used to display the values of the cube measure</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o351">
<a:ObjectID>9F179669-560E-4B08-B207-2F9B6A0BA9B5</a:ObjectID>
<a:Name>Function</a:Name>
<a:Comment>A value corresponding to the type of aggregate function used by the cube measure</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<a:ExtendedAttributeTargetItem.Value>SUM</a:ExtendedAttributeTargetItem.Value>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o307"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o352">
<a:ObjectID>CFC048B1-A5E8-4537-B09C-3403266A008F</a:ObjectID>
<a:Name>IsHidden</a:Name>
<a:Comment>Indicates whether the measure is visible to the client</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o353">
<a:ObjectID>CD875553-23BA-4FB6-A44D-B89B6448F9D2</a:ObjectID>
<a:Name>Type</a:Name>
<a:Comment>Returns a OLE DB enumeration constant that identifies the SourceColumn (in the fact table) data type</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o308"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o354">
<a:ObjectID>6BB626BB-07E0-4D3A-BB77-5862B9CBCFAD</a:ObjectID>
<a:Name>SolveOrder</a:Name>
<a:Comment>Order in which the calculated member will be solved when calculated members intersect each other</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>10</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o355">
<a:TypePublicName>TemplateTargetItem</a:TypePublicName>
<a:Name>Templates</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TemplateTargetItem Id="o356">
<a:Name>HiddenDef</a:Name>
<a:TemplateTargetItem.Value>.if (%IsHidden%)
HIDDEN
.endif</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o357">
<a:Name>MeasureDef</a:Name>
<a:TemplateTargetItem.Value>MEASURE %GeneratedName% %MeasureFunctionDef%[ %MeasureFormatDef%][ %MeasureTypeDef%][ %HiddenDef%]</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o358">
<a:Name>MeasureFormatDef</a:Name>
<a:TemplateTargetItem.Value>[FORMAT %Format%]</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o359">
<a:Name>MeasureFunctionDef</a:Name>
<a:TemplateTargetItem.Value>FUNCTION %Function%</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o360">
<a:Name>MeasureTypeDef</a:Name>
<a:TemplateTargetItem.Value>[TYPE %Type%]</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o361">
<a:Name>CommandDef</a:Name>
<a:TemplateTargetItem.Value>COMMAND ( CREATE MEMBER \[%CubeName%\].\[Measures\].\[%GeneratedName%\] as &#39;%formula%&#39;
.if (%IsHidden%)
, VISIBLE = 1
.endif
.if (%Format%)
, FORMAT_STRING = %Format%
.endif
.if (%SolveOrder%)
, SOLVEORDER = %SolveOrder%
.endif
)</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o362">
<a:Name>formula</a:Name>
<a:TemplateTargetItem.Value>%FormulaExpression%</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o363">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o364">
<a:Name>Microsoft</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Name=&quot;Function&quot; Caption=&quot;Cube measure function type&quot; Attribute=&quot;Function&quot; AttributeID=&quot;{9F179669-560E-4B08-B207-2F9B6A0BA9B5}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;Type&quot; Caption=&quot;Source column data type&quot; Attribute=&quot;Type&quot; AttributeID=&quot;{CD875553-23BA-4FB6-A44D-B89B6448F9D2}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;SolveOrder&quot; Caption=&quot;Member calculating order&quot; Attribute=&quot;SolveOrder&quot; AttributeID=&quot;{6BB626BB-07E0-4D3A-BB77-5862B9CBCFAD}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;Format&quot; Caption=&quot;Format&quot; Attribute=&quot;Format&quot; AttributeID=&quot;{E6E0F5DB-EC9F-4E54-BD66-364F4F0403F3}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;IsHidden&quot; Caption=&quot;Hidden&quot; Attribute=&quot;IsHidden&quot; AttributeID=&quot;{CFC048B1-A5E8-4537-B09C-3403266A008F}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o365">
<a:Name>Model</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o366">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o367">
<a:Name>Storage requires a database.</a:Name>
<a:Comment>This check ensures that the model has a defined database in order to create storages.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This custom check ensures that a database is defined in the model if it contains a storages.</a:HelpMessage>
<a:OutputMessage>Create a database for the model in the model property sheet.</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   if (obj.Storages.Count = 0) then
      %Check% = True &#39; No storage, no need of checking database existence.
   else
      %Check% = Not(obj.Database is Nothing)
   end if
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o368">
<a:Name>PhysicalDomain</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o369">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o370">
<a:Name>Domain missing default object</a:Name>
<a:Comment>In the SQL SERVER family, you set a default value to a domain using a default object. This check ensures that all domains with a default use a default object.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>A domain cannot have a default value without being attached to a default object. You can either create a default object for the value and run the autofix on the domain or use the Rebuild Default feature.</a:HelpMessage>
<a:OutputMessage>The following domain must be linked to a default object:</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   if (obj.default is Nothing) then &#39;        not an object
      if CStr(obj.defaultvalue) &lt;&gt; &quot;&quot; then &#39; but not empty !!
         %Check% = false
         exit function
      end if
   end if
   %Check% = True
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   if (obj.default is Nothing) then &#39;        not an object
      if CStr(obj.defaultvalue) &lt;&gt; &quot;&quot; then &#39; but not empty !!
         dim pDefault, sDefault
         set pDefault = ActiveModel.CreateObject(cls_PhysicalDefault)
         sDefault = replace(Cstr(obj.DefaultValue), &quot;&#39;&quot;, &quot;&quot;)
         If (CanSetNameCode(pDefault, &quot;D_&quot; &amp; sDefault, &quot;D_&quot; &amp; sDefault)) Then
            pDefault.Name = &quot;D_&quot; &amp; sDefault
            pDefault.Code = &quot;D_&quot; &amp; sDefault
         ElseIf (CanSetNameCode(pDefault, &quot;D_&quot; &amp; Cstr(obj.Name), &quot;D_&quot; &amp; Cstr(obj.Code))) Then
            pDefault.Name = &quot;D_&quot; &amp; Cstr(obj.Name)
            pDefault.Code = &quot;D_&quot; &amp; Cstr(obj.Code)
         Else
            Dim i
            i = 1
            While not (CanSetNameCode(pDefault, &quot;D_&quot; &amp; Cstr(obj.Name) &amp; &quot;_&quot; &amp; CStr(i), &quot;D_&quot; &amp; Cstr(obj.Code) &amp; &quot;_&quot; &amp; CStr(i)))
               i = i + 1
            Wend
            pDefault.Name = &quot;D_&quot; &amp; Cstr(obj.Name) &amp; &quot;_&quot; &amp; CStr(i)
            pDefault.Code = &quot;D_&quot; &amp; Cstr(obj.Code) &amp; &quot;_&quot; &amp; CStr(i)
         End If         
         pDefault.Value = obj.DefaultValue
         Set obj.Default = pDefault
         %Fix% = True
         outmsg = &quot;Default &quot; &amp; pDefault.Name &amp; &quot; created and attached to domain &quot; &amp; obj.Name
         Exit Function
      end if
   end if
   outmsg = &quot;Unknown Error occurs, autofix failed&quot;
   %Fix% = False
End Function
</a:AutoFixScrpt>
<a:EnableAutoFix>1</a:EnableAutoFix>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o371">
<a:Name>Reference</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o372">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o373">
<a:ObjectID>8199587B-82BD-4A15-9DA6-CC85B39724E9</a:ObjectID>
<a:Name>ExtFkNotForReplication</a:Name>
<a:Comment>Specifies that &quot;NOT FOR REPLICATION&quot; keywords are used to prevent the FOREIGN KEY constraint from being enforced during the distribution process used by replication.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.Value>false</a:ExtendedAttributeTargetItem.Value>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o374">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o375">
<a:Name>Microsoft</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Name=&quot;ExtFkNotForReplication&quot; Caption=&quot;Do not validate foreign key constraint during replication&quot; Attribute=&quot;ExtFkNotForReplication&quot; AttributeID=&quot;{8199587B-82BD-4A15-9DA6-CC85B39724E9}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o376">
<a:Name>Dimension</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o377">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o378">
<a:ObjectID>D6137CA3-96BF-45A0-9523-03FAF65F0976</a:ObjectID>
<a:Name>IsHidden</a:Name>
<a:Comment>Indicates whether the dimension is visible to clients.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o379">
<a:ObjectID>0C250E53-803C-462D-9185-61CBBC7F83CF</a:ObjectID>
<a:Name>Options</a:Name>
<a:Comment>Dimension options to manage member uniqueness and specified their storage.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o302"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o380">
<a:ObjectID>4A313314-C505-4C80-B1B6-F28C2D180EE3</a:ObjectID>
<a:Name>SubType</a:Name>
<a:Comment>Indicates that the level is a parent-child level.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o309"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o381">
<a:ObjectID>CB1C00EE-4713-436A-80D9-F2733BCC95C1</a:ObjectID>
<a:Name>Template</a:Name>
<a:Comment>Contains a template string that is used to generate captions for system-generated data members.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>14</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o382">
<a:ObjectID>FFAFDF79-3F2D-4F3C-A6FE-77C421EB59EA</a:ObjectID>
<a:Name>TimeDef</a:Name>
<a:Comment>Indicates that a dimension refers to time (year, month, week, day, and so on).
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o310"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o383">
<a:TypePublicName>TemplateTargetItem</a:TypePublicName>
<a:Name>Templates</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TemplateTargetItem Id="o384">
<a:Name>DimensionDef</a:Name>
<a:TemplateTargetItem.Value>DIMENSION %GeneratedName%[ %TimeDef%][ DIMENSION_STRUCTURE %SubType%][ %HiddenDef%][ OPTIONS %Options%]</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o385">
<a:Name>HiddenDef</a:Name>
<a:TemplateTargetItem.Value>.if (%IsHidden%)
HIDDEN
.endif</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o386">
<a:Name>AllLevelDef</a:Name>
<a:TemplateTargetItem.Value>.if (%SubType% == &quot;PARENT_CHILD&quot;)
   .foreach_item(Attributes,,&quot;,\n&quot;)
      .if (%Type% == &quot;ALL&quot;)
%LevelDef%
      .endif
   .next
TEMPLATE %Template%
.else
   .foreach_item(Attributes,,\n)
%LevelDef%
   .next(&quot;,\n&quot;)
.endif
</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o387">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o388">
<a:Name>Microsoft</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Name=&quot;SubType&quot; Caption=&quot;Subtype&quot; Attribute=&quot;SubType&quot; AttributeID=&quot;{4A313314-C505-4C80-B1B6-F28C2D180EE3}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;Template&quot; Caption=&quot;Template&quot; Attribute=&quot;Template&quot; AttributeID=&quot;{CB1C00EE-4713-436A-80D9-F2733BCC95C1}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;Options&quot; Caption=&quot;Options&quot; Attribute=&quot;Options&quot; AttributeID=&quot;{0C250E53-803C-462D-9185-61CBBC7F83CF}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;TimeDef&quot; Caption=&quot;Time&quot; Attribute=&quot;TimeDef&quot; AttributeID=&quot;{FFAFDF79-3F2D-4F3C-A6FE-77C421EB59EA}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;IsHidden&quot; Caption=&quot;Hidden&quot; Attribute=&quot;IsHidden&quot; AttributeID=&quot;{D6137CA3-96BF-45A0-9523-03FAF65F0976}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o389">
<a:Name>DimensionAttribute</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o390">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o391">
<a:ObjectID>F651475B-4C4C-499F-B167-24FA24C73FD4</a:ObjectID>
<a:Name>CustomRollupExpr</a:Name>
<a:Comment>Contains a Multidimensional Expressions (MDX) expression used to override the default rollup mode.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o392">
<a:ObjectID>9FB7C442-8895-4BEB-B2C3-53C52FC1D602</a:ObjectID>
<a:Name>FormatKey</a:Name>
<a:Comment>The name of the column or expression that contains member keys</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o393">
<a:ObjectID>69804BD6-E570-43DD-9D56-6CD5F52DE2AE</a:ObjectID>
<a:Name>FormatName</a:Name>
<a:Comment>The name of the column or expression that contains member names</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o394">
<a:ObjectID>C83A8A39-CA35-41E8-AD38-A28B345D1D5D</a:ObjectID>
<a:Name>HideValues</a:Name>
<a:Comment>Options to hide level members</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o303"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o395">
<a:ObjectID>1B9D44DD-F5CB-4286-ABB7-C76AA98E7D6C</a:ObjectID>
<a:Name>IsHidden</a:Name>
<a:Comment>Indicates whether the level is visible to client applications.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o396">
<a:ObjectID>CCACE3E1-3306-4EC9-855D-85BC53C48A91</a:ObjectID>
<a:Name>Options</a:Name>
<a:Comment>Options about members uniqueness, ordering and data source.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o304"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o397">
<a:ObjectID>02408F28-2FBF-40B3-B4E2-D316A29D2078</a:ObjectID>
<a:Name>RootValues</a:Name>
<a:Comment>Determines how the root member or members of a parent-child hierarchy are identified</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o305"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o398">
<a:ObjectID>EC12D33A-9393-4ADB-B562-581160080B67</a:ObjectID>
<a:Name>Type</a:Name>
<a:Comment>Identifies the specific type of level</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>-1</a:ExtendedAttributeTargetItem.DataType>
<c:ExtendedAttributeType>
<o:ExtendedAttributeTypeTargetItem Ref="o306"/>
</c:ExtendedAttributeType>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o399">
<a:TypePublicName>TemplateTargetItem</a:TypePublicName>
<a:Name>Templates</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TemplateTargetItem Id="o400">
<a:Name>CustomRollupExprDef</a:Name>
<a:TemplateTargetItem.Value>[CUSTOM_ROLLUP_EXPRESSION %CustomRollupExpr%]</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o401">
<a:Name>FormatDef</a:Name>
<a:TemplateTargetItem.Value>[FORMAT_NAME %FormatName% [FORMAT_KEY %FormatKey%]]
</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o402">
<a:Name>HiddenDef</a:Name>
<a:TemplateTargetItem.Value>.if (%IsHidden%)
HIDDEN
.endif</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o403">
<a:Name>HoleDef</a:Name>
<a:TemplateTargetItem.Value>[HIDE_MEMBER_IF %HideValues%]
</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o404">
<a:Name>LevelDef</a:Name>
<a:TemplateTargetItem.Value>LEVEL %GeneratedName%[ TYPE %Type%][ %FormatDef%][ %OptionDef%][ %HiddenDef%][ %RootMemberDef%][ %CustomRollupExprDef%]</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o405">
<a:Name>OptionDef</a:Name>
<a:TemplateTargetItem.Value>[OPTIONS (%Options%)] </a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o406">
<a:Name>RootMemberDef</a:Name>
<a:TemplateTargetItem.Value>[ROOT_MEMBER_IF %RootValues%]</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o407">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o408">
<a:Name>Microsoft</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Name=&quot;CustomRollupExpr&quot; Caption=&quot;Rollup expression&quot; Attribute=&quot;CustomRollupExpr&quot; AttributeID=&quot;{F651475B-4C4C-499F-B167-24FA24C73FD4}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;GroupBox Name=&quot;GroupBox1&quot;   Caption=&quot;Member attributes&quot; ControlAsLabel=&quot;No&quot; &gt;
      &lt;ExtendedAttribute Name=&quot;FormatKey&quot; Caption=&quot;Format key&quot; Attribute=&quot;FormatKey&quot; AttributeID=&quot;{9FB7C442-8895-4BEB-B2C3-53C52FC1D602}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
      &lt;ExtendedAttribute Name=&quot;FormatName&quot; Caption=&quot;Format name&quot; Attribute=&quot;FormatName&quot; AttributeID=&quot;{69804BD6-E570-43DD-9D56-6CD5F52DE2AE}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;/GroupBox&gt;
   &lt;ExtendedAttribute Name=&quot;HideValues&quot; Caption=&quot;Hide values&quot; Attribute=&quot;HideValues&quot; AttributeID=&quot;{C83A8A39-CA35-41E8-AD38-A28B345D1D5D}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;Type&quot; Caption=&quot;Type&quot; Attribute=&quot;Type&quot; AttributeID=&quot;{EC12D33A-9393-4ADB-B562-581160080B67}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;RootValues&quot; Caption=&quot;Root values&quot; Attribute=&quot;RootValues&quot; AttributeID=&quot;{02408F28-2FBF-40B3-B4E2-D316A29D2078}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;Options&quot; Caption=&quot;Options&quot; Attribute=&quot;Options&quot; AttributeID=&quot;{CCACE3E1-3306-4EC9-855D-85BC53C48A91}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;ExtendedAttribute Name=&quot;IsHidden&quot; Caption=&quot;Hidden&quot; Attribute=&quot;IsHidden&quot; AttributeID=&quot;{1B9D44DD-F5CB-4286-ABB7-C76AA98E7D6C}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o409">
<a:Name>DimensionHierarchy</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o410">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o411">
<a:ObjectID>EDCEB98E-31D5-4D06-8462-B09367363F3F</a:ObjectID>
<a:Name>IsHidden</a:Name>
<a:Comment>Indicates whether the hierarchy is visible to client applications</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o412">
<a:TypePublicName>TemplateTargetItem</a:TypePublicName>
<a:Name>Templates</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TemplateTargetItem Id="o413">
<a:Name>HiddenDef</a:Name>
<a:TemplateTargetItem.Value>.if (%IsHidden%)
HIDDEN
.endif</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o414">
<a:Name>HierarchyAllLevelDef</a:Name>
<a:TemplateTargetItem.Value>.if (%Dimension.SubType% == &quot;PARENT_CHILD&quot;)
   .foreach_item(Attributes,,&quot;,\n&quot;)
      .if (%Type% == &quot;ALL&quot;)
%LevelDef%
      .endif
   .next
TEMPLATE %Dimension.Template%
.else
   .foreach_item(Attributes,,\n)
%LevelDef%
   .next(&quot;,\n&quot;)
.endif
</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
<o:TemplateTargetItem Id="o415">
<a:Name>HierarchyDef</a:Name>
<a:TemplateTargetItem.Value>HIERARCHY %GeneratedName%[ %HiddenDef%]
</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o416">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o417">
<a:Name>Microsoft</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Name=&quot;IsHidden&quot; Caption=&quot;Hidden&quot; Attribute=&quot;IsHidden&quot; AttributeID=&quot;{EDCEB98E-31D5-4D06-8462-B09367363F3F}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o418">
<a:Name>User</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o419">
<a:TypePublicName>StereotypeTargetItem</a:TypePublicName>
<a:Name>Stereotypes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:StereotypeTargetItem Id="o420">
<a:ObjectID>B0730247-DEF0-43B8-A432-FC84DEEE50BA</a:ObjectID>
<a:Name>Schema</a:Name>
<a:Comment>The User with this stereotype is a Schema.
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o421">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o422">
<a:ObjectID>69A14499-EFB3-4887-8A11-F6D78F7AB98E</a:ObjectID>
<a:Name>SchemaOwner</a:Name>
<a:Comment>Specifies the name of the database-level principal user that will own the schema. This principal may own other schemas, and may not use the current schema as its default schema.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.DataType>12</a:ExtendedAttributeTargetItem.DataType>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o423">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o424">
<a:Name>Microsoft</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Name=&quot;SchemaOwner&quot; Caption=&quot;Schema owner&quot; Attribute=&quot;SchemaOwner&quot; AttributeID=&quot;{69A14499-EFB3-4887-8A11-F6D78F7AB98E}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:StereotypeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o425">
<a:TypePublicName>TemplateTargetItem</a:TypePublicName>
<a:Name>Templates</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TemplateTargetItem Id="o426">
<a:Name>isSchema</a:Name>
<a:TemplateTargetItem.Value>.bool(%Stereotype%==Schema)</a:TemplateTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TemplateTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o427">
<a:Name>Index</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o428">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o429">
<a:ObjectID>85C3F87F-D036-47C9-B928-6410931E45A1</a:ObjectID>
<a:Name>XML</a:Name>
<a:Comment>Creates an XML index on the specified xml column.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:ExtendedAttributeTargetItem>
<o:ExtendedAttributeTargetItem Id="o430">
<a:ObjectID>E6219921-A484-4520-97D9-A8439A8C2136</a:ObjectID>
<a:Name>XMLPrimary</a:Name>
<a:Comment>True when xml index is the primary xml index</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o431">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o432">
<a:Name>Microsoft</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;HorizontalLayout Name=&quot;HorizontalLayout1&quot;   &gt;
      &lt;ExtendedAttribute Name=&quot;XML&quot; Caption=&quot;XML index&quot; Attribute=&quot;XML&quot; AttributeID=&quot;{85C3F87F-D036-47C9-B928-6410931E45A1}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
      &lt;ExtendedAttribute Name=&quot;XMLPrimary&quot; Caption=&quot;Primary&quot; Attribute=&quot;XMLPrimary&quot; AttributeID=&quot;{E6219921-A484-4520-97D9-A8439A8C2136}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
   &lt;/HorizontalLayout&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o433">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o434">
<a:Name>XML index specific checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that XML index respects following rules:
- XML index needs a clustered key or index on the table
- XML Index can only have one column and this column must have xml datatype
- A primary (clustered) XML index on an xml column must exist before a secondary XML index can be created on the column.
- You cannot create a primary XML index on a computed xml column.
</a:HelpMessage>
<a:OutputMessage>The following XML indexes are not correctly defined:</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   dim bPrimary : bPrimary = C2Bool(obj.GetExtendedAttribute(&quot;XMLPrimary&quot;))
   if (C2Bool(obj.GetExtendedAttribute(&quot;XML&quot;))) then

      &#39; XML index needs a clustered key or index on the table
      if (obj.Table.ClusterObject is Nothing) then
         output &quot;XML Index &quot; &amp; obj.Table.Name &amp; &quot;.&quot; &amp; obj.Name &amp; &quot; needs a clustered index on the table.&quot;
         %Check% = False
         Exit Function
      end if
      &#39; XML Index can only have one column 
      if (obj.IndexColumns.Count &lt;&gt; 1) then
         output &quot;XML Index &quot; &amp; obj.Table.Name &amp; &quot;.&quot; &amp; obj.Name &amp; &quot; can only have one column&quot;
         %Check% = False
         Exit Function
      end if

      &#39; and this column must have xml datatype
      dim pCol : set pCol = obj.IndexColumns.Item(0).Column
      if (lCase(left(pCol.Datatype, 3)) &lt;&gt; &quot;xml&quot;) then
         output &quot;XML Index &quot; &amp; obj.Table.Name &amp; &quot;.&quot; &amp; obj.Name &amp; &quot; column must have xml datatype&quot;
         %Check% = False
         Exit Function
      end if

      &#39; A primary XML index on an xml column must exist before a secondary XML index can be created on the column.
      &#39; Also control that a xml column do not have two primary indexes.
      if not(bPrimary) then
         dim pIdxCol, bFound
         bFound = False
         for each pIdxCol in pCol.IndexColumns
            if (C2Bool(pIdxCol.Index.GetExtendedAttribute(&quot;XML&quot;)) and C2Bool(pIdxCol.Index.GetExtendedAttribute(&quot;XMLPrimary&quot;))) then
               if (bFound) then
                  output &quot;Column &quot; &amp; pCol.Table.Name &amp; &quot;.&quot; &amp; pCol.Name &amp; &quot; cannot have two PRIMARY XML indexes&quot;
                  %Check% = False
                  Exit Function
               else
                  bFound = True
               end if
            end if
         next
         if not(bFound) then
            output &quot;A primary XML index on the xml column must exist before secondary XML index &quot; &amp; obj.Table.Name &amp; &quot;.&quot; &amp; obj.Name &amp; &quot; can be created.&quot;
            %Check% = False
            Exit Function
         end if
      end if

      &#39; You cannot create a primary XML index on a computed xml column.
      if (pCol.Computed and bPrimary) then
         output &quot;You cannot create primary XML Index &quot; &amp; obj.Table.Name &amp; &quot;.&quot; &amp; obj.Name &amp; &quot; on a computed xml column.&quot;
         %Check% = False
         Exit Function
      end if
      %Check% = True
   else
      %Check% = not bPrimary
   end if
   
End Function
</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
</c:Categories>
</o:ProfileTargetItem>
<o:TargetCategory Id="o435">
<a:Name>Odbc</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the ODBC generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o436">
<a:Name>Objects</a:Name>
<a:Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:Comment>
<c:Categories>
<o:TargetCategory Id="o437">
<a:Name>Qualifier</a:Name>
<a:Comment>Manages the use of qualifier in ODBC reverse engineering</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o438">
<a:Name>Enable</a:Name>
<a:Comment>Allows using the qualifier combo box during ODBC reverse engineering</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o439">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>select name from master.dbo.sysdatabases order by name</a:TextTargetItem.Value>
<a:Comment>Query to retrieve qualifier during ODBC reverse engineering</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o440">
<a:Name>Label</a:Name>
<a:Comment>Label for &lt;All&gt; in qualifier selection list</a:Comment>
<a:StringTargetItem.Value>All databases</a:StringTargetItem.Value>
</o:StringTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
</c:Categories>
<c:TriggerItems>
<o:TriggerItem Id="o441">
<a:ObjectID>7E716806-007E-42C5-8FCA-ECA77C65B108</a:ObjectID>
<a:Name>InsertChildParentExist</a:Name>
<a:Code>InsertChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKNOTNULL&quot;)
/*  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when inserting a child in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   if (select count(*)
       from   [%PQUALIFIER%]%PARENT% t1, inserted t2
       where  .JOIN(&quot;t1.%PK% = t2.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;) != @numrows&quot;)
      .ERROR(50002, &quot;Parent does not exist in &quot;[%PQUALIFIER%]%PARENT%&quot;. Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end
.ENDFOR
.FOREACH_PARENT(&quot;FKNULL&quot;)
/*  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when inserting a child in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   select @numnull = (select count(*)
                      from   inserted
                      where  .JOIN(&quot;%FK% is null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)&quot;)
   if @numnull != @numrows
      if (select count(*)
          from   [%PQUALIFIER%]%PARENT% t1, inserted t2
          where  .JOIN(&quot;t1.%PK% = t2.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;) != @numrows - @numnull&quot;)
      .ERROR(50002, &quot;Parent does not exist in &quot;[%PQUALIFIER%]%PARENT%&quot;. Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>974284173</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Parent must exist when inserting child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o442">
<a:ObjectID>D6CB8FB9-03AA-4FDC-A228-9C81EAB9A9D1</a:ObjectID>
<a:Name>InsertTooManyChildren</a:Name>
<a:Code>InsertTooManyChildren</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
/*  The cardinality of Parent &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; cannot exceed %MAXCARD% */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   select @maxcard = (select count(*)
      from   [%CQUALIFIER%]%CHILD% old
      where .JOIN(&quot;ins.%FK% = old.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)&quot;)
   from  inserted ins
   where .JOIN(&quot;ins.%FK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;&quot;)
   group by .JOIN(&quot;ins.%FK%&quot;, &quot;, &quot;, &quot;&quot;, &quot;&quot;)
   order by 1
   if @maxcard &gt; %MAXCARD%
   .ERROR(50007, &quot;The maximum cardinality of a child has been exceeded! Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>974284173</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot exceed the maximum cardinality constraint when inserting the child</a:Comment>
<a:Declaration>@maxcard  int,
.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o443">
<a:ObjectID>7D46A37C-F5D3-488A-88D3-024C83643603</a:ObjectID>
<a:Name>UpdateChangeColumn</a:Name>
<a:Code>UpdateChangeColumn</a:Code>
<a:Text>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
/*  Non modifiable column &quot;%COLUMN%&quot; cannot be modified  */
if update(%COLUMN%)
   if exists (select 1
              from   inserted i, deleted d
              where  i.%COLUMN% != d.%COLUMN%)
      .ERROR(50001, &quot;Non modifiable column &quot;%COLUMN%&quot; cannot be modified.&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>974284173</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot modify non modifiable column constraint</a:Comment>
<a:Declaration>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o444">
<a:ObjectID>04AFDF5A-9013-4BCA-B19F-A1555BD9D474</a:ObjectID>
<a:Name>UpdateChildParentExist</a:Name>
<a:Code>UpdateChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKNOTNULL&quot;)
/*  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when updating a child in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   if (select count(*)
       from   [%PQUALIFIER%]%PARENT% t1, inserted t2
       where  .JOIN(&quot;t1.%PK% = t2.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;) != @numrows&quot;)
      .ERROR(50003, &quot;&quot;[%PQUALIFIER%]%PARENT%&quot; does not exist. Cannot modify child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end
.ENDFOR
.FOREACH_PARENT(&quot;FKNULL&quot;)
/*  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when updating a child in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   select @numnull = (select count(*)
                      from   inserted
                      where  .JOIN(&quot;%FK% is null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)&quot;)
   if @numnull != @numrows
      if (select count(*)
          from   [%PQUALIFIER%]%PARENT% t1, inserted t2
          where  .JOIN(&quot;t1.%PK% = t2.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;) != @numrows - @numnull&quot;)
      .ERROR(50003, &quot;&quot;[%PQUALIFIER%]%PARENT%&quot; does not exist. Cannot modify child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>974284173</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Parent must exist when updating a child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o445">
<a:ObjectID>F9563ADE-83CF-42B1-A993-DB48AFD3F16E</a:ObjectID>
<a:Name>UpdateTooManyChildren</a:Name>
<a:Code>UpdateTooManyChildren</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
/*  The cardinality of Parent &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; cannot exceed %MAXCARD% */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   select @maxcard = (select count(*)
      from   [%CQUALIFIER%]%CHILD% old
      where .JOIN(&quot;ins.%FK% = old.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)&quot;)
   from  inserted ins
   where .JOIN(&quot;ins.%FK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;&quot;)
   group by .JOIN(&quot;ins.%FK%&quot;, &quot;, &quot;, &quot;&quot;, &quot;&quot;)
   order by 1
   if @maxcard &gt; %MAXCARD%
   .ERROR(50007, &quot;The maximum cardinality of a child has been exceeded! Cannot modify child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>974284173</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot exceed the maximum cardinality constraint when updating the child</a:Comment>
<a:Declaration>@maxcard  int,
.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o446">
<a:ObjectID>02A4DADF-828A-4CA6-8451-A66D19C4CE07</a:ObjectID>
<a:Name>UpdateChildChangeParent</a:Name>
<a:Code>UpdateChildChangeParent</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
/*  Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
   if exists (select 1
              from   inserted i, deleted d
              where  .JOIN(&quot;i.%FK% != d.%FK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;)&quot;)
      .ERROR(50004, &quot;Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>974284173</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Cannot change parent constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o447">
<a:ObjectID>70B34186-E4E6-41A1-9E22-3D6983D6F272</a:ObjectID>
<a:Name>UpdateParentRestrict</a:Name>
<a:Code>UpdateParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
/*  Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .PKCOLN(&quot;update(%COLUMN%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   if exists (select 1
              from   [%CQUALIFIER%]%CHILD% t2, inserted i1, deleted d1
              where  .JOIN(&quot;t2.%FK% = d1.%PK%&quot;, &quot;and   &quot;)
               and  (.JOIN(&quot;i1.%PK% != d1.%PK%&quot;, &quot;or   &quot;, &quot;&quot;, &quot;))&quot;)
      .ERROR(50005, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)
end

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>974284173</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o448">
<a:ObjectID>96DD6C14-7A48-4148-9F6B-BCC5DE65CDB2</a:ObjectID>
<a:Name>UpdateParentCascade</a:Name>
<a:Code>UpdateParentCascade</a:Code>
<a:Text>declare cIns cursor local for select 
        .PKCOLN(&quot;%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;)
    from inserted
declare cDel cursor local for select 
        .PKCOLN(&quot;%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;) 
    from deleted

.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
/*  Modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; for all children in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .PKCOLN(&quot;update(%COLUMN%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   if @@rowcount = 1
      update [%CQUALIFIER%]%CHILD%
         set   .JOIN(&quot;%FK% = i1.%PK%&quot;, &quot;&quot;, &quot;,&quot;)
      from   [%CQUALIFIER%]%CHILD% t2, inserted i1, deleted d1
         where  .JOIN(&quot;t2.%FK% = d1.%PK%&quot;, &quot;and   &quot;)
          and  (.JOIN(&quot;i1.%PK% != d1.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;)&quot;)
   else
   begin
      open cIns
      open cDel
      fetch cIns into .PKCOLN(&quot;@ins_%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;) 
      fetch cDel into .PKCOLN(&quot;@del_%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;) 

      while (@@fetch_status = 0)
      begin
         update [%CQUALIFIER%]%CHILD%
            set   .JOIN(&quot;%FK% = @ins_%PK%&quot;, &quot;&quot;, &quot;,&quot;)
         where  .JOIN(&quot;%FK% = @del_%PK%&quot;, &quot;and   &quot;)
         fetch cIns into .PKCOLN(&quot;@ins_%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;) 
         fetch cDel into .PKCOLN(&quot;@del_%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;) 
      end
      close cIns
      close cDel
   end
end
.ENDFOR
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1081437635</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update cascade constraint</a:Comment>
<a:Declaration>.PKCOLN(&quot;@ins_%COLUMN% %DATATYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;,&quot;)
.PKCOLN(&quot;@del_%COLUMN% %DATATYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;,&quot;)</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o449">
<a:ObjectID>5B51A5F3-5BC7-4365-9E05-CC54F7D916FD</a:ObjectID>
<a:Name>UpdateParentSetNull</a:Name>
<a:Code>UpdateParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .PKCOLN(&quot;update(%COLUMN%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
   from   [%CQUALIFIER%]%CHILD% t2, inserted i1, deleted d1
   where  .JOIN(&quot;t2.%FK% = d1.%PK%&quot;, &quot;and   &quot;)
    and  (.JOIN(&quot;i1.%PK% != d1.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;)&quot;)
end

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>933262535</a:ModificationDate>
<a:Modifier>stevensj</a:Modifier>
<a:Comment>Set parent code to null in child</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o450">
<a:ObjectID>CB598F9D-C0B9-47F0-A8DA-E9FEDA70473C</a:ObjectID>
<a:Name>UpdateParentSetDefault</a:Name>
<a:Code>UpdateParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot;
.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .PKCOLN(&quot;update(%COLUMN%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
   from   [%CQUALIFIER%]%CHILD% t2, inserted i1, deleted d1
   where  .JOIN(&quot;t2.%FK% = d1.%PK%&quot;, &quot;and   &quot;)
    and  (.JOIN(&quot;i1.%PK% != d1.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;)&quot;)
end

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>933262535</a:ModificationDate>
<a:Modifier>stevensj</a:Modifier>
<a:Comment>Set parent code to default in child</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o451">
<a:ObjectID>50469C2E-6920-42A3-827C-DA61A0E03B9E</a:ObjectID>
<a:Name>DeleteParentRestrict</a:Name>
<a:Code>DeleteParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
/*  Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if exists (select 1
           from   [%CQUALIFIER%]%CHILD% t2, deleted t1
           where  .JOIN(&quot;t2.%FK% = t1.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)&quot;)
   .ERROR(50006, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>974284173</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Delete restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o452">
<a:ObjectID>8448FACA-F244-46CA-9CF2-932B789987B7</a:ObjectID>
<a:Name>DeleteParentCascade</a:Name>
<a:Code>DeleteParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
/*  Delete all children in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
delete [%CQUALIFIER%]%CHILD%
from   [%CQUALIFIER%]%CHILD% t2, deleted t1
where  .JOIN(&quot;t2.%FK% = t1.%PK%&quot;, &quot;and   &quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>933262501</a:ModificationDate>
<a:Modifier>stevensj</a:Modifier>
<a:Comment>Delete cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o453">
<a:ObjectID>48A0D100-E642-40D1-B3BB-93FC1DD4F2D7</a:ObjectID>
<a:Name>DeleteParentSetNull</a:Name>
<a:Code>DeleteParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in child &quot;[%CQUALIFIER%]%CHILD%&quot;  */
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
from   [%CQUALIFIER%]%CHILD% t2, deleted t1
where  .JOIN(&quot;t2.%FK% = t1.%PK%&quot;, &quot;and   &quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>933262501</a:ModificationDate>
<a:Modifier>stevensj</a:Modifier>
<a:Comment>Delete set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o454">
<a:ObjectID>A04FE6CD-86F4-4039-85EC-E8A52191A9AD</a:ObjectID>
<a:Name>DeleteParentSetDefault</a:Name>
<a:Code>DeleteParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot;
.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
from   [%CQUALIFIER%]%CHILD% t2, deleted t1
where  .JOIN(&quot;t2.%FK% = t1.%PK%&quot;, &quot;and   &quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>933262501</a:ModificationDate>
<a:Modifier>stevensj</a:Modifier>
<a:Comment>Delete set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
</c:TriggerItems>
<c:TriggerTemplates>
<o:TriggerTemplate Id="o455">
<a:ObjectID>4C7D2531-2FCC-4583-8E28-CB8578A7AEC2</a:ObjectID>
<a:Name>InsertTrigger</a:Name>
<a:Code>InsertTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% on [%TABLQUALIFIER%]%TABLE% for insert as
begin
    declare
       .DeclInsertChildParentExist
       .DeclInsertTooManyChildren
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    .InsertChildParentExist
    .InsertTooManyChildren

    return

/*  Errors handling  */
error:
    raiserror @errno @errmsg
    rollback  transaction
end
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>933337536</a:ModificationDate>
<a:Modifier>stevensj</a:Modifier>
<a:Comment>Insert trigger</a:Comment>
<a:Time/>
<a:TriggerName>ti_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o441"/>
<o:TriggerItem Ref="o442"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o456">
<a:ObjectID>567877FA-1F78-4479-AE3B-415EB2BD6FCD</a:ObjectID>
<a:Name>UpdateTrigger</a:Name>
<a:Code>UpdateTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% on [%TABLQUALIFIER%]%TABLE% for update as
begin
   declare
      .DeclUpdateChangeColumn
      .DeclUpdateChildParentExist
      .DeclUpdateTooManyChildren
      .DeclUpdateChildChangeParent
      .DeclUpdateParentRestrict
      .DeclUpdateParentCascade
      .DeclUpdateParentSetNull
      .DeclUpdateParentSetDefault
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      .UpdateChangeColumn
      .UpdateChildParentExist
      .UpdateTooManyChildren
      .UpdateChildChangeParent
      .UpdateParentRestrict
      .UpdateParentCascade
      .UpdateParentSetNull
      .UpdateParentSetDefault

      return

/*  Errors handling  */
error:
    raiserror @errno @errmsg
    rollback  transaction
end
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>933337536</a:ModificationDate>
<a:Modifier>stevensj</a:Modifier>
<a:Comment>Update trigger</a:Comment>
<a:Time/>
<a:Event>Update</a:Event>
<a:TriggerName>tu_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o443"/>
<o:TriggerItem Ref="o444"/>
<o:TriggerItem Ref="o445"/>
<o:TriggerItem Ref="o446"/>
<o:TriggerItem Ref="o447"/>
<o:TriggerItem Ref="o448"/>
<o:TriggerItem Ref="o449"/>
<o:TriggerItem Ref="o450"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o457">
<a:ObjectID>87511D82-C6F1-4FE3-AFFD-6E68E12485CC</a:ObjectID>
<a:Name>DeleteTrigger</a:Name>
<a:Code>DeleteTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% on [%TABLQUALIFIER%]%TABLE% for delete as
begin
    declare
       .DeclDeleteParentRestrict
       .DeclDeleteParentCascade
       .DeclDeleteParentSetNull
       .DeclDeleteParentSetDefault
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    .DeleteParentRestrict
    .DeleteParentCascade
    .DeleteParentSetNull
    .DeleteParentSetDefault

    return

/*  Errors handling  */
error:
    raiserror @errno @errmsg
    rollback  transaction
end
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>933337536</a:ModificationDate>
<a:Modifier>stevensj</a:Modifier>
<a:Comment>Delete trigger</a:Comment>
<a:Time/>
<a:Event>Delete</a:Event>
<a:TriggerName>td_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o451"/>
<o:TriggerItem Ref="o452"/>
<o:TriggerItem Ref="o453"/>
<o:TriggerItem Ref="o454"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
</c:TriggerTemplates>
</o:DBMS>

</DBMS>