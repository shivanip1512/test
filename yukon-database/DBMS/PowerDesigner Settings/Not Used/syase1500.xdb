<?xml version="1.0" encoding="UTF-8"?>
<?PowerDesigner AppLocale="UTF16" Code="SYASE1500" Family="SQL SERVER" Name="Sybase AS Enterprise 15.0" signature="XDB_XML" version="12.0.0.1667"?>
<!-- do not edit this file -->

<DBMS xmlns:a="attribute" xmlns:c="collection" xmlns:o="object">

<o:DBMS Id="o1">
<a:ObjectID>9F7831CA-9C8B-4764-85FE-EBBCC89134F3</a:ObjectID>
<a:Name>Sybase AS Enterprise 15.0</a:Name>
<a:Code>SYASE1500</a:Code>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1126799746</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Family>SQL SERVER</a:Family>
<a:CheckGlobalScript>&#39;******************************************************************************
&#39;* Purpose:  This VB-Script holds global definitions shared by all the custom-
&#39;*            checks scripts of the model extension.
&#39;******************************************************************************

Option Explicit &#39; This is to ensure all used variables are defined

Function ColumnLength(pCol)
   if (pCol.IsKindOf(cls_Column)) then
      Select Case GetDatatypeName(pCol.Datatype)
         Case &quot;tinyint&quot;, &quot;bit&quot;
                           : ColumnLength = 1
         Case &quot;smallint&quot;   
                           : ColumnLength = 2
         Case &quot;int&quot;, &quot;integer&quot;, &quot;real&quot;, &quot;smallmoney&quot;, &quot;smalldatetime&quot;
                           : ColumnLength = 4
         case &quot;double precision&quot;, &quot;smallmoney&quot;, &quot;datetime&quot;, &quot;timestamp&quot;
                           : ColumnLength = 8
         case &quot;char&quot;, &quot;varchar&quot;, &quot;binary&quot;, &quot;varbinary&quot;
                           : ColumnLength = pCol.Length
         case &quot;nchar&quot;, &quot;nvarchar&quot;
                           : ColumnLength = 1 * pCol.Length &#39; multiple may be adapted to server configuration
         case &quot;sysname&quot;    : ColumnLength = 30
         case &quot;float&quot;      : 
            if (pCol.Precision &lt; 16) then
               ColumnLength = 4
            else
               ColumnLength = 8
            end if
         case &quot;numeric&quot;, &quot;decimal&quot;, &quot;dec&quot;, &quot;num&quot; :
            if (pCol.length = 0) then
               ColumnLength = 10
            else
               ColumnLength = int(pCol.length / 2) + 1
            end if
         case else ColumnLength = 0
      end select
   else
      ColumnLength = 0
   end if
end function

function GetDatatypeName(sDatatype)
   if (instr(sDatatype, &quot;(&quot;) &gt; 0) then
      GetDatatypeName = lcase(rtrim(left(sDatatype, instr(sDatatype, &quot;(&quot;) - 1)))
   else
      GetDatatypeName = lCase(sDatatype)
   end if
end function

function GetOptsItemStrValue(sOpts, sItem)
   dim nPos
   nPos = Instr(sOpts, sItem)
   if (nPos &gt; 0) then
      GetOptsItemStrValue = NextPart(ltrim(mid(sOpts, nPos + len(sItem))))
   else
      GetOptsItemStrValue = NULL
   end if
end function

function GetOptsItemNumValue(sOpts, sItem)
   dim sVal
   sVal = GetOptsItemStrValue(sOpts, sItem)
   if (IsNumeric(sVal)) then
      GetOptsItemNumValue = CInt(sVal)
   else
      GetOptsItemNumValue = NULL
   end if
end function

function NextPart(s) &#39;get the next word
   dim nPos, nPosMin
   nPosMin = len(s)
   nPos = Instr(s, &quot; &quot;)
   if (nPos &lt; nPosMin) and (nPos &gt; 0) then nPosMin = nPos
   nPos = Instr(s, &quot;,&quot;)
   if (nPos &lt; nPosMin) and (nPos &gt; 0) then nPosMin = nPos
   nPos = Instr(s, vbCrLf)
   if (nPos &lt; nPosMin) and (nPos &gt; 0) then nPosMin = nPos
  
   NextPart = left(s, nPosMin - 1)
end function

&#39; Create views for a partitioned table
Sub CreatePartitionViews(tab, diagram)

   On Error Resume Next
   
   Dim model
   Set model = tab.Model

   Dim options
   options = Trim(tab.PhysicalOptions)
   Dim pos, line, bFoundPartition, bFoundPartType, bPartRange, bPartList
   bFoundPartition = false
   bFoundPartType  = false
   bPartRange = false
   bPartList  = false

   &#39; extract partition type: partition by range/list/hash
   pos = InStr(1, options, vbCR+vbLF)
   Do While (pos &lt;&gt; 0)
      line = Trim(Left(options, pos - 1))

      &#39; search partition
      If (LCase(line) = &quot;partition&quot;) Then
         bFoundPartition = true
      Elseif (LCase(Left(line, 10)) = &quot;partition &quot;) Then
         bFoundPartition = true
         line = Trim(Right(line, Len(line) - 10))
      End If

      &#39; search partition type
      If bFoundPartition and (Not bFoundPartType) Then
         If (LCase(Left(line, 8)) = &quot;by range&quot;) Then
            line = Trim(Right(line, Len(line) - 8))
            bFoundPartType  = true
            bPartRange = true
         ElseIf (LCase(Left(line, 7)) = &quot;by list&quot;) Then
            line = Trim(Right(line, Len(line) - 7))
            bFoundPartType  = true
            bPartList = true
         ElseIf (LCase(Left(line, 3)) = &quot;by &quot;) Then
            Dim partType
            pos = InStr(4, line, &quot; &quot;)
            if (pos &gt; 0) then
               partType = Left(line, pos)
            else
               partType = line
            end if
            Output &quot;The table &#39;&quot; + tab.Code + &quot;&#39; has &quot; + partType + &quot; partition.  Cannot create partition views for &quot; + partType + &quot; partition.&quot; + vbCrLf + vbCrLf
            Exit Sub
         End If
      End if

      options = Right(options, Len(options) - pos - 1)
      If bFoundPartition and bFoundPartType Then
         If line &lt;&gt; &quot;&quot; and options &lt;&gt; &quot;&quot; Then
            options = line + vbCR + vbLF + options
            Exit Do
         End If
      End If
      pos = InStr(1, options, vbCR+vbLF)
   Loop
   If (Not bFoundPartition) or (Not bFoundPartType) Then
      &#39; table does not have partition
      Output &quot;The table &#39;&quot; + tab.Code + &quot;&#39; does not have partition.&quot; + vbCrLf + vbCrLf
      Exit Sub
   End If
   
   &#39; extract partition columns: (column[, column])
   Dim bFoundColumns, columns, columnArray, nbColumns
   bFoundColumns = false
   options = TrimtbText(options)
   columns = ExtractParenthesis(options)
   If columns &lt;&gt; &quot;&quot; Then
      options = Trim(Right(options, Len(options) - Len(columns)))
      columns = RemoveParenthesis(columns)
      If columns &lt;&gt; &quot;&quot; Then
         bFoundColumns = true
      End If
   End If
   If Not bFoundColumns Then
      &#39; partition column not found
      Output &quot;The table &#39;&quot; + tab.Code + &quot;&#39; does not have partition columns.&quot; + vbCrLf + vbCrLf
      Exit Sub
   End If
   columnArray = Split(columns, &quot;,&quot;, -1, 1)
   nbColumns = UBound(columnArray) + 1
   
   &#39; extract partition list: (partition[, partition])
   Dim bFoundPartList, partList, noParnthesis, partArray, nbParts
   bFoundPartList = false
   options = TrimtbText(options)
   partList = ExtractParenthesis(options)
   If partList &lt;&gt; &quot;&quot; Then
      options = Trim(Right(options, Len(options) - Len(partList)))
      partList = RemoveParenthesis(partList)
      If partList &lt;&gt; &quot;&quot; Then
         bFoundPartList = true
      End If
   End If
   If Not bFoundPartList Then
      &#39; partition list not found
      Output &quot;The table &#39;&quot; + tab.Code + &quot;&#39; does not have partition definitions.&quot; + vbCrLf + vbCrLf
      Exit Sub
   End If
   partArray = SplitText(partList, &quot;,&quot;)
   nbParts = UBound(partArray)

   Output &quot;Create partition views for the table: &#39;&quot; + tab.Code + &quot;&#39;&quot;

   &#39; find table symbol   
   Dim tabSymbol
   If Not (diagram Is Nothing) Then
      Set tabSymbol = diagram.FindSymbol(tab)
   End if

   &#39; extract partitions
   Dim partText, partName, partValue
   Dim oldPartText, oldPartName, oldPartValue
   Dim n
   Dim view
   For n = 1 to nbParts
      partText = partArray(n-1)
      partName = ExtractPartName(partText)
      partText = TrimtbText(Right(partText, Len(partText) - Len(partName)))
      partValue = Trim(ExtractPartValue(partText))
      If n &gt; 1 Then
         oldPartText = partArray(n-2)
         oldPartName = ExtractPartName(oldPartText)
         oldPartText = TrimtbText(Right(oldPartText, Len(oldPartText) - Len(oldPartName)))
         oldPartValue = Trim(ExtractPartValue(oldPartText))
      Else
         oldPartValue = &quot;&quot;
      End If
      output &quot;   Partition &quot; + CStr(n) + &quot;: column(s)=&quot; + partName + &quot;, value(s)=&quot; + partValue
      
      &#39; create view
      Set view = model.Views.CreateNew
      If Not (view is Nothing) Then
         If partName = &quot;&quot; Then
            partName = &quot;view&quot; + CStr(n)
         End If
         view.SetNameAndCode tab.Name + &quot; &quot; + partName, tab.Code + &quot;_&quot; + partName, true
         view.SQLQuery = GetViewQuery(tab) + GetViewWhereClause(columnArray, n, partValue, oldPartValue, bPartRange, bPartList)
         view.Owner = tab.Owner
      End If

      &#39; create view symbol
      If Not (tabSymbol is Nothing) Then
         Dim viewSymbol
         Set viewSymbol = diagram.AttachObject(view)
         If Not (viewSymbol is Nothing) Then
            Dim pt
            Set pt = viewSymbol.Position
            pt.x = tabSymbol.Position.x + 1600 * n
            pt.y = tabSymbol.Position.y - 1200 * n
         End If
      End If
   Next
   output &quot;&quot;
End Sub

&#39; Extract a substring from an open parenthesis to a close parenthesis
Function ExtractParenthesis(text)
   ExtractParenthesis = ExtractParenthesis
   Dim noParnthesis
   noParnthesis = 0
   If Left(text, 1) = &quot;(&quot; Then
      noParnthesis = 1
      Dim i
      For i = 2 to Len(text)
         If Mid(text, i, 1) = &quot;(&quot; Then
            noParnthesis = noParnthesis + 1
         ElseIf Mid(text, i, 1) = &quot;)&quot; Then
            noParnthesis = noParnthesis - 1
            If (noParnthesis = 0) Then
               ExtractParenthesis = Mid(text, 1, i)
               Exit For
            End If
         End If
      Next
   End If   
End Function

&#39; Remove open and close parenthesis
Function RemoveParenthesis(text)
   Dim trimText
   trimText = TrimtbText(text)
   RemoveParenthesis = trimText
   If Len(trimText) &gt; 1 Then
      If Left(trimText, 1) = &quot;(&quot; and Right(trimText, 1) = &quot;)&quot; Then
         RemoveParenthesis = Mid(trimText, 2, Len(trimText) - 2)
      End If
   End If
End Function

&#39; Split a string by a delimiter
Function SplitText(text, delimiter)
   Dim splitArray()
   Dim noParnthesis, nbDelimiter, begin
   noParnthesis = 0
   nbDelimiter  = 0
   begin = 1
   Dim i
   For i = 1 to Len(text)
      If Mid(text, i, 1) = &quot;(&quot; Then
         noParnthesis = noParnthesis + 1
      ElseIf Mid(text, i, 1) = &quot;)&quot; Then
         noParnthesis = noParnthesis - 1
      ElseIf Mid(text, i, 1) = delimiter Then
         If (noParnthesis = 0) Then
            nbDelimiter = nbDelimiter + 1
            ReDim Preserve splitArray(nbDelimiter)
            splitArray(nbDelimiter - 1) = TrimtbText(Mid(text, begin, i - begin))
            begin = i + 1
         End If
      End If
   Next
   If begin &lt; Len(Text) Then
      nbDelimiter = nbDelimiter + 1
      ReDim Preserve splitArray(nbDelimiter)
      splitArray(nbDelimiter - 1) = TrimtbText(Right(text, Len(text) - begin + 1))
   End If
   SplitText = splitArray
End Function

&#39; Trim top and bottom of text and remove top and bottom CR + LF
Function TrimtbText(text)
   Dim tmpText  
   tmpText = Trim(text)
   Do While (Left(tmpText, 2) = vbCR+vbLF)
      tmpText = Trim(Right(tmpText, Len(tmpText) - 2))
   Loop
   Do While (Right(tmpText, 2) = vbCR+vbLF)
      tmpText = Trim(Left(tmpText, Len(tmpText) - 2))
   Loop

   Dim pos, line
   pos = InStr(1, tmpText, vbCR+vbLF)
   TrimtbText = &quot;&quot;
   Do While (pos &gt; 0)
      line = Trim(Left(tmpText, pos - 1))
      tmpText = Right(tmpText, Len(tmpText) - pos - 1)
      If TrimtbText = &quot;&quot; Then
         TrimtbText = line
      Else
         TrimtbText = TrimtbText + vbCR + vbLF + line
      End If
      pos = InStr(1, tmpText, vbCR+vbLF)
   Loop
   If pos = 0 and tmpText &lt;&gt; &quot;&quot; Then
      If TrimtbText = &quot;&quot; Then
         TrimtbText = tmpText
      Else
         TrimtbText = TrimtbText + vbCR + vbLF + tmpText
      End If
   End If
End Function

&#39; Extract partition name
Function ExtractPartName(text)
   ExtractPartName = &quot;&quot;
   Dim pos, line
   pos = InStr(1, text, vbCR+vbLF)
   if (pos &gt; 0) then
      line = Trim(Left(text, pos - 1))
   else
      line = Trim(text)
   end if
   if LCase(line) = &quot;values&quot; or LCase(Left(line, 7)) = &quot;values &quot; or LCase(Left(line, 8)) = &quot;values&lt;=&quot; or LCase(Left(line, 7)) = &quot;values(&quot; Then
      &#39; no partition name
      Exit Function
   End If
   pos = InStr(1, line, &quot; &quot;)
   If pos &gt; 0 Then
      ExtractPartName = Trim(Left(line, pos - 1))
   Else
      ExtractPartName = line
   End If
End Function

&#39; Extract partition value
Function ExtractPartValue(text)
   ExtractPartValue = &quot;&quot;
   Dim tmpText
   tmpText = TrimtbText(text)
   If LCase(Left(tmpText, 6)) = &quot;values&quot; Then
      tmpText = TrimtbText(Right(tmpText, Len(tmpText) - 6))
      If Left(tmpText, 2) = &quot;&lt;=&quot; Then
         tmpText = TrimtbText(Right(tmpText, Len(tmpText) - 2))
      End If
      ExtractPartValue = RemoveParenthesis(ExtractParenthesis(tmpText))
   End If
End Function

&#39; Get view SQL query
Function GetViewQuery(tab)
   GetViewQuery = &quot;select &quot;
   Dim n
   For n = 1 to tab.Columns.Count
      If n &gt; 1 Then
         GetViewQuery = GetViewQuery + &quot;, &quot;
      End If
      GetViewQuery = GetViewQuery + tab.Columns.Item(n-1).Code
   Next
   GetViewQuery = GetViewQuery + vbCR + vbLF + &quot;from &quot; + tab.Code
End Function

&#39; Get view where clause
Function GetViewWhereClause(columnArray, noPart, partValue, oldPartValue, bPartRange, bPartList)
   GetViewWhereClause = vbCR + vbLF + &quot;where &quot;
   Dim columnName
   columnName = Trim(columnArray(0))
   
   If bPartRange Then
      If noPart &gt; 1 Then
         GetViewWhereClause = GetViewWhereClause + columnName + &quot; &gt; &quot; + oldPartValue + &quot; and &quot;
      End If
      GetViewWhereClause = GetViewWhereClause + columnName + &quot; &lt;= &quot; + partValue
   ElseIf bPartList Then
      Dim valueArray, nbValue
      valueArray = Split(partValue, &quot;,&quot;, -1, 1)
      nbValue = UBound(valueArray) + 1
      Dim n
      Dim value
      For n = 1 to nbValue
         If n &gt; 1 Then
            GetViewWhereClause = GetViewWhereClause + vbCrLf + &quot; or &quot;
         End If
         value = Trim(valueArray(n-1))
         if (Left(value, 2) = vbCrLf) Then
            value = Right(value, Len(value) - 2)
         end if
         GetViewWhereClause = GetViewWhereClause + columnName + &quot; = &quot; + value
      Next
   End If
End Function

Function CanSetNameCode(pObj, sName, sCode)
   CanSetNameCode = (pObj.CanSetAttribute(&quot;Name&quot;, sName, &quot;&quot;) and pObj.CanSetAttribute(&quot;Code&quot;, sCode, &quot;&quot;))
End Function
</a:CheckGlobalScript>
<c:Categories>
<o:TargetCategory Id="o2">
<a:Name>General</a:Name>
<a:Comment>Target DBMS identification</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o3">
<a:Name>SqlSupport</a:Name>
<a:Comment>SQL syntax allowed. This does not impact the script generation, but it impacts the SQL Preview</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o4">
<a:Name>EnableCheck</a:Name>
<a:Comment>Determines if the generation of check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o5">
<a:Name>Enableconstname</a:Name>
<a:Comment>Determines if constraint names are used during the generation</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o6">
<a:Name>UniqConstName</a:Name>
<a:Comment>Determines if unique constraint names for objects are authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o7">
<a:Name>EnableMultiCheck</a:Name>
<a:Comment>Determines if the generation of multiple check parameters is authorized or not</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o8">
<a:Name>Script</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the Script generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o9">
<a:Name>Sql</a:Name>
<a:Comment>Contains sub-categories Syntax, Format, File and Keywords. Each sub-category contains entries whose values define general syntax for the database</a:Comment>
<c:Categories>
<o:TargetCategory Id="o10">
<a:Name>Syntax</a:Name>
<a:Comment>Contains general parameters for SQL syntax</a:Comment>
<c:Categories>
<o:CharacterTargetItem Id="o11">
<a:Name>Terminator</a:Name>
<a:Comment>End of command character</a:Comment>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o12">
<a:Name>BlockTerminator</a:Name>
<a:Comment>End of block character</a:Comment>
<a:StringTargetItem.Value>go</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:CharacterTargetItem Id="o13">
<a:Name>Delimiter</a:Name>
<a:Comment>Field separation character. Example: col1, col2, col3</a:Comment>
<a:CharacterTargetItem.Value>,</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o14">
<a:Name>Quote</a:Name>
<a:Comment>Character used to enclose string values</a:Comment>
<a:CharacterTargetItem.Value>&#39;</a:CharacterTargetItem.Value>
</o:CharacterTargetItem>
<o:CharacterTargetItem Id="o15">
<a:Name>SqlContinue</a:Name>
<a:Comment>Continuation character</a:Comment>
</o:CharacterTargetItem>
<o:StringTargetItem Id="o16">
<a:Name>BlockComment</a:Name>
<a:Comment>Characters used to enclose a multi-line comment</a:Comment>
<a:StringTargetItem.Value>/*   */</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o17">
<a:Name>LineComment</a:Name>
<a:Comment>Characters used to enclose a single line comment</a:Comment>
<a:StringTargetItem.Value>--</a:StringTargetItem.Value>
</o:StringTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o18">
<a:Name>Format</a:Name>
<a:Comment>Contains entries that define script formatting</a:Comment>
<c:Categories>
<o:StringTargetItem Id="o19">
<a:Name>IllegalChar</a:Name>
<a:Comment>Invalid characters for names</a:Comment>
<a:StringTargetItem.Value>&quot; +-*/!=&lt;&gt;&#39;&quot;()&quot;.</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:BooleanTargetItem Id="o20">
<a:Name>UpperCaseOnly</a:Name>
<a:Comment>Uppercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o21">
<a:Name>LowerCaseOnly</a:Name>
<a:Comment>Lowercase only</a:Comment>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o22">
<a:Name>EnableOwnerPrefix</a:Name>
<a:Comment>Object codes can have a prefix made of the object owner code</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o23">
<a:Name>File</a:Name>
<a:Comment>Contains header, footer and usage text entries used during the generation</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o24">
<a:Name>Header</a:Name>
<a:Comment>Header text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o25">
<a:Name>Footer</a:Name>
<a:Comment>Footer text for a database generation script</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o26">
<a:Name>EnableMultiFile</a:Name>
<a:Comment>Multi-script allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:StringTargetItem Id="o27">
<a:Name>ScriptExt</a:Name>
<a:Comment>Main script extension in database generation</a:Comment>
<a:StringTargetItem.Value>sql</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o28">
<a:Name>TableExt</a:Name>
<a:Comment>Other scripts extension in database generation</a:Comment>
<a:StringTargetItem.Value>tab</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o29">
<a:Name>StartCommand</a:Name>
<a:Comment>Command for executing a script</a:Comment>
<a:StringTargetItem.Value>isql -i %NAMESCRIPT%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o30">
<a:Name>Usage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Run the database creation script:
        isql -U&lt;username&gt; -P&lt;password&gt;  -i %NAMESCRIPT%</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in database generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o31">
<a:Name>Usage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Run the database creation scripts one by one:
        isql -U&lt;username&gt; -P&lt;password&gt;  -i &lt;script_name&gt;</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in database generation</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o32">
<a:Name>TriggerExt</a:Name>
<a:Comment>Script file extension in triggers and procedures generation</a:Comment>
<a:StringTargetItem.Value>sql</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o33">
<a:Name>TrgUsage1</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Run the trigger creation script:
        isql -U&lt;username&gt; -P&lt;password&gt;  -i %NAMESCRIPT%</a:TextTargetItem.Value>
<a:Comment>Usage for a single script in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o34">
<a:Name>TrgUsage2</a:Name>
<a:TextTargetItem.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Run the trigger creation scripts:
        isql -U&lt;username&gt; -P&lt;password&gt;  -i &lt;script_name&gt;</a:TextTargetItem.Value>
<a:Comment>Usage for multiple scripts in triggers and procedures generation</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o35">
<a:Name>Keywords</a:Name>
<a:Comment>Contains the list of reserved words and functions available in SQL</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o36">
<a:Name>ReservedDefault</a:Name>
<a:TextTargetItem.Value>user
null
getdate()
user_id()
user_name()
db_id()
db_name()
host_id()
host_name()
suser_id()
suser_name()
show_role()</a:TextTargetItem.Value>
<a:Comment>Reserved default values</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o37">
<a:Name>GroupFunc</a:Name>
<a:TextTargetItem.Value>avg()
count()
max()
min()
sum()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions to use with group keywords.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o38">
<a:Name>NumberFunc</a:Name>
<a:TextTargetItem.Value>abs()
acos()
asin()
atan()
atn2()
ceiling()
cos()
cot()
degrees()
exp()
floor()
lockscheme()
log()
log10()
pagesize()
pi()
power()
radians()
rand()
round()
sign()
sin()
sqrt()
tan()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used on numbers</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o39">
<a:Name>CharFunc</a:Name>
<a:TextTargetItem.Value>ascii()
char()
charindex()
char_length()
difference()
lower()
ltrim()
patindex()
replicate()
reverse()
right()
rtrim()
soundex()
space()
str()
stuff()
substring()
textptr()
textvalid()
to_unichar()
uhighsurr()
ulowsurr()
upper()
uscalar()
</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for characters and strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o40">
<a:Name>DateFunc</a:Name>
<a:TextTargetItem.Value>current_date()
current_time()
dateadd()
datediff()
datename()
datepart()
getdate()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions for dates</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o41">
<a:Name>ConvertFunc</a:Name>
<a:TextTargetItem.Value>convert()
hextoint()
inttohex()</a:TextTargetItem.Value>
<a:Comment>List of SQL functions used to convert values between hex and integer and handling strings</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o42">
<a:Name>OtherFunc</a:Name>
<a:TextTargetItem.Value>col_length()
col_name()
curunreservedpgs()
data_pgs()
datalength()
db_id()
db_name()
host_id()
host_name()
index_col()
is_sec_service_on()
isnull()
lct_admin()
mut_excl_roles()
object_id()
object_name()
proc_role()
ptn_data_pgs()
reserved_pgs()
role_contain()
role_id()
role_name()
rowcnt()
show_role()
show_sec_services()
suser_id()
suser_name()
tsequal()
used_pgs()
user()
user_id()
user_name()
valid_name()
valid_user()
msgsend(&lt;message_body&gt;, &lt;end_point&gt;[, &lt;options_and_properties&gt;])
msgrecv(&lt;end_point&gt;[, &lt;options_filter_and_returns&gt;])
msgpublish(&lt;message_body&gt;, &lt;subscription_name&gt;[, &lt;options_and_properties&gt;])
msgconsume(&lt;subscription_name&gt;[, &lt;option _and_returns&gt;])
msgsubscribe(&lt;subscription_name&gt;)
msgunsubscribe(&lt;subscription_name&gt;)
sp_msgadmin &lt;action&gt;[,&lt;parameters&gt;]
</a:TextTargetItem.Value>
<a:Comment>List of other SQL functions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o43">
<a:Name>ListOperators</a:Name>
<a:TextTargetItem.Value>=
!=
&lt;&gt;
&gt;
!&gt;
&lt;
!&lt;
&gt;=
&lt;=
*=
=*
not
in
not in
between
not between
exists
not exists
like
not like
is
is not
= any
&lt;&gt; any
&gt; any
&lt; any
&gt;= any
&lt;= any
= all
&lt;&gt; all
&gt; all
&lt; all
&gt;= all
&lt;= all</a:TextTargetItem.Value>
<a:Comment>List of operators for comparing values, boolean, and various semantic operators</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o44">
<a:Name>Commit</a:Name>
<a:TextTargetItem.Value>commit</a:TextTargetItem.Value>
<a:Comment>Command for validating the transaction by OBDC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o45">
<a:Name>ReservedWord</a:Name>
<a:TextTargetItem.Value>ADD
ALL
ALTER
AND
ANY
ARITH_OVERFLOW
AS
ASC
AT
AUTHORIZATION
AVG
BEGIN
BETWEEN
BREAK
BROWSE
BULK
BY
CASCADE
CASE
CHAR_CONVERT
CHECK
CHECKPOINT
CLOSE
CLUSTERED
COALESCE
COMMIT
COMPUTE
CONFIRM
CONNECT
CONSTRAINT
CONTINUE
CONTROLROW
CONVERT
COUNT
CREATE
CURRENT
CURSOR
DATABASE
DBCC
DEALLOCATE
DECLARE
DEFAULT
DELETE
DESC
DETERMINISTIC
DISK
DISTINCT
DOUBLE
DROP
DUMMY
DUMP
ELSE
END
ENDTRAN
ERRLVL
ERRORDATA
ERROREXIT
ESCAPE
EXCEPT
EXCLUSIVE
EXEC
EXECUTE
EXISTS
EXIT
EXP_ROW_SIZE
EXTERNAL
FETCH
FILLFACTOR
FOR
FOREIGN
FROM
FUNC
GOTO
GRANT
GROUP
HAVING
HOLDLOCK
IDENTITY
IDENTITY_GAP
IDENTITY_INSERT
IDENTITY_START
IF
IN
INDEX
INOUT
INSERT
INSTALL
INTERSECT
INTO
IS
ISOLATION
JAR
JOIN
KEY
KILL
LEVEL
LIKE
LINENO
LOAD
LOCK
MAX
MAX_ROWS_PER_PAGE
MIN
MIRROR
MIRROREXIT
MODIFY
NATIONAL
NEW
NOHOLDLOCK
NONCLUSTERED
NOT
NULL
NULLIF
NUMERIC_TRUNCATION
OF
OFF
OFFSETS
ON
ONCE
ONLINE
ONLY
OPEN
OPTION
OR
ORDER
OUT
OUTPUT
OVER
PARTITION
PERM
PERMANENT
PLAN
PRECISION
PREPARE
PRIMARY
PRINT
PRIVILEGES
PROC
PROCEDURE
PROCESSEXIT
PROXY_TABLE
PUBLIC
QUIESCE
RAISERROR
READ
READPAST
READTEXT
RECONFIGURE
REFERENCES
REMOVE
REORG
REPLACE
REPLICATION
RESERVEPAGEGAP
RETURN
RETURNS
REVOKE
ROLE
ROLLBACK
ROWCOUNT
ROWS
RULE
SAVE
SCHEMA
SELECT
SET
SETUSER
SHARED
SHUTDOWN
SOME
STATISTICS
STRINGSIZE
STRIPE
SUM
SYB_IDENTITY
SYB_RESTREE
SYB_TERMINATE
TABLE
TEMP
TEMPORARY
TEXTSIZE
TO
TRAN
TRANSACTION
TRIGGER
TRUNCATE
TSEQUAL
UNION
UNIQUE
UNPARTITION
UPDATE
USE
USER
USER_OPTION
USING
VALUES
VARYING
VIEW
WAITFOR
WHEN
WHERE
WHILE
WITH
WORK
WRITETEXT</a:TextTargetItem.Value>
<a:Comment>Reserved words</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o46">
<a:Name>SQLXML</a:Name>
<a:TextTargetItem.Value>for xml
forxmlj(&lt;sql_query_expression&gt;, &lt;option_string&gt;)
forxmldtdj(&lt;sql_query_expression&gt;, &lt;option_string&gt;)
forxmlschemaj(&lt;sql_query_expression&gt;, &lt;option_string&gt;)
forxmlallj
forsqlcreatej(&lt;sqlx_schema&gt;, &lt;option_string&gt;)
forsqlinsertj(&lt;sqlx_resultset&gt;, &lt;option_string&gt;)
forsqlscriptj(&lt;sqlx_schema&gt;, &lt;sqlx_resultset&gt;, &lt;option_string&gt;)
xmltest
xmlextract (&lt;xml_query_expression&gt;, &lt;xml_data_expression&gt;[ &lt;optional_parameters&gt;])
xmlparse(&lt;general_string_expression&gt;[ &lt;options_parameter&gt;])
xmlrepresentation(&lt;image_expression&gt;)
xmlcomment()
xmlconcat()
xmlelement()
xmlattributes()
xmlforest()
xmlpi()
xmlroot()
xmlagg()</a:TextTargetItem.Value>
<a:Comment>List of SQL/XML functions to write a SQL query</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o47">
<a:Name>Objects</a:Name>
<a:Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:Comment>
<c:Categories>
<o:TargetCategory Id="o48">
<a:Name>Table</a:Name>
<a:Code>TABL</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLE&quot;        // generated code of the table
   &quot;TNAME&quot;        // name of the table
   &quot;TCODE&quot;        // code of the table
   &quot;TLABL&quot;        // comment of the table
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;TABLDEFN&quot;     // complete body of the table definition. Contains definition of columns, checks and keys
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o49">
<a:Name>Enable</a:Name>
<a:Comment>Table allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o50">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o51">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKT_%.U26:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for check of table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o52">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create table [%QUALIFIER%]%TABLE% (
   %TABLDEFN%
)
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a table. Example: create table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o53">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>lock %s : list=datarows |datapages |allpages
with : composite=yes, separator=yes
{
   max_rows_per_page = %d
   exp_row_size = %d
   reservepagegap = %d
   identity_gap = %d
}
on %s : category=storage
external table : nextmand=yes
at %s
partition : composite=yes
{
   by range : composite=yes
   {
      &lt;column_list&gt; : composite=yes, parenthesis=yes, separator=yes, chldmand=yes
      {
         &lt;column&gt; %s : multiple=yes
      }
      &lt;partition_list&gt; : composite=yes, parenthesis=yes, separator=yes
      {
         &lt;partition_definition&gt; : composite=yes, multiple=yes
         {
            &lt;partition_name&gt; %s
            values &lt;= : composite=yes, parenthesis=yes, separator=yes, chldmand=yes
            {
               &lt;value_list&gt; %s : multiple=yes, default=maxvalue
            }
            on %s : category=storage
         }
      }
   }
   by hash : composite=yes
   {
      &lt;column_list&gt; : composite=yes, parenthesis=yes, separator=yes, chldmand=yes
      {
         &lt;column&gt; %s : multiple=yes
      }
      &lt;partition_list&gt; : composite=yes, parenthesis=yes, separator=yes
      {
         &lt;partition_definition&gt; : composite=yes, multiple=yes
         {
            &lt;partition_name&gt; %s
            on %s : category=storage
         }
      }
   }
   by list : composite=yes
   {
      &lt;column&gt; : composite=yes, parenthesis=yes
      {
         &lt;column_name&gt; %s
      }
      &lt;partition_list&gt; : composite=yes, parenthesis=yes, separator=yes
      {
         &lt;partition_definition&gt; : composite=yes, multiple=yes
         {
            &lt;partition_name&gt; %s
            values : composite=yes, parenthesis=yes, separator=yes, chldmand=yes
            {
               &lt;value_list&gt; %s : multiple=yes, default=listvalue
            }
            on %s : category=storage
         }
      }
   }
   by roundrobin : composite=yes
   {
      &lt;segment_enum&gt; : composite=yes
      {
         &lt;partition_num&gt; %d
         on : composite = yes, parenthesis = yes, separator=yes
         {
            &lt;segment_name&gt; %s : category=storage, multiple=yes
         }
      }
      &lt;partition_list&gt; : composite=yes, parenthesis=yes, separator=yes
      {
         &lt;partition_definition&gt; : composite=yes, multiple=yes
         {
            &lt;partition_name&gt; %s
            on %s : category=storage
         }
      }
}</a:TextTargetItem.Value>
<a:Comment>Available options for creating a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o54">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for table options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o55">
<a:Name>TableComment</a:Name>
<a:Comment>Command for adding a table comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o56">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
            from  sysobjects
            where  id = object_id(&#39;[%QUALIFIER%]%TABLE%&#39;)
            and    type = &#39;U&#39;)
   drop table [%QUALIFIER%]%TABLE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table. Example: drop table %TABLE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o57">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_rename %OLDTABL%, %NEWTABL%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o58">
<a:Name>AlterTableHeader</a:Name>
<a:Comment>Alter table header</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o59">
<a:Name>AlterTableFooter</a:Name>
<a:Comment>Alter table footer</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o60">
<a:Name>DropTableCheck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a table check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o61">
<a:Name>DefineTableCheck</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]check (%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of table check constraints</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o62">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, TABLE_TYPE}

select
   u.name,
   o.name,
   case o.type when &#39;U&#39; then &#39;TABLE&#39; else &#39;SYSTEM TABLE&#39; end
from
   [%CATALOG%.]dbo.sysusers u
   join [%CATALOG%.]dbo.sysobjects o on (o.uid = u.uid)
where
   u.uid = o.uid
   and o.type in (&#39;U&#39;, &#39;S&#39;)
[  and o.name = %.q:TABLE%]
[  and u.name = %.q:SCHEMA%]
order by
   1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o63">
<a:Name>AddTableCheck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME% ]check (%.A:CONSTRAINT%)</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script for modifying table constraints within an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o64">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, OPTIONS EX}

select
   u.name,
   o.name,
   case
      when (o.sysstat2 &amp; 8192 = 8192) then &#39;lock allpages &#39;
      when (o.sysstat2 &amp; 16384 = 16384) then &#39;lock datapages &#39;
      when (o.sysstat2 &amp; 32768 = 32768) then &#39;lock datarows &#39;
      else &#39;&#39;
   end
   + case (isnull(i.maxrowsperpage, 0)) when 0 then &#39;&#39; else 
      &#39;with max_rows_per_page = &#39; + rtrim(convert(CHAR, i.maxrowsperpage)) end
   + case when ((isnull(i.exp_rowsize, 0) = 0) or (o.sysstat2 &amp; 8192 = 8192)) then &#39;&#39; else
      case (isnull(i.maxrowsperpage, 0)) when 0 then &#39;with&#39; else &#39;,&#39; end 
      + &#39; exp_row_size = &#39; + rtrim(convert(CHAR, i.exp_rowsize)) end
   + case (isnull(i.res_page_gap, 0))   when 0 then &#39;&#39; else 
      case (isnull(i.maxrowsperpage, isnull(i.exp_rowsize, o.sysstat2 &amp; 8192))) when 0 then &#39;with&#39; else &#39;,&#39; end 
      + &#39; reservepagegap = &#39; + rtrim(convert(CHAR, i.res_page_gap)) end
   + case (isnull(i.identitygap, 0))    when 0 then &#39;&#39; else 
      case (isnull(i.maxrowsperpage, isnull(i.exp_rowsize, isnull(i.res_page_gap, 0)))) when 0 then &#39;with&#39; else &#39;,&#39; end 
      + &#39; identity_gap = &#39;+ rtrim(convert(CHAR, i.identitygap)) end
   + case(i.partitiontype) 
      when 1 then &#39; partition by range (%SqlPartColList.&#39; + convert(varchar(30), o.id) + &#39;%) (%SqlRangePartDefList.&#39; + convert(varchar(30), o.id) + &#39;%)&#39;
      when 2 then &#39; partition by hash (%SqlPartColList.&#39; + convert(varchar(30), o.id) + &#39;%) (%SqlHashPartDefList.&#39; + convert(varchar(30), o.id) + &#39;%)&#39;
      when 4 then &#39; partition by list (%SqlPartColList.&#39; + convert(varchar(30), o.id) + &#39;%) (%SqlListPartDefList.&#39; + convert(varchar(30), o.id) + &#39;%)&#39;
      else case(select count(*) from [%CATALOG%.]dbo.syspartitions p where p.id = o.id)
         when 1 then &#39; on &#39; + (select s.name from [%CATALOG%.]dbo.syssegments s where s.segment = i.segment) 
         else &#39;partition by roundrobin (%SqlRoundRobinPartDef.&#39; + convert(varchar(30), o.id) + &#39;%)&#39;
      end
   end
from
   [%CATALOG%.]dbo.sysindexes i
   join [%CATALOG%.]dbo.sysobjects o on (o.id = i.id and o.type = &#39;U&#39;)
   join [%CATALOG%.]dbo.sysusers   u on (u.uid = o.uid)
where
   i.indid &lt; 2
[  and u.name = %.q:SCHEMA%]
[  and o.name = %.q:TABLE%]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o65">
<a:Name>SqlChckQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, CONSTNAME, CONSTRAINT}

select distinct
   u.name,
   o.name,
   r.name,
   reverse(substring(reverse(t.text), 1, char_length(t.text)-char_length(r.name)-19))
from
   [%CATALOG%.]dbo.sysusers u,
   [%CATALOG%.]dbo.sysobjects o,
   [%CATALOG%.]dbo.sysconstraints k,
   [%CATALOG%.]dbo.sysobjects r,
   [%CATALOG%.]dbo.syscomments t
where
   r.id=k.constrid
   and t.id=r.id
   and k.tableid=o.id
   and u.uid = o.uid
   and (o.type=&#39;U&#39; or o.type=&#39;S&#39;)
   and k.colid=0
[  and u.name = %.q:SCHEMA%]
[  and o.name = %.q:TABLE%]
order by 1,2, k.constrid</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object check constraints</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o66">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a table.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>SELECT=Sel
INSERT=Ins
DELETE=Del
UPDATE=Upd
REFERENCES=Ref</a:MapTargetItem.Value>
<a:List>SELECT
INSERT
DELETE
UPDATE
REFERENCES
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o67">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

select 
   u1.name,
   case (s.action) when 193 then &#39;SELECT&#39; when 195 then &#39;INSERT&#39; when 196 then &#39;DELETE&#39; when 197 then &#39;UPDATE&#39; when 151 then &#39;REFERENCES&#39; else &#39;&#39; end
   + case (s.protecttype) when 0 then &#39;+&#39; when 2 then &#39;-&#39; else &#39;&#39; end
   + &#39;,&#39;
from 
   [%CATALOG%.]dbo.sysprotects s, 
   [%CATALOG%.]dbo.sysusers u, 
   [%CATALOG%.]dbo.sysusers u1, 
   [%CATALOG%.]dbo.sysobjects o
where
  o.name = %.q:TABLE% and
  o.uid = u.uid and
  [u.name = %.q:OWNER% and]
  s.id = o.id and
  u1.uid = s.uid
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o68">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o69">
<a:Name>InsertIdentityOn</a:Name>
<a:TextTargetItem.Value>set identity_insert [%QUALIFIER%]%@OBJTCODE% on</a:TextTargetItem.Value>
<a:Comment>Command for enabling insertion of data into table containing identity column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o70">
<a:Name>InsertIdentityOff</a:Name>
<a:TextTargetItem.Value>set identity_insert [%QUALIFIER%]%@OBJTCODE% off</a:TextTargetItem.Value>
<a:Comment>Command for disabling insertion of data into table containing identity column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o71">
<a:Name>SqlPartColList</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   convert(varchar(30), o.id),
   c.name + &#39;,&#39;
from
   [%CATALOG%.]dbo.syspartitionkeys k
      join [%CATALOG%.]dbo.sysobjects o on (o.id = k.id)
      join [%CATALOG%.]dbo.syscolumns c on (c.id = k.id and c.colid = k.colid)
where o.name = %.q:TABLE%
  and o.uid = user_id(%.q:OWNER%)
order by k.position

</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o72">
<a:Name>SqlRangePartDefList</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   convert(varchar(30), o.id),
   k.name
   + &#39; &#39; + t.text
   + &#39; on &#39; + s.name
   + &#39;, &#39;
from
   [%CATALOG%.]dbo.syspartitions k
      join [%CATALOG%.]dbo.sysobjects o on (o.id = k.id and o.type=&#39;U&#39;)
      join [%CATALOG%.]dbo.syssegments s on (s.segment = k.segment)
      join [%CATALOG%.]dbo.syscomments t on (t.partitionid = k.partitionid)
where k.indid = 0
[ and o.name = %.q:TABLE%]
[ and o.uid = user_id(%.q:OWNER%)]
order by 1, k.partitionid</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o73">
<a:Name>SqlHashPartDefList</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   convert(varchar(30), o.id),
   k.name
   + &#39; on &#39; + s.name
   + &#39;, &#39;
from
   [%CATALOG%.]dbo.syspartitions k
      join [%CATALOG%.]dbo.sysobjects o on (o.id = k.id and o.type=&#39;U&#39;)
      join [%CATALOG%.]dbo.syssegments s on (s.segment = k.segment)
where k.indid = 0
[ and o.name = %.q:TABLE%]
[ and o.uid = user_id(%.q:OWNER%)]
order by 1, k.partitionid</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o74">
<a:Name>SqlListPartDefList</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   convert(varchar(30), o.id),
   k.name
   + &#39; &#39; + t.text
   + &#39; on &#39; + s.name
   + &#39;, &#39;
from
   [%CATALOG%.]dbo.syspartitions k
      join [%CATALOG%.]dbo.sysobjects o on (o.id = k.id and o.type=&#39;U&#39;)
      join [%CATALOG%.]dbo.syssegments s on (s.segment = k.segment)
      join [%CATALOG%.]dbo.syscomments t on (t.partitionid = k.partitionid)
where k.indid = 0
[ and o.name = %.q:TABLE%]
[ and o.uid = user_id(%.q:OWNER%)]
order by 1, k.partitionid</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o75">
<a:Name>SqlRoundRobinPartDef</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   convert(varchar(30), o.id),
   k.name
   + &#39; on &#39; + s.name
   + &#39;, &#39;
from
   [%CATALOG%.]dbo.syspartitions k
      join [%CATALOG%.]dbo.sysobjects o on (o.id = k.id and o.type=&#39;U&#39;)
      join [%CATALOG%.]dbo.syssegments s on (s.segment = k.segment)
where k.indid = 0
[ and o.name = %.q:TABLE%]
[ and o.uid = user_id(%.q:OWNER%)]
order by 1, k.partitionid</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o76">
<a:Name>Alter</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE% add %TABLDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for modifying a table.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o77">
<a:Name>Index</a:Name>
<a:Code>INDX</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
   &quot;INDEX&quot;        // generated code of the index
   &quot;INDEXNAME&quot;    // index name
   &quot;INDEXCODE&quot;    // index code
   &quot;UNIQUE&quot;       // keyword &quot;unique&quot; when the index is unique
   &quot;INDEXTYPE&quot;    // index type (available only for a few DBMS)
   &quot;INDEXKEY&quot;     // keywords &quot;primary&quot;, &quot;unique&quot; or &quot;foreign&quot; depending on the index origin
   &quot;CIDXLIST&quot;     // list of index columns. Eg: A asc, B desc, C asc
   &quot;CLUSTER&quot;      // keyword &quot;cluster&quot; when the index is cluster
For index columns, the following system variables are available:
   &quot;ASC&quot;          // keywords &quot;ASC&quot; or &quot;DESC&quot; depending on sort order
   &quot;ISASC&quot;        // TRUE if the index column sort is ascending
</a:Comment>
<c:Categories>
<o:IntegerTargetItem Id="o78">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o79">
<a:Name>MaxColIndex</a:Name>
<a:Comment>Maximum number of columns in an index</a:Comment>
<a:IntegerTargetItem.Value>16</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o80">
<a:Name>Enable</a:Name>
<a:Comment>Index allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o81">
<a:Name>EnableAscDesc</a:Name>
<a:Comment>ASC, DESC keywords allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o82">
<a:Name>UniqName</a:Name>
<a:Comment>Unique index name in the database</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o83">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create[ %UNIQUE%][%CLUSTER%? clustered:[%R%?[ nonclustered]]] index %INDEX% on [%TABLQUALIFIER%]%TABLE% (
%CIDXLIST%
)
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating an index. Example: create index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o84">
<a:Name>Cluster</a:Name>
<a:Comment>Cluster index keyword (default value: cluster)</a:Comment>
<a:StringTargetItem.Value>clustered</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o85">
<a:Name>AddColIndex</a:Name>
<a:TextTargetItem.Value>%COLUMN%[ %ASC%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an index column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o86">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with : composite=yes, separator=yes
{
max_rows_per_page = %d : default=0
fillfactor = %d : default=1
reservepagegap = %d : default=0
consumers = %d : default=0
ignore_dup_key
sorted_data
&lt;duprow&gt; %s : list=ignore_dup_row | allow_dup_row
statistics using %d : composite=yes, childmand=yes
{
values
}
}
on %s : category=storage
local index : composite=yes, separator=yes
{
   &lt;partition_list&gt; : composite=yes, multiple=yes
   {
      &lt;partition_name&gt; %s
      on %s : category=storage
   }
}
</a:TextTargetItem.Value>
<a:Comment>Default options for creating an index</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o87">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, INDEX, UNIQUE, CLUSTER, CIDXLIST EX}

select
   u.name,
   t.name,
   i.name,
   case (i.status &amp; 2) when 0 then &#39;&#39; else &#39;unique&#39; end,
   case ((i.status2&amp;512)+(i.status&amp;16)) when 0 then &#39;&#39; else &#39;cluster&#39; end,
   &#39;%SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 1, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 1, u.uid)
   + case when (i.keycnt &gt; 1) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 2, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 2, u.uid) end
   + case when (i.keycnt &gt; 2) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 3, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 3, u.uid) end
   + case when (i.keycnt &gt; 3) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 4, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 4, u.uid) end
   + case when (i.keycnt &gt; 4) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 5, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 5, u.uid) end
   + case when (i.keycnt &gt; 5) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 6, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 6, u.uid) end
   + case when (i.keycnt &gt; 6) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 7, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 7, u.uid) end
   + case when (i.keycnt &gt; 7) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 8, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 8, u.uid) end
   + case when (i.keycnt &gt; 8) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 9, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 9, u.uid) end
   + case when (i.keycnt &gt; 9) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 10, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 10, u.uid) end
   + case when (i.keycnt &gt; 10) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 11, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 11, u.uid) end
   + case when (i.keycnt &gt; 11) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 12, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 12, u.uid) end
   + case when (i.keycnt &gt; 12) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 13, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 13, u.uid) end
   + case when (i.keycnt &gt; 13) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 14, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 14, u.uid) end
   + case when (i.keycnt &gt; 14) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 15, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 15, u.uid) end
   + case when (i.keycnt &gt; 15) then &#39;, %SqlIdxCol.&#39; + u.name + t.name + i.name + index_col(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 16, u.uid) + &#39;% &#39; + index_colorder(&#39;[%CATALOG%].&#39; + u.name + &#39;.&#39; + t.name, i.indid, 16, u.uid) end
from
   [%CATALOG%.]dbo.sysusers u
   join [%CATALOG%.]dbo.sysobjects t on (t.uid = u.uid and t.type = &#39;U&#39;)
   join [%CATALOG%.]dbo.sysindexes i on (i.id = t.id)
where i.indid != 0
   and (i.status2 &amp; 2) = 0
   and i.keycnt != 0
[  and u.name = %.q:SCHEMA%]
[  and t.name = %.q:TABLE%]
order by 1, 2, i.indid</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o88">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for index options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o89">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, INDEX, OPTIONS EX}

select
   u.name,
   o.name,
   i.name,
   case(isnull(i.maxrowsperpage, 0)) when 0 then &#39;&#39; else &#39;with max_rows_per_page = &#39; + rtrim(convert(CHAR, i.maxrowsperpage)) end +
   case(isnull(i.fill_factor, 0))    when 0 then &#39;&#39; else case(isnull(i.maxrowsperpage, 0)) when 0 then &#39;with&#39; else &#39;,&#39; end + &#39; fillfactor = &#39; + rtrim(convert(CHAR, i.fill_factor)) end +
   case(isnull(i.res_page_gap, 0))   when 0 then &#39;&#39; else case(isnull(i.maxrowsperpage, 0) + isnull(i.fill_factor, 0)) when 0 then &#39;with&#39; else &#39;,&#39; end + &#39; reservepagegap = &#39; + rtrim(convert(CHAR, i.res_page_gap)) end +
   case(i.status&amp;1) when 1 then case(isnull(i.maxrowsperpage, 0) + isnull(i.fill_factor, 0) + isnull(i.res_page_gap, 0)) when 0 then &#39;with&#39; else &#39;,&#39; end + &#39; ignore_dup_key &#39; else &#39;&#39; end +
   case(i.status&amp;512) when 512 then case(isnull(i.maxrowsperpage, 0) + isnull(i.fill_factor, 0) + isnull(i.res_page_gap, 0) + i.status&amp;1) when 0 then &#39;with&#39; else &#39;,&#39; end + &#39; sorted_data &#39;    else &#39;&#39; end +
   case((i.status2&amp;512)+(i.status&amp;16)) when 0 then &#39;&#39; else case (i.status&amp;2) when 2 then &#39;&#39; else
      case(isnull(i.maxrowsperpage, 0) + isnull(i.fill_factor, 0) + isnull(i.res_page_gap, 0) + i.status&amp;513) when 0 then &#39;with &#39; else &#39;, &#39; end +
      case(i.status&amp;4) when 4 then &#39;ignore_dup_row &#39; else &#39;allow_dup_row&#39; end 
   end end +
   case(i.status3 &amp; 8) 
      when 0 then case (lower(s.name)) when null then &#39;&#39; when &#39;default&#39; then &#39; on &quot;default&quot;&#39; else &#39; on &#39; + s.name end
      else &#39;local index %SqlIndexPartList.&#39; + convert(varchar(30), i.id) + &#39;_&#39; + convert(varchar(30), i.indid) + &#39;%&#39;
   end
from
   [%CATALOG%.]dbo.sysusers u
   join [%CATALOG%.]dbo.sysobjects o on (o.uid = u.uid)
   join [%CATALOG%.]dbo.sysindexes i on (i.id = o.id and i.indid != 0)
   join [%CATALOG%.]dbo.syssegments s on (s.segment = i.segment)
where 1=1   
[  and u.name = %.q:SCHEMA%]
[  and o.name = %.q:TABLE%]
[  and i.name = %.q:INDEX%]</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o90">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
            from  sysindexes
           where  id    = object_id(&#39;[%QUALIFIER%]%TABLE%&#39;)
            and   name  = %.q:INDEX%
            and   indid &gt; 0
            and   indid &lt; 255)
   drop index %TABLE%.%INDEX%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an index. Example: drop index %INDEX%</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o91">
<a:Name>EnableCluster</a:Name>
<a:Comment>Cluster option available for indexes</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o92">
<a:Name>EnableFunction</a:Name>
<a:Comment>Function-based indexes allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o93">
<a:Name>SqlIdxCol</a:Name>
<a:TextTargetItem.Value>{VAR, VAL}

select
   user_name(t.uid) + t.name + i.name + c.name,
   case(c.status3 &amp; 1) when 0 then c.name else
      (select substring(m.text, 5, char_length(m.text)-16) from syscomments m where m.id = c.computedcol)
   end
from
   [%CATALOG%.]dbo.sysobjects t
   join [%CATALOG%.]dbo.syscolumns c on (c.id = t.id)
   join [%CATALOG%.]dbo.sysindexes i on (i.id = t.id)
where
   i.name = %.q:INDEX%
[  and t.name = %.q:TABLE%]
[  and t.uid = user_id(%.q:OWNER%)]
</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o94">
<a:Name>SqlIndexPartList</a:Name>
<a:TextTargetItem.Value>{VAR ID, VAL ...}

select
   convert(varchar(30), i.id) + &#39;_&#39; + convert(varchar(30), i.indid),
   k.name
   + &#39; on &#39; + s.name
   + &#39;, &#39;
from
   [%CATALOG%.]dbo.syspartitions k
      join [%CATALOG%.]dbo.sysobjects o on (o.id = k.id and o.type=&#39;U&#39;)
      join [%CATALOG%.]dbo.sysindexes i on (i.id = o.id and i.indid = k.indid)
      join [%CATALOG%.]dbo.syssegments s on (s.segment = k.segment)
where k.indid != 0
[ and i.name = %.q:INDEX%]
[ and o.name = %.q:TABLE%]
[ and o.uid = user_id(%.q:OWNER%)]
order by 1</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o95">
<a:Name>Column</a:Name>
<a:Code>COLN</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for columns)
   &quot;COLUMN&quot;       // generated code of the column
   &quot;COLNNO&quot;       // position of the column in the list of columns of the table
   &quot;COLNNAME&quot;     // name of the column
   &quot;COLNCODE&quot;     // code of the column
   &quot;PRIMARY&quot;      // keyword &quot;primary&quot; if the column is primary
   &quot;ISPKEY&quot;       // TRUE if the column is part of the primary key
   &quot;FOREIGN&quot;      // TRUE if the column is part of one foreign key
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o96">
<a:Name>Enable</a:Name>
<a:Comment>Column allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o97">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o98">
<a:Name>EnableIdentity</a:Name>
<a:Comment>Identity keyword entry support. Identity columns are serial counters maintains by the database</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o99">
<a:Name>EnableDefault</a:Name>
<a:Comment>Default values allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o100">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>CKC_%.U17:COLUMN%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for a column check parameter</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o101">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>%20:COLUMN% [%COMPUTE%?compute %COMPUTE%[%Materialized%? materialized]:%30:DATATYPE%[.Z:[ default %DEFAULT%][%IDENTITY%? identity:[ %NULL%][ %NOTNULL%]]][%InRow%? in row:[%R%? off row]]]
      [%CONSTDEFN%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a table column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o102">
<a:Name>ColumnComment</a:Name>
<a:Comment>Command for adding a column comment</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o103">
<a:Name>Rename</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_rename &#39;%TABLE%.%OLDCOLN%&#39;, %NEWCOLN%</a:TextTargetItem.Value>
<a:Comment>Command for renaming a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o104">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
  add %20:COLUMN% [%COMPUTE%?compute %COMPUTE%[%Materialized%? materialized]:%DATATYPE%[.Z:[ default %DEFAULT%][%IDENTITY%? identity:[ %NULL%][ %NOTNULL%]]][%InRow%? in row:[%R%? off row]]]
      [%CONSTDEFN%]</a:TextTargetItem.Value>
<a:Comment>Command for adding a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o105">
<a:Name>ModifyColumn</a:Name>
<a:Comment>Command for modifying a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o106">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table %TABLE% drop %COLUMN%
</a:TextTargetItem.Value>
<a:Comment>Command for dropping a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o107">
<a:Name>ModifyColnDflt</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   replace %COLUMN% default %DEFAULT%</a:TextTargetItem.Value>
<a:Comment>Command for modifying a column default in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o108">
<a:Name>ModifyColnChck</a:Name>
<a:Comment>Command for modifying a column check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o109">
<a:Name>DropColnChck</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a column check in an alter table statement</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o110">
<a:Name>AltEnableAddColnChk</a:Name>
<a:Comment>Column check constraint allowed in an alter table statement</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o111">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, S, COLUMN, DTTPCODE, LENGTH, SIZE, PREC, NOTNULL, IDENTITY, DOMAIN, DEFAULT, DEFAULTNAME (&#39;0&#39;=&#39;&#39;), RULENAME(&#39;0&#39;=&#39;&#39;)}

select 
   u.name,
   o.name,
   c.colid,
   c.name,
   isnull(convert(char(30), z.name), isnull(convert(char(30), get_xtypename(c.xtype, c.xdbid)), s.name)),
   case(isnull(c.xtype, 0)) when 0 then c.prec else null end,
   case(isnull(c.xtype, 0)) when 0 then c.length else null end,
   case(isnull(c.xtype, 0)) when 0 then c.scale else null end,
   case (c.status &amp; 8) when 8 then &#39;NULL&#39; else &#39;NOTNULL&#39; end,
   case (c.status &amp; 128) when 128 then &#39;identity&#39; else &#39;&#39; end,
   d.name,
   case(lower(substring(ltrim(t.text), 1, 7))) when &#39;default&#39; then ltrim(substring (t.text, charindex(&#39;default&#39;, lower(t.text)) + 7, char_length(t.text))) else &#39;&#39; end,
   convert(char(20), c.cdefault),
   convert(char(20), c.domain)
from 
    [%CATALOG%.]dbo.sysusers u
       join [%CATALOG%.]dbo.sysobjects o on (o.uid = u.uid[ and o.name = %.q:TABLE%])
       join [%CATALOG%.]dbo.syscolumns c on (c.id = o.id)
       left outer join [%CATALOG%.]dbo.systypes s on (s.usertype = c.usertype and c.usertype between 0 and 100)
       left outer join [%CATALOG%.]dbo.systypes d on (d.usertype = c.usertype and c.usertype &gt;= 100)
       left outer join [%CATALOG%.]dbo.syscomments t on (t.id = c.cdefault and t.colid = 1)
       left outer join [%CATALOG%.]dbo.systypes z on (z.type = d.type and z.usertype &lt; 100 and z.usertype not in (18, 24, 25, 80))
where 
   c.name is not null
   and c.status3 &amp; 1 != 1
[  and u.name = %.q:OWNER%]
order by 1, 2, 3
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects
(18, 24, 25, 80) are synonymous types for other system-defined datatypes.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o112">
<a:Name>SqlChckQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, COLUMN, CONSTNAME, CONSTRAINT}

select distinct
   u.name,
   o.name,
   c.name,
   r.name,
   reverse(substring(reverse(t.text), 1, char_length(t.text)-char_length(r.name)-19))
from
   [%CATALOG%.]dbo.sysusers u,
   [%CATALOG%.]dbo.sysobjects o,
   [%CATALOG%.]dbo.syscolumns c,
   [%CATALOG%.]dbo.sysconstraints k,
   [%CATALOG%.]dbo.sysobjects r,
   [%CATALOG%.]dbo.syscomments t
where
   r.id=k.constrid
   and t.id=r.id
   and k.tableid=o.id
   and k.colid=c.colid
   and u.uid = o.uid
   and c.id=o.id
   and (o.type=&#39;U&#39; or o.type=&#39;S&#39;)
[  and u.name = %.q:SCHEMA%]
[  and o.name = %.q:TABLE%]
[  and c.name = %.q:COLUMN%]
order by 1,2,3, k.constrid</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object check constraints</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o113">
<a:Name>EnableBindRule</a:Name>
<a:Comment>Allows the binding of business rule to a column for check parameters</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o114">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_bindrule [%R%?[&#39;[%QUALIFIER%]%RULE%&#39;][[%QUALIFIER%]%RULE%]:[&#39;[%QUALIFIER%]%RULE%&#39;]], &#39;%TABLE%.%COLUMN%&#39;</a:TextTargetItem.Value>
<a:Comment>Command for binding a rule to a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o115">
<a:Name>Unbind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_unbindrule &#39;%TABLE%.%COLUMN%&#39;</a:TextTargetItem.Value>
<a:Comment>Command for unbinding a rule from a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o116">
<a:Name>DefineColnChck</a:Name>
<a:TextTargetItem.Value>[%R%?[%ISPKEY%?[constraint %PKNAME%] primary key [%PKEYCLUSTER%?[%R%?[clustered ]]:nonclustered ]:[%ISAKEY%?[constraint %AKNAME%] unique [%AKEYCLUSTER%?clustered :[%R%?[nonclustered ]]]:[[constraint %CONSTNAME% ]check (%.A:CONSTRAINT%)]]]:[[constraint %CONSTNAME% ]check (%.A:CONSTRAINT%)]]</a:TextTargetItem.Value>
<a:Comment>Allows to customize the script of column check constraints</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o117">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a column.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>SELECT=Sel
UPDATE=Upd
REFERENCES=Ref</a:MapTargetItem.Value>
<a:List>SELECT
UPDATE
REFERENCES
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o118">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE, BITMAPCOLN, COLNPERMISSION}

select 
   u1.name,
   convert(integer, s.columns),
   case (s.action) when 193 then &#39;SELECT&#39; when 197 then &#39;UPDATE&#39; when 151 then &#39;REFERENCES&#39; else &#39;&#39; end
   + case (s.protecttype) when  204 then &#39;+&#39; else &#39;&#39; end
from 
   [%CATALOG%.]dbo.sysprotects s, 
   [%CATALOG%.]dbo.sysusers u, 
   [%CATALOG%.]dbo.sysusers u1, 
   [%CATALOG%.]dbo.sysobjects o
where
  s.columns &lt;&gt; 1 and
  o.name = %.q:TABLE% and
  o.uid = u.uid and
  [u.name = %.q:OWNER% and]
  s.id = o.id and
  u1.uid = s.uid
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o119">
<a:Name>ReversedQueries</a:Name>
<a:TextTargetItem.Value>SqlCompAttrQuery</a:TextTargetItem.Value>
<a:Comment>Additional attributes queries to be called by ODBC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o120">
<a:Name>SqlCompAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, TABLE ID, COLUMN ID, Materialized ID, COMPUTE ...}

select 
   u.name,
   o.name,
   c.name,
   case(isnull(c.status2, 0) &amp; 32) when 0 then &#39;False&#39; else &#39;True&#39; end,
   case when (patindex(&#39;as % materialized&#39;, lower(t.text)) &gt; 0) then
      substring(t.text, 3, char_length(t.text) - char_length(&#39;as  materialized&#39;) + 1)
   else stuff(t.text, 1, 3, &#39;&#39;) end
from 
   [%CATALOG%.]dbo.sysusers u
      join [%CATALOG%.]dbo.sysobjects o on (o.uid = u.uid)
      join [%CATALOG%.]dbo.syscolumns c on (c.id = o.id)
      join [%CATALOG%.]dbo.syscomments t on (t.id = c.computedcol)
where 
   c.name is not null
   and isnull(c.computedcol, 0) != 0
[  and u.name = %.q:OWNER%]
[  and o.name = %.q:TABLE%]
order by 1, 2, 3, t.number
</a:TextTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o121">
<a:Name>EnableComputedColn</a:Name>
<a:Comment>Computed columns allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o122">
<a:Name>Default</a:Name>
<a:Code>DFLT</a:Code>
<a:Comment>The following system variables are available:
   &quot;DEFAULT&quot;      // generated code of the default
   &quot;VALUE&quot;        // value of the default object
   &quot;BOUND_OBJECT&quot; // the generated code (including qualifier and parent) of the object which is bound to the default
   &quot;SCRIPT&quot;       // the create default body
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o123">
<a:Name>Enable</a:Name>
<a:Comment>Defaults allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o124">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create default [%QUALIFIER%]%DEFAULT%
    as %VALUE%
</a:TextTargetItem.Value>
<a:Comment>Command for creating a default.
Example: create default %DEFAULT% as %VALUE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o125">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_bindefault [%R%?[&#39;[%QUALIFIER%]%DEFAULT%&#39;][[%QUALIFIER%]%DEFAULT%]:&#39;[%QUALIFIER%]%DEFAULT%&#39;], %.q:BOUND_OBJECT%
</a:TextTargetItem.Value>
<a:Comment>Command for binding a default object to a domain or a column</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o126">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, DEFAULT ID, SCRIPT ...}

select
   user_name(o.uid),
   o.name,
   t.text,
   t.colid
from 
   dbo.sysobjects o,
   dbo.syscomments t
where
   o.type = &#39;D&#39;
   and t.id = o.id
   and t.text not like &#39;DEFAULT%&#39;
[  and user_name(o.uid) = %.q:SCHEMA%]
order by
   1, 2, 4</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o127">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
   from  sysobjects where type = &#39;D&#39;
   and name = %.q:DEFAULT%[ and user_name(uid) = %.q:OWNER%]
   )
   drop default [%QUALIFIER%]%DEFAULT%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a default</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o128">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o129">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, DEFAULT, BOUND_OBJECT}

select
   user_name(o.uid),
   o.name,
   d.name
from
   [%CATALOG%.]dbo.sysobjects o,
   [%CATALOG%.]dbo.systypes d 
where
   o.type = &#39;D&#39; 
   and d.tdefault = o.id
[  and o.name = %.q:DEFAULT%]
[  and user_name(o.uid) = %.q:OWNER%]
union select 
   user_name(o.uid),
   o.name,
   user_name(t.uid)||&#39;.&#39;||t.name||&#39;.&#39;||c.name
from
   [%CATALOG%.]dbo.sysobjects o,
   [%CATALOG%.]dbo.syscolumns c,
   [%CATALOG%.]dbo.sysobjects t 
where
   o.type = &#39;D&#39;
   and c.cdefault = o.id
   and t.id = c.id
[  and o.name = %.q:DEFAULT%]
[  and user_name(o.uid) = %.q:OWNER%]
order by
   1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o130">
<a:Name>Unbind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_unbindefault %.q:BOUND_OBJECT%</a:TextTargetItem.Value>
<a:Comment>Command for unbinding a default value from an object (domain or column)</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o131">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o132">
<a:Name>User</a:Name>
<a:Code>USER</a:Code>
<a:Comment>The following system variables are available:
   &quot;USER&quot;         // generated code of the user
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o133">
<a:Name>Enable</a:Name>
<a:Comment>User allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o134">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o135">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{USER}

select
   u.name
from
   [%CATALOG%.]dbo.sysusers u
where
   u.suid &gt;= -1
[and UPPER(u.name) = %.qU:SCHEMA%]
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o136">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o137">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_adduser %USER%
</a:TextTargetItem.Value>
<a:Comment>Command for creating a user</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o138">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_dropuser %USER%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a user</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o139">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{USER ID, PRIVILEGE ...}

select 
   u1.name,
   case (s.action) when  198 then &#39;CREATE TABLE&#39; when 203 then &#39;CREATE DATABASE&#39; when 207 then &#39;CREATE VIEW&#39; when 221 then &#39;CREATE TRIGGER&#39;
       when 222 then &#39;CREATE PROCEDURE&#39; when 233 then &#39;CREATE DEFAULT&#39; when 236 then &#39;CREATE RULE&#39; end 
   + case (s.protecttype) when 0 then &#39;+&#39; when 2 then &#39;-&#39; else &#39;&#39; end
   + &#39;,&#39;
from 
   [%CATALOG%.]dbo.sysprotects s, 
   [%CATALOG%.]dbo.sysusers u1
where 
   u1.uid = s.uid
order by 1
</a:TextTargetItem.Value>
<a:Comment>Query to reverse privileges</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:IntegerTargetItem Id="o140">
<a:Name>MaxConstLen</a:Name>
<a:Comment>Maximum constraint name length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:BooleanTargetItem Id="o141">
<a:Name>EnableOption</a:Name>
<a:Comment>Physical options allowed  YES/NO</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TargetCategory Id="o142">
<a:Name>Reference</a:Name>
<a:Code>REFR</a:Code>
<a:Comment>The following system variables are available:
   &quot;REFR&quot;         // generated code of the reference
   &quot;REFNAME&quot;      // reference name
   &quot;PARENT&quot;       // generated code of the parent table
   &quot;PNAME&quot;        // name of the parent table
   &quot;PCODE&quot;        // code of the parent table
   &quot;CHILD&quot;        // generated code of the reference
   &quot;CNAME&quot;        // name of the child table
   &quot;CCODE&quot;        // code of the child table
   &quot;PQUALIFIER&quot;   // qualifier of the parent table. See QUALIFIER
   &quot;CQUALIFIER&quot;   // qualifier of the child table. See QUALIFIER
   &quot;REFRNAME&quot;     // Reference name
   &quot;REFRCODE&quot;     // Reference code
   &quot;FKCONSTRAINT&quot; // Reference constraint name (foreign key)
   &quot;PKCONSTRAINT&quot; // constraint name of the parent key used to reference object
   &quot;CKEYCOLUMNS&quot;  // list of parent key columns. Eg: C1, C2, C3
   &quot;FKEYCOLUMNS&quot;  // list of child foreign key columns. Eg:
   &quot;UPDCONST&quot;     // Update declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;DELCONST&quot;     // Delete declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;MINCARD&quot;      // Min cardinality
   &quot;MAXCARD&quot;      // Max cardinality
   &quot;POWNER&quot;       // Parent table owner
   &quot;COWNER&quot;       // child table owner
   &quot;CHCKONCMMT&quot;   // TRUE when check on commit is selected on the reference (ASA 6.0 specific)

For reference joins (couple of column in a reference),
the following system variables are available:
   &quot;CKEYCOLUMN&quot;   // generated code of the parent table column (primary key)
   &quot;FKEYCOLUMN&quot;   // generated code of the child table column (foreign key)
   &quot;PK&quot;           // primary key column generated code
   &quot;PKNAME&quot;       // primary key column name
   &quot;FK&quot;           // foreign key column generated code
   &quot;FKNAME&quot;       // foreign key column name
   &quot;AK&quot;           // alternate key column code (same as PK)
   &quot;AKNAME&quot;       // alternate key column name (same as PKNAME)
   &quot;COLTYPE&quot;      // primary column column datatype
   &quot;DEFAULT&quot;      // foreign key column default value
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o143">
<a:Name>Enable</a:Name>
<a:Comment>Foreign key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o144">
<a:Name>FKAutoIndex</a:Name>
<a:Comment>Foreign key is auto-indexed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o145">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>FK_%.U8:CHILD%_%.U9:REFR%_%.U8:PARENT%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for foreign keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o146">
<a:Name>CheckOnCommit</a:Name>
<a:Comment>Referential integrity test differed after the COMMIT</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o147">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>[%USE_SP_FKEY%?[%R%?[exec ]][execute ]sp_dropkey foreign, [%QUALIFIER%?&#39;%QUALIFIER%%TABLE%&#39;:%.q:TABLE%], [%PQUALIFIER%?&#39;%PQUALIFIER%%PARENT%&#39;:%.q:PARENT%]
:alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Command for dropping a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o148">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]foreign key (%FKEYCOLUMNS%)
      references [%PQUALIFIER%]%PARENT%[ (%CKEYCOLUMNS%)]</a:TextTargetItem.Value>
<a:Comment>Command for defining a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o149">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%USE_SP_FKEY%?[%R%?[exec ]][execute ]sp_foreignkey [%QUALIFIER%?&#39;%QUALIFIER%%TABLE%&#39;:%.q:TABLE%], [%PQUALIFIER%?&#39;%PQUALIFIER%%PARENT%&#39;:%.q:PARENT%], %FKEYCOLUMNS%
:alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME% ]foreign key (%FKEYCOLUMNS%)
      references [%PQUALIFIER%]%PARENT%[ (%CKEYCOLUMNS%)]]</a:TextTargetItem.Value>
<a:Comment>Command for adding a foreign key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o150">
<a:Name>DclUpdIntegrity</a:Name>
<a:TextTargetItem.Value>
RESTRICT</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for update</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o151">
<a:Name>DclDelIntegrity</a:Name>
<a:TextTargetItem.Value>
RESTRICT</a:TextTargetItem.Value>
<a:Comment>Declarative referential integrity constraint allowed for delete</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o152">
<a:Name>UseSpFornKey</a:Name>
<a:Comment>Use sp_foreignkey command to create foreign key</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o153">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{COWNER, CHILD, FKCONSTRAINT, POWNER, PARENT, FKEYCOLUMNS, CKEYCOLUMNS}

select
   u.name,
   o.name,
   c.name,
   v.name,
   p.name,
   col_name(o.id, r.fokey1[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, r.fokey2[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, r.fokey3[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, r.fokey4[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, r.fokey5[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, r.fokey6[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, r.fokey7[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, r.fokey8[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, r.fokey9[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, r.fokey10[,db_id(%.q:CATALOG%)]),
   col_name(p.id, r.refkey1[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, r.refkey2[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, r.refkey3[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, r.refkey4[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, r.refkey5[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, r.refkey6[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, r.refkey7[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, r.refkey8[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, r.refkey9[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, r.refkey10[,db_id(%.q:CATALOG%)])
from
   [%CATALOG%.]dbo.sysusers u,
   [%CATALOG%.]dbo.sysusers v,
   [%CATALOG%.]dbo.sysobjects o,
   [%CATALOG%.]dbo.sysobjects c,
   [%CATALOG%.]dbo.sysconstraints s,
   [%CATALOG%.]dbo.sysreferences r,
   [%CATALOG%.]dbo.sysobjects p
where
   u.uid = o.uid
   and v.uid = p.uid
   and o.id = r.tableid
   and p.id = r.reftabid
   and s.constrid = r.constrid
   and s.constrid=c.id
   and s.tableid=o.id
   and c.type = &#39;RI&#39;
[  and u.name = %.q:SCHEMA%]
[  and o.name = %.q:TABLE%]
union select
   u.name,
   o.name,
   &#39;&#39;,
   v.name,
   p.name,
   col_name(o.id, k.key1[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, k.key2[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, k.key3[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, k.key4[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, k.key5[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, k.key6[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, k.key7[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, k.key8[,db_id(%.q:CATALOG%)]),
   col_name(p.id, k.depkey1[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, k.depkey2[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, k.depkey3[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, k.depkey4[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, k.depkey5[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, k.depkey6[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, k.depkey7[,db_id(%.q:CATALOG%)])+ &#39;,&#39; +
   col_name(p.id, k.depkey8[,db_id(%.q:CATALOG%)])
from
   [%CATALOG%.]dbo.sysusers u,
   [%CATALOG%.]dbo.sysusers v,
   [%CATALOG%.]dbo.sysobjects o,
   [%CATALOG%.]dbo.syskeys k,
   [%CATALOG%.]dbo.sysobjects p
where
   u.uid = o.uid
   and v.uid = p.uid
   and o.id = k.id
   and p.id = k.depid
   and k.type != 1
[  and u.name = %.q:SCHEMA%]
[  and o.name = %.q:TABLE%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o154">
<a:Name>PKey</a:Name>
<a:Code>PKEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Eg: A, B
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o155">
<a:Name>Enable</a:Name>
<a:Comment>Primary key allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o156">
<a:Name>PkAutoIndex</a:Name>
<a:Comment>Primary key is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o157">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>PK_%.U27:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for primary keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o158">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with : composite=yes, separator=yes
{
fillfactor = %d : default=15
max_rows_per_page = %d : default=0
reservepagegap = %d : default=0
}
on %s : category=storage</a:TextTargetItem.Value>
<a:Comment>Available options for creating a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o159">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for primary key options</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o160">
<a:Name>UseSpPrimKey</a:Name>
<a:Comment>Use the sp_primarykey command to generate primary key</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o161">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>[%USE_SP_PKEY%?[%R%?[exec ]][execute ]sp_dropkey primary, [%QUALIFIER%?&#39;%QUALIFIER%%TABLE%&#39;:%.q:TABLE%]
:alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%]</a:TextTargetItem.Value>
<a:Comment>Command for dropping a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o162">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]primary key [%CLUSTER%?[%R%?[clustered ]]:nonclustered ](%PKEYCOLUMNS%)
      [%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for defining a primary key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o163">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%USE_SP_PKEY%?[%R%?[exec ]][execute ]sp_primarykey [%QUALIFIER%?&#39;%QUALIFIER%%TABLE%&#39;:%.q:TABLE%], %PKEYCOLUMNS%
:alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME% ]primary key [%CLUSTER%?[%R%?[clustered ]]:nonclustered ](%PKEYCOLUMNS%)
      [%OPTIONS%]]</a:TextTargetItem.Value>
<a:Comment>Command for adding a primary key</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o164">
<a:Name>EnableCluster</a:Name>
<a:Comment>Cluster option available for primary keys</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o165">
<a:Name>Key</a:Name>
<a:Code>KEY</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for keys)
   &quot;COLUMNS&quot;      // List of columns of the key. Eg: &quot;A, B, C&quot;
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;KEY&quot;          // constraint name
   &quot;PKEY&quot;         // constraint name for primary key
   &quot;AKEY&quot;         // constraint name for alternate key
   &quot;ISMULTICOLN&quot;  // TRUE if key has more than one column
   &quot;CLUSTER&quot;      // keyword cluster
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o166">
<a:Name>Enable</a:Name>
<a:Comment>UNIQUE constraint allowed for tables</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o167">
<a:Name>UniqConstAutoIndex</a:Name>
<a:Comment>UNIQUE constraint is auto-indexed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o168">
<a:Name>ConstName</a:Name>
<a:TextTargetItem.Value>AK_%.U18:AKEY%_%.U8:TABLE%</a:TextTargetItem.Value>
<a:Comment>Constraint name template for alternate keys</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o169">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>with : composite=yes, separator=yes
{
fillfactor = %d : default=15
max_rows_per_page = %d : default=0
reservepagegap = %d : default=0
}
on %s : category=storage</a:TextTargetItem.Value>
<a:Comment>Available options for an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o170">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for alternate key options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o171">
<a:Name>SqlAkeyIndex</a:Name>
<a:Comment>SQL query to obtain the alternate key indexes of a table by ODBC</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o172">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TextTargetItem.Value>
<a:Comment>Command for dropping an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o173">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, @OBJTCODE, CONSTNAME, ISPKEY, CLUSTER, COLUMNS}

select
   u.name,
   o.name,
   i.name,
   i.name,
   case (i.status&amp;2048) when 2048 then &#39;YES&#39; else &#39;NO&#39; end,
   case (o.sysstat2&amp;131072) when 131072 then case (i.status2&amp;512) when 512 then &#39;YES&#39; else &#39;NO&#39; end else case (i.status&amp;16) when 16 then &#39;YES&#39; else &#39;NO&#39; end end,
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,1,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,2,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,3,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,4,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,5,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,6,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,7,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,8,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,9,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,10,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,11,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,12,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,13,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,14,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,15,u.uid)+&#39;,&#39;+
   index_col(&#39;[%CATALOG%..]%TABLE%&#39;,i.indid,16,u.uid)
from
   [%CATALOG%.]dbo.sysusers u,
   [%CATALOG%.]dbo.sysindexes i,
   [%CATALOG%.]dbo.sysobjects o
where
   u.uid = o.uid
   and o.id=i.id
   and ( (i.status2&amp;2=2) )
[  and u.name = %.q:SCHEMA%]
[  and o.name = %.q:TABLE%]
union select
   u.name,
   o.name,
   &#39;&#39;,
   &#39;&#39;,
   &#39;YES&#39;,
   &#39;NO&#39;,
   col_name(o.id, k.key1[, db_id(%.Q:CATALOG%)])+ &#39;,&#39; + col_name(o.id, k.key2[, db_id(%.Q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, k.key3[, db_id(%.Q:CATALOG%)])+ &#39;,&#39; + col_name(o.id, k.key4[, db_id(%.Q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, k.key5[, db_id(%.Q:CATALOG%)])+ &#39;,&#39; + col_name(o.id, k.key6[, db_id(%.Q:CATALOG%)])+ &#39;,&#39; +
   col_name(o.id, k.key7[, db_id(%.Q:CATALOG%)])+ &#39;,&#39; + col_name(o.id, k.key8[, db_id(%.Q:CATALOG%)])
from
   [%CATALOG%.]dbo.sysusers u,
   [%CATALOG%.]dbo.syskeys k,
   [%CATALOG%.]dbo.sysobjects o
where
   u.uid = o.uid
   and o.id=k.id
   and k.type=1
[  and u.name = %.q:SCHEMA%]
[  and o.name = %.q:TABLE%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o174">
<a:Name>SqlAttrQuery</a:Name>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o175">
<a:Name>Add</a:Name>
<a:TextTargetItem.Value>[constraint %CONSTNAME% ]unique [%CLUSTER%?clustered :[%R%?[nonclustered ]]][%DescKey%?desc :[%R%?asc ]](%COLUMNS%)
      [%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for defining an alternate key</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o176">
<a:Name>SqlOptsQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, TABLE, CONSTNAME, OPTIONS}

select
   u.name,
   o.name,
   i.name,
   case(isnull(i.maxrowsperpage, 0)) when 0 then &#39;&#39; else &#39; with max_rows_per_page = &#39; + rtrim(convert(CHAR, i.maxrowsperpage)) end
   +case(isnull(i.fill_factor, 0))    when 0 then &#39;&#39; else case(isnull(i.maxrowsperpage, 0)) when 0 then &#39; with&#39; else &#39;,&#39; end + &#39; fillfactor = &#39; + rtrim(convert(CHAR, i.fill_factor)) end
   +case(isnull(i.res_page_gap, 0))   when 0 then &#39;&#39; else case(isnull(i.maxrowsperpage, 0) + isnull(i.fill_factor, 0)) when 0 then &#39; with&#39; else &#39;,&#39; end + &#39; reservepagegap = &#39; + rtrim(convert(CHAR, i.res_page_gap)) end
   +case (lower(s.name)) when &#39;default&#39; then &#39; on &quot;default&quot;&#39; else &#39; on &#39; + s.name end
from
   [%CATALOG%.]dbo.sysusers u
      join [%CATALOG%.]dbo.sysobjects o on (u.uid = o.uid)
      join [%CATALOG%.]dbo.sysindexes i on (i.id = o.id)
      join [%CATALOG%.]dbo.syssegments s on (i.segment = s.segment)
where (i.status2&amp;2) = 2
[  and u.name = %.q:SCHEMA%]
[  and o.name = %.q:TABLE%]
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object physical options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o177">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME% ]unique [%CLUSTER%?clustered :[%R%?[nonclustered ]]][%DescKey%?desc :[%R%?asc ]](%COLUMNS%)
      [%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for adding an alternate key</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o178">
<a:Name>EnableCluster</a:Name>
<a:Comment>Cluster option available for alternate keys</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o179">
<a:Name>Domain</a:Name>
<a:Code>PDMDOMN</a:Code>
<a:Comment>The following system variables are available:
   &quot;DOMAIN&quot;       // generated code of the domain (also available for columns)
SQL Server specific domain system variables:
   &quot;RULENAME&quot;     // name of the rule object associated with the domain
   &quot;DEFAULTNAME&quot;  // name of the default object associated with the domain
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o180">
<a:Name>Enable</a:Name>
<a:Comment>User defined data types allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o181">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o182">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_addtype %DOMAIN%, %.q:DATATYPE%, &#39;[%IDENTITY%?%IDENTITY%:[%NOTNULL%?not null:null]]&#39;</a:TextTargetItem.Value>
<a:Comment>Command for creating a user defined data type</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o183">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{DOMAIN, DTTPCODE, LENGTH, PREC, DEFAULTNAME (&#39;0&#39;=&#39;&#39;), RULENAME (&#39;0&#39;=&#39;&#39;)}

select distinct
   u.name,
   i.name,
   isnull(u.prec,u.length),
   u.scale,
   convert(char(20), isnull(u.tdefault, 0)),
   convert(char(20), isnull(u.domain, 0))
from
   [%CATALOG%.]dbo.systypes u,
   [%CATALOG%.]dbo.systypes i
where
   u.type=i.type
   and u.usertype&gt;=100
   and i.usertype&lt;100
   and i.usertype not in (18, 24, 25, 80)
[  and u.name = %.q:DOMAIN%]
order by
   1,2</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o184">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{DOMAIN, DTTPCODE, LENGTH, PREC, NOTNULL, IDENTITY}

select distinct
   u.name,
   i.name,
   isnull(u.prec,u.length),
   u.scale,
   case (u.allownulls) when 1 then &#39;NULL&#39; else &#39;NOT NULL&#39; end,
   case (u.ident) when 1 then &#39;identity&#39; else &#39;&#39; end
from
   [%CATALOG%.]dbo.systypes u,
   [%CATALOG%.]dbo.systypes i
where
   u.type=i.type
   and u.usertype&gt;=100
   and i.usertype&lt;100
   and i.usertype not in (18, 24, 25, 80)
order by
   1,2</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o185">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>[%DEFAULT% ?
if exists(select 1 from systypes where name=%.q:DOMAIN%)
begin
   [%R%?[exec ]][execute ]sp_droptype %DOMAIN%
   drop default %DEFAULTNAME%
end
:
if exists(select 1 from systypes where name=%.q:DOMAIN%)
   [%R%?[exec ]][execute ]sp_droptype %DOMAIN%
]
</a:TextTargetItem.Value>
<a:Comment>Command for dropping a user defined data type</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o186">
<a:Name>EnableBindRule</a:Name>
<a:Comment>Allows the binding of a business rule to a domain</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o187">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_bindrule [%R%?[&#39;[%QUALIFIER%]%RULE%&#39;][[%QUALIFIER%]%RULE%]:[&#39;[%QUALIFIER%]%RULE%&#39;]], %DOMAIN%</a:TextTargetItem.Value>
<a:Comment>Command for binding a rule to a domain</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o188">
<a:Name>Unbind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_unbindrule %DOMAIN%</a:TextTargetItem.Value>
<a:Comment>Command for unbinding a rule from a domain</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o189">
<a:Name>Rule</a:Name>
<a:Code>RULE</a:Code>
<a:Comment>The following system variables are available:
   &quot;RULE&quot;         // generated code of the rule
   &quot;RULENAME&quot;     // rule name
   &quot;RULECODE&quot;     // rule code
   &quot;RULECEXPR&quot;    // rule client expression
   &quot;RULESEXPR&quot;    // rule server expression
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o190">
<a:Name>Enable</a:Name>
<a:Comment>Rule allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o191">
<a:Name>MaxDefaultLen</a:Name>
<a:Comment>Length of name of default</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:StringTargetItem Id="o192">
<a:Name>UddtDefaultName</a:Name>
<a:Comment>Name of default for domain</a:Comment>
<a:StringTargetItem.Value>D_%.28:DOMAIN%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o193">
<a:Name>ColnDefaultName</a:Name>
<a:Comment>Name of default for column</a:Comment>
<a:StringTargetItem.Value>D_%.19:COLUMN%_%.8:TABLE%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:IntegerTargetItem Id="o194">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:StringTargetItem Id="o195">
<a:Name>UddtRuleName</a:Name>
<a:Comment>Name of rules for domains</a:Comment>
<a:StringTargetItem.Value>R_%.28:DOMAIN%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:StringTargetItem Id="o196">
<a:Name>ColnRuleName</a:Name>
<a:Comment>Name of rules for columns</a:Comment>
<a:StringTargetItem.Value>R_%.19:COLUMN%_%.8:TABLE%</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o197">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create rule [%S%.]%RULE% as
      %RULESEXPR%</a:TextTargetItem.Value>
<a:Comment>Command for adding a rule</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o198">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1 from sysobjects where name=%.q:RULE% and type=&#39;R&#39;)
   drop rule [%S%.]%RULE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a rule</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o199">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, @OBJTNAME ID, @OBJTCODE ID, SCRIPT ...}

select
   u.name,
   o.name,
   convert(char(20), o.id),
   t.text
from
   [%CATALOG%.]dbo.sysusers u,
   [%CATALOG%.]dbo.sysobjects o,
   [%CATALOG%.]dbo.syscomments t
where
   u.uid = o.uid
   and o.type=&#39;R&#39;
   and t.id=o.id
   and t.texttype=0
[  and u.name = %.q:SCHEMA%]
order by
   1, 2, t.number, t.colid
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o200">
<a:Name>Database</a:Name>
<a:Code>DTBS</a:Code>
<a:Comment>The following system variables are available:
   &quot;DATABASE&quot;     // generated code of the database
</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o201">
<a:Name>BeforeCreate</a:Name>
<a:TextTargetItem.Value>use master
go
</a:TextTargetItem.Value>
<a:Comment>Commands executed before create statement</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o202">
<a:Name>Enable</a:Name>
<a:Comment>Database allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o203">
<a:Name>BeforeCreateDatabase</a:Name>
<a:Comment>Creates tablespaces and storages before database</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o204">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create database %DATABASE%
[%OPTIONS%]</a:TextTargetItem.Value>
<a:Comment>Command for creating a database. Example: create database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o205">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>on : composite=yes, separator=yes
{
   &lt;database_device[=size]&gt; %s : multiple=yes
}
log on : composite=yes, separator=yes
{
   &lt;database_device[=size]&gt; %s : multiple=yes
}
with override
for load</a:TextTargetItem.Value>
<a:Comment>Available options for creating a database</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o206">
<a:Name>OpenDatabase</a:Name>
<a:TextTargetItem.Value>use %DATABASE%</a:TextTargetItem.Value>
<a:Comment>Command for opening a database. Example: open database %DATABASE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o207">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists( select 1 from master.dbo.sysdatabases where name = %.q:DATABASE%)
begin
   use master
   drop database %DATABASE%
end</a:TextTargetItem.Value>
<a:Comment>Command for dropping a database. Example: drop database %DATABASE%</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o208">
<a:Name>Tablespace</a:Name>
<a:Code>TSPC</a:Code>
<a:Comment>The following system variables are available:
   &quot;TABLESPACE&quot;   // generated code of the tablespace
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o209">
<a:Name>Enable</a:Name>
<a:Comment>Tablespace allowed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o210">
<a:Name>Create</a:Name>
<a:Comment>Command for creating a tablespace. Example: create tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o211">
<a:Name>Drop</a:Name>
<a:Comment>Command for dropping a tablespace. Example: drop tablespace %TABLESPACE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o212">
<a:Name>Options</a:Name>
<a:Comment>Default options for creating a tablespace.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o213">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for tablespace options.</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o214">
<a:Name>Storage</a:Name>
<a:Code>STOR</a:Code>
<a:Comment>The following system variables are available:
   &quot;STORAGE&quot;      // generated code of the storage
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o215">
<a:Name>Enable</a:Name>
<a:Comment>Storage allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o216">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_addsegment %STORAGE%, %DATABASE%, %OPTIONS%</a:TextTargetItem.Value>
<a:Comment>Command for creating a storage. Example: create storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o217">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_dropsegment %STORAGE%, %DATABASE%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a storage. Example: drop storage %STORAGE%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o218">
<a:Name>Options</a:Name>
<a:TextTargetItem.Value>&lt;devname&gt; %s</a:TextTargetItem.Value>
<a:Comment>Default options for creating a storage</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o219">
<a:Name>DefOptions</a:Name>
<a:Comment>Default values for storage options</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o220">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{STORAGE}

select
   name
from
   [%CATALOG%.]dbo.syssegments
order by name
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o221">
<a:Name>View</a:Name>
<a:Code>VIEW</a:Code>
<a:Comment>The following system variables are available:
   &quot;VIEW&quot;         // generated code of the view
   &quot;VIEWNAME&quot;     // view name
   &quot;VIEWCODE&quot;     // view code
   &quot;VIEWCOLN&quot;     // List of columns of the view. Eg: &quot;A, B, C&quot;
   &quot;SQL&quot;          // SQL text of the view. Eg: Select * from T1
   &quot;VIEWCHECK&quot;    // Keyword &quot;with check option&quot; if selected on the view
   &quot;SCRIPT&quot;       // complete view creation order. Eg: create view V1 as select * from T1
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o222">
<a:Name>Enable</a:Name>
<a:Comment>View allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o223">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create view [%QUALIFIER%]%VIEW% [(%VIEWCOLN%) ]as
%SQL%
[%VIEWCHECK%]
</a:TextTargetItem.Value>
<a:Comment>Command for creating a view. Example: create view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o224">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
            from  sysobjects
            where  id = object_id(&#39;[%QUALIFIER%]%VIEW%&#39;)
            and   type = &#39;V&#39;)
   drop view [%QUALIFIER%]%VIEW%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a view. Example: drop view %VIEW%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o225">
<a:Name>ViewComment</a:Name>
<a:Comment>Command for adding a view comment.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o226">
<a:Name>ViewCheck</a:Name>
<a:TextTargetItem.Value>with check option</a:TextTargetItem.Value>
<a:Comment>Option for checking a view</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o227">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, VIEW}

select
   u.name,
   o.name
from
   [%CATALOG%.]dbo.sysusers u
      join [%CATALOG%.]dbo.sysobjects o on (o.uid = u.uid and o.type=&#39;V&#39;)
[where u.name = %.q:SCHEMA%]
order by 1, 2
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o228">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, VIEW ID, SCRIPT ...}

select
   u.name,
   v.name,
   convert(char(255), t.text)
from
   [%CATALOG%.]dbo.sysusers u,
   [%CATALOG%.]dbo.sysobjects v,
   [%CATALOG%.]dbo.syscomments t
where
   u.uid = v.uid
   and t.id=v.id
   and v.type=&#39;V&#39;
   [and u.name = %.q:SCHEMA%]
   [and v.name = %.q:VIEW%]
order by
   1, 2, t.number, t.colid2, t.colid
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o229">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a view.
The first column is the SQL name of permission (eg: SELECT)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>SELECT=Sel
INSERT=Ins
DELETE=Del
UPDATE=Upd</a:MapTargetItem.Value>
<a:List>SELECT
INSERT
DELETE
UPDATE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o230">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE ID, PERMISSION ...}

select 
   u1.name,
   case (s.action) when  193 then &#39;SELECT&#39; when 195 then &#39;INSERT&#39; when 196 then &#39;DELETE&#39; when 197 then &#39;UPDATE&#39; else &#39;&#39; end
   + case (s.protecttype) when  0 then &#39;+&#39; when 2 then &#39;-&#39; else &#39;&#39; end
   + &#39;,&#39;
from 
   [%CATALOG%.]dbo.sysprotects s, 
   [%CATALOG%.]dbo.sysusers u, 
   [%CATALOG%.]dbo.sysusers u1, 
   [%CATALOG%.]dbo.sysobjects o
where
  o.name = %.q:VIEW% and
  o.uid = u.uid and
  [u.name = %.q:OWNER% and]
  s.id = o.id and
  u1.uid = s.uid
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o231">
<a:Name>SqlColnListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, VIEW ID, VIEWCOLN ...}

select
   u.name,
   o.name,
   c.name + &#39;,&#39;,
   c.colid
from
   [%CATALOG%.]dbo.sysusers u
      join [%CATALOG%.]dbo.sysobjects o on (o.uid = u.uid and o.type=&#39;V&#39;)
      join [%CATALOG%.]dbo.syscolumns c on (c.id = o.id)
where
  1=1
[  and u.name = %.q:SCHEMA%]
[  and o.name = %.q:VIEW%]
order by 1, 2, 4
</a:TextTargetItem.Value>
<a:Comment>SQL query to list view columns</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TextTargetItem>
<o:TextTargetItem Id="o232">
<a:Name>ReversedQueries</a:Name>
<a:TextTargetItem.Value>SqlColnListQuery</a:TextTargetItem.Value>
<a:Comment>Additional attributes queries to be called by ODBC</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o233">
<a:Name>Trigger</a:Name>
<a:Code>TRGR</a:Code>
<a:Comment>The following system variables are available:
(parent table items are also available for indexes)
 trigger object specific items
   &quot;ORDER&quot;        // order number of the trigger (to sort the triggers when the DBMS supports more than one trigger of one type)
   &quot;TRIGGER&quot;      // generated code of trigger
   &quot;TRGTYPE&quot;      // trigger type (keywords &quot;beforeinsert&quot;, &quot;afterupdate&quot;, ...)
   &quot;TRGEVENT&quot;     // trigger event (keywords &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;)
   &quot;TRGTIME&quot;      // trigger time (keywords NULL, &quot;before&quot;, &quot;after&quot;)
 inside the body of the trigger, macros redefine variables on objects
   &quot;REFNO&quot;        // reference position in the list of references of the table
 customized error messages management
   &quot;ERRNO&quot;        // error number for standard error
   &quot;ERRMSG&quot;       // error message for standard error
   &quot;MSGTAB&quot;       // name of the table containing user-defined error messages
   &quot;MSGNO&quot;        // in the user-defined error table, name of the column containing the error numbers
   &quot;MSGTXT&quot;       // in the user-defined error table, name of the column containing the error messages
   &quot;SCRIPT&quot;       // body of trigger or procedure
   &quot;TRGDEFN&quot;      // complete body of the trigger definition. Contains variable declarations and body of trigger or procedure
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o234">
<a:Name>Enable</a:Name>
<a:Comment>Trigger allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o235">
<a:Name>EnableMultiTrigger</a:Name>
<a:Comment>Multi trigger allowed</a:Comment>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o236">
<a:Name>DefaultTriggerName</a:Name>
<a:TextTargetItem.Value>%TEMPLATE%_%.L:TABLE%</a:TextTargetItem.Value>
<a:Comment>Default trigger name</a:Comment>
</o:TextTargetItem>
<o:IntegerTargetItem Id="o237">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o238">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
            from  sysobjects
            where id = object_id(&#39;[%QUALIFIER%]%TRIGGER%&#39;)
            and   type = &#39;TR&#39;)
   drop trigger [%QUALIFIER%]%TRIGGER%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a trigger. Example: drop trigger %TRIGGER%</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o239">
<a:Name>EnableOwner</a:Name>
<a:Comment>Owner allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:StringTargetItem Id="o240">
<a:Name>EventDelimiter</a:Name>
<a:Comment>Events separation character.</a:Comment>
<a:StringTargetItem.Value>,</a:StringTargetItem.Value>
</o:StringTargetItem>
<o:TextTargetItem Id="o241">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER, TABLE, OWNER, TRIGGER, TRGEVENT}

select
   user_name(tb.uid),
   tb.name,
   user_name(tr.uid),
   tr.name,
   case(tb.deltrig) when tr.id then &#39;delete,&#39; else &#39;&#39; end +
   case(tb.instrig) when tr.id then &#39;insert,&#39; else &#39;&#39; end +
   case(tb.updtrig) when tr.id then &#39;update,&#39; else &#39;&#39; end
from
   [%CATALOG%.]dbo.sysobjects tb,
   [%CATALOG%.]dbo.sysobjects tr
where
   tr.type = &#39;TR&#39;
   and tr.id in (tb.deltrig, tb.instrig, tb.updtrig)
[  and user_name(tb.uid) = %.q:TABLOWNER%]
[  and user_name(tr.uid) = %.q:SCHEMA%]
[  and tb.name = %.q:TABLE%]</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o242">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{TABLOWNER ID, TABLE ID, OWNER ID, TRIGGER ID, SCRIPT ...}

select
   user_name(o.uid),
   o.name,
   user_name(t.uid),
   t.name,
   convert(char(255), c.text)
from
   [%CATALOG%.]dbo.sysobjects o,
   [%CATALOG%.]dbo.sysobjects t,
   [%CATALOG%.]dbo.syscomments c
where
   c.id = t.id
   and t.type = &#39;TR&#39;
   and t.id in (o.deltrig, o.instrig, o.updtrig)
   and (t.deltrig!=0 or t.instrig!=0 or t.updtrig!=0)
[  and user_name(o.uid) = %.q:TABLOWNER%]
[  and user_name(t.uid) = %.q:OWNER%]
[  and o.name = %.q:TABLE%]
[  and t.name = %.q:TRIGGER%]
order by
   1, 2, 3, 4, c.number, c.colid2, c.colid</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o243">
<a:Name>UseErrorMsgTable</a:Name>
<a:TextTargetItem.Value>begin
   select @errno  = %ERRNO%,
          @errmsg = %MSGTXT%
   from   %MSGTAB%
   where  %MSGNO% = %ERRNO%
   goto error
end</a:TextTargetItem.Value>
<a:Comment>Errors handling using an error messages table</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o244">
<a:Name>UseErrorMsgText</a:Name>
<a:TextTargetItem.Value>begin
   select @errno  = %ERRNO%,
          @errmsg = %.q:ERRMSG%
   goto error
end</a:TextTargetItem.Value>
<a:Comment>Errors handling using fixed error messages</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o245">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create trigger [%QUALIFIER%]%TRIGGER% on [%TABLQUALIFIER%]%TABLE%[ for %TRGEVENT%] as
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a trigger. Example: create trigger on [%QUALIFIER%]%TABLE% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o246">
<a:Name>Procedure</a:Name>
<a:Code>PROC</a:Code>
<a:Comment>The following system variables are available:
   &quot;PROC&quot;         // generated code of the procedure (also available for trigger when the trigger is implemented with a procedure)
   &quot;FUNC&quot;         // generated code of the procedure if the procedure is a function (with return value)
   &quot;PROCPRMS&quot;     // list of parameters of the procedure (also available for function)
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o247">
<a:Name>Enable</a:Name>
<a:Comment>Procedure allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o248">
<a:Name>EnableFunc</a:Name>
<a:Comment>Function allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:IntegerTargetItem Id="o249">
<a:Name>Maxlen</a:Name>
<a:Comment>Maximum object code length</a:Comment>
<a:IntegerTargetItem.Value>30</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:IntegerTargetItem Id="o250">
<a:Name>MaxFuncLen</a:Name>
<a:Comment>Function name length</a:Comment>
<a:IntegerTargetItem.Value>128</a:IntegerTargetItem.Value>
</o:IntegerTargetItem>
<o:TextTargetItem Id="o251">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>if exists (select 1
          from sysobjects
          where id = object_id(&#39;[%QUALIFIER%]%PROC%&#39;)
          and type = &#39;P&#39;)
   drop procedure [%QUALIFIER%]%PROC%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a procedure. Example: drop procedure %PROC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o252">
<a:Name>CustomProc</a:Name>
<a:TextTargetItem.Value>create procedure [%QUALIFIER%]%PROC% &lt;@arg&gt; &lt;type&gt; as
declare &lt;@var&gt; &lt;type&gt;
begin

end
</a:TextTargetItem.Value>
<a:Comment>Command for creating a stored procedure</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o253">
<a:Name>DropFunc</a:Name>
<a:Comment>Command for dropping a function. Example: drop function %FUNC%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o254">
<a:Name>CustomFunc</a:Name>
<a:TextTargetItem.Value>create function [%QUALIFIER%]%FUNC% (&lt;arg&gt; &lt;type&gt;)
returns &lt;sql_datatype&gt;
modifies sql data
called on null input
deterministic
exportable
language java
parameter style java
external name &#39;&lt;java_method_name&gt;&#39;

</a:TextTargetItem.Value>
<a:Comment>Command for creating a function</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o255">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{OWNER, PROC, FUNC}

select
   u.name,
   case(p.type) when &#39;P&#39; then p.name else &#39;&#39; end,
   case(p.type) when &#39;F&#39; then p.name else &#39;&#39; end
from
   [%CATALOG%.]dbo.sysusers u,
   [%CATALOG%.]dbo.sysobjects p
where
   u.uid = p.uid
   and p.type in (&#39;P&#39;, &#39;F&#39;)
[  and u.name = %.q:SCHEMA%]
order by
   1, 2, 3
</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o256">
<a:Name>SqlAttrQuery</a:Name>
<a:TextTargetItem.Value>{OWNER ID, PROC ID, SCRIPT ...}

select
   u.name,
   p.name,
   t.text
from
   [%CATALOG%.]dbo.sysusers u,
   [%CATALOG%.]dbo.sysobjects p,
   [%CATALOG%.]dbo.syscomments t
where
   u.uid = p.uid
   and p.type in (&#39;P&#39;, &#39;F&#39;)
   and t.id=p.id
[  and p.name = %.q:PROC%]
[  and u.name = %.q:SCHEMA%]
order by
   1, 2, t.number, t.colid2, t.colid
</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object attributes</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o257">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create [.O:[procedure ][proc ]][%QUALIFIER%]%PROC%[ %PROCPRMS%] as
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a procedure. Example: create procedure %PROC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o258">
<a:Name>CreateFunc</a:Name>
<a:TextTargetItem.Value>create function [%QUALIFIER%]%FUNC% (%PROCPRMS%)
%TRGDEFN%</a:TextTargetItem.Value>
<a:Comment>Command for creating a function. Example: create function %FUNC% %TRGDEFN%</a:Comment>
</o:TextTargetItem>
<o:MapTargetItem Id="o259">
<a:Name>Permission</a:Name>
<a:Comment>Available permission for a procedure.
The first column is the SQL name of permission (eg: EXECUTE)
The second column is a shortname to display in a grid</a:Comment>
<a:MapTargetItem.Value>EXECUTE=Exe</a:MapTargetItem.Value>
<a:List>EXECUTE
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o260">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GRANTEE, PERMISSION}

select 
   u1.name,
   &#39;EXECUTE&#39;
   + case (s.protecttype) when 0 then &#39;+&#39; when 2 then &#39;-&#39; else &#39;&#39; end
from 
   [%CATALOG%.]dbo.sysprotects s, 
   [%CATALOG%.]dbo.sysusers u, 
   [%CATALOG%.]dbo.sysusers u1, 
   [%CATALOG%.]dbo.sysobjects o
where
  s.action = 224 and
  o.name =  %.q:PROC% and
  o.uid = u.uid and
  [u.name = %.q:OWNER% and]
  s.id = o.id and
  u1.uid = s.uid
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to reverse object permissions</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o261">
<a:Name>Abstract Data Type</a:Name>
<a:Code>ADT</a:Code>
<a:Comment>The following system variables are available:
   &quot;ADT&quot;          // generated code of the abstract data type
   &quot;TYPE&quot;         // ADT type
   &quot;SIZE&quot;         // ADT size
   &quot;FILE&quot;         // ADT: Java file
   &quot;ISARRAY&quot;      // ADT: is an array?
   &quot;ISLIST&quot;       // ADT: is a list?
   &quot;ISSTRUCT&quot;     // ADT: is a structure?
   &quot;ISOBJECT&quot;     // ADT: is an object?
   &quot;ISJAVA&quot;       // ADT: is a JAVA class?
   &quot;ADTDEF&quot;       // ADT definition
</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o262">
<a:Name>Enable</a:Name>
<a:Comment>Abstract Data Types allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o263">
<a:Name>EnableAdtOnDomn</a:Name>
<a:Comment>Abstract Data Types allowed on domain</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:BooleanTargetItem Id="o264">
<a:Name>EnableAdtOnColn</a:Name>
<a:Comment>Abstract Data Types allowed on column</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o265">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{ADT, TYPE}

select
   t.xtname,
   &#39;JAVA&#39;
from
   [%CATALOG%.]dbo.sysxtypes t
where
   t.xtmetatype = 1
order by
   t.xtname</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o266">
<a:Name>Group</a:Name>
<a:Code>GRPE</a:Code>
<a:Comment>Manages the group object.</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o267">
<a:Name>Enable</a:Name>
<a:Comment>Group allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o268">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_addgroup %GROUP%
</a:TextTargetItem.Value>
<a:Comment>Command for creating a group.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o269">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_dropgroup %GROUP%</a:TextTargetItem.Value>
<a:Comment>Command for dropping a group.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o270">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{GROUP}

select
   u.name
from
   [%CATALOG%.]dbo.sysusers u
where
   u.uid = u.gid and
   u.gid not in (select r.lrid from [%CATALOG%.]dbo.sysroles r)
[and UPPER(u.name) = %.qU:SCHEMA%]
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o271">
<a:Name>SqlListChildrenQuery</a:Name>
<a:TextTargetItem.Value>{GROUP ID, MEMBER}

select
   g.name, u.name
from
   [%CATALOG%.]dbo.sysusers u, [%CATALOG%.]dbo.sysusers g
where
   u.suid &gt; 0 and
   u.gid = g.gid and
   g.gid = g.uid
order by 1, 2</a:TextTargetItem.Value>
<a:Comment>SQL query to list members of the group</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o272">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>[%R%?[exec ]][execute ]sp_changegroup %GROUP% , %USER%
</a:TextTargetItem.Value>
<a:Comment>Command for adding a member to a group</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o273">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{GROUP ID, PRIVILEGE ...}

select 
   u.name,
   case (s.action) when 198 then &#39;CREATE TABLE&#39; when 203 then &#39;CREATE DATABASE&#39; when 207 then &#39;CREATE VIEW&#39; when 221 then &#39;CREATE TRIGGER&#39;
      when 222 then &#39;CREATE PROCEDURE&#39; when 233 then &#39;CREATE DEFAULT&#39; when 236 then &#39;CREATE RULE&#39; end
   + case (s.protecttype) when 0 then &#39;+&#39; when 2 then &#39;-&#39; else &#39;&#39; end
   + &#39;,&#39;
from 
   [%CATALOG%.]dbo.sysprotects s, 
   [%CATALOG%.]dbo.sysusers u
where
   u.uid = u.gid and
   u.gid not in (select r.lrid from [%CATALOG%.]dbo.sysroles r) and
   u.uid = s.uid
order by 1
</a:TextTargetItem.Value>
<a:Comment>Query to reverse privileges</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o274">
<a:Name>Role</a:Name>
<a:Code>ROLE</a:Code>
<a:Comment>Manages the role object.</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o275">
<a:Name>Enable</a:Name>
<a:Comment>Role allowed</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o276">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>create role %ROLE% [with passwd &quot;%PASSWORD%&quot;]
</a:TextTargetItem.Value>
<a:Comment>Command for creating a role.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o277">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>drop role %ROLE% [with override]</a:TextTargetItem.Value>
<a:Comment>Command for dropping a role.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o278">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>{ROLE}

select
   u.name
from
   master.dbo.syssrvroles u
order by 1</a:TextTargetItem.Value>
<a:Comment>SQL query to list objects</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o279">
<a:Name>SqlListChildrenQuery</a:Name>
<a:TextTargetItem.Value>{ ROLE ID, MEMBER }

SELECT
   r.name, u.name
FROM
   master.dbo.sysloginroles l,
   [%CATALOG%.]dbo.sysroles s,
   [%CATALOG%.]dbo.sysusers u,
   [%CATALOG%.]dbo.sysusers r
where
   l.suid = u.suid
   and s.id     =l.srid
   and r.uid = s.lrid
</a:TextTargetItem.Value>
<a:Comment>SQL query to list assigned ids to the role.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o280">
<a:Name>Bind</a:Name>
<a:TextTargetItem.Value>grant role %ROLE% to %USER%
</a:TextTargetItem.Value>
<a:Comment>Command for assigning a role to a user or another role</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o281">
<a:Name>SqlPermQuery</a:Name>
<a:TextTargetItem.Value>{ROLE ID, PRIVILEGE ...}

select 
   u.name,
   case (s.action) when 198 then &#39;CREATE TABLE&#39; when 203 then &#39;CREATE DATABASE&#39; when 207 then &#39;CREATE VIEW&#39; when 221 then &#39;CREATE TRIGGER&#39;
      when 222 then &#39;CREATE PROCEDURE&#39; when 233 then &#39;CREATE DEFAULT&#39; when 236 then &#39;CREATE RULE&#39; end
   + case (s.protecttype) when 0 then &#39;+&#39; when 2 then &#39;-&#39; else &#39;&#39; end
   + &#39;,&#39;
from 
   [%CATALOG%.]dbo.sysprotects s, 
   master.dbo.syssrvroles u, 
   [%CATALOG%.]dbo.sysroles r
where
   u.srid = r.id and
   r.lrid = s.uid
order by 1
</a:TextTargetItem.Value>
<a:Comment>Query to reverse privileges</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o282">
<a:Name>AfterCreate</a:Name>
<a:TextTargetItem.Value>[use %DATABASE%]</a:TextTargetItem.Value>
<a:Comment>Commands executed after create statement</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o283">
<a:Name>BeforeCreate</a:Name>
<a:TextTargetItem.Value>[%DATABASE% ?use master]</a:TextTargetItem.Value>
<a:Comment>Commands executed before create statement</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o284">
<a:Name>Privilege</a:Name>
<a:Comment>Manages the system privileges for a user, role or group</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o285">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>grant %PRIVLIST% to %USER%</a:TextTargetItem.Value>
<a:Comment>Command for granting privileges.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o286">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>revoke %REVPRIVLIST% from %USER%</a:TextTargetItem.Value>
<a:Comment>Command for revoking privileges.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o287">
<a:Name>System</a:Name>
<a:TextTargetItem.Value>CREATE DATABASE
CREATE DEFAULT
CREATE PROCEDURE
CREATE TRIGGER
CREATE RULE
CREATE TABLE
CREATE VIEW</a:TextTargetItem.Value>
<a:Comment>List of system privileges</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o288">
<a:Name>RevokeInherited</a:Name>
<a:Comment>Allows to revoke an inherited privilege from a group or a role.</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o289">
<a:Name>Permission</a:Name>
<a:Code>PERM</a:Code>
<a:Comment>Manages the permissions on database objects</a:Comment>
<c:Categories>
<o:TextTargetItem Id="o290">
<a:Name>Create</a:Name>
<a:TextTargetItem.Value>grant %PERMLIST% on [%QUALIFIER%]%OBJECT% to %GRANTEE% [%GRANTOPTION%]</a:TextTargetItem.Value>
<a:Comment>Command for granting permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o291">
<a:Name>Drop</a:Name>
<a:TextTargetItem.Value>revoke %REVPERMLIST% on [%QUALIFIER%]%OBJECT% from %GRANTEE% [%REVOKEOPTION%]</a:TextTargetItem.Value>
<a:Comment>Command for revoking permissions.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o292">
<a:Name>GrantOption</a:Name>
<a:TextTargetItem.Value>with grant option</a:TextTargetItem.Value>
<a:Comment>Option for the grant statement.</a:Comment>
</o:TextTargetItem>
<o:TextTargetItem Id="o293">
<a:Name>RevokeOption</a:Name>
<a:TextTargetItem.Value>cascade</a:TextTargetItem.Value>
<a:Comment>Option for the revoke statement.</a:Comment>
</o:TextTargetItem>
<o:BooleanTargetItem Id="o294">
<a:Name>RevokeInherited</a:Name>
<a:Comment>Allow to revoke an inherited permission from a group or a role.</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o295">
<a:Name>DataType</a:Name>
<a:Comment>Contains data type translation entries. These entries list the correspondence between internal data types and the target database data types</a:Comment>
<c:Categories>
<o:MapTargetItem Id="o296">
<a:Name>AmcdDataType</a:Name>
<a:Comment>Data types translation table from internal data types to target database data types.
        %n is the length of the data type
        %s is the size of the data type
        %p is the precision of the data type</a:Comment>
<a:MapTargetItem.Value>&lt;UNDEF&gt;=&lt;Undefined&gt;
A%n=char(%n)
VA%n=varchar(%n)
LA=varchar(1)
LA%n=varchar(%n)
LVA=text
LVA%n=text
BT=tinyint
BT%n=tinyint
SI=smallint
I=int
LI=int
N=numeric
N%n=numeric(%n)
N%s,%p=numeric(%s,%p)
DC=decimal
DC%n=decimal(%n)
DC%s,%p=decimal(%s,%p)
SF=real
F=float
F%n=float(%n)
LF=double precision
MN=money
MN%n=money
MN%s,%p=money
D=date
T=time
DT=datetime
TS=timestamp
BL=bit
NO=numeric
NO%n=numeric(%n)
BIN%n=binary(%n)
LBIN=image
LBIN%n=image
TXT=text
TXT%n=text
MBT=nchar(1)
MBT%n=nchar(%n)
VMBT=nvarchar(255)
VMBT%n=nvarchar(%n)
PIC=image
PIC%n=image
BMP=image
BMP%n=image
OLE=image
OLE%n=image
*=char(10)</a:MapTargetItem.Value>
<a:List>&lt;UNDEF&gt;
A%n
VA%n
LA
LA%n
LVA
LVA%n
BT
BT%n
SI
I
LI
N
N%n
N%s,%p
DC
DC%n
DC%s,%p
SF
F
F%n
LF
MN
MN%n
MN%s,%p
D
T
DT
TS
BL
NO
NO%n
BIN%n
LBIN
LBIN%n
TXT
TXT%n
MBT
MBT%n
VMBT
VMBT%n
PIC
PIC%n
BMP
BMP%n
OLE
OLE%n
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o297">
<a:Name>PhysDataType</a:Name>
<a:Comment>Data types translation table from target database data types to internal data types.</a:Comment>
<a:MapTargetItem.Value>&lt;Undefined&gt;=&lt;UNDEF&gt;
char(%n)=A%n
nchar(%n)=MBT%n
unichar=MBT
unichar(%n)=MBT%n
varchar(%n)=VA%n
nvarchar(%n)=VMBT%n
univarchar=VMBT
univarchar(%n)=VMBT%n
sysname=VA30
longsysname=VA255
tinyint=BT
smallint=SI
int=I
integer=I
numeric=N
numeric(%n)=N%n
numeric(%s,%p)=N%s,%p
dec=DC
dec(%n)=DC%n
dec(%s,%p)=DC%s,%p
decimal=DC
decimal(%n)=DC%n
decimal(%s,%p)=DC%s,%p
real=SF
float=F
float(%n)=F%n
double precision=LF
smallmoney=MN
money=MN
smalldatetime=DT
datetime=DT
timestamp=TS
date=D
time=T
bit=BL
binary(%n)=BIN%n
varbinary(%n)=BIN%n
text=TXT
image=PIC
xml=LVA
*=A10</a:MapTargetItem.Value>
<a:List>&lt;Undefined&gt;
char(%n)
nchar(%n)
unichar
unichar(%n)
varchar(%n)
nvarchar(%n)
univarchar
univarchar(%n)
sysname
longsysname
tinyint
smallint
int
integer
numeric
numeric(%n)
numeric(%s,%p)
dec
dec(%n)
dec(%s,%p)
decimal
decimal(%n)
decimal(%s,%p)
real
float
float(%n)
double precision
smallmoney
money
smalldatetime
datetime
timestamp
date
time
bit
binary(%n)
varbinary(%n)
text
image
xml
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o298">
<a:Name>PhysDttpSize</a:Name>
<a:Comment>Table of storage sizes of target database data type</a:Comment>
<a:MapTargetItem.Value>smallmoney=8
smalldatetime=4
datetime=8
timestamp=8</a:MapTargetItem.Value>
<a:List>smallmoney
smalldatetime
datetime
timestamp
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o299">
<a:Name>PhysOdbcDataType</a:Name>
<a:Comment>Data types translation table from target database data types to ODBC data types.</a:Comment>
<a:MapTargetItem.Value>integer=int
dec=decimal
dec(%n)=decimal(%n)
dec(%s,%p)=decimal(%s,%p)
double precision=float
float(1)=float(4)
float(2)=float(4)
float(3)=float(4)
float(4)=float(4)
float(5)=float(4)
float(6)=float(4)
float(7)=float(4)
float(8)=float(4)
float(9)=float(4)
float(10)=float(4)
float(11)=float(4)
float(12)=float(4)
float(13)=float(4)
float(14)=float(4)
float(15)=float(4)
float(16)=float
float(17)=float
float(18)=float
float(19)=float
float(20)=float
float(21)=float
float(22)=float
float(23)=float
float(24)=float
float(25)=float
float(26)=float
float(27)=float
float(28)=float
float(29)=float
float(30)=float
float(31)=float
float(32)=float
decimal=decimal(18)
numeric=numeric(18)</a:MapTargetItem.Value>
<a:List>integer
dec
dec(%n)
dec(%s,%p)
double precision
float(1)
float(2)
float(3)
float(4)
float(5)
float(6)
float(7)
float(8)
float(9)
float(10)
float(11)
float(12)
float(13)
float(14)
float(15)
float(16)
float(17)
float(18)
float(19)
float(20)
float(21)
float(22)
float(23)
float(24)
float(25)
float(26)
float(27)
float(28)
float(29)
float(30)
float(31)
float(32)
decimal
numeric
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o300">
<a:Name>OdbcPhysDataType</a:Name>
<a:Comment>Data types translation table from ODBC data types to target database data types.</a:Comment>
<a:MapTargetItem.Value>float(8)=float
float(4)=float(15)
longsysname(255, -1)=longsysname</a:MapTargetItem.Value>
<a:List>float(8)
float(4)
longsysname(255, -1)
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o301">
<a:Name>LogPhysADTType</a:Name>
<a:Comment>Abstract Data types translation table from internal abstract data types to target database abstract data types.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:MapTargetItem.Value>Array=&lt;Undefined&gt;
Java=Java
List=&lt;Undefined&gt;
Structured=&lt;Undefined&gt;
Object=&lt;Undefined&gt;</a:MapTargetItem.Value>
<a:List>Array
Java
List
Structured
Object
</a:List>
</o:MapTargetItem>
<o:MapTargetItem Id="o302">
<a:Name>PhysLogADTType</a:Name>
<a:Comment>Abstract Data types translation table from target database abstract data types to internal abstract data types.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:MapTargetItem.Value>Java=Java</a:MapTargetItem.Value>
<a:List>Java
</a:List>
</o:MapTargetItem>
<o:TextTargetItem Id="o303">
<a:Name>AllowedADT</a:Name>
<a:TextTargetItem.Value>Java</a:TextTargetItem.Value>
<a:Comment>The list of ADT which can be used as the datatype of a domain or column</a:Comment>
</o:TextTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:TargetCategory Id="o304">
<a:Name>Odbc</a:Name>
<a:Comment>DBMS characteristics, command definition, and data type translations for the ODBC generation and reverse engineering</a:Comment>
<c:Categories>
<o:TargetCategory Id="o305">
<a:Name>Objects</a:Name>
<a:Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:Comment>
<c:Categories>
<o:TargetCategory Id="o306">
<a:Name>Qualifier</a:Name>
<a:Comment>Manages the use of qualifier in ODBC reverse engineering</a:Comment>
<c:Categories>
<o:BooleanTargetItem Id="o307">
<a:Name>Enable</a:Name>
<a:Comment>Allows using the qualifier combo box during ODBC reverse engineering</a:Comment>
<a:Value>1</a:Value>
</o:BooleanTargetItem>
<o:TextTargetItem Id="o308">
<a:Name>SqlListQuery</a:Name>
<a:TextTargetItem.Value>select name from master.dbo.sysdatabases
where 1=1
[and name = %.q:CATALOG%]</a:TextTargetItem.Value>
<a:Comment>Query to retrieve qualifier during ODBC reverse engineering</a:Comment>
</o:TextTargetItem>
<o:StringTargetItem Id="o309">
<a:Name>Label</a:Name>
<a:Comment>Label for &lt;All&gt; in qualifier selection list</a:Comment>
<a:StringTargetItem.Value>Default database</a:StringTargetItem.Value>
</o:StringTargetItem>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
</c:Categories>
</o:TargetCategory>
<o:ProfileTargetItem Id="o310">
<a:Name>Profile</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:MetaClassTargetItem Id="o311">
<a:Name>Table</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o312">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o313">
<a:Name>Table Timestamp Uniqueness</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that a table has no more than one timestamp column.</a:HelpMessage>
<a:OutputMessage>The following tables have more than one timestamp column:</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   dim pCol, bTSFound
   bTSFound = false
   for each pCol in obj.Columns
      if GetDatatypeName(pCol.datatype) = &quot;timestamp&quot; then
         if (bTSFound) then
            %Check% = false
            exit function
         end if
         bTSFound = true
      end if
   next
   %Check% = True
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o314">
<a:TypePublicName>MethodTargetItem</a:TypePublicName>
<a:Name>Methods</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:MethodTargetItem Id="o315">
<a:Name>CreateViews</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:MethodScript>Sub %Method%(tab)
   CreatePartitionViews tab, ActiveDiagram
End Sub</a:MethodScript>
</o:MethodTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o316">
<a:TypePublicName>MenuTargetItem</a:TypePublicName>
<a:Name>Menus</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:MenuTargetItem Id="o317">
<a:Name>Menu_1</a:Name>
<a:MenuTargetItem.Value>&lt;Menu&gt;
   &lt;Command Name=&quot;CreateViews&quot; Caption=&quot;Create Partition Views&quot; /&gt;
&lt;/Menu&gt;
</a:MenuTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:MenuTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o318">
<a:Name>Index</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o319">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o320">
<a:Name>Index Column Length</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that total index column length is lower than 600 bytes.</a:HelpMessage>
<a:OutputMessage>The following indexes have column length higher than 600 bytes.</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   dim nLen, pICol
   nLen = 0
   for each pICol in obj.IndexColumns
      if (pICol.Expression = &quot;&quot;) then
         nLen = nLen + ColumnLength(pICol.Column)
      end if
   next
   if (nLen &gt; 600) then
      %Check% = false
   else
      %Check% = True
   end if
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
<o:CustomCheckTargetItem Id="o321">
<a:Name>Index Restricted Datatype</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that index columns have an supported datatype.</a:HelpMessage>
<a:OutputMessage>The following indexes have column with unsupported datatype.</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   dim pICol, sType
   for each pICol in obj.IndexColumns
      if (pICol.Expression = &quot;&quot;) then
         sType = GetDatatypeName(pICol.Column.Datatype)
         if (sType = &quot;bit&quot; or sType = &quot;image&quot; or sType = &quot;text&quot;) then
            %Check% = false
            exit function
         end if
      end if
   next
   %Check% = true
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
<o:CustomCheckTargetItem Id="o322">
<a:Name>Index Physical Options</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>Checking that index physical options are correct.</a:HelpMessage>
<a:OutputMessage>The following index physical options are erroneously defined (see Script output page for details):</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   dim sOpts, sItem, nItem
   sOpts = lcase(obj.PhysicalOptions)
   sOpts = replace(sOpts, &quot; =&quot;, &quot;=&quot;)
   sOpts = replace(sOpts, &quot;= &quot;, &quot;=&quot;)
   &#39; check fillfactor is between 0 and 100
   nItem = GetOptsItemNumValue(sOpts, &quot;fillfactor=&quot;)
   if (nItem &lt; 0) or (nItem &gt; 100) then &#39; NULL is not compared
      output &quot;index &quot; &amp; obj.Name &amp; &quot; (&quot; &amp; obj.Code &amp; &quot;) of table &quot; &amp; obj.Table.Name &amp; &quot; (&quot; &amp; obj.Table.Code &amp; &quot;)&quot;
      output &quot;   fillfactor option must have a value between 0 and 100&quot;
      %Check% = false
      exit function
   end if
   &#39; check max_rows_per_page is between 0 and 256
   nItem = GetOptsItemNumValue(sOpts, &quot;max_rows_per_page=&quot;)
   if (nItem &lt; 0) or (nItem &gt; 256) then &#39; NULL is not compared
      output &quot;index &quot; &amp; obj.Name &amp; &quot; (&quot; &amp; obj.Code &amp; &quot;) of table &quot; &amp; obj.Table.Name &amp; &quot; (&quot; &amp; obj.Table.Code &amp; &quot;)&quot;
      output &quot;   max_rows_per_page option must have a value between 0 and 256&quot;
      %Check% = false
      exit function
   end if
   &#39; check reservepagegap is between 0 and 255
   nItem = GetOptsItemNumValue(sOpts, &quot;reservepagegap=&quot;)
   if (nItem &lt; 0) or (nItem &gt; 255) then &#39; NULL is not compared
      output &quot;index &quot; &amp; obj.Name &amp; &quot; (&quot; &amp; obj.Code &amp; &quot;) of table &quot; &amp; obj.Table.Name &amp; &quot; (&quot; &amp; obj.Table.Code &amp; &quot;)&quot;
      output &quot;   reservepagegap option must have a value between 0 and 255&quot;
      %Check% = false
      exit function
   end if
   &#39; check allow_dup_row is on clustered index
   if (instr(sOpts, &quot;allow_dup_row&quot;) &gt; 0) and not (obj.Clustered) then
      output &quot;index &quot; &amp; obj.Name &amp; &quot; (&quot; &amp; obj.Code &amp; &quot;) of table &quot; &amp; obj.Table.Name &amp; &quot; (&quot; &amp; obj.Table.Code &amp; &quot;)&quot;
      output &quot;   allow_dup_row option can only be set on clustered index&quot;
      %Check% = false
      exit function
   end if
   &#39; check ignore_dup_row is on clustered or unique index
   if (instr(sOpts, &quot;ignore_dup_row&quot;) &gt; 0) and not (obj.Clustered or obj.Unique) then
      output &quot;index &quot; &amp; obj.Name &amp; &quot; (&quot; &amp; obj.Code &amp; &quot;) of table &quot; &amp; obj.Table.Name &amp; &quot; (&quot; &amp; obj.Table.Code &amp; &quot;)&quot;
      output &quot;   ignore_dup_row option can only be set on clustered or unique index&quot;
      %Check% = false
      exit function
   end if
   &#39; check ignore_dup_key is on unique index
   if (instr(sOpts, &quot;ignore_dup_key&quot;) &gt; 0) and not (obj.Unique) then
      output &quot;index &quot; &amp; obj.Name &amp; &quot; (&quot; &amp; obj.Code &amp; &quot;) of table &quot; &amp; obj.Table.Name &amp; &quot; (&quot; &amp; obj.Table.Code &amp; &quot;)&quot;
      output &quot;   ignore_dup_key option can only be set on unique index&quot;
      %Check% = false
      exit function
   end if
   %Check% = True
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o323">
<a:Name>Column</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o324">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o325">
<a:ObjectID>DCC90448-4FC9-48C5-93A8-AB6E049C90BC</a:ObjectID>
<a:Name>InRow</a:Name>
<a:Comment>Specifies whether a Java-SQL column is stored separate from the row (off row) or in storage allocated directly in the row (in row).
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.Value>false</a:ExtendedAttributeTargetItem.Value>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o326">
<a:TypePublicName>CriterionTargetItem</a:TypePublicName>
<a:Name>Criteria</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CriterionTargetItem Id="o327">
<a:Name>IsComputed</a:Name>
<a:CriterionTargetItem.Value>%Computed%</a:CriterionTargetItem.Value>
<a:Comment>Return TRUE if the column is computed.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o328">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o329">
<a:ObjectID>CC032CDC-808F-48C5-B4F9-B3FDAD25ABB2</a:ObjectID>
<a:Name>Materialized</a:Name>
<a:Comment>Specifies if a computed column is materialized.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.Value>false</a:ExtendedAttributeTargetItem.Value>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:CriterionTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o330">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o331">
<a:Name>Sybase</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Attribute=&quot;InRow&quot; AttributeID=&quot;{DCC90448-4FC9-48C5-93A8-AB6E049C90BC}&quot; Name=&quot;InRow&quot; Caption=&quot;Store Java-SQL column in row&quot; GrayHiddenAttributes=&quot;No&quot; /&gt;
   &lt;ExtendedAttribute Attribute=&quot;Materialized&quot; AttributeID=&quot;{CC032CDC-808F-48C5-B4F9-B3FDAD25ABB2}&quot; Name=&quot;Materialized computed column&quot; Caption=&quot;Computed column is materialized&quot; GrayHiddenAttributes=&quot;No&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o332">
<a:Name>Key</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o333">
<a:TypePublicName>ExtendedAttributeTargetItem</a:TypePublicName>
<a:Name>Extended Attributes</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:ExtendedAttributeTargetItem Id="o334">
<a:ObjectID>1A302BFE-D92A-48AE-9AA4-B317E83647DA</a:ObjectID>
<a:Name>DescKey</a:Name>
<a:Comment>Specifies if the index created for a constraint is to be created in descending order for each column.
</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:ExtendedAttributeTargetItem.Value>false</a:ExtendedAttributeTargetItem.Value>
</o:ExtendedAttributeTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o335">
<a:TypePublicName>FormTargetItem</a:TypePublicName>
<a:Name>Forms</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:FormTargetItem Id="o336">
<a:Name>Sybase</a:Name>
<a:FormTargetItem.Value>&lt;Form  &gt;
   &lt;ExtendedAttribute Name=&quot;DescKey&quot; Caption=&quot;Key index is descending&quot; Attribute=&quot;DescKey&quot; AttributeID=&quot;{1A302BFE-D92A-48AE-9AA4-B317E83647DA}&quot; GrayHiddenAttributes=&quot;Yes&quot; /&gt;
&lt;/Form&gt;
</a:FormTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:FormTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:TargetCategory Id="o337">
<a:Name>Shared</a:Name>
<a:Code>Shared</a:Code>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
</o:TargetCategory>
<o:MetaClassTargetItem Id="o338">
<a:Name>User</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o339">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o340">
<a:Name>User can belong to only one group</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that each user does not belong to more than one group.</a:HelpMessage>
<a:OutputMessage>The following users belong to several groups:</a:OutputMessage>
<a:CheckScript>&#39; To check user Group Uniqueness we must take into account
&#39; the implicit PUBLIC group.
Function %Check%(obj)
   if (obj.Groups.Count &gt; 2) then
      %Check% = False
      exit function
   end if
   %Check% = True
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o341">
<a:Name>PhysicalDomain</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o342">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o343">
<a:Name>Domain missing default object</a:Name>
<a:Comment>In the SQL SERVER family, you set a default value to a domain using a default object. This check ensures that all domains with a default use a default object.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>A domain cannot have a default value without being attached to a default object. You can either create a default object for the value and run the autofix on the domain or use the Rebuild Default feature.</a:HelpMessage>
<a:OutputMessage>The following domain must be linked to a default object:</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   if (obj.default is Nothing) then &#39;        not an object
      if CStr(obj.defaultvalue) &lt;&gt; &quot;&quot; then &#39; but not empty!
         %Check% = false
         exit function
      end if
   end if
   %Check% = True
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   if (obj.default is Nothing) then &#39;        not an object
      if CStr(obj.defaultvalue) &lt;&gt; &quot;&quot; then &#39; but not empty !!
         dim pDefault, sDefault
         set pDefault = ActiveModel.CreateObject(cls_PhysicalDefault)
         sDefault = replace(Cstr(obj.DefaultValue), &quot;&#39;&quot;, &quot;&quot;)
         If (CanSetNameCode(pDefault, &quot;D_&quot; &amp; sDefault, &quot;D_&quot; &amp; sDefault)) Then
            pDefault.Name = &quot;D_&quot; &amp; sDefault
            pDefault.Code = &quot;D_&quot; &amp; sDefault
         ElseIf (CanSetNameCode(pDefault, &quot;D_&quot; &amp; Cstr(obj.Name), &quot;D_&quot; &amp; Cstr(obj.Code))) Then
            pDefault.Name = &quot;D_&quot; &amp; Cstr(obj.Name)
            pDefault.Code = &quot;D_&quot; &amp; Cstr(obj.Code)
         Else
            Dim i
            i = 1
            While not (CanSetNameCode(pDefault, &quot;D_&quot; &amp; Cstr(obj.Name) &amp; &quot;_&quot; &amp; CStr(i), &quot;D_&quot; &amp; Cstr(obj.Code) &amp; &quot;_&quot; &amp; CStr(i)))
               i = i + 1
            Wend
            pDefault.Name = &quot;D_&quot; &amp; Cstr(obj.Name) &amp; &quot;_&quot; &amp; CStr(i)
            pDefault.Code = &quot;D_&quot; &amp; Cstr(obj.Code) &amp; &quot;_&quot; &amp; CStr(i)
         End If         
         pDefault.Value = obj.DefaultValue
         Set obj.Default = pDefault
         %Fix% = True
         outmsg = &quot;Default &quot; &amp; pDefault.Name &amp; &quot; created and attached to domain &quot; &amp; obj.Name
         Exit Function
      end if
   end if
   outmsg = &quot;Unknown Error occurs, autofix failed&quot;
   %Fix% = False
End Function
</a:AutoFixScrpt>
<a:EnableAutoFix>1</a:EnableAutoFix>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o344">
<a:Name>Storage</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o345">
<a:TypePublicName>CustomCheckTargetItem</a:TypePublicName>
<a:Name>Custom Checks</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:CustomCheckTargetItem Id="o346">
<a:Name>Empty Device Name</a:Name>
<a:Comment>The device name defined in the physical options is mandatory for the sp_addsegment procedure.</a:Comment>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:HelpMessage>This check ensures that a device name has been defined in the physical options of the segment (storage).</a:HelpMessage>
<a:OutputMessage>The following segments do not have device:</a:OutputMessage>
<a:CheckScript>Function %Check%(obj)
   if not (obj is nothing) then
      if (obj.PhysicalOptions = &quot;&quot;) or (left(obj.PhysicalOptions, 1) = &quot;?&quot;) then
         %Check% = false
         exit function
      end if
   end if
   %Check% = True
End Function</a:CheckScript>
<a:AutoFixScrpt>Function %Fix%(obj, outmsg)
   &#39; Implement your automatic correction on &lt;obj&gt; here
   &#39; filling &lt;outmsg&gt; as you wish
   &#39; and return True if successful.

   outmsg = &quot;Automatic correction not implemented&quot;

   %Fix% = False
End Function</a:AutoFixScrpt>
</o:CustomCheckTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
<o:MetaClassTargetItem Id="o347">
<a:Name>Model</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:TypedCategoryTargetItem Id="o348">
<a:TypePublicName>MethodTargetItem</a:TypePublicName>
<a:Name>Methods</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:MethodTargetItem Id="o349">
<a:Name>CreateViews</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:MethodScript>Sub %Method%(model)
   If (ActiveSelection.Count &gt; 0) Then
      Dim tab
      For Each tab in ActiveSelection
         If tab.ObjectType = &quot;Table&quot; Then
            CreatePartitionViews tab, ActiveDiagram
         End If
      Next
   Else
      MsgBox &quot;To create partition views, you need to graphically select the tables you want first.&quot;, vbOKOnly, &quot;Errro&quot;   
   End If      
End Sub</a:MethodScript>
</o:MethodTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
<o:TypedCategoryTargetItem Id="o350">
<a:TypePublicName>MenuTargetItem</a:TypePublicName>
<a:Name>Menus</a:Name>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<c:Categories>
<o:MenuTargetItem Id="o351">
<a:Name>Menu_1</a:Name>
<a:MenuTargetItem.Value>&lt;Menu&gt;
   &lt;Command Name=&quot;CreateViews&quot; Caption=&quot;Create Partition Views&quot; /&gt;
&lt;/Menu&gt;
</a:MenuTargetItem.Value>
<a:TargetCategory.Type>1</a:TargetCategory.Type>
<a:MenuTargetItem.Location>Tools</a:MenuTargetItem.Location>
</o:MenuTargetItem>
</c:Categories>
</o:TypedCategoryTargetItem>
</c:Categories>
</o:MetaClassTargetItem>
</c:Categories>
</o:ProfileTargetItem>
</c:Categories>
<c:TriggerItems>
<o:TriggerItem Id="o352">
<a:ObjectID>433769A9-07B7-43D1-B576-D5666F7F9BC0</a:ObjectID>
<a:Name>InsertChildParentExist</a:Name>
<a:Code>InsertChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKNOTNULL&quot;)
/*  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when inserting a child in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   if (select count(*)
       from   [%PQUALIFIER%]%PARENT% t1, inserted t2
       where  .JOIN(&quot;t1.%PK% = t2.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;) != @numrows&quot;)
      .ERROR(30002, &quot;Parent does not exist in &quot;[%PQUALIFIER%]%PARENT%&quot;. Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end
.ENDFOR
.FOREACH_PARENT(&quot;FKNULL&quot;)
/*  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when inserting a child in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   select @numnull = (select count(*)
                      from   inserted
                      where  .JOIN(&quot;%FK% is null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)&quot;)
   if @numnull != @numrows
   begin
      if (select count(*)
         from   [%PQUALIFIER%]%PARENT% t1, inserted t2
         where  .JOIN(&quot;t1.%PK% = t2.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;) != @numrows - @numnull&quot;)
         .ERROR(30002, &quot;Parent does not exist in &quot;[%PQUALIFIER%]%PARENT%&quot;. Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
   end
end
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Parent must exist when inserting child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o353">
<a:ObjectID>7C4ADE0B-4581-4AD6-B513-BC69F768A7BB</a:ObjectID>
<a:Name>InsertTooManyChildren</a:Name>
<a:Code>InsertTooManyChildren</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
/*  The cardinality of Parent &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; cannot exceed %MAXCARD% */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   select @maxcard = (select count(*)
      from   [%CQUALIFIER%]%CHILD% old
      where .JOIN(&quot;ins.%FK% = old.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)&quot;)
   from  inserted ins
   where .JOIN(&quot;ins.%FK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;&quot;)
   group by .JOIN(&quot;ins.%FK%&quot;, &quot;, &quot;, &quot;&quot;, &quot;&quot;)
   order by 1
   if @maxcard &gt; %MAXCARD%
   .ERROR(30007, &quot;The maximum cardinality of a child has been exceeded! Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot exceed the maximum cardinality constraint when inserting the child</a:Comment>
<a:Declaration>@maxcard  int,
.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o354">
<a:ObjectID>FE1FC79C-32CB-444D-906E-473358466B22</a:ObjectID>
<a:Name>UpdateChangeColumn</a:Name>
<a:Code>UpdateChangeColumn</a:Code>
<a:Text>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
/*  Non modifiable column &quot;%COLUMN%&quot; cannot be modified  */
if update(%COLUMN%)
   if exists (select 1
              from   inserted i, deleted d
              where  i.%COLUMN% != d.%COLUMN%)
      .ERROR(30001, &quot;Non modifiable column &quot;%COLUMN%&quot; cannot be modified.&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot modify non modifiable column constraint</a:Comment>
<a:Declaration>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o355">
<a:ObjectID>44746857-67D8-45A4-9F34-6F57C12D1924</a:ObjectID>
<a:Name>UpdateChildParentExist</a:Name>
<a:Code>UpdateChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKNOTNULL&quot;)
/*  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when updating a child in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   if (select count(*)
       from   [%PQUALIFIER%]%PARENT% t1, inserted t2
       where  .JOIN(&quot;t1.%PK% = t2.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;) != @numrows&quot;)
      .ERROR(30003, &quot;&quot;[%PQUALIFIER%]%PARENT%&quot; does not exist. Cannot modify child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end
.ENDFOR
.FOREACH_PARENT(&quot;FKNULL&quot;)
/*  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when updating a child in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   select @numnull = (select count(*)
                      from   inserted
                      where  .JOIN(&quot;%FK% is null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)&quot;)
   if @numnull != @numrows
      if (select count(*)
          from   [%PQUALIFIER%]%PARENT% t1, inserted t2
          where  .JOIN(&quot;t1.%PK% = t2.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;) != @numrows - @numnull&quot;)
      .ERROR(30003, &quot;&quot;[%PQUALIFIER%]%PARENT%&quot; does not exist. Cannot modify child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Parent must exist when updating a child constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT()
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o356">
<a:ObjectID>42E84812-AB04-435C-862E-7097AE486DDE</a:ObjectID>
<a:Name>UpdateTooManyChildren</a:Name>
<a:Code>UpdateTooManyChildren</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
/*  The cardinality of Parent &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot; cannot exceed %MAXCARD% */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   select @maxcard = (select count(*)
      from   [%CQUALIFIER%]%CHILD% old
      where .JOIN(&quot;ins.%FK% = old.%FK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)&quot;)
   from  inserted ins
   where .JOIN(&quot;ins.%FK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;&quot;)
   group by .JOIN(&quot;ins.%FK%&quot;, &quot;, &quot;, &quot;&quot;, &quot;&quot;)
   order by 1
   if @maxcard &gt; %MAXCARD%
   .ERROR(30007, &quot;The maximum cardinality of a child has been exceeded! Cannot modify child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end
.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot exceed the maximum cardinality constraint when updating the child</a:Comment>
<a:Declaration>@maxcard  int,
.FOREACH_PARENT(&quot;FKMAXCARD&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o357">
<a:ObjectID>69BFB682-5318-4208-851C-82D4641E7D57</a:ObjectID>
<a:Name>UpdateChildChangeParent</a:Name>
<a:Code>UpdateChildChangeParent</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
/*  Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .JOIN(&quot;update(%FK%)&quot;, &quot;&quot;, &quot; or&quot;)
   if exists (select 1
              from   inserted i, deleted d
              where  .JOIN(&quot;i.%FK% != d.%FK%&quot;, &quot;&quot;, &quot; or  &quot;, &quot;)&quot;)
      .ERROR(30004, &quot;Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Cannot change parent constraint</a:Comment>
<a:Declaration>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o358">
<a:ObjectID>391D2BC1-513A-48D8-9434-8798297D8AB1</a:ObjectID>
<a:Name>UpdateParentRestrict</a:Name>
<a:Code>UpdateParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
/*  Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .PKCOLN(&quot;update(%COLUMN%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   if exists (select 1
              from   [%CQUALIFIER%]%CHILD% t2, inserted i1, deleted d1
              where  .JOIN(&quot;t2.%FK% = d1.%PK%&quot;, &quot;and   &quot;)
               and  (.JOIN(&quot;i1.%PK% != d1.%PK%&quot;, &quot;or   &quot;, &quot;&quot;, &quot;))&quot;)
      .ERROR(30005, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)
end

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o359">
<a:ObjectID>27AA8AC5-BC7F-4239-8848-B10C8853A617</a:ObjectID>
<a:Name>UpdateParentCascade</a:Name>
<a:Code>UpdateParentCascade</a:Code>
<a:Text>declare cIns cursor for select 
      .PKCOLN(&quot;%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;) 
   from inserted
declare cDel cursor for select 
      .PKCOLN(&quot;%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;) 
   from deleted

.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
/*  Modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; for all children in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .PKCOLN(&quot;update(%COLUMN%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   if @@rowcount = 1
      update [%CQUALIFIER%]%CHILD%
         set   .JOIN(&quot;%FK% = i1.%PK%&quot;, &quot;&quot;, &quot;,&quot;)
      from   [%CQUALIFIER%]%CHILD% t2, inserted i1, deleted d1
         where  .JOIN(&quot;t2.%FK% = d1.%PK%&quot;, &quot;and   &quot;)
          and  (.JOIN(&quot;i1.%PK% != d1.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;)&quot;)
   else
   begin
      open cIns
      open cDel
      fetch cIns into .PKCOLN(&quot;@ins_%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;) 
      fetch cDel into .PKCOLN(&quot;@del_%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;) 

      while (@@sqlstatus = 0)
      begin
         update [%CQUALIFIER%]%CHILD%
            set   .JOIN(&quot;%FK% = @ins_%PK%&quot;, &quot;&quot;, &quot;,&quot;)
         where  .JOIN(&quot;%FK% = @del_%PK%&quot;, &quot;and   &quot;)
         fetch cIns into .PKCOLN(&quot;@ins_%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;) 
         fetch cDel into .PKCOLN(&quot;@del_%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;) 
      end
      close cIns
      close cDel
   end
end
.ENDFOR
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>1081437474</a:ModificationDate>
<a:Modifier>mledier</a:Modifier>
<a:Comment>Update cascade constraint</a:Comment>
<a:Declaration>.PKCOLN(&quot;@ins_%COLUMN% %DATATYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;,&quot;)
.PKCOLN(&quot;@del_%COLUMN% %DATATYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;,&quot;)</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o360">
<a:ObjectID>596A4614-62BE-43D6-A24C-FD76D691296F</a:ObjectID>
<a:Name>UpdateParentSetNull</a:Name>
<a:Code>UpdateParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .PKCOLN(&quot;update(%COLUMN%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
   from   [%CQUALIFIER%]%CHILD% t2, inserted i1, deleted d1
   where  .JOIN(&quot;t2.%FK% = d1.%PK%&quot;, &quot;and   &quot;)
    and  (.JOIN(&quot;i1.%PK% != d1.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;)&quot;)
end

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Set parent code to null in child</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o361">
<a:ObjectID>4B60E998-B581-4B07-B4A2-CD7CEA5B5F34</a:ObjectID>
<a:Name>UpdateParentSetDefault</a:Name>
<a:Code>UpdateParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot;
.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if .PKCOLN(&quot;update(%COLUMN%)&quot;, &quot;&quot;, &quot; or&quot;)
begin
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
   from   [%CQUALIFIER%]%CHILD% t2, inserted i1, deleted d1
   where  .JOIN(&quot;t2.%FK% = d1.%PK%&quot;, &quot;and   &quot;)
    and  (.JOIN(&quot;i1.%PK% != d1.%PK%&quot;, &quot;&quot;, &quot; or&quot;, &quot;)&quot;)
end

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Set parent code to default in child</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o362">
<a:ObjectID>A1634DDD-C947-4CAE-A9D0-ECE1AED4FBCC</a:ObjectID>
<a:Name>DeleteParentRestrict</a:Name>
<a:Code>DeleteParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
/*  Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
if exists (select 1
           from   [%CQUALIFIER%]%CHILD% t2, deleted t1
           where  .JOIN(&quot;t2.%FK% = t1.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;)&quot;)
   .ERROR(30006, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete restrict constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o363">
<a:ObjectID>3F6E50CC-B998-4F8D-B8DD-1BC2A5660E93</a:ObjectID>
<a:Name>DeleteParentCascade</a:Name>
<a:Code>DeleteParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
/*  Delete all children in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
delete [%CQUALIFIER%]%CHILD%
from   [%CQUALIFIER%]%CHILD% t2, deleted t1
where  .JOIN(&quot;t2.%FK% = t1.%PK%&quot;, &quot;and   &quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete cascade constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o364">
<a:ObjectID>B890E788-9185-46A7-A5E8-2555C318B431</a:ObjectID>
<a:Name>DeleteParentSetNull</a:Name>
<a:Code>DeleteParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in child &quot;[%CQUALIFIER%]%CHILD%&quot;  */
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
from   [%CQUALIFIER%]%CHILD% t2, deleted t1
where  .JOIN(&quot;t2.%FK% = t1.%PK%&quot;, &quot;and   &quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete set null constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
<o:TriggerItem Id="o365">
<a:ObjectID>151FF80D-48AB-4870-84E3-B8A2EF4807DE</a:ObjectID>
<a:Name>DeleteParentSetDefault</a:Name>
<a:Code>DeleteParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot;
.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
/*  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;  */
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
from   [%CQUALIFIER%]%CHILD% t2, deleted t1
where  .JOIN(&quot;t2.%FK% = t1.%PK%&quot;, &quot;and   &quot;)

.ENDFOR</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete set default constraint</a:Comment>
<a:Declaration>.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
.ENDFOR</a:Declaration>
</o:TriggerItem>
</c:TriggerItems>
<c:TriggerTemplates>
<o:TriggerTemplate Id="o366">
<a:ObjectID>DB00CF9B-ADBB-46E5-A169-9373D0F52D2E</a:ObjectID>
<a:Name>InsertTrigger</a:Name>
<a:Code>InsertTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% on [%TABLQUALIFIER%]%TABLE% for insert as
begin
    declare
       .DeclInsertChildParentExist
       .DeclInsertTooManyChildren
       @numrows  int,
       @numnull  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    .InsertChildParentExist
    .InsertTooManyChildren

    return

/*  Errors handling  */
error:
    raiserror @errno @errmsg
    rollback  transaction
end
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Insert trigger</a:Comment>
<a:Time/>
<a:TriggerName>ti_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o352"/>
<o:TriggerItem Ref="o353"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o367">
<a:ObjectID>3EF55D7F-D657-4B25-B959-F398101177F8</a:ObjectID>
<a:Name>UpdateTrigger</a:Name>
<a:Code>UpdateTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% on [%TABLQUALIFIER%]%TABLE% for update as
begin
   declare
      .DeclUpdateChangeColumn
      .DeclUpdateChildParentExist
      .DeclUpdateTooManyChildren
      .DeclUpdateChildChangeParent
      .DeclUpdateParentRestrict
      .DeclUpdateParentCascade
      .DeclUpdateParentSetNull
      .DeclUpdateParentSetDefault
      @numrows  int,
      @numnull  int,
      @errno    int,
      @errmsg   varchar(255)

      select  @numrows = @@rowcount
      if @numrows = 0
         return

      .UpdateChangeColumn
      .UpdateChildParentExist
      .UpdateTooManyChildren
      .UpdateChildChangeParent
      .UpdateParentRestrict
      .UpdateParentCascade
      .UpdateParentSetNull
      .UpdateParentSetDefault


      return

/*  Errors handling  */
error:
    raiserror @errno @errmsg
    rollback  transaction
end
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Update trigger</a:Comment>
<a:Time/>
<a:Event>Update</a:Event>
<a:TriggerName>tu_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o354"/>
<o:TriggerItem Ref="o355"/>
<o:TriggerItem Ref="o356"/>
<o:TriggerItem Ref="o357"/>
<o:TriggerItem Ref="o358"/>
<o:TriggerItem Ref="o359"/>
<o:TriggerItem Ref="o360"/>
<o:TriggerItem Ref="o361"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
<o:TriggerTemplate Id="o368">
<a:ObjectID>011AB6C2-CBCA-41DB-91A1-CE735B55BDD9</a:ObjectID>
<a:Name>DeleteTrigger</a:Name>
<a:Code>DeleteTrigger</a:Code>
<a:Text>create trigger [%QUALIFIER%]%TRIGGER% on [%TABLQUALIFIER%]%TABLE% for delete as
begin
    declare
       .DeclDeleteParentRestrict
       .DeclDeleteParentCascade
       .DeclDeleteParentSetNull
       .DeclDeleteParentSetDefault
       @numrows  int,
       @errno    int,
       @errmsg   varchar(255)

    select  @numrows = @@rowcount
    if @numrows = 0
       return

    .DeleteParentRestrict
    .DeleteParentCascade
    .DeleteParentSetNull
    .DeleteParentSetDefault

    return

/*  Errors handling  */
error:
    raiserror @errno @errmsg
    rollback  transaction
end
</a:Text>
<a:CreationDate>0</a:CreationDate>
<a:Creator/>
<a:ModificationDate>0</a:ModificationDate>
<a:Modifier/>
<a:Comment>Delete trigger</a:Comment>
<a:Time/>
<a:Event>Delete</a:Event>
<a:TriggerName>td_%.L:TABLE%</a:TriggerName>
<c:TriggerTemplate.TriggerItems>
<o:TriggerItem Ref="o362"/>
<o:TriggerItem Ref="o363"/>
<o:TriggerItem Ref="o364"/>
<o:TriggerItem Ref="o365"/>
</c:TriggerTemplate.TriggerItems>
</o:TriggerTemplate>
</c:TriggerTemplates>
</o:DBMS>

</DBMS>