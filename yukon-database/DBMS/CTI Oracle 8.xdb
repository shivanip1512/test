<?xml version="1.0" encoding="UTF-8"?>
<?PowerDesigner Code="JUNK" Family="ORACLE" Name="JUNK" signature="XDB_XML" version="7.5.0.826"?>
<!-- please do not edit this file -->

<DBMS xmlns:a="http://www.sybase.com/products/powerdesigner/xml/attribute" xmlns:c="http://www.sybase.com/products/powerdesigner/xml/collection" xmlns:o="http://www.sybase.com/products/powerdesigner/xml/object">

<o:SPdoObjDbms Id="o1">
<a:OID>16A36BAA-DE0D-11D2-B692-0008C7EA924D</a:OID>
<a:Name>JUNK</a:Name>
<a:Code>JUNK</a:Code>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>1011986858</a:MDAT>
<a:MUSR>rneuharth</a:MUSR>
<c:Item>
<o:SObjTargetItem Id="o2">
<a:Name>General</a:Name>
<a:TRGTITEM.Comment>Target DBMS identification</a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemString Id="o3">
<a:Name>Product</a:Name>
<a:TRGTITEM.Comment>Product name. Ensures that the DBMS definition is for the product in use</a:TRGTITEM.Comment>
<a:STRINGITEM.Value>PowerDesigner</a:STRINGITEM.Value>
</o:SObjTargetItemString>
<o:SObjTargetItemString Id="o4">
<a:Name>Version</a:Name>
<a:TRGTITEM.Comment>Version number</a:TRGTITEM.Comment>
<a:STRINGITEM.Value>7.5</a:STRINGITEM.Value>
</o:SObjTargetItemString>
<o:SObjTargetItemString Id="o5">
<a:Name>DbmsFamily</a:Name>
<a:TRGTITEM.Comment>DBMS Family. DBMS that are part of the same group of DBMS. for example, Sybase includes Adaptive Server Anywhere 6 and Adaptive Server Anywhere 7
</a:TRGTITEM.Comment>
<a:STRINGITEM.Value>ORACLE</a:STRINGITEM.Value>
</o:SObjTargetItemString>
<o:SObjTargetItemBool Id="o6">
<a:Name>SqlSupport</a:Name>
<a:TRGTITEM.Comment>SQL syntax allowed. This does not affect script generation but afftect the SQL Preview</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o7">
<a:Name>EnableCheck</a:Name>
<a:TRGTITEM.Comment>Determines if the generation of check parameters is authorized or not</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o8">
<a:Name>Enableconstname</a:Name>
<a:TRGTITEM.Comment>Determines if constraint names are use during the generation</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o9">
<a:Name>UniqConstName</a:Name>
<a:TRGTITEM.Comment>Determines if unique constraint names for objects are authorized or not</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemString Id="o10">
<a:Name>USER_ROLE</a:Name>
<a:TRGTITEM.Comment>The name of the role that all generic users will use.</a:TRGTITEM.Comment>
<a:TRGTITEM.Type>1</a:TRGTITEM.Type>
<a:STRINGITEM.Value>YUKON_USER</a:STRINGITEM.Value>
</o:SObjTargetItemString>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o11">
<a:Name>Script</a:Name>
<a:TRGTITEM.Comment>DBMS characteristics, command definition, and data type translations for the Script generation and reverse engineering</a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItem Id="o12">
<a:Name>Sql</a:Name>
<a:TRGTITEM.Comment>Contains sub-categories Syntax, Format, File and Keywords. Each sub-category contains entries whose values define general syntax for the database</a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItem Id="o13">
<a:Name>Syntax</a:Name>
<a:TRGTITEM.Comment>Contains general parameters for SQL syntax</a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemChar Id="o14">
<a:Name>Terminator</a:Name>
<a:TRGTITEM.Comment>End of command character</a:TRGTITEM.Comment>
<a:CHARITEM.Value>;</a:CHARITEM.Value>
</o:SObjTargetItemChar>
<o:SObjTargetItemString Id="o15">
<a:Name>BlockTerminator</a:Name>
<a:TRGTITEM.Comment>End of block character</a:TRGTITEM.Comment>
<a:STRINGITEM.Value>/</a:STRINGITEM.Value>
</o:SObjTargetItemString>
<o:SObjTargetItemBool Id="o16">
<a:Name>UseBlockTerm</a:Name>
<a:TRGTITEM.Comment>Use end of block character by default</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemChar Id="o17">
<a:Name>Delimiter</a:Name>
<a:TRGTITEM.Comment>Field separation character. Example: col1, col2, col3</a:TRGTITEM.Comment>
<a:CHARITEM.Value>,</a:CHARITEM.Value>
</o:SObjTargetItemChar>
<o:SObjTargetItemChar Id="o18">
<a:Name>Quote</a:Name>
<a:TRGTITEM.Comment>Character used to enclose string values</a:TRGTITEM.Comment>
<a:CHARITEM.Value>&#39;</a:CHARITEM.Value>
</o:SObjTargetItemChar>
<o:SObjTargetItemChar Id="o19">
<a:Name>SqlContinue</a:Name>
<a:TRGTITEM.Comment>Continuation character</a:TRGTITEM.Comment>
</o:SObjTargetItemChar>
<o:SObjTargetItemString Id="o20">
<a:Name>LineComment</a:Name>
<a:TRGTITEM.Comment>Characters used to enclose a single line commentary</a:TRGTITEM.Comment>
<a:STRINGITEM.Value>--</a:STRINGITEM.Value>
</o:SObjTargetItemString>
<o:SObjTargetItemString Id="o21">
<a:Name>BlockComment</a:Name>
<a:TRGTITEM.Comment>Characters used to enclose a multi-line commentary</a:TRGTITEM.Comment>
<a:STRINGITEM.Value>/* */</a:STRINGITEM.Value>
</o:SObjTargetItemString>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o22">
<a:Name>Format</a:Name>
<a:TRGTITEM.Comment>Contains entries that define script formatting</a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemString Id="o23">
<a:Name>IllegalChar</a:Name>
<a:TRGTITEM.Comment>Invalid characters for names</a:TRGTITEM.Comment>
<a:STRINGITEM.Value>&quot; +-*/!=&amp;&lt;&gt;&#39;&quot;()&quot;.</a:STRINGITEM.Value>
</o:SObjTargetItemString>
<o:SObjTargetItemBool Id="o24">
<a:Name>UpperCaseOnly</a:Name>
<a:TRGTITEM.Comment>Uppercase only</a:TRGTITEM.Comment>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o25">
<a:Name>LowerCaseOnly</a:Name>
<a:TRGTITEM.Comment>Lowercase only</a:TRGTITEM.Comment>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o26">
<a:Name>EnableOwnerPrefix</a:Name>
<a:TRGTITEM.Comment>Object codes can have a prefix made of the object owner code</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o27">
<a:Name>File</a:Name>
<a:TRGTITEM.Comment>Contains header, footer and usage text entries used during the generation</a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemText Id="o28">
<a:Name>Header</a:Name>
<a:TRGTITEM.Comment>Header text for a database generation script</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o29">
<a:Name>Footer</a:Name>
<a:TRGTITEM.Comment>Footer text for a database generation script</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemBool Id="o30">
<a:Name>EnableMultiFile</a:Name>
<a:TRGTITEM.Comment>Multi-script allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemString Id="o31">
<a:Name>ScriptExt</a:Name>
<a:TRGTITEM.Comment>Main script extension in database generation</a:TRGTITEM.Comment>
<a:STRINGITEM.Value>sql</a:STRINGITEM.Value>
</o:SObjTargetItemString>
<o:SObjTargetItemString Id="o32">
<a:Name>TableExt</a:Name>
<a:TRGTITEM.Comment>Other scripts extension in database generation</a:TRGTITEM.Comment>
<a:STRINGITEM.Value>tab</a:STRINGITEM.Value>
</o:SObjTargetItemString>
<o:SObjTargetItemString Id="o33">
<a:Name>StartCommand</a:Name>
<a:TRGTITEM.Comment>Command for executing a script</a:TRGTITEM.Comment>
<a:STRINGITEM.Value>start %NAMESCRIPT%</a:STRINGITEM.Value>
</o:SObjTargetItemString>
<o:SObjTargetItemText Id="o34">
<a:Name>Usage1</a:Name>
<a:TEXTITEM.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter:
        sqlplus &lt;username&gt;/&lt;password&gt;
  (3) Run the database creation script:
        %STARTCMD%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Usage for a single script in database generation</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o35">
<a:Name>Usage2</a:Name>
<a:TEXTITEM.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start the SQL interpreter:
        sqlplus &lt;username&gt;/&lt;password&gt;
  (3) Run the database creation scripts:
        %STARTCMD% &lt;script_name&gt;</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Usage for multiple scripts in database generation</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemString Id="o36">
<a:Name>TriggerExt</a:Name>
<a:TRGTITEM.Comment>Script file extension in triggers and procedures generation</a:TRGTITEM.Comment>
<a:STRINGITEM.Value>trg</a:STRINGITEM.Value>
</o:SObjTargetItemString>
<o:SObjTargetItemText Id="o37">
<a:Name>TrgUsage1</a:Name>
<a:TEXTITEM.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start SQL interpreter:
        sqlplus &lt;username&gt;/&lt;password&gt;
  (3) Execute the trigger creation script:
        start %NAMESCRIPT%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Usage for a single script in triggers and procedures generation</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o38">
<a:Name>TrgUsage2</a:Name>
<a:TEXTITEM.Value>  (1) Go to the directory %PATHSCRIPT%
  (2) Start SQL interpreter:
        sqlplus &lt;username&gt;/&lt;password&gt;
  (3) Execute the triggers creation scripts:
        start &lt;script_name&gt;</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Usage for multiple scripts in triggers and procedures generation</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o39">
<a:Name>TrgHeader</a:Name>
<a:TEXTITEM.Value>-- Integrity package declaration
create or replace package IntegrityPackage AS
 procedure InitNestLevel;
 function GetNestLevel return number;
 procedure NextNestLevel;
 procedure PreviousNestLevel;
 end IntegrityPackage;
/

-- Integrity package definition
create or replace package body IntegrityPackage AS
 NestLevel number;

-- Procedure to initialize the trigger nest level
 procedure InitNestLevel is
 begin
 NestLevel := 0;
 end; 


-- Function to return the trigger nest level
 function GetNestLevel return number is
 begin
 if NestLevel is null then
     NestLevel := 0;
 end if;
 return(NestLevel);
 end; 

-- Procedure to increase the trigger nest level
 procedure NextNestLevel is
 begin
 if NestLevel is null then
     NestLevel := 0;
 end if;
 NestLevel := NestLevel + 1;
 end; 

-- Procedure to decrease the trigger nest level
 procedure PreviousNestLevel is
 begin
 NestLevel := NestLevel - 1;
 end; 
 
 end IntegrityPackage;
/</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Header text for a triggers and procedures generation script</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o40">
<a:Name>Keywords</a:Name>
<a:TRGTITEM.Comment>Contains the list of reserved words and functions available in SQL</a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemText Id="o41">
<a:Name>ReservedWord</a:Name>
<a:TEXTITEM.Value>ACCESS
ADD
ALL
ALTER
AND
ANY
AS
ASC
AUDIT
BETWEEN
BY
CHAR
CHECK
CLUSTER  
COLUMN  
COMMENT  
COMPRESS  
CONNECT
CREATE
CURRENT
DATE
DECIMAL
DEFAULT
DELETE
DESC
DISTINCT
DROP
ELSE
EXCLUSIVE  
EXISTS  
FILE  
FLOAT
FOR
FROM
GRANT
GROUP
HAVING
IDENTIFIED  
IMMEDIATE
IN
INCREMENT  
INDEX  
INITIAL  
INSERT
INTEGER
INTERSECT
INTO
IS
LEVEL
LIKE
LOCK  
LONG  
MAXEXTENTS  
MINUS  
MODE  
MODIFY  
NETWORK  
NOAUDIT  
NOCOMPRESS  
NOT
NOWAIT  
NULL
NUMBER  
OF
OFFLINE  
ON
ONLINE  
OPTION
OR
ORDER
PCTFREE  
PRIOR
PRIVILEGES
PUBLIC
RAW  
RENAME  
RESOURCE  
REVOKE
ROW  
ROWID  
ROWNUM  
ROWS
SELECT
SESSION
SET
SHARE  
SIZE
SMALLINT
START  
SUCCESSFUL  
SYNONYM  
SYSDATE  
TABLE
THEN
TO
TRIGGER  
UID  
UNION
UNIQUE
UPDATE
USER
VALIDATE  
VALUES
VARCHAR
VARCHAR2  
VIEW
WHENEVER
WHERE  
WITH</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Reserved words</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o42">
<a:Name>ReservedDefault</a:Name>
<a:TEXTITEM.Value>NULL

SYSDATE</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Reserved default values</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o43">
<a:Name>GroupFunc</a:Name>
<a:TEXTITEM.Value>avg()
count()
glb()
lub()
max()
min()
stddev()
sum()
variance()</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>List of SQL functions to use with group keywords.</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o44">
<a:Name>NumberFunc</a:Name>
<a:TEXTITEM.Value>abs()
acos()
asin()
atan()
atan2()
ceil()
cos()
cosh()
exp()
floor()
ln()
log()
mod()
power()
round()
sign()
sin()
sinh()
sqrt()
tan()
tanh()
trunc()</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>List of SQL functions used on numbers</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o45">
<a:Name>CharFunc</a:Name>
<a:TEXTITEM.Value>ascii()
chr()
concat()
initcap()
instr()
instrb()
length()
lengthb()
lower()
lpad()
ltrim()
nls_initcap()
nls_lower()
nls_upper()
nlssort()
replace()
rpad()
rtrim()
soundex()
substr()
substrb()
translate()
upper()</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>List of SQL functions for characters and strings</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o46">
<a:Name>DateFunc</a:Name>
<a:TEXTITEM.Value>add_months()
last_day()
months_between()
new_time()
next_day()
round()
sysdate
trunc()</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>List of SQLfunctions for dates</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o47">
<a:Name>ConvertFunc</a:Name>
<a:TEXTITEM.Value>chartorowid()
convert()
hextoraw()
rawtohex()
rowidtochar()
to_char()
to_date()
to_label()
to_multi_byte()
to_number()
to_single_byte()</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>List of SQL functions used to convert values between hex and integer and handling strings</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o48">
<a:Name>OtherFunc</a:Name>
<a:TEXTITEM.Value>bfilename()
currval
decode()
dump()
empty_blob()
empty_clob()
greatest()
least()
level
nls_charset_decl_len()
nls_charset_id()
nls_charset_name()
nvl()
nextval
rowid
rownum
uid
user
userenv()
vsize()</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>List of other SQL functions</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o49">
<a:Name>ListOperators</a:Name>
<a:TEXTITEM.Value>=
!=
^=
&lt;&gt;
&gt;
&lt;
&gt;=
&lt;=
not
in
not in
between
not between
exists
not exists
like
not like
is null
is not null
= any
!= any
&gt; any
&lt; any
&gt;= any
&lt;= any
= all
!= all
&gt; all
&lt; all
&gt;= all
&lt;= all</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>List of operators for comparing values, boolean, and various semantic operators</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o50">
<a:Name>Commit</a:Name>
<a:TEXTITEM.Value>commit</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for validating the transaction by OBDC</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o51">
<a:Name>Objects</a:Name>
<a:TRGTITEM.Comment>Contains sub-categories for each type of object in the database, for example: Table, or Reference. Each sub-category contains entries whose values define database commands and object-related characteristics</a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItem Id="o52">
<a:Name>Domain</a:Name>
<a:TRGTITEM.Comment>The following system variables are available:
   &quot;DOMAIN&quot;       // generated code of the domain (also available for columns)
Sql Server specific domain system variables:
   &quot;RULENAME&quot;     // name of the rule object associated with the domain
   &quot;DEFAULTNAME&quot;  // name of the default object associated with the domain       </a:TRGTITEM.Comment>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o53">
<a:Name>Table</a:Name>
<a:Code>TABL</a:Code>
<a:TRGTITEM.Comment>The following system variables are available :
   &quot;TABLE&quot;        // generated code of the table
   &quot;TNAME&quot;        // name of the table
   &quot;TCODE&quot;        // code of the table
   &quot;TLABL&quot;        // comment of the table
   &quot;PKEYCOLUMNS&quot;  // list of primary key columns. Ex: A, B
   &quot;TABLDEFN&quot;     // complete body of the table definition. Contains definition of columns, checks and keys       
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o54">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>Table allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemInt Id="o55">
<a:Name>Maxlen</a:Name>
<a:TRGTITEM.Comment>Maximum object name length</a:TRGTITEM.Comment>
<a:INTITEM.Value>30</a:INTITEM.Value>
</o:SObjTargetItemInt>
<o:SObjTargetItemBool Id="o56">
<a:Name>CKTInTable</a:Name>
<a:TRGTITEM.Comment>Check on table generated in table</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o57">
<a:Name>ConstName</a:Name>
<a:TEXTITEM.Value>CKT_%.U26:TABLE%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Constraint name template for check of table</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o58">
<a:Name>Create</a:Name>
<a:TEXTITEM.Value>[%CLASS% ?
[%CLUSTERCOLUMNS%? create cluster  [%QUALIFIER%]C_%TABLE% 
   (%CLUSTERCOLUMNS%)]
create table [%QUALIFIER%]%TABLE% of [%QUALIFIER%]%CLASS% [%TABLDEFN% ? (
   %TABLDEFN%
)
[%OPTIONS%]]
:
[%CLUSTERCOLUMNS%? create cluster  [%QUALIFIER%]C_%TABLE% 
   (%CLUSTERCOLUMNS%)]
create table [%QUALIFIER%]%TABLE% [%TABLDEFN% ? (
   %TABLDEFN%
)
grant all on %TABLE% to YUKON_USER

[%OPTIONS%]]
]
</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for creating a table. Example: create table %TABLE%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o59">
<a:Name>Options</a:Name>
<a:TEXTITEM.Value>&lt;segment_attribute_clause&gt; : composite=yes
{
&lt;physical_attribute_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default | keep | recycle
}
}
tablespace %s : category=tablespace
&lt;log&gt; %s : list=logging | nologging
}
organization : composite=yes
{
heap : composite=yes
{
&lt;segment_attribute_clause&gt; : composite=yes
{
&lt;physical_attribute_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default | keep | recycle
}
}
tablespace %s : category=tablespace
&lt;log&gt; %s : list=logging | nologging
}
}
index : composite=yes
{
&lt;index_organized_table_clause&gt; : composite=yes
{
&lt;segment_attribute_clause&gt; : composite=yes
{
&lt;physical_attribute_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default | keep | recycle
}
}
tablespace %s : category=tablespace
&lt;log&gt; %s : list=logging | nologging
}
pctthreshold %d
&lt;index_organized_overflow_clause&gt; : composite=yes
{
including %s
overflow
&lt;segment_attribute_clause&gt; : composite=yes
{
&lt;physical_attribute_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default | keep | recycle
}
}
tablespace %s : category=tablespace
&lt;log&gt; %s : list=logging | nologging
}
}
}
}
}
cluster %s : composite=yes, separator=yes, parenthesis=yes
{
&lt;column&gt; %s : multiple=yes
}
lob : composite=yes
{
&lt;lob_items&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;lob_item&gt; %s : multiple=yes
}
store as : composite=yes
{
&lt;lob_segname&gt; : composite=yes
{
&lt;name&gt; %s
}
&lt;lob_parameters&gt; : composite=yes, parenthesis=yes
{
tablespace %s : category=tablespace
&lt;storage_in_row&gt; %s : list=enable storage in row |disable storage in row
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default | keep | recycle
}
chunk %d
pctversion %d
&lt;cache_clause&gt; %s : list=cache |nocache | nocache logging | nocache nologging
index : composite=yes
{
&lt;lob_index_name&gt; %s
tablespace %s : category=tablespace
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default | keep | recycle
}
initrans %d : default=1
maxtrans %d
}
}
}
}
nested table %s : composite=yes, childmand=yes
{
store as %s
}
partition by range : composite=yes, childmand=yes
{
&lt;columns&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;column&gt; %s : multiple=yes
}
&lt;partition&gt; : composite=yes, parenthesis=yes, separator=yes
{
&lt;partition_list&gt; :composite=yes, multiple=yes
{
partition %s : composite=yes
{
value less than : composite=yes, parenthesis=yes, separator=yes
{
&lt;value_list&gt; %s : multiple=yes
}
&lt;segment_attribute_clause&gt; : composite=yes
{
&lt;physical_attribute_clause&gt; : composite=yes
{
pctfree %d : default=10
pctused %d : default=40
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default | keep | recycle
}
}
tablespace %s : category=tablespace
&lt;log&gt; %s : list=logging | nologging
}
}
}
}
}
&lt;parallel_clause&gt; : composite=yes
{
noparallel
parallel :composite=yes, parenthesis=yes
{
degree %d : default=default
instances %d : default=default
}
}
&lt;enable_disable_clause&gt; : composite=yes
{
enable : composite=yes
{
&lt;validation&gt; %s : composite=yes, list=validate | novalidate
{
unique : composite=yes, parenthesis=yes, separator=yes
{
&lt;columns&gt; %s : multiple=yes
}
primary key
constraint %s
using index : composite=yes
{
pctfree %d
initrans %d
maxtrans %d
tablespace %s : category=tablespace
storage : category=storage, composite=yes, parenthesis=yes
{
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default | keep | recycle
}
nosort
&lt;logging&gt; %s : list=logging | nologging
}
exception into %s
}
all_triggers
}
disable : composite=yes
{
unique %s
primary key
constraint %s
cascade
all_triggers
}
}
oidindex : composite=yes
{
 &lt;index name&gt; %s 
 &lt;container_clause&gt; : composite=yes, parenthesis=yes
 {
tablespace %s : category=tablespace, multiple=yes
&lt;physical_attribute_clause&gt; : composite=yes, multiple=yes
{
 pctfree %d : default=10
 pctused %d : default=40
 initrans %d : default=1
 maxtrans %d
 storage : category=storage, composite=yes, parenthesis=yes
 {
initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
maxextents unlimited
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
optimal NULL
buffer_pool %s : list=default | keep | recycle
 }
}
 }
}
as %s
&lt;cache&gt; %s : list=cache |nocache
</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Available options for creating a table</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o60">
<a:Name>DefOptions</a:Name>
<a:TRGTITEM.Comment>Default values for table options</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o61">
<a:Name>SqlAttrQuery</a:Name>
<a:TEXTITEM.Value>{OWNER, TABLE, COMMENT}
         
[%ISODBCUSER% ?
SELECT &#39;%SCHEMA%&#39;, TABLE_NAME, COMMENTS 
FROM SYS.USER_TAB_COMMENTS
WHERE COMMENTS IS NOT NULL [AND TABLE_NAME=&#39;%TABLE%&#39;]
ORDER BY TABLE_NAME
:
SELECT OWNER, TABLE_NAME, COMMENTS 
FROM SYS.ALL_TAB_COMMENTS
WHERE COMMENTS IS NOT NULL [AND OWNER=&#39;%SCHEMA%&#39;] [AND TABLE_NAME=&#39;%TABLE%&#39;]
ORDER BY OWNER, TABLE_NAME
]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to reverse object attributes</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o62">
<a:Name>SqlOptsQuery</a:Name>
<a:TEXTITEM.Value>{OWNER ID, TABLE ID, OPTIONS ...}

select 
   t.owner,
   t.table_name,
   decode (t.pct_free, 10, &#39;&#39;, 0, &#39;&#39;, &#39; pctfree &#39; || t.pct_free) || 
   decode (t.pct_used, 40, &#39;&#39;, 0, &#39;&#39;,  &#39; pctused &#39; || t.pct_used) || 
   decode (t.ini_trans, 1, &#39;&#39;, 0, &#39;&#39;,  &#39; initrans &#39; || t.ini_trans) || 
   decode (t.max_trans, 255, &#39;&#39;, 0, &#39;&#39;,  &#39; maxtrans &#39; || t.max_trans) || 
   decode (t.tablespace_name, &#39;SYSTEM&#39;, &#39;&#39;, NULL, &#39;&#39;, &#39; tablespace &#39; || t.tablespace_name) ||
   decode (t.initial_extent, NULL, &#39;&#39;, &#39; storage (initial &#39;|| (t.initial_extent/1024)||&#39; K&#39;) ||
   decode (t.next_extent, NULL, &#39;&#39;, 10240, &#39;&#39;, &#39; next &#39;|| (t.next_extent/1024)||&#39; K&#39;) ||
   decode (t.min_extents, NULL, &#39;&#39;, 1, &#39;&#39;, &#39; minextents &#39;|| t.min_extents) ||
   decode (t.max_extents, NULL, &#39;&#39;, 121, &#39;&#39;, 2147483645, &#39; maxextents unlimited&#39;, &#39; maxextents &#39;|| t.max_extents) ||
   decode (t.pct_increase, NULL, &#39;&#39;, 50, &#39;&#39;, &#39; pctincrease &#39;|| t.pct_increase)||
   decode (t.freelists, NULL, &#39;&#39;, 1, &#39;&#39;, &#39; freelists&#39;||t.freelists) ||
   decode (t.freelist_groups, NULL, &#39;&#39;, 1, &#39;&#39;, &#39; freelist groups&#39;||t.freelist_groups) ||
   decode (t.initial_extent, NULL, &#39;&#39;, &#39;)&#39;) ||
   decode (t.cluster_name, NULL, &#39;&#39;, &#39; cluster &#39;||t.cluster_name||&#39; (&#39;),
   0
from 
   all_tables t
where 1=1
[  and t.owner=&#39;%SCHEMA%&#39; ]
[  and t.table_name=&#39;%TABLE%&#39;]
union select
   t.owner,
   t.table_name,
   decode (c.column_id, 1, c.column_name, &#39;,&#39;||c.column_name),
   c.column_id
from
   all_tables t, all_clusters k, all_tab_columns c
where 
   t.cluster_name=k.cluster_name
   and t.owner=k.owner
   and c.owner=t.owner
   and c.table_name=k.cluster_name
   and t.cluster_name is not null
[  and t.owner=&#39;%SCHEMA%&#39; ]
[  and t.table_name=&#39;%TABLE%&#39;]
union select
   t.owner,
   t.table_name,
   decode (t.cluster_name, NULL, &#39;&#39;, &#39;)&#39;) ||
   decode (t.cache, &#39;N&#39;, &#39; nocache&#39;, &#39;Y&#39;, &#39; cache&#39;, &#39; &#39;),
   999
from 
   all_tables t
where 1=1
[  and t.owner=&#39;%SCHEMA%&#39; ]
[  and t.table_name=&#39;%TABLE%&#39;]
order by 1, 2, 4

</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to reverse object physical options</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o63">
<a:Name>SqlChckQuery</a:Name>
<a:TEXTITEM.Value>{OWNER, TABLE, CONSTNAME, CONSTRAINT}
         
[%ISODBCUSER% ?
SELECT &#39;%SCHEMA%&#39;, C.TABLE_NAME, C.CONSTRAINT_NAME, C.SEARCH_CONDITION
FROM SYS.USER_CONSTRAINTS C
WHERE ( C.CONSTRAINT_TYPE=&#39;C&#39;  [AND TABLE_NAME=&#39;%TABLE%&#39;]
        AND 1&lt;(SELECT COUNT(*) FROM SYS.USER_CONS_COLUMNS C2
                  WHERE C.CONSTRAINT_NAME=C2.CONSTRAINT_NAME) )
ORDER BY C.TABLE_NAME
:
SELECT C.OWNER, C.TABLE_NAME, C.CONSTRAINT_NAME, C.SEARCH_CONDITION
FROM SYS.ALL_CONSTRAINTS C
WHERE ( C.CONSTRAINT_TYPE=&#39;C&#39;  [AND OWNER=&#39;%SCHEMA%&#39;] [AND TABLE_NAME=&#39;%TABLE%&#39;]
        AND 1&lt;(SELECT COUNT(*) FROM SYS.ALL_CONS_COLUMNS C2
                  WHERE C2.OWNER=C.OWNER AND C.CONSTRAINT_NAME=C2.CONSTRAINT_NAME) )
ORDER BY C.OWNER, C.TABLE_NAME
]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to reverse object checks</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o64">
<a:Name>TableComment</a:Name>
<a:TEXTITEM.Value>comment on table [%QUALIFIER%]%TABLE% is %.q:COMMENT%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for adding a table comment</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o65">
<a:Name>Drop</a:Name>
<a:TEXTITEM.Value>drop table [%QUALIFIER%]%TABLE% [cascade constraints]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping a table. Example: drop table %TABLE%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o66">
<a:Name>Rename</a:Name>
<a:TEXTITEM.Value>rename %OLDTABL% to %NEWTABL%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for renaming a table</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o67">
<a:Name>AlterTableHeader</a:Name>
<a:TRGTITEM.Comment>Alter table header</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o68">
<a:Name>AlterTableFooter</a:Name>
<a:TRGTITEM.Comment>Alter table footer</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o69">
<a:Name>DropTableCheck</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping a table check in an alter table statement</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o70">
<a:Name>DefineTableCheck</a:Name>
<a:TEXTITEM.Value>[constraint %CONSTNAME%] check (%CONSTRAINT%)</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Allows to customize the script of table check constraints</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o71">
<a:Name>AddTableCheck</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME%] check (%CONSTRAINT%)</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Allows to customize the script for modifying table constraints within an alter table statement</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o72">
<a:Name>AllowedADT</a:Name>
<a:TEXTITEM.Value>OBJECT</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>List of ADT on which a table can be based</a:TRGTITEM.Comment>
<a:TRGTITEM.Type>1</a:TRGTITEM.Type>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o73">
<a:Name>Column</a:Name>
<a:Code>COLN</a:Code>
<a:TRGTITEM.Comment>The following system variables are available :
(parent table items are also available for columns)
   &quot;COLUMN&quot;       // generated code of the column
   &quot;COLNNO&quot;       // position of the column in the list of columns of the table
   &quot;COLNNAME&quot;     // name of the column
   &quot;COLNCODE&quot;     // code of the column
   &quot;PRIMARY&quot;      // keyword &quot;primary&quot; if the column is primary
   &quot;ISPKEY&quot;       // TRUE if the column is part of the primary key
   &quot;FOREIGN&quot;      // TRUE if the column is part of one foreign key       
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o74">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>Column allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemInt Id="o75">
<a:Name>Maxlen</a:Name>
<a:TRGTITEM.Comment>Column name length</a:TRGTITEM.Comment>
<a:INTITEM.Value>30</a:INTITEM.Value>
</o:SObjTargetItemInt>
<o:SObjTargetItemBool Id="o76">
<a:Name>EnableNull</a:Name>
<a:TRGTITEM.Comment>NULL keyword allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o77">
<a:Name>EnableDefault</a:Name>
<a:TRGTITEM.Comment>Default values allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o78">
<a:Name>CheckNull</a:Name>
<a:TRGTITEM.Comment>Verifies if a column is NULL</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o79">
<a:Name>ConstName</a:Name>
<a:TEXTITEM.Value>CKC_%.U17:COLUMN%_%.U8:TABLE%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Constraint name template for a column check parameter</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o80">
<a:Name>Add</a:Name>
<a:TEXTITEM.Value>[%CLASS% ? [%NOTNULL% ? %20:COLUMN% [default %DEFAULT%] [%NOTNULL%]
      [[constraint %CONSTNAME%] check (%CONSTRAINT%)]
:[%DEFAULT% ? %20:COLUMN% [default %DEFAULT%] [%NOTNULL%]
      [[constraint %CONSTNAME%] check (%CONSTRAINT%)]
:[%CONSTRAINT% ? %20:COLUMN%
      [[constraint %CONSTNAME%] check (%CONSTRAINT%)]]]]
:%20:COLUMN% %30:DATATYPE% [default %DEFAULT%] [%R% ? [with rowid] [scope is [%QUALIFIER%]%S%] [constraint %CONSTNAME%] ] [%NOTNULL%]
      [[constraint %CONSTNAME%] check (%CONSTRAINT%)]
]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for defining a table column</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o81">
<a:Name>ColumnComment</a:Name>
<a:TEXTITEM.Value>comment on column [%QUALIFIER%]%TABLE%.%COLUMN% is %.q:COMMENT%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for adding a column comment</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o82">
<a:Name>Rename</a:Name>
<a:TRGTITEM.Comment>Command for renaming a column</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o83">
<a:Name>Create</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE% add %COLUMN% %DATATYPE% [default %DEFAULT%][ %NOTNULL%]
   [[constraint %CONSTNAME%] check (%CONSTRAINT%)]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for adding a column</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o84">
<a:Name>ModifyColumn</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE% modify %COLUMN% %DATATYPE% [default %DEFAULT%][%R% ? [with rowid] [scope is [%QUALIFIER%]%S%]] ][%NOTNULL%]
   [[constraint %CONSTNAME%] check (%CONSTRAINT%) ])</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for modifying a column</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o85">
<a:Name>Drop</a:Name>
<a:TRGTITEM.Comment>Command for dropping a column</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o86">
<a:Name>ModifyColnNull</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE%
   modify %COLUMN% %NOTNULL%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for modifying null/not null for a column in an alter table statement
</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o87">
<a:Name>ModifyColnDflt</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE%
   modify %COLUMN% default %DEFAULT%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for modifying a column default in an alter table statement</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o88">
<a:Name>ModifyColnChck</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE%
   modify %COLUMN% [[constraint %CONSTNAME%] check (%CONSTRAINT%) ]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for modifying a column check in an alter table statement</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o89">
<a:Name>DropColnChck</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE%
   drop constraint %CONSTNAME%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping a column check in an alter table statement</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemBool Id="o90">
<a:Name>AltEnableAddColnChk</a:Name>
<a:TRGTITEM.Comment>Column check constraint allowed in an alter table statement</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o91">
<a:Name>SqlListQuery</a:Name>
<a:TEXTITEM.Value>{OWNER, TABLE, COLUMN, DTTPCODE, LENGTH, SIZE, PREC, NOTNULL (N=&#39;NOT NULL&#39;, *=NULL), DEFAULT, COMMENT}

[%ISODBCUSER% ?
SELECT &#39;%SCHEMA%&#39;, C.TABLE_NAME, C.COLUMN_NAME, C.DATA_TYPE, C.DATA_PRECISION, C.DATA_LENGTH, C.DATA_SCALE, C.NULLABLE, C.DATA_DEFAULT, M.COMMENTS
FROM SYS.USER_COL_COMMENTS M, SYS.USER_TAB_COLUMNS C
WHERE M.TABLE_NAME = C.TABLE_NAME AND M.COLUMN_NAME = C.COLUMN_NAME
      [AND C.TABLE_NAME=&#39;%TABLE%&#39;]
ORDER BY C.TABLE_NAME, C.COLUMN_ID
:
SELECT C.OWNER, C.TABLE_NAME, C.COLUMN_NAME, C.DATA_TYPE, C.DATA_PRECISION, C.DATA_LENGTH, C.DATA_SCALE, C.NULLABLE, C.DATA_DEFAULT, M.COMMENTS
FROM SYS.ALL_COL_COMMENTS M, SYS.ALL_TAB_COLUMNS C
WHERE M.OWNER = C.OWNER AND M.TABLE_NAME = C.TABLE_NAME AND M.COLUMN_NAME = C.COLUMN_NAME
      [AND C.OWNER=&#39;%SCHEMA%&#39;] [AND C.TABLE_NAME=&#39;%TABLE%&#39;]
ORDER BY C.OWNER, C.TABLE_NAME, C.COLUMN_ID
]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to list objects</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o92">
<a:Name>SqlAttrQuery</a:Name>
<a:TRGTITEM.Comment>SQL query to reverse object attributes</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o93">
<a:Name>SqlChckQuery</a:Name>
<a:TEXTITEM.Value>{OWNER, TABLE, COLUMN, CONSTNAME, CONSTRAINT}

[%ISODBCUSER% ?
SELECT &#39;%SCHEMA%&#39;, COL.TABLE_NAME, COL.COLUMN_NAME, CST.CONSTRAINT_NAME, CST.SEARCH_CONDITION
FROM SYS.USER_CONS_COLUMNS COL, SYS.USER_CONSTRAINTS CST
WHERE ( COL.TABLE_NAME=CST.TABLE_NAME
        AND (1=(SELECT COUNT(*) FROM SYS.USER_CONS_COLUMNS COL2
               WHERE COL2.CONSTRAINT_NAME=COL.CONSTRAINT_NAME)   )
        AND COL.CONSTRAINT_NAME=CST.CONSTRAINT_NAME AND CST.CONSTRAINT_TYPE=&#39;C&#39;        
        [AND COL.TABLE_NAME=&#39;%TABLE%&#39;] )  
:
SELECT COL.OWNER, COL.TABLE_NAME, COL.COLUMN_NAME, CST.CONSTRAINT_NAME, CST.SEARCH_CONDITION
FROM SYS.ALL_CONS_COLUMNS COL, SYS.ALL_CONSTRAINTS CST
WHERE ( COL.OWNER=CST.OWNER AND COL.TABLE_NAME=CST.TABLE_NAME
        AND (1=(SELECT COUNT(*) FROM SYS.ALL_CONS_COLUMNS COL2
               WHERE COL2.OWNER=COL.OWNER AND COL2.CONSTRAINT_NAME=COL.CONSTRAINT_NAME)   )
        AND COL.CONSTRAINT_NAME=CST.CONSTRAINT_NAME AND CST.CONSTRAINT_TYPE=&#39;C&#39;        
        [AND COL.OWNER=&#39;%SCHEMA%&#39;] [AND COL.TABLE_NAME=&#39;%TABLE%&#39;] )  
]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to reverse object checks</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o94">
<a:Name>Index</a:Name>
<a:Code>INDX</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
(parent table items are also available for indexes)
   &quot;INDEX&quot;        // generated code of the index
   &quot;INDEXNAME&quot;    // index name
   &quot;INDEXCODE&quot;    // index code
   &quot;UNIQUE&quot;       // keyword &quot;unique&quot; when the index is unique
   &quot;INDEXTYPE&quot;    // index type (available only for a few DBMS)
   &quot;INDEXKEY&quot;     // keywords &quot;primary&quot;, &quot;unique&quot; or &quot;foreign&quot; depending on the index origin
   &quot;CIDXLIST&quot;     // list of index columns. Ex: A asc, B desc, C asc
   &quot;CLUSTER&quot;      // keyword &quot;cluster&quot; when the index is cluster
For index columns, the following system variables are available:
   &quot;ASC&quot;          // keywords &quot;ASC&quot; or &quot;DESC&quot; depending on sort order
   &quot;ISASC&quot;        // TRUE if the index column sort is ascending
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o95">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>Index allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemInt Id="o96">
<a:Name>Maxlen</a:Name>
<a:TRGTITEM.Comment>Index name length</a:TRGTITEM.Comment>
<a:INTITEM.Value>30</a:INTITEM.Value>
</o:SObjTargetItemInt>
<o:SObjTargetItemInt Id="o97">
<a:Name>MaxColIndex</a:Name>
<a:TRGTITEM.Comment>Maximum number of columns in an index</a:TRGTITEM.Comment>
<a:INTITEM.Value>32</a:INTITEM.Value>
</o:SObjTargetItemInt>
<o:SObjTargetItemBool Id="o98">
<a:Name>UniqName</a:Name>
<a:TRGTITEM.Comment>Unique index name in the database</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o99">
<a:Name>Create</a:Name>
<a:TEXTITEM.Value>create [%UNIQUE%?%UNIQUE%:[%INDEXTYPE%]] index [%QUALIFIER%]%INDEX% on [%CLUSTER%?cluster C_%TABLE%:[%QUALIFIER%]%TABLE% (
   %CIDXLIST%
)]
[%OPTIONS%]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for creating an index. Example: create index %INDEX%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o100">
<a:Name>AddColIndex</a:Name>
<a:TEXTITEM.Value>%COLUMN% [%ASC%]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for defining an index column</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o101">
<a:Name>IndexType</a:Name>
<a:TEXTITEM.Value>bitmap</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>List of types available for an index</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemString Id="o102">
<a:Name>DefIndexType</a:Name>
<a:TRGTITEM.Comment>Default type for an index</a:TRGTITEM.Comment>
</o:SObjTargetItemString>
<o:SObjTargetItemText Id="o103">
<a:Name>Options</a:Name>
<a:TEXTITEM.Value>&lt;global_index_clause&gt; : composite=yes
{
   global partition by range : composite=yes
   {
      &lt;column_list&gt; : composite=yes, parenthesis=yes, separator=yes
      {
         &lt;column&gt;  %s : multiple=yes
      }

      &lt;global_partition_clause&gt; : composite=yes, parenthesis=yes
      {
         partition %s : composite=yes
         {
            value less than : composite=yes, parenthesis=yes, separator=yes
            {
               &lt;value_list&gt; %s : multiple=yes
            }
            pctfree %d : default=10
            initrans %d : default=1
            maxtrans %d
            storage : category=storage, composite=yes, parenthesis=yes
            {
               initial %d : default=10K
               next %d : default=10K
               minextents %d : default=1
               maxextents %d
               maxextents unlimited
               pctincrease %d : default=50
               freelists %d : default=1
               freelist groups %d : default=1
               optimal %d
               optimal NULL
               buffer_pool %s : list=keep | recycle | default
            }
            tablespace %s : category=tablespace
            &lt;login_clause&gt; %s : list=logging | nologging
         }
      }
   }
}
&lt;local_index_clause&gt; : composite=yes
{
   local : composite=yes, parenthesis=yes, separator=yes
   {
      partition : composite=yes, multiple=yes
      {
         &lt;partition_name&gt; %s : composite=yes
         {
            pctfree %d : default=10
            initrans %d : default=1
            maxtrans %d
            storage : category=storage, composite=yes, parenthesis=yes
            {
               initial %d : default=10K
               next %d : default=10K
               minextents %d : default=1
               maxextents %d
               maxextents unlimited
               pctincrease %d : default=50
               freelists %d : default=1
               freelist groups %d : default=1
               optimal %d
               optimal NULL
               buffer_pool %s : list=keep | recycle | default
            }
            tablespace %s : category=tablespace
            &lt;login_clause&gt; %s : list=logging | nologging
         }
      }
   }
}

&lt;parallel_clause&gt; : composite=yes
{
   noparallel
   parallel :  composite=yes, parenthesis=yes
   {
      degree %d : default=default
      instances %d : default=default
   }
}

pctfree %d : default=10
initrans %d : default=1
maxtrans %d
storage : category=storage, composite=yes, parenthesis=yes
{
   initial %d : default=10K
   next %d : default=10K
   minextents %d : default=1
   maxextents %d
   maxextents unlimited
   pctincrease %d : default=50
   freelists %d : default=1
   freelist groups %d : default=1
   optimal %d
   optimal NULL
   buffer_pool %s : list=keep | recycle | default
}
&lt;login_clause&gt; %s : list=logging | nologging
tablespace %s : category=tablespace, default=default
&lt;sort_clause&gt; %s : list=nosort | reverse

</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Default options for creating an index</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o104">
<a:Name>DefOptions</a:Name>
<a:TRGTITEM.Comment>Default values for index options</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o105">
<a:Name>SqlOptsQuery</a:Name>
<a:TEXTITEM.Value>{OWNER, TABLE, INDEX, OPTIONS}

select 
   i.table_owner,
   i.table_name,
   i.index_name,
   decode(i.pct_free, 10, &#39;&#39;, &#39;pctfree &#39; || i.pct_free) || 
   decode(i.ini_trans, 2, &#39;&#39;, &#39; initrans &#39; || i.ini_trans) ||
   decode(i.max_trans, 255, &#39;&#39;, &#39; maxtrans &#39; || i.max_trans) || 
   decode(i.tablespace_name, &#39;SYSTEM&#39;, &#39;&#39;, &#39; tablespace &#39; || i.tablespace_name)
from 
   all_indexes i
where 1=1
[  and i.table_owner=&#39;%SCHEMA%&#39;]
[  and i.table_name=&#39;%TABLE%&#39;]
[  and i.index_name=&#39;%INDEX%&#39;]
order by 1, 2

</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to reverse object physical options</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o106">
<a:Name>Drop</a:Name>
<a:TEXTITEM.Value>drop index [%QUALIFIER%]%INDEX%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping an index. Example: drop index %INDEX%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o107">
<a:Name>SqlAttrQuery</a:Name>
<a:TEXTITEM.Value>{OWNER, TABLE, INDEX, INDEXTYPE}

select 
   i.table_owner,
   i.table_name,
   i.index_name,
   decode(i.index_type, &#39;BITMAP&#39;, &#39;bitmap&#39;, &#39;&#39;)
from 
   all_indexes i
where 1=1
[  and i.table_owner=&#39;%SCHEMA%&#39;]
[  and i.table_name=&#39;%TABLE%&#39;]
[  and i.index_name=&#39;%INDEX%&#39;]
</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to reverse object attributes</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o108">
<a:Name>SqlSysIndexQuery</a:Name>
<a:TEXTITEM.Value>{OWNER, TABLE, INDEX}

select 
   i.table_owner,
   i.table_name,
   i.index_name
from 
   all_indexes i
where
   i.generated=&#39;Y&#39;
</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to list system indexes created by the database</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o109">
<a:Name>PKey</a:Name>
<a:Code>PKEY</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
(parent table items are also available for indexes)
   &quot;COLUMNS&quot;      // List of columns of the key. Ex: &quot;A, B, C&quot;
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;PKEY&quot;         // constraint name
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o110">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>Primary key allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o111">
<a:Name>PKInTable</a:Name>
<a:TRGTITEM.Comment>Primary key created in table</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o112">
<a:Name>PkAutoIndex</a:Name>
<a:TRGTITEM.Comment>Primary key is auto-indexed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o113">
<a:Name>ConstName</a:Name>
<a:TEXTITEM.Value>PK_%.U27:TABLE%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Constraint name template for primary keys</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o114">
<a:Name>Options</a:Name>
<a:TEXTITEM.Value>initially %s : list=immediate | deferred
&lt;deferrable&gt; %s : list=not deferrable | deferrable
using index : composite=yes,  separator=no, parenthesis=no
{
pctfree %d
initrans %d : default=1
maxtrans %d
tablespace %s : category=tablespace
storage : category=storage, composite=yes, separator=no, parenthesis=yes
{
  initial %d : default=10K
  next %d : default=10K
  minextents %d : default=1
  maxextents %s
  maxextents unlimited
  pctincrease %d : default=50
  freelists %d : default=1
  freelist groups %d : default=1
  optimal %d
  optimal NULL
  buffer_pool %s : list=keep | recycle | default
}
nosort
&lt;log&gt; %s : list=logging | nologging
}
exceptions into %s
enable %s : list=validate | novalidate
disable</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Available options for creating a primary key</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o115">
<a:Name>DefOptions</a:Name>
<a:TRGTITEM.Comment>Default values for primary key options</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o116">
<a:Name>Add</a:Name>
<a:TEXTITEM.Value>[constraint %CONSTNAME%] primary key (%PKEYCOLUMNS%)
      [%OPTIONS%]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for defining a primary key</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o117">
<a:Name>Create</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME%] primary key (%PKEYCOLUMNS%)
      [%OPTIONS%]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for adding a primary key</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o118">
<a:Name>Drop</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE%
   drop primary key [cascade]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping a primary key</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o119">
<a:Name>Key</a:Name>
<a:Code>KEY</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
(parent table items are also available for indexes)
   &quot;COLUMNS&quot;      // List of columns of the key. Ex: &quot;A, B, C&quot;
   &quot;ISPKEY&quot;       // TRUE when the key is the primary key of the table
   &quot;PKEY&quot;         // constraint name
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o120">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>UNIQUE constraint allowed for tables</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o121">
<a:Name>UniqConstAutoIndex</a:Name>
<a:TRGTITEM.Comment>UNIQUE constraint is auto-indexed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o122">
<a:Name>ConstName</a:Name>
<a:TEXTITEM.Value>AK_%.U18:AKEY%_%.U8:TABLE%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Constraint name template for alternate keys</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o123">
<a:Name>Options</a:Name>
<a:TEXTITEM.Value>initially %s : list=immediate | deferred
&lt;deferrable&gt; %s : list=not deferrable | deferrable
using index : composite=yes,  separator=no, parenthesis=no
{
pctfree %d
initrans %d : default=1
maxtrans %d
tablespace %s : category=tablespace
storage : category=storage, composite=yes, separator=no, parenthesis=yes
{
  initial %d : default=10K
  next %d : default=10K
  minextents %d : default=1
  maxextents %s
  maxextents unlimited
  pctincrease %d : default=50
  freelists %d : default=1
  freelist groups %d : default=1
  optimal %d
  optimal NULL
  buffer_pool %s : list=keep | recycle | default
}
nosort
&lt;log&gt; %s : list=logging | nologging
}
exceptions into %s
enable %s : list=validate | novalidate
disable</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Available options for an alternate key</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o124">
<a:Name>DefOptions</a:Name>
<a:TRGTITEM.Comment>Default values for alternate key options</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o125">
<a:Name>SqlAkeyIndex</a:Name>
<a:TEXTITEM.Value>select I.INDEX_NAME
from ALL_INDEXES I, ALL_CONSTRAINTS CS
where CS.CONSTRAINT_TYPE = &#39;U&#39; and CS.OWNER = &#39;%USER%&#39; and 
      CS.CONSTRAINT_NAME = I.INDEX_NAME and 
      I.TABLE_OWNER = &#39;%USER%&#39; and I.TABLE_NAME = &#39;%TABLE%&#39;</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to obtain the alternate key indexes of a table by ODBC</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o126">
<a:Name>Drop</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE%
   drop unique (%COLUMNS%) [cascade]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping an alternate key</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemBool Id="o127">
<a:Name>UniqInTable</a:Name>
<a:TRGTITEM.Comment>Alternate key generated in table</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o128">
<a:Name>Add</a:Name>
<a:TEXTITEM.Value>[constraint %CONSTNAME%] unique (%COLUMNS%)
      [%OPTIONS%]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for defining an alternate key
</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o129">
<a:Name>Create</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME%] unique (%COLUMNS%)
      [%OPTIONS%]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for adding an alternate key</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o130">
<a:Name>Procedure</a:Name>
<a:Code>PROC</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
   &quot;PROC&quot;       // generated code of the procedure (also available for trigger when the trigger is implemented with a procedure)
   &quot;FUNC&quot;       // generated code of the procedure if the procedure is a function (with return value)
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o131">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>Procedure allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o132">
<a:Name>EnableFunc</a:Name>
<a:TRGTITEM.Comment>Function allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemInt Id="o133">
<a:Name>Maxlen</a:Name>
<a:TRGTITEM.Comment>Procedure name length</a:TRGTITEM.Comment>
<a:INTITEM.Value>30</a:INTITEM.Value>
</o:SObjTargetItemInt>
<o:SObjTargetItemInt Id="o134">
<a:Name>MaxFuncLen</a:Name>
<a:TRGTITEM.Comment>Function name length</a:TRGTITEM.Comment>
<a:INTITEM.Value>30</a:INTITEM.Value>
</o:SObjTargetItemInt>
<o:SObjTargetItemText Id="o135">
<a:Name>Drop</a:Name>
<a:TEXTITEM.Value>drop procedure %PROC%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping a procedure. Example: drop procedure %PROC%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o136">
<a:Name>DropFunc</a:Name>
<a:TEXTITEM.Value>drop function %FUNC%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping a function. Example: drop function %FUNC%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o137">
<a:Name>CustomProc</a:Name>
<a:TEXTITEM.Value>create or replace procedure %PROC%(&lt;arg&gt; in out &lt;type&gt;) as
declare
begin

end;
/

alter procedure %PROC% compile
/</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for creating a stored procedure</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o138">
<a:Name>CustomFunc</a:Name>
<a:TEXTITEM.Value>create or replace function %FUNC%(&lt;arg&gt; &lt;type&gt;) return &lt;type&gt; as
declare
    &lt;retval&gt;  &lt;type&gt;;
begin
    return (&lt;retval&gt;);
end;
/

alter function %FUNC% compile
/</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for creating a function</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o139">
<a:Name>SqlListQuery</a:Name>
<a:TEXTITEM.Value>{OWNER, PROC}

[%ISODBCUSER% ?
SELECT DISTINCT &#39;%SCHEMA%&#39;, NAME
FROM SYS.USER_SOURCE
WHERE (TYPE = &#39;PROCEDURE&#39; OR TYPE = &#39;FUNCTION&#39;)
ORDER BY NAME
:
SELECT DISTINCT OWNER, NAME
FROM SYS.ALL_SOURCE
WHERE (TYPE = &#39;PROCEDURE&#39; OR TYPE = &#39;FUNCTION&#39;) [AND OWNER=&#39;%SCHEMA%&#39;]
ORDER BY OWNER, NAME
]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to list objects</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o140">
<a:Name>SqlAttrQuery</a:Name>
<a:TEXTITEM.Value>{OWNER ID, PROC ID, SCRIPT ...}

[%ISODBCUSER% ?
SELECT &#39;%SCHEMA%&#39;, NAME, TEXT
FROM SYS.USER_SOURCE
WHERE (TYPE = &#39;PROCEDURE&#39; OR TYPE = &#39;FUNCTION&#39;)
ORDER BY NAME, LINE
:
SELECT OWNER, NAME, TEXT
FROM SYS.ALL_SOURCE
WHERE (TYPE = &#39;PROCEDURE&#39; OR TYPE = &#39;FUNCTION&#39;) [AND OWNER=&#39;%SCHEMA%&#39;]
ORDER BY OWNER, NAME, LINE
]
             </a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to reverse object attributes</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o141">
<a:Name>Reference</a:Name>
<a:Code>REFR</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
   &quot;REFR&quot;         // generated code of the reference
   &quot;REFNAME&quot;      // reference name
   &quot;PARENT&quot;       // generated code of the parent table
   &quot;PNAME&quot;        // name of the parent table
   &quot;PCODE&quot;        // code of the parent table
   &quot;CHILD&quot;        // generated code of the reference
   &quot;CNAME&quot;        // name of the child table
   &quot;CCODE&quot;        // code of the child table
   &quot;PQUALIFIER&quot;   // qualifier of the parent table. See QUALIFIER
   &quot;CQUALIFIER&quot;   // qualifier of the child table. See QUALIFIER
   &quot;REFRNAME&quot;     // Reference name
   &quot;REFRCODE&quot;     // Reference code
   &quot;FKCONSTRAINT&quot; // Reference constraint name (foreign key)
   &quot;PKCONSTRAINT&quot; // constraint name of the parent key used to reference object
   &quot;CKEYCOLUMNS&quot;  // list of parent key columns. Ex: C1, C2, C3
   &quot;FKEYCOLUMNS&quot;  // list of child foreign key columns. Ex: 
   &quot;UPDCONST&quot;     // Update declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;DELCONST&quot;     // Delete declarative constraint. Keywords &quot;restrict&quot;, &quot;cascade&quot;, &quot;set null&quot; or &quot;set default&quot;
   &quot;MINCARD&quot;      // Min cardinality
   &quot;MAXCARD&quot;      // Max cardinality
   &quot;POWNER&quot;       // Parent table owner
   &quot;COWNER&quot;       // child table owner
   &quot;CHCKONCMMT&quot;   // TRUE when check on commit is selected on the reference (ASA 6.0 specific)

For reference joins (couple of column in a reference),
the following system variables are available:
   &quot;CKEYCOLUMN&quot;   // generated code of the parent table column (primary key)
   &quot;FKEYCOLUMN&quot;   // generated code of the child table column (foreign key)
   &quot;PK&quot;           // primary key column generated code
   &quot;PKNAME&quot;       // primary key column name
   &quot;FK&quot;           // foreign key column generated code
   &quot;FKNAME&quot;       // foreign key column name
   &quot;AK&quot;           // alternate key column code (same as PK)
   &quot;AKNAME&quot;       // alternate key column name (same as PKNAME)
   &quot;COLTYPE&quot;      // primary column column datatype
   &quot;DEFAULT&quot;      // foreign key column default value       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o142">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>Foreign key allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o143">
<a:Name>FKInTable</a:Name>
<a:TRGTITEM.Comment>Foreign key created in table</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o144">
<a:Name>FKAutoIndex</a:Name>
<a:TRGTITEM.Comment>Foreign key is auto-indexed</a:TRGTITEM.Comment>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o145">
<a:Name>ConstName</a:Name>
<a:TEXTITEM.Value>FK_%.U8:CHILD%_%.U9:REFR%_%.U8:PARENT%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Constraint name template for foreign keys</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o146">
<a:Name>CheckOnCommit</a:Name>
<a:TRGTITEM.Comment>Referential integrity test differed after the COMMIT</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o147">
<a:Name>DclDelIntegrity</a:Name>
<a:TEXTITEM.Value>RESTRICT
CASCADE</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Declarative referential integrity constraint allowed for delete</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o148">
<a:Name>Add</a:Name>
<a:TEXTITEM.Value>[constraint %CONSTNAME%] foreign key (%FKEYCOLUMNS%)
      references [%PQUALIFIER%]%PARENT% [(%CKEYCOLUMNS%)]
      [%DELCONST%=RESTRICT?:[on delete %DELCONST%]]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for defining a foreign key</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o149">
<a:Name>Create</a:Name>
<a:TEXTITEM.Value>alter table [%QUALIFIER%]%TABLE%
   add [constraint %CONSTNAME%] foreign key (%FKEYCOLUMNS%)
      references [%PQUALIFIER%]%PARENT% [(%CKEYCOLUMNS%)]
      [%DELCONST%=RESTRICT?:[on delete %DELCONST%]]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for adding a foreign key</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o150">
<a:Name>DclUpdIntegrity</a:Name>
<a:TEXTITEM.Value>RESTRICT</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Declarative referential integrity constraint allowed for update</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o151">
<a:Name>SqlListQuery</a:Name>
<a:TEXTITEM.Value>{COWNER, CHILD, FKCONSTRAINT, POWNER, PARENT, PKCONSTRAINT, DELCONST}

[%ISODBCUSER% ?
select 
   &#39;%SCHEMA%&#39;, 
   C1.table_name,
   C1.constraint_name,
   &#39;%SCHEMA%&#39;,
   C2.table_name,
   C2.constraint_name,
   C1.delete_rule
from
   sys.user_constraints C1,
   sys.user_constraints C2
where
   C1.constraint_type=&#39;R&#39;
   and C1.r_constraint_name=C2.constraint_name
   and C1.generated != &#39;GENERATED_NAME&#39;
   [and C1.table_name=&#39;%TABLE%&#39;]
order by
   C1.table_name
:
select 
   &#39;%SCHEMA%&#39;, 
   C1.table_name,
   C1.constraint_name,
   &#39;%SCHEMA%&#39;,
   C2.table_name,
   C2.constraint_name,
   C1.delete_rule
from
   sys.all_constraints C1,
   sys.all_constraints C2
where
   C1.constraint_type=&#39;R&#39;
   and C1.r_constraint_name=C2.constraint_name
   and C1.generated != &#39;GENERATED_NAME&#39;
   [and C1.table_name=&#39;%TABLE%&#39;]
order by
   C1.table_name
]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to list objects</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o152">
<a:Name>SqlListChildrenQuery</a:Name>
<a:TEXTITEM.Value>{CKEYCOLUMN, FKEYCOLUMN}

[%ISODBCUSER% ?
SELECT COL2.COLUMN_NAME, COL1.COLUMN_NAME
FROM SYS.USER_CONS_COLUMNS COL1, SYS.USER_CONS_COLUMNS COL2
WHERE 
  COL1.POSITION = COL2.POSITION
  AND COL1.TABLE_NAME=&#39;%TABLE%&#39;
  AND COL2.TABLE_NAME=&#39;%PARENT%&#39;
  AND COL1.CONSTRAINT_NAME=&#39;%FKCONSTRAINT%&#39; AND COL2.CONSTRAINT_NAME=&#39;%PKCONSTRAINT%&#39;
ORDER BY COL1.POSITION
:
SELECT COL2.COLUMN_NAME, COL1.COLUMN_NAME
FROM SYS.ALL_CONS_COLUMNS COL1, SYS.ALL_CONS_COLUMNS COL2
WHERE 
  COL1.POSITION = COL2.POSITION
  AND COL1.OWNER=&#39;%SCHEMA%&#39; AND COL1.TABLE_NAME=&#39;%TABLE%&#39;
  AND COL2.OWNER=&#39;%POWNER%&#39; AND COL2.TABLE_NAME=&#39;%PARENT%&#39;
  AND COL1.CONSTRAINT_NAME=&#39;%FKCONSTRAINT%&#39; AND COL2.CONSTRAINT_NAME=&#39;%PKCONSTRAINT%&#39;
ORDER BY COL1.POSITION
]
         </a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to list reference joins</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o153">
<a:Name>SqlAttrQuery</a:Name>
<a:TRGTITEM.Comment>SQL query to reverse object attributes</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o154">
<a:Name>View</a:Name>
<a:Code>VIEW</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
   &quot;VIEW&quot;         // generated code of the view
   &quot;VIEWNAME&quot;     // view name
   &quot;VIEWCODE&quot;     // view code
   &quot;VIEWCOLN&quot;     // List of columns of the view. Ex: &quot;A, B, C&quot;
   &quot;SQL&quot;          // SQL text of the view. Ex: Select * from T1
   &quot;VIEWCHECK&quot;    // Keyword &quot;with check option&quot; if selected on the view
   &quot;SCRIPT&quot;       // complete view creation order. Ex: create view V1 as select * from T1
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o155">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>View allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o156">
<a:Name>Create</a:Name>
<a:TEXTITEM.Value>create [or replace ][%R% [no] force]view [%QUALIFIER%]%VIEW% [(%VIEWCOLN%) ]as
%SQL%
[%VIEWCHECK%] [%R%with read only]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for creating a view. Example: create view %VIEW%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o157">
<a:Name>Drop</a:Name>
<a:TEXTITEM.Value>drop view [%QUALIFIER%]%VIEW%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping a view. Example: drop view %VIEW%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o158">
<a:Name>ViewComment</a:Name>
<a:TEXTITEM.Value>comment on table [%QUALIFIER%]%VIEW% is %.q:COMMENT%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for adding a view comment.</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o159">
<a:Name>ViewCheck</a:Name>
<a:TEXTITEM.Value>with check option</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Option for checking a view</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o160">
<a:Name>SqlListQuery</a:Name>
<a:TEXTITEM.Value>{OWNER ID, VIEW ID, VIEWCOLN ...}

[%ISODBCUSER% ?
select
   &#39;%SCHEMA%&#39;,
   v.view_name, 
   c.column_name||&#39;, &#39;
from 
   sys.user_views v,
   sys.user_tab_columns c
where 
   c.table_name=v.view_name
order by 
   v.view_name, c.column_id
:
select
   v.owner,
   v.view_name, 
   c.column_name||&#39;, &#39;
from 
   sys.all_views v,
   sys.all_tab_columns c
where 
   c.table_name=v.view_name
   and c.owner=v.owner 
   [and v.owner=&#39;%SCHEMA%&#39;]
order by 
   v.owner, v.view_name, c.column_id
]
</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to list objects</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o161">
<a:Name>SqlAttrQuery</a:Name>
<a:TEXTITEM.Value>{OWNER, VIEW, SCRIPT}

[%ISODBCUSER% ?
SELECT &#39;%SCHEMA%&#39;, VIEW_NAME, TEXT
FROM SYS.USER_VIEWS
ORDER BY VIEW_NAME
:
SELECT OWNER, VIEW_NAME, TEXT
FROM SYS.ALL_VIEWS [WHERE OWNER=&#39;%SCHEMA%&#39;]
ORDER BY OWNER, VIEW_NAME
]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to reverse object attributes</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o162">
<a:Name>Tablespace</a:Name>
<a:Code>TSPC</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
   &quot;TABLESPACE&quot;   // generated code of the tablespace
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o163">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>Tablespace allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o164">
<a:Name>Create</a:Name>
<a:TEXTITEM.Value>create tablespace %TABLESPACE%
[%OPTIONS%]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for creating a tablespace. Example: create tablespace %TABLESPACE%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o165">
<a:Name>Drop</a:Name>
<a:TEXTITEM.Value>drop tablespace %TABLESPACE% [including contents ][cascade constraints]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping a tablespace. Example: drop tablespace %TABLESPACE%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o166">
<a:Name>Options</a:Name>
<a:TEXTITEM.Value>datafile : composite=yes, chldmand=yes
{
   &lt;datafile_clause&gt; : composite=yes, separator=yes, multiple=yes
   {
      &lt;file_spec&gt; : composite=yes
      {
         &lt;filename&gt; %s : squoted=yes
         size %d
         reuse
      }
      &lt;autoextend_clause&gt; : composite=yes
      {
         autoextend off
         autoextend on : composite=yes
         {
            next %s
            maxsize %s : default=UNLIMITED
         }
      }
   }
}
minimum extent %s
&lt;log&gt; %s : list=logging | nologging
default storage : category=storage, composite=yes, parenthesis=yes
{
   initial %d : default=10K
   next %d : default=10K
   minextents %d : default=1
   maxextents %d
   maxextents unlimited
   pctincrease %d : default=50
   freelists %d : default=1
   optimal %d
   optimal NULL
   buffer_pool %s : list=keep | recycle | default
}
&lt;online&gt; %s : default=online, list=online | offline
&lt;permanent&gt; %s : default=permanent, list=permanent | temporary</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Default options for creating a tablespace.</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o167">
<a:Name>DefOptions</a:Name>
<a:TRGTITEM.Comment>Default values for tablespace options.</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o168">
<a:Name>SqlListQuery</a:Name>
<a:TEXTITEM.Value>{TABLESPACE}

select
   t.tablespace_name
from 
   user_tablespaces t
order by
   t.tablespace_name
</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to list objects</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o169">
<a:Name>SqlAttrQuery</a:Name>
<a:TEXTITEM.Value>{TABLESPACE ID, OPTIONS ...}

select
   t.tablespace_name,
   &#39;datafile &#39;&#39;&#39;||f.file_name||&#39;&#39;&#39;&#39;||
   decode (f.bytes, 0, &#39;&#39;, &#39; size &#39;||f.bytes/1024||&#39;K&#39;)||
   decode (f.autoextensible, &#39;NO&#39;, &#39; autoextend off&#39;, 
      &#39; autoextend on next &#39;||increment_by*8||&#39;K maxsize &#39;||
      decode (f.maxbytes, 34359721984, &#39;unlimited&#39;, f.maxbytes/1024||&#39;K&#39;)
      ),
   f.file_id
from 
   dba_data_files f, 
   dba_tablespaces t
where
   f.tablespace_name=t.tablespace_name
   and f.file_id = (select min(z.file_id) from dba_data_files z where z.tablespace_name=f.tablespace_name)
union select
   t.tablespace_name,
   &#39;, &#39;&#39;&#39;||f.file_name||&#39;&#39;&#39;&#39;||
   decode (f.bytes, 0, &#39;&#39;, &#39; size &#39;||f.bytes/1024||&#39;K&#39;)||
   decode (f.autoextensible, &#39;NO&#39;, &#39; autoextend off&#39;, 
      &#39; autoextend on next &#39;||increment_by*8||&#39;K maxsize &#39;||
      decode (f.maxbytes, 34359721984, &#39;unlimited&#39;, f.maxbytes/1024||&#39;K&#39;)
      ),
   f.file_id
from 
   dba_data_files f, 
   dba_tablespaces t
where
   f.tablespace_name=t.tablespace_name
   and f.file_id &gt; (select min(z.file_id) from dba_data_files z where z.tablespace_name=f.tablespace_name)
union select
   t.tablespace_name,
   &#39; default storage ( initial &#39;|| (t.initial_extent/1024)||&#39;K &#39; ||
   decode (t.next_extent, 10240, &#39;&#39;, &#39;next &#39;|| (t.next_extent/1024)||&#39;K &#39;) ||
   decode (t.min_extents, 1, &#39;&#39;, &#39;minextents &#39;|| t.min_extents||&#39; &#39;) ||
   decode (t.max_extents, 121, &#39;&#39;, 2147483645, &#39;maxextents unlimited &#39;, &#39;maxextents &#39;|| t.max_extents||&#39; &#39;) ||
   decode (t.pct_increase, 50, &#39;&#39;, &#39;pctincrease &#39;|| t.pct_increase)||&#39;) &#39;||
   decode (t.status, &#39;OFFLINE&#39;, &#39;offline &#39;, &#39;&#39;)||
   decode (t.contents, &#39;PERMANENT&#39;, &#39;&#39;, t.contents),
   999
from 
   dba_tablespaces t
order by 1, 3

</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to reverse object attributes</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o170">
<a:Name>Storage</a:Name>
<a:Code>STOR</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
   &quot;STORAGE&quot;      // generated code of the storage
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o171">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>Storage allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o172">
<a:Name>Create</a:Name>
<a:TRGTITEM.Comment>Command for creating a storage. Example: create storage %STORAGE%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o173">
<a:Name>Drop</a:Name>
<a:TRGTITEM.Comment>Command for dropping a storage. Example: drop storage %STORAGE%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o174">
<a:Name>Options</a:Name>
<a:TEXTITEM.Value>initial %d : default=10K
next %d : default=10K
minextents %d : default=1
maxextents %d
pctincrease %d : default=50
freelists %d : default=1
freelist groups %d : default=1
optimal %d
buffer_pool %s : list=keep | recycle | default</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Default options for creating a storage</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o175">
<a:Name>DefOptions</a:Name>
<a:TRGTITEM.Comment>Default values for storage options</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o176">
<a:Name>SqlListQuery</a:Name>
<a:TRGTITEM.Comment>SQL query to list objects</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o177">
<a:Name>SqlAttrQuery</a:Name>
<a:TEXTITEM.Value>{STORAGE, OPTIONS}

SELECT SEGMENT_NAME, &#39;INITIAL &#39; || INITIAL_EXTENT ||
  &#39; NEXT &#39; || NEXT_EXTENT || &#39; MIN_EXTENTS &#39; || MIN_EXTENTS ||
  &#39; MAX_EXTENTS &#39; || MAX_EXTENTS || &#39; PCTINCREASE &#39; || PCT_INCREASE || 
  &#39; FREELISTS &#39; || FREELISTS || &#39; FREELIST_GROUPS &#39; || FREELIST_GROUPS OPTS
FROM USER_SEGMENTS</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to reverse object attributes</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o178">
<a:Name>Database</a:Name>
<a:Code>DTBS</a:Code>
<c:Item>
<o:SObjTargetItemText Id="o179">
<a:Name>Create</a:Name>
<a:TEXTITEM.Value>create database [%DATABASE%]
[%OPTIONS%]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for creating a database. Example: create database %DATABASE%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o180">
<a:Name>Options</a:Name>
<a:TEXTITEM.Value>controlfile reuse
logfile : composite=yes, separator=yes
{
   &lt;log_file_clause&gt; : composite=yes, multiple=yes
   {
      group %d
      &lt;file_spec&gt; : composite=yes
      {
         &lt;filename&gt; %s
         size %d
         reuse
      }
   }
}
maxlogfiles %d
maxlogmembers %d
maxloghistory %d
maxdatafiles %d
maxinstances %d
&lt;archivelog&gt; %s : default=noarchivelog, list=archivelog | noarchivelog
character set %s
national character set
datafile : composite=yes, separator=yes
{
   &lt;datafile_clause&gt; : composite=yes, multiple=yes
   {
      &lt;file_spec&gt; : composite=yes
      {
         &lt;filename&gt; %s
         size %d
         reuse
      }
      &lt;autoextend_clause&gt; : composite=yes
      {
         autoextend off
         autoextend on : composite=yes
         {
            next %s
            maxsize %s : default=UNLIMITED
         }
      }
   }
}
</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Available options for creating a database</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o181">
<a:Name>DefOptions</a:Name>
<a:TRGTITEM.Comment>Default values for database options</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o182">
<a:Name>OpenDatabase</a:Name>
<a:TRGTITEM.Comment>Command for opening a database. Example: open database %DATABASE%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o183">
<a:Name>CloseDatabase</a:Name>
<a:TRGTITEM.Comment>Command for closing a database. Example: close database</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o184">
<a:Name>Drop</a:Name>
<a:TRGTITEM.Comment>Command for dropping a database. Example: drop database %DATABASE%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o185">
<a:Name>Abstract Data Type</a:Name>
<a:Code>ADT</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
   &quot;ADT&quot;          // generated code of the abstract data type
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o186">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>Abstract Data Types allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o187">
<a:Name>EnableAdtOnDomn</a:Name>
<a:TRGTITEM.Comment>Abstract Data Types allowed on domain</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o188">
<a:Name>EnableAdtOnColn</a:Name>
<a:TRGTITEM.Comment>Abstract Data Types allowed on column</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o189">
<a:Name>SqlListQuery</a:Name>
<a:TEXTITEM.Value>{ADT, OWNER , TYPE (&#39;VARYING ARRAY&#39;=VARRAY) , SIZE,  DTTPCODE, LENGTH, PREC}
SELECT type_name, owner, coll_type, upper_bound, elem_type_name, length, precision
FROM all_coll_types
UNION
SELECT u.type_name, a.owner, u.typecode, 0, &#39;&#39;, 0, 0
FROM user_types u, all_types a
WHERE (u.typecode=&#39;OBJECT&#39; AND u.incomplete=&#39;NO&#39;)
AND u.type_oid=a.type_oid
ORDER BY type_name</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to list objects</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o190">
<a:Name>Create</a:Name>
<a:TEXTITEM.Value>[%ISARRAY% ? create [or replace ] type %ADT% as %TYPE% (%SIZE%) of %DATATYPE%]
[%ISLIST%   ? create [or replace ] type %ADT% as %TYPE% of %DATATYPE%]
[%ISOBJECT% ? create [or replace ] type %ADT% as %TYPE%
(
    %ADTDEF%
)]</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for adding an abstract data type</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o191">
<a:Name>Drop</a:Name>
<a:TEXTITEM.Value>drop type %ADT%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping an abstract data type</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o192">
<a:Name>AllowedADT</a:Name>
<a:TEXTITEM.Value>OBJECT</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>List of ADTs which can be used as the datatype of an ADT type</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o193">
<a:Name>User</a:Name>
<a:Code>USER</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
   &quot;USER&quot;          // generated code of the user
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o194">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>User allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemInt Id="o195">
<a:Name>Maxlen</a:Name>
<a:TRGTITEM.Comment>User name length</a:TRGTITEM.Comment>
<a:INTITEM.Value>30</a:INTITEM.Value>
</o:SObjTargetItemInt>
<o:SObjTargetItemText Id="o196">
<a:Name>SqlListQuery</a:Name>
<a:TEXTITEM.Value>{USER}
         
SELECT USERNAME FROM ALL_USERS ORDER BY USERNAME</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to list objects</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o197">
<a:Name>SqlAttrQuery</a:Name>
<a:TRGTITEM.Comment>SQL query to reverse object attributes</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o198">
<a:Name>Trigger</a:Name>
<a:Code>TRGR</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
(parent table items are also available for indexes)
 trigger object specific items
   &quot;ORDER&quot;      // Order number of the trigger (for sort of trigger when the DBMS support more than one trigger of one type)
   &quot;TRIGGER&quot;    // generated code of trigger
   &quot;TRGTYPE&quot;    // trigger type (keywords &quot;beforeinsert&quot;, &quot;afterupdate&quot;, ...)
   &quot;TRGEVENT&quot;   // trigger event (keywords &quot;insert&quot;, &quot;update&quot;, &quot;delete&quot;
   &quot;TRGTIME&quot;    // trigger time (keywords NULL, &quot;before&quot;, &quot;after&quot;
 inside the body of the trigger, macros redefine variables on objects
   &quot;REFNO&quot;      // reference position in the list of references of the table
 customized error messages management
   &quot;ERRNO&quot;      // error number for standard error
   &quot;ERRMSG&quot;     // error message for standard error
   &quot;MSGTAB&quot;     // name of the table containing user-defined error messages
   &quot;MSGNO&quot;      // in the user-defined error table, name of the column containing the error numbers
   &quot;MSGTXT&quot;     // in the user-defined error table, name of the column containing the error messages
   &quot;SCRIPT&quot;     // body of trigger or procedure       
       </a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemBool Id="o199">
<a:Name>Enable</a:Name>
<a:TRGTITEM.Comment>Trigger allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemBool Id="o200">
<a:Name>EnableMultiTrigger</a:Name>
<a:TRGTITEM.Comment>Multi trigger allowed</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItemText Id="o201">
<a:Name>DefaultTriggerName</a:Name>
<a:TEXTITEM.Value>%TEMPLATE%_%.L:TABLE%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Default trigger name</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemInt Id="o202">
<a:Name>Maxlen</a:Name>
<a:TRGTITEM.Comment>Trigger name length</a:TRGTITEM.Comment>
<a:INTITEM.Value>30</a:INTITEM.Value>
</o:SObjTargetItemInt>
<o:SObjTargetItemText Id="o203">
<a:Name>Drop</a:Name>
<a:TEXTITEM.Value>drop trigger [%QUALIFIER%]%TRIGGER%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for dropping a trigger. Example: drop trigger %TRIGGER%</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o204">
<a:Name>SqlListQuery</a:Name>
<a:TEXTITEM.Value>{OWNER, TABLE, TRIGGER, TRGEVENT, TRGTIME}
         
[%ISODBCUSER% ?select 
   &#39;%SCHEMA%&#39;,
   table_name,
   trigger_name, 
   lower(triggering_event),
   decode (substr(trigger_type, 1, 1),&#39;A&#39;, &#39;after&#39;, &#39;B&#39;, &#39;before&#39;)
from
   sys.user_triggers
order by
   table_name
:select 
   owner,
   table_name,
   trigger_name, 
   lower(triggering_event),
   decode (substr(trigger_type, 1, 1),&#39;A&#39;, &#39;after&#39;, &#39;B&#39;, &#39;before&#39;)
from
   sys.all_triggers
[where owner=&#39;%SCHEMA%&#39;]
order by
   owner, table_name
]
</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to list objects</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o205">
<a:Name>SqlAttrQuery</a:Name>
<a:TEXTITEM.Value>{OWNER, TABLE, TRIGGER, TRGDESC, TRGBODY}
                  
[%ISODBCUSER% ?
SELECT &#39;%SCHEMA%&#39;, TABLE_NAME, TRIGGER_NAME, &#39;create trigger &#39; || DESCRIPTION, TRIGGER_BODY
FROM SYS.USER_TRIGGERS [WHERE TABLE_NAME=&#39;%TABLE%&#39;]
ORDER BY TABLE_NAME
:
SELECT OWNER, TABLE_NAME, TRIGGER_NAME, &#39;create trigger &#39; || DESCRIPTION, TRIGGER_BODY
FROM SYS.ALL_TRIGGERS [WHERE OWNER=&#39;%SCHEMA%&#39; [AND TABLE_NAME=&#39;%TABLE%&#39;]]
ORDER BY OWNER, TABLE_NAME
]
         </a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to reverse object attributes</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o206">
<a:Name>UseErrorMsgTable</a:Name>
<a:TEXTITEM.Value>select %MSGNO%, %MSGTXT%
into   errno, errmsg
from   %MSGTAB%
where  %MSGNO% = %ERRNO%;
raise integrity_error;</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Errors handling using an error messages table</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o207">
<a:Name>UseErrorMsgText</a:Name>
<a:TEXTITEM.Value>errno  := %ERRNO%;
errmsg := &#39;%ERRMSG%&#39;;
raise integrity_error;</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Errors handling using fixed error messages</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItemInt Id="o208">
<a:Name>MaxConstLen</a:Name>
<a:TRGTITEM.Comment>Constraint name length</a:TRGTITEM.Comment>
<a:INTITEM.Value>30</a:INTITEM.Value>
</o:SObjTargetItemInt>
<o:SObjTargetItemBool Id="o209">
<a:Name>EnableOption</a:Name>
<a:TRGTITEM.Comment>Physical options allowed  YES/NO</a:TRGTITEM.Comment>
<a:BOOLITEM.Value>1</a:BOOLITEM.Value>
</o:SObjTargetItemBool>
<o:SObjTargetItem Id="o210">
<a:Name>Abstract Data Type Attribute</a:Name>
<a:Code>ATTR</a:Code>
<a:TRGTITEM.Comment>The following system variables are available:
   &quot;ATTR&quot;          // generated code of the abstract data type attribute</a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemText Id="o211">
<a:Name>Add</a:Name>
<a:TEXTITEM.Value>%ADTATTR% %DATATYPE%</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>Command for defining an abstract data type attribute
</a:TRGTITEM.Comment>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o212">
<a:Name>SqlListQuery</a:Name>
<a:TEXTITEM.Value>{ ADT, ADTATTR , DTTPCODE, LENGTH, PREC }
SELECT type_name, attr_name, attr_type_name, length, precision
FROM all_type_attrs
ORDER BY type_name</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>SQL query to list objects</a:TRGTITEM.Comment>
<a:TRGTITEM.Type>1</a:TRGTITEM.Type>
</o:SObjTargetItemText>
<o:SObjTargetItemText Id="o213">
<a:Name>AllowedADT</a:Name>
<a:TEXTITEM.Value>OBJECT
TABLE
VARRAY</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>List of ADTs which can be used as the datatype of an ADT attribute</a:TRGTITEM.Comment>
<a:TRGTITEM.Type>1</a:TRGTITEM.Type>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o214">
<a:Name>DataType</a:Name>
<a:TRGTITEM.Comment>Contains data type translation entries. These entries list the correspondence between internal data types and the target database data types</a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItemMap Id="o215">
<a:Name>AmcdDataType</a:Name>
<a:TRGTITEM.Comment>Data types translation table from internal data types to target database data types. 
        %n is the length of the data type
        %s is the size of the data type
        %p is the precision of the data type</a:TRGTITEM.Comment>
<a:MAPITEM.Value>&lt;UNDEF&gt;=&lt;Undefined&gt;
A%n=CHAR(%n)
VA%n=VARCHAR2(%n)
LA=LONG
LA%n=LONG
LVA=LONG
LVA%n=LONG
BT=SMALLINT
BT%n=SMALLINT
SI=SMALLINT
I=INTEGER
LI=INTEGER
N=NUMBER
N%n=NUMBER(%n)
N%s,%p=NUMBER(%s,%p)
DC=NUMBER
DC%n=NUMBER(%n)
DC%s,%p=NUMBER(%s,%p)
SF=FLOAT
F=FLOAT
F%n=FLOAT(%n)
LF=FLOAT
MN=NUMBER(8,2)
MN%n=NUMBER(%n)
MN%s,%p=NUMBER(%s,%p)
D=DATE
T=DATE
DT=DATE
TS=DATE
BL=SMALLINT
NO=NUMBER(6)
NO%n=NUMBER(%n)
BIN%n=RAW(%n)
LBIN=LONG RAW
LBIN%n=LONG RAW
TXT=LONG
TXT%n=LONG
MBT=NCHAR(1)
MBT%n=NCHAR(%n)
VMBT=NVARCHAR2(255)
VMBT%n=NVARCHAR2(%n)
PIC=LONG RAW
PIC%n=LONG RAW
BMP=LONG RAW
BMP%n=LONG RAW
OLE=LONG RAW
OLE%n=LONG RAW
*=CHAR(10)</a:MAPITEM.Value>
<a:List>&lt;UNDEF&gt;
A%n
VA%n
LA
LA%n
LVA
LVA%n
BT
BT%n
SI
I
LI
N
N%n
N%s,%p
DC
DC%n
DC%s,%p
SF
F
F%n
LF
MN
MN%n
MN%s,%p
D
T
DT
TS
BL
NO
NO%n
BIN%n
LBIN
LBIN%n
TXT
TXT%n
MBT
MBT%n
VMBT
VMBT%n
PIC
PIC%n
BMP
BMP%n
OLE
OLE%n
</a:List>
</o:SObjTargetItemMap>
<o:SObjTargetItemMap Id="o216">
<a:Name>PhysDataType</a:Name>
<a:TRGTITEM.Comment>Data types translation table from target database data types to internal data types.</a:TRGTITEM.Comment>
<a:MAPITEM.Value>&lt;Undefined&gt;=&lt;UNDEF&gt;
CHAR=A1
CHARACTER=A1
CHAR(%n)=A%n
NCHAR(%n)=MBT%n
CHARACTER(%n)=A%n
CHARACTER VARYING(%n)=VA%n
CHAR VARYING(%n)=VA%n
VARCHAR(%n)=VA%n
VARCHAR2(%n)=VA%n
NVARCHAR2(%n)=VMBT%n
LONG=LA
LONG VARCHAR=LVA
SMALLINT=SI
INT=I
INTEGER=I
REAL=N
DOUBLE PRECISION=N
DEC=N
DEC(%n)=N%n
DEC(%s,%p)=N%s,%p
DECIMAL=N
DECIMAL(%n)=N%n
DECIMAL(%s,%p)=N%s,%p
NUMBER=N
NUMBER(%n)=N%n
NUMBER(%s,%p)=N%s,%p
FLOAT=F
FLOAT(%n)=F%n
DATE=DT
RAW(%n)=BIN%n
LONG RAW=LBIN
MLSLABEL=BIN
CLOB=LBIN
NCLOB=LBIN
BLOB=LBIN
BFILE=LBIN
*=A10
ROWID=A64</a:MAPITEM.Value>
<a:List>&lt;Undefined&gt;
CHAR
CHARACTER
CHAR(%n)
NCHAR(%n)
CHARACTER(%n)
CHARACTER VARYING(%n)
CHAR VARYING(%n)
VARCHAR(%n)
VARCHAR2(%n)
NVARCHAR2(%n)
LONG
LONG VARCHAR
SMALLINT
INT
INTEGER
REAL
DOUBLE PRECISION
DEC
DEC(%n)
DEC(%s,%p)
DECIMAL
DECIMAL(%n)
DECIMAL(%s,%p)
NUMBER
NUMBER(%n)
NUMBER(%s,%p)
FLOAT
FLOAT(%n)
DATE
RAW(%n)
LONG RAW
MLSLABEL
CLOB
NCLOB
BLOB
BFILE
ROWID
</a:List>
</o:SObjTargetItemMap>
<o:SObjTargetItemMap Id="o217">
<a:Name>PhysDttpSize</a:Name>
<a:TRGTITEM.Comment>Table of storage sizes of target database data type</a:TRGTITEM.Comment>
<a:MAPITEM.Value>DATE=7</a:MAPITEM.Value>
<a:List>DATE
</a:List>
</o:SObjTargetItemMap>
<o:SObjTargetItemMap Id="o218">
<a:Name>OdbcPhysDataType</a:Name>
<a:TRGTITEM.Comment>Data types translation table from ODBC data types to target database data types.</a:TRGTITEM.Comment>
<a:MAPITEM.Value>CHAR(1)=CHAR
NUMBER(22)=NUMBER
FLOAT(126)=FLOAT
FLOAT(63)=REAL</a:MAPITEM.Value>
<a:List>CHAR(1)
NUMBER(22)
FLOAT(126)
FLOAT(63)
</a:List>
</o:SObjTargetItemMap>
<o:SObjTargetItemMap Id="o219">
<a:Name>HostDataType</a:Name>
<a:TRGTITEM.Comment>Date types translation from database data type to procedure data type</a:TRGTITEM.Comment>
<a:MAPITEM.Value>CHAR=char
CHARACTER=char
CHAR(%n)=varchar
CHARACTER(%n)=varchar
CHARACTER VARYING(%n)=varchar
CHAR VARYING(%n)=varchar
VARCHAR(%n)=varchar
VARCHAR2(%n)=varchar
LONG=long
LONG VARCHAR=long
SMALLINT=integer
INT=integer
INTEGER=integer
REAL=number
DOUBLE PRECISION=number
DEC=number
DEC(%n)=number
DEC(%s,%p)=number
DECIMAL=number
DECIMAL(%n)=number
DECIMAL(%s,%p)=number
NUMBER=number
NUMBER(%n)=number
NUMBER(%s,%p)=number
FLOAT=float
FLOAT(%n)=number
DATE=date
RAW(%n)=raw
LONG RAW=raw</a:MAPITEM.Value>
<a:List>CHAR
CHARACTER
CHAR(%n)
CHARACTER(%n)
CHARACTER VARYING(%n)
CHAR VARYING(%n)
VARCHAR(%n)
VARCHAR2(%n)
LONG
LONG VARCHAR
SMALLINT
INT
INTEGER
REAL
DOUBLE PRECISION
DEC
DEC(%n)
DEC(%s,%p)
DECIMAL
DECIMAL(%n)
DECIMAL(%s,%p)
NUMBER
NUMBER(%n)
NUMBER(%s,%p)
FLOAT
FLOAT(%n)
DATE
RAW(%n)
LONG RAW
</a:List>
</o:SObjTargetItemMap>
<o:SObjTargetItemMap Id="o220">
<a:Name>PhysLogADTType</a:Name>
<a:TRGTITEM.Comment>Abstract Data types translation table from target database abstract data types to PowerDesigner internal abstract data types.</a:TRGTITEM.Comment>
<a:TRGTITEM.Type>1</a:TRGTITEM.Type>
<a:MAPITEM.Value>OBJECT=Object
TABLE=List
VARRAY=Array</a:MAPITEM.Value>
<a:List>OBJECT
TABLE
VARRAY
</a:List>
</o:SObjTargetItemMap>
<o:SObjTargetItemMap Id="o221">
<a:Name>LogPhysADTType</a:Name>
<a:TRGTITEM.Comment>Abstract Data types translation table from internal abstract data types to target database abstract data types.</a:TRGTITEM.Comment>
<a:TRGTITEM.Type>1</a:TRGTITEM.Type>
<a:MAPITEM.Value>Array=VARRAY
Java=&lt;Undefined&gt;
List=TABLE
Object=OBJECT
Structured=&lt;Undefined&gt;</a:MAPITEM.Value>
<a:List>Array
Java
List
Object
Structured
</a:List>
</o:SObjTargetItemMap>
<o:SObjTargetItemText Id="o222">
<a:Name>AllowedADT</a:Name>
<a:TEXTITEM.Value>OBJECT
TABLE
VARRAY</a:TEXTITEM.Value>
<a:TRGTITEM.Comment>The list of ADT which can be used as the datatype of a domain or column</a:TRGTITEM.Comment>
<a:TRGTITEM.Type>1</a:TRGTITEM.Type>
</o:SObjTargetItemText>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o223">
<a:Name>Customize</a:Name>
<a:TRGTITEM.Comment>Retrieves information from PowerDesigner Version 6 DBMS definition files. It is not used in Version 7.</a:TRGTITEM.Comment>
</o:SObjTargetItem>
</c:Item>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o224">
<a:Name>Extended Attributes</a:Name>
<a:Code>Extended Attributes</a:Code>
<a:TRGTITEM.Comment>Extended Attributes definition</a:TRGTITEM.Comment>
<c:Item>
<o:SObjTargetItem Id="o225">
<a:Name>Types</a:Name>
<a:Code>Types</a:Code>
<a:TRGTITEM.Comment>Defines extended attribute types that can be used into the DBMS.</a:TRGTITEM.Comment>
</o:SObjTargetItem>
<o:SObjTargetItem Id="o226">
<a:Name>Objects</a:Name>
<a:Code>Objects</a:Code>
<a:TRGTITEM.Comment>Defines each type of object which needs extended attributes for the DBMS.</a:TRGTITEM.Comment>
</o:SObjTargetItem>
</c:Item>
</o:SObjTargetItem>
</c:Item>
<c:TrgrItems>
<o:SPdoObjTrgi Id="o227">
<a:OID>4D4FEE04-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>InsertChildParentExist</a:Name>
<a:Code>InsertChildParentExist</a:Code>
<a:Text>.FOREACH_PARENT()
--  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when inserting a child in &quot;[%CQUALIFIER%]%CHILD%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cpk%REFNO%_%.25L:TABLE%&quot;
if .JOIN(&quot;:new.%FK% is not null&quot;, &quot;&quot;, &quot; and&quot;, &quot; then&quot;)
   open  %CURSOR%(.JOIN(&quot;:new.%FK%&quot;, &quot;&quot;, &quot;,&quot;, &quot;);&quot;)
   fetch %CURSOR% into dummy;
   found := %CURSOR%%FOUND;
   close %CURSOR%;
   if not found then
      .ERROR(-20002, &quot;Parent does not exist in &quot;[%PQUALIFIER%]%PARENT%&quot;. Cannot create child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
   end if;
end if;

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Parent must exist when inserting child constraint</a:Labl>
<a:Decl>.FOREACH_PARENT()
--  Declaration of InsertChildParentExist constraint for the parent &quot;[%PQUALIFIER%]%PARENT%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cpk%REFNO%_%.25L:TABLE%&quot;
cursor %CURSOR%(.JOIN(&quot;var_%.L26:FK% %.L:HOSTCOLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;) is&quot;)
   select 1
   from   [%PQUALIFIER%]%PARENT%
   where  .JOIN(&quot;%PK% = var_%.L26:FK%&quot;, &quot;and   &quot;)
    and   .JOIN(&quot;var_%.L26:FK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o228">
<a:OID>4D4FEE05-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>InsertTooManyChildren</a:Name>
<a:Code>InsertTooManyChildren</a:Code>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Cannot exceed the maximum cardinality constraint when inserting the child</a:Labl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o229">
<a:OID>4D4FEE09-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>UpdateChangeColumn</a:Name>
<a:Code>UpdateChangeColumn</a:Code>
<a:Text>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
--  Non modifiable column &quot;%COLUMN%&quot; cannot be modified
if updating(&#39;%COLUMN%&#39;) and :old.%COLUMN% != :new.%COLUMN% then
   .ERROR(-20001, &quot;Non modifiable column &quot;%COLUMN%&quot; cannot be modified.&quot;)
end if;

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Cannot modify non modifiable column constraint</a:Labl>
<a:Decl>.FOREACH_COLUMN(&quot;NMFCOL&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o230">
<a:OID>4D4FEE0A-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>UpdateChildParentExist</a:Name>
<a:Code>UpdateChildParentExist</a:Code>
<a:Text>seq := IntegrityPackage.GetNestLevel;
.FOREACH_PARENT()
--  Parent &quot;[%PQUALIFIER%]%PARENT%&quot; must exist when updating a child in &quot;[%CQUALIFIER%]%CHILD%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cpk%REFNO%_%.25L:TABLE%&quot;
if .JOIN(&quot;(:new.%FK% is not null)&quot;, &quot;&quot;, &quot; and&quot;, &quot; and (seq = 0) then &quot;) 
   open  %CURSOR%(.JOIN(&quot;:new.%FK%&quot;, &quot;&quot;, &quot;,&quot;, &quot;);&quot;)
   fetch %CURSOR% into dummy;
   found := %CURSOR%%FOUND;
   close %CURSOR%;
   if not found then
      .ERROR(-20003, &quot;Parent does not exist in &quot;[%PQUALIFIER%]%PARENT%&quot;. Cannot update child in &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
   end if;
end if;

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Parent must exist when updating a child constraint</a:Labl>
<a:Decl>seq NUMBER;
.FOREACH_PARENT()
--  Declaration of UpdateChildParentExist constraint for the parent &quot;[%PQUALIFIER%]%PARENT%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cpk%REFNO%_%.25L:TABLE%&quot;
cursor %CURSOR%(.JOIN(&quot;var_%.L26:FK% %.L:HOSTCOLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;) is&quot;)
   select 1
   from   [%PQUALIFIER%]%PARENT%
   where  .JOIN(&quot;%PK% = var_%.L26:FK%&quot;, &quot;and   &quot;)
    and   .JOIN(&quot;var_%.L26:FK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o231">
<a:OID>4D4FEE0B-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>UpdateTooManyChildren</a:Name>
<a:Code>UpdateTooManyChildren</a:Code>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Cannot exceed the maximum cardinality constraint when updating the child</a:Labl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o232">
<a:OID>4D4FEE0C-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>UpdateChildChangeParent</a:Name>
<a:Code>UpdateChildChangeParent</a:Code>
<a:Text>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
--  Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;(updating(&#39;%FK%&#39;) and :old.%FK% != :new.%FK%)&quot;, &quot;&quot;, &quot; or&quot;, &quot; then&quot;)
   .ERROR(-20004, &quot;Cannot modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; in child &quot;[%CQUALIFIER%]%CHILD%&quot;.&quot;)
end if;

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Cannot change parent constraint</a:Labl>
<a:Decl>.FOREACH_PARENT(&quot;FKCANTCHG&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o233">
<a:OID>4D4FEE0D-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>UpdateParentRestrict</a:Name>
<a:Code>UpdateParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
--  Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;(updating(&#39;%PK%&#39;) and :old.%PK% != :new.%PK%)&quot;, &quot;&quot;, &quot; or&quot;, &quot; then&quot;)
.DEFINE &quot;CURSOR&quot; &quot;cfk%REFNO%_%.25L:TABLE%&quot;
   open  %CURSOR%(.JOIN(&quot;:old.%PK%&quot;, &quot;&quot;, &quot;,&quot;, &quot;);&quot;)
   fetch %CURSOR% into dummy;
   found := %CURSOR%%FOUND;
   close %CURSOR%;
   if found then
      .ERROR(-20005, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot modify parent code in &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)
   end if;
end if;

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Update restrict constraint</a:Labl>
<a:Decl>.FOREACH_CHILD(&quot;UPDATE RESTRICT&quot;)
--  Declaration of UpdateParentRestrict constraint for &quot;[%CQUALIFIER%]%CHILD%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cfk%REFNO%_%.25L:TABLE%&quot;
cursor %CURSOR%(.JOIN(&quot;var_%.L26:PK% %.L:HOSTCOLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;) is&quot;)
   select 1
   from   [%CQUALIFIER%]%CHILD%
   where  .JOIN(&quot;%FK% = var_%.L26:PK%&quot;, &quot;and   &quot;)
    and   .JOIN(&quot;var_%.L26:PK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o234">
<a:OID>4D4FEE0E-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>UpdateParentCascade</a:Name>
<a:Code>UpdateParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
--  Modify parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; for all children in &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;(updating(&#39;%PK%&#39;) and :old.%PK% != :new.%PK%)&quot;, &quot;&quot;, &quot; or&quot;, &quot; then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = :new.%PK%&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Update cascade constraint</a:Labl>
<a:Decl>.FOREACH_CHILD(&quot;UPDATE CASCADE&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o235">
<a:OID>4D4FEE0F-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>UpdateParentSetNull</a:Name>
<a:Code>UpdateParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;(updating(&#39;%PK%&#39;) and :old.%PK% != :new.%PK%)&quot;, &quot;&quot;, &quot; or&quot;, &quot; then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Update set null constraint</a:Labl>
<a:Decl>.FOREACH_CHILD(&quot;UPDATE SETNULL&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o236">
<a:OID>4D4FEE10-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>UpdateParentSetDefault</a:Name>
<a:Code>UpdateParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot; 
.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;
if .JOIN(&quot;(updating(&#39;%PK%&#39;) and :old.%PK% != :new.%PK%)&quot;, &quot;&quot;, &quot; or&quot;, &quot; then&quot;)
   update [%CQUALIFIER%]%CHILD%
    set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
   where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
end if;

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Update set default constraint</a:Labl>
<a:Decl>.FOREACH_CHILD(&quot;UPDATE SETDEFAULT&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o237">
<a:OID>4D4FEE13-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>DeleteParentRestrict</a:Name>
<a:Code>DeleteParentRestrict</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
--  Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot; if children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cfk%REFNO%_%.25L:TABLE%&quot;
open  %CURSOR%(.JOIN(&quot;:old.%PK%&quot;, &quot;&quot;, &quot;,&quot;, &quot;);&quot;)
fetch %CURSOR% into dummy;
found := %CURSOR%%FOUND;
close %CURSOR%;
if found then
   .ERROR(-20006, &quot;Children still exist in &quot;[%CQUALIFIER%]%CHILD%&quot;. Cannot delete parent &quot;[%PQUALIFIER%]%PARENT%&quot;.&quot;)
end if;

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Delete restrict constraint</a:Labl>
<a:Decl>.FOREACH_CHILD(&quot;DELETE RESTRICT&quot;)
--  Declaration of DeleteParentRestrict constraint for &quot;[%CQUALIFIER%]%CHILD%&quot;
.DEFINE &quot;CURSOR&quot; &quot;cfk%REFNO%_%.25L:TABLE%&quot;
cursor %CURSOR%(.JOIN(&quot;var_%.L26:PK% %.L:HOSTCOLTYPE%&quot;, &quot;&quot;, &quot;,&quot;, &quot;) is&quot;)
   select 1
   from   [%CQUALIFIER%]%CHILD%
   where  .JOIN(&quot;%FK% = var_%.L26:PK%&quot;, &quot;and   &quot;)
    and   .JOIN(&quot;var_%.L26:PK% is not null&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o238">
<a:OID>4D4FEE14-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>DeleteParentCascade</a:Name>
<a:Code>DeleteParentCascade</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
--  Delete all children in &quot;[%CQUALIFIER%]%CHILD%&quot;
delete [%CQUALIFIER%]%CHILD%
where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Delete cascade constraint</a:Labl>
<a:Decl>.FOREACH_CHILD(&quot;DELETE CASCADE&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o239">
<a:OID>4D4FEE15-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>DeleteParentSetNull</a:Name>
<a:Code>DeleteParentSetNull</a:Code>
<a:Text>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
--  Set parent code of &quot;[%PQUALIFIER%]%PARENT%&quot; to NULL in child &quot;[%CQUALIFIER%]%CHILD%&quot;
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = NULL&quot;, &quot;&quot;, &quot;,&quot;)
where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Delete set null constraint</a:Labl>
<a:Decl>.FOREACH_CHILD(&quot;DELETE SETNULL&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
<o:SPdoObjTrgi Id="o240">
<a:OID>4D4FEE16-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>DeleteParentSetDefault</a:Name>
<a:Code>DeleteParentSetDefault</a:Code>
<a:Text>.DEFINE &quot;_DEFAULT&quot; &quot;NULL&quot; 
.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
--  Set parent code &quot;[%PQUALIFIER%]%PARENT%&quot; to default in &quot;[%CQUALIFIER%]%CHILD%&quot;
update [%CQUALIFIER%]%CHILD%
 set   .JOIN(&quot;%FK% = %DEFAULT%&quot;, &quot;&quot;, &quot;,&quot;)
where  .JOIN(&quot;%FK% = :old.%PK%&quot;, &quot;and   &quot;, &quot;&quot;, &quot;;&quot;)

.ENDFOR</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Delete set default constraint</a:Labl>
<a:Decl>.FOREACH_CHILD(&quot;DELETE SETDEFAULT&quot;)
.ENDFOR</a:Decl>
</o:SPdoObjTrgi>
</c:TrgrItems>
<c:TrgrTemplates>
<o:SPdoObjTrgt Id="o241">
<a:OID>4D4FEE03-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>BeforeInsertTrigger</a:Name>
<a:Code>BeforeInsertTrigger</a:Code>
<a:Text>--  Before insert trigger &quot;[%QUALIFIER%]%TRIGGER%&quot; for table &quot;[%QUALIFIER%]%TABLE%&quot;
create trigger [%QUALIFIER%]%TRIGGER% before insert
on [%QUALIFIER%]%TABLE% for each row
declare
    integrity_error  exception;
    errno            integer;
    errmsg           char(200);
    dummy            integer;
    found            boolean;
    .DeclInsertChildParentExist

begin
    .InsertChildParentExist

--  Errors handling
exception
    when integrity_error then
       raise_application_error(errno, errmsg);
end;
/</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Before insert trigger</a:Labl>
<a:Tnam>tib_%.L:TABLE%</a:Tnam>
<a:TRGT.Type>BI</a:TRGT.Type>
<c:TRGT.Items>
<o:SPdoObjTrgi Ref="o227"/>
</c:TRGT.Items>
</o:SPdoObjTrgt>
<o:SPdoObjTrgt Id="o242">
<a:OID>4D4FEE06-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>AfterInsertTrigger</a:Name>
<a:Code>AfterInsertTrigger</a:Code>
<a:Text>--  After insert trigger &quot;[%QUALIFIER%]%TRIGGER%&quot; for table &quot;[%QUALIFIER%]%TABLE%&quot;
create trigger [%QUALIFIER%]%TRIGGER% after insert
on [%QUALIFIER%]%TABLE% for each row
begin
end;
/</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>After insert trigger</a:Labl>
<a:Tnam>tia_%.L:TABLE%</a:Tnam>
<a:TRGT.Type>AI</a:TRGT.Type>
</o:SPdoObjTrgt>
<o:SPdoObjTrgt Id="o243">
<a:OID>4D4FEE07-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>BeforeUpdateTrigger</a:Name>
<a:Code>BeforeUpdateTrigger</a:Code>
<a:Text>--  Before update trigger &quot;[%QUALIFIER%]%TRIGGER%&quot; for table &quot;[%QUALIFIER%]%TABLE%&quot;
create trigger [%QUALIFIER%]%TRIGGER% before update
of .INCOLN(&quot;%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;)
on [%QUALIFIER%]%TABLE% for each row
declare  
    integrity_error  exception;
    errno            integer;
    errmsg           char(200);
    dummy            integer;
    found            boolean;
    .DeclUpdateChangeColumn
    .DeclUpdateChildParentExist
    .DeclUpdateChildChangeParent
    .DeclUpdateParentRestrict

begin
    .UpdateChangeColumn
    .UpdateChildParentExist
    .UpdateChildChangeParent
    .UpdateParentRestrict

--  Errors handling
exception
    when integrity_error then
       raise_application_error(errno, errmsg);
end;
/</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Before update trigger</a:Labl>
<a:Tnam>tub_%.L:TABLE%</a:Tnam>
<a:TRGT.Type>BU</a:TRGT.Type>
<c:TRGT.Items>
<o:SPdoObjTrgi Ref="o230"/>
<o:SPdoObjTrgi Ref="o229"/>
<o:SPdoObjTrgi Ref="o233"/>
<o:SPdoObjTrgi Ref="o232"/>
</c:TRGT.Items>
</o:SPdoObjTrgt>
<o:SPdoObjTrgt Id="o244">
<a:OID>4D4FEE08-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>AfterUpdateTrigger</a:Name>
<a:Code>AfterUpdateTrigger</a:Code>
<a:Text>--  After update trigger &quot;[%QUALIFIER%]%TRIGGER%&quot; for table &quot;[%QUALIFIER%]%TABLE%&quot;
create trigger [%QUALIFIER%]%TRIGGER% after update
of .INCOLN(&quot;%COLUMN%&quot;, &quot;&quot;, &quot;,&quot;)
on [%QUALIFIER%]%TABLE% for each row
declare  
    integrity_error  exception;
    errno            integer;
    errmsg           char(200);
    dummy            integer;
    found            boolean;
    .DeclUpdateParentCascade
    .DeclUpdateParentSetNull
    .DeclUpdateParentSetDefault
begin
    IntegrityPackage.NextNestLevel;
    .UpdateParentCascade
    .UpdateParentSetNull
    .UpdateParentSetDefault
    IntegrityPackage.PreviousNestLevel;

--  Errors handling
exception
    when integrity_error then
       begin
       IntegrityPackage.InitNestLevel;
       raise_application_error(errno, errmsg);
       end;
end;
/</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>After update trigger</a:Labl>
<a:Tnam>tua_%.L:TABLE%</a:Tnam>
<a:TRGT.Type>AU</a:TRGT.Type>
<c:TRGT.Items>
<o:SPdoObjTrgi Ref="o236"/>
<o:SPdoObjTrgi Ref="o235"/>
<o:SPdoObjTrgi Ref="o234"/>
</c:TRGT.Items>
</o:SPdoObjTrgt>
<o:SPdoObjTrgt Id="o245">
<a:OID>4D4FEE11-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>BeforeDeleteTrigger</a:Name>
<a:Code>BeforeDeleteTrigger</a:Code>
<a:Text>--  Before delete trigger &quot;[%QUALIFIER%]%TRIGGER%&quot; for table &quot;[%QUALIFIER%]%TABLE%&quot;
create trigger [%QUALIFIER%]%TRIGGER% before delete 
on [%QUALIFIER%]%TABLE% for each row
declare
    integrity_error  exception;
    errno            integer;
    errmsg           char(200);
    dummy            integer;
    found            boolean;
    .DeclDeleteParentRestrict

begin
    .DeleteParentRestrict

--  Errors handling
exception
    when integrity_error then
       raise_application_error(errno, errmsg);
end;
/</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>Before delete trigger</a:Labl>
<a:Tnam>tdb_%.L:TABLE%</a:Tnam>
<a:TRGT.Type>BD</a:TRGT.Type>
<c:TRGT.Items>
<o:SPdoObjTrgi Ref="o237"/>
</c:TRGT.Items>
</o:SPdoObjTrgt>
<o:SPdoObjTrgt Id="o246">
<a:OID>4D4FEE12-FCA1-11D2-B69E-0008C7EA924D</a:OID>
<a:Name>AfterDeleteTrigger</a:Name>
<a:Code>AfterDeleteTrigger</a:Code>
<a:Text>--  After delete trigger &quot;[%QUALIFIER%]%TRIGGER%&quot; for table &quot;[%QUALIFIER%]%TABLE%&quot;
create trigger [%QUALIFIER%]%TRIGGER% after delete 
on [%QUALIFIER%]%TABLE% for each row
declare
    integrity_error  exception;
    errno            integer;
    errmsg           char(200);
    dummy            integer;
    found            boolean;
    .DeclDeleteParentCascade
    .DeclDeleteParentSetNull
    .DeclDeleteParentSetDefault

begin
    IntegrityPackage.NextNestLevel;
    .DeleteParentCascade
    .DeleteParentSetNull
    .DeleteParentSetDefault
    IntegrityPackage.PreviousNestLevel;

--  Errors handling
exception
    when integrity_error then
       begin
       IntegrityPackage.InitNestLevel;
       raise_application_error(errno, errmsg);
       end;
end;
/</a:Text>
<a:CDAT>0</a:CDAT>
<a:CUSR/>
<a:MDAT>0</a:MDAT>
<a:MUSR/>
<a:Labl>After delete trigger</a:Labl>
<a:Tnam>tda_%.L:TABLE%</a:Tnam>
<a:TRGT.Type>AD</a:TRGT.Type>
<c:TRGT.Items>
<o:SPdoObjTrgi Ref="o240"/>
<o:SPdoObjTrgi Ref="o239"/>
<o:SPdoObjTrgi Ref="o238"/>
</c:TRGT.Items>
</o:SPdoObjTrgt>
</c:TrgrTemplates>
</o:SPdoObjDbms>

</DBMS>