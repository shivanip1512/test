
                      R O G U E   W A V E

         T O O L S . H + +    C L A S S   L I B R A R Y

         Rogue Wave Tools.h++: Version 7.1.0 August 1999


=========================================================================
Contents:
-------------------------------------------------------------------------
  1. IMPORTANT MESSAGES
  2. Rogue Wave Contact Information
  3: Supported OS, Compiler and Thread Combinations
  4: Changes --- What's New This Release
  5: SPM (Software Parts Manager) Notes:
  6: Documentation Notes
  7: OS/Compiler Specific Issues and Patch Level Information 
     [Tools.h++ specific]
  8: FAQ
  9: Impact on other Rogue Wave products
 10: Shared Library Versioning
 11: Known difficulties
 12: Change Log --- History of changes from 7.0.0
 


=========================================================================
1: IMPORTANT MESSAGES 
-------------------------------------------------------------------------

A. Borland C++ Builder VCL users must read the "Borland users"
notes below, under the section "OS/Compiler Specific Issues and
Patch Level Information [common across products]"


B. Toolread.doc (this document) improvements:

   We are making every effort to improve this document and so we
   will be delighted to hear from you on your suggestions. Please
   send your feedback to support@roguewave.com. 

   Here are the important improvements in this release:

   o Detailed OS/Compiler environment
 
     We have attempted to provide detailed information on the 
     versions, up to the patch level, of the OS/Compilers that we 
     used, to certify this product. We strongly urge you to verify
     that your system is current with the recommended patch levels.

   o Consolidation and cleanup
  
     We have consolidated information on several versions of the
     same compiler under the latest version of the compiler 
     supported for this release.



=========================================================================
2: Rogue Wave Contact Information 
-------------------------------------------------------------------------

Rogue Wave Software, Inc.
5500 Flatiron Parkway
Boulder, CO  80301
 
Corporate Office:  (303) 473-9118
Toll Free:  (800) 487-3217
Fax:  (303) 447-2568
sales@roguewave.com
www.roguewave.com
 
Technical Support:  (303) 545-3205
Online Knowledge Base:  support.roguewave.com
Email:  support@roguewave.com


Serving Europe:
Rogue Wave Software GmbH
+49-6103-59 34-0
Rogue Wave Software B.V.
+31-20-301 26 26
Rogue Wave Software S.A.R.L.
+33-1-4196 2626
Rogue Wave Software-UK.Ltd.
+44-118-988 0224
Rogue Wave Software S.R.L.
+39-02-3809 3288



=========================================================================
3: Supported OS, Compiler and Thread Combinations
-------------------------------------------------------------------------

  For this release, the following combinations are supported.
  Please contact your sales rep for up-to-date information on 
  platform and multithreading support.
 
  For more specific details please see the sections "OS/Compiler Specific 
  Issues and Patch Level Information [common across products]" and "OS/Compiler 
  Specific Issues and Patch Level Information [Tools.h++ specific]."

  ------------------------------------------------------------------------
  OPERATING SYSTEM      COMPILER                       THREADS PACKAGES
  ------------------------------------------------------------------------
  Windows 95/NT4.0      Borland C++ Builder V4           WIN32
  Windows 95/NT4.0      Microsoft Visual C++ V6.0 SP3(*) WIN32
  Digital Unix 4.0d     DEC C++ V6.1                     POSIX
  HP-UX 10.20           HP CC A.10.36                    DCE 
  HP-UX 10.20           HP CC A.10.45(*)                 DCE 
  HP-UX 10.20           HP aCC 1.18                      DCE 
  HP-UX 11              HP aCC 3.10                      DCE, POSIX
  AIX 4.3.2(*)          IBM C and C++ version 3.6.6      POSIX
  AIX 4.3.2             IBM C and C++ version 3.6.4      POSIX
  AIX 4.3               IBM C and C++ version 3.6.0      DCE, POSIX
  AIX 4.2               CSet++ 3.1                       DCE, POSIX
  Irix 6.5              SGI MIPS Pro C++ 7.2.1           POSIX 
  Linux 2.2.5(*)        GNU/egcs g++ 1.1.2               POSIX 
  Solaris 7             SunPro C++ 5.0                   POSIX, SOLARIS
  Solaris 7             SunPro C++ 5.0(*) -compat        POSIX, SOLARIS
  Solaris 2.6           SunPro C++ 5.0(*)                POSIX, SOLARIS
  Solaris 2.6           SunPro C++ 4.2p7                 POSIX, SOLARIS
  Solaris 2.5.1         SunPro C++ 4.2p7                 DCE
  SunOS 4.1.X           SunPro C++ 4.1 p22+ (!)          None
  ------------------------------------------------------------------------

  (*) This release added support for these OS/Compiler combinations.
  (!) The patch level for SunPro C++ 4.1 for SunOS 4.1.X includes an
      unofficial patch release that takes the compiler beyond p22 in order
      to fix Sun's Bug #4164766. Please contact Sun for information regarding
      the patch for this necessary fix.


=========================================================================
4: Changes - What's New This Release
-------------------------------------------------------------------------
7.0.B --> 7.1.0
	o A new static function has been added to zone.cpp which, when envoked, will
	  deduce the current daylight saving rule fron the underlying system. It is
	  named RWZone::os(). Instantiating RWZone::local( RWZone::os() ) will set
	  the daylight rule for the current year. 

=========================================================================
5: SPM (Software Parts Manager) notes:
-------------------------------------------------------------------------

o Please review the online guide to the installation of
  Tools.h++. Use your favorite browser to open the HTML file 
  located at:
  <installation_directory>/htmldocs/genbd/index.htm

o If you are experiencing the error message "File 
  truncated due to lack of sufficient memory" on Windows machines 
  and cannot see all of these notes or all of your  
  install or build transcripts, then use a Windows text 
  viewer that does not have a 65k limit, such as WordPad or Word.  
  The readme files are: 
       .../parts/tls070??/docs/toolread.doc
       .../workspaces/<OS>/<COMPILER>/<BUILD>/docs/toolread.doc
   The "parts" location will hold it immediately after you install
   Tools.h++, and the "workspaces" location will also hold it after
   you have built one or more Tools.h++ libraries.

o During installation and build, you may be asked to answer 
  some questions to enable SPM to correctly install and build 
  Tools.h++. The following information provides more details 
  about those questions: 

  ?: "Select the source of the Standard Library you are using."
  You choose:
     "Rogue Wave" if you have installed the Rogue Wave version of the
       Standard C++ Library.
     "Microsoft" if you are using the Standard Library that ships with
       Microsoft VC++.

  ?: "Enter full path to the Standard Library headers directory."
  You reply:
     The default which SPM fills in for you is probably correct.
     If you installed the Standard Library someplace other than 
     the default workspace, you will have to provide that location.
     (Note:  If your Standard Library headers are accessed by an NFS 
     automount daemon, SPM may not be able to successfully access them.  
     If this happens, you will need to move the headers to a local or 
     hard-mounted directory.)

  ?: "Enter full path to directory containing Standard Library."
  You reply:
     As with the location of the header directory, you may have to
     help SPM find the location of the compiled Standard Library lib
     file.

  ?: "Select Standard Library File Name."
  Your choices:
     SPM will simply list the files in the location where it expects
     to find the library file for the Standard C++ Library. The base
     part of the name you need will be  std<NUMBER><LETTER> where
       NUMBER      means
       8           single thread, no debugging
       11          single thread, symbolic debugging, extra assertions
       12          multi-thread, no debugging
       15          multi-thread, symbolic debugging, extra assertions

       LETTER      means
       s           static library
       d           dynamic (shared) library
     You must choose the appropriate standard library to meet the
     needs of the Tools.h++ library you are building. For instance if
     you are building a static, debug, multi-thread version of
     Tools.h++, you should link with std15s.lib (PC) or libstd15s.a
     (Unix). 



=========================================================================
6: Documentation Notes
-------------------------------------------------------------------------

If you spot a typo in our manuals, or have a suggestion, we would
be happy to have you let us know at onlinedocs@roguewave.com. Please
note that we update the online HTML documentation to fix typos and 
other small errors at each release.  If there is a discrepancy between
printed and online documentation, the online docs are the most current
and accurate.

  o Some classes which were developed purely for internal use by
    Tools.h++ appear in the documented hierarchy, but not in the class
    reference section. This omission is deliberate, and implies that
    the undocumented classes may be changed, augmented, or removed in
    a later release without warning to users. We encourage you not to
    use such classes.

  o The example for using RWFactory in the Class Reference is
    in error.

    This is wrong:

       RWBag* b = (RWBag*)getRWFactory()->create(__RWBAG);

    This is correct:

       RWBag* b = (RWBag*)rwCreateFromFactory(__RWBAG);


  o Class Reference for "RWTPtrSlistIterator<T>" should tell
    the user that if the slist is modified, the iterator is no longer
    valid. This is generally true for all iterators.

  o Values stored in the templatized dictionary containers must be
    able to respond to operator==() and operator<(). This is necessary
    when the Standard C++ Library is being used as the implementation
    for these classes because the standard requires it, and when our
    own implementation is used because we wanted to be sure that
    containers with identical keys but distinct values were not
    considered the same. According to the Draft ANSII/ISO Standard,
    compilers should only require these operators if they are used.
    Unfortunately, we know of several compilers that do not meet this
    part of the draft standard.

  o The manual talks about the semantics of the types that may
    instantiate the templatized collections by saying something like
    "Class K must have
     * well-defined equality semantics (K::operator==(const K&))."
    The example is too restrictive. We should be saying that the
    compiler must be able to unambiguously find an operator== that
    applies to two instances of K regardless of how the operator is
    implemented.

  o RW_CENTURY_REQD will force asString with the "x" format to output
    4 digit years.  Since asString defaults to the "x" formatting
    option, 4 digit years will also be the default.  This doesn't 
    affect the other formatting options, which are handled by the 
    operating system.


=========================================================================
7: OS/Compiler Specific Issues and Patch Level Information  
   [Tools.h++ specific]
-------------------------------------------------------------------------

This section notes OS/Compilers issues that are specific to 
Tools.h++, and could effect application development.  Precise version 
information and patch levels which were used for test certification 
can be found in the file platform.doc, which is located in the directory
<install directory>/parts/tls070a?/docs/.  There are many platforms where 
Tools.h++ is known to work.  You should not take the absence of 
certification on your platform to mean that Tools.h++ does not work there. 
Rather, a note of certification is your guarantee that we have indeed 
proven Tools.h++ to work. 

Platforms are listed below alphabetically, by OS for Unix, and by 
compiler for Windows. 



                  *****************************
                    ****  AIX xlC users ****
                   ***************************

Tools.h++ is certified for:
  AIX V4.3.2 for IBM C and C++ version 3.6.6, with POSIX threads
  AIX V4.3.2 for IBM C and C++ version 3.6.4, with POSIX threads
  AIX V4.3   for IBM C and C++ version 3.6.0, with DCE and POSIX threads
  AIX V4.2   for IBM CSet++ version 3.1,      with DCE and POSIX threads

1.  Tools.h++ no longer names its static and shared libraries according
to the AIX naming convention: We now use a "d" to indicate a shared
or _d_ynamic library, and an "s" to indicate a _s_tatic library.
The "ns" form is deprecated.

2. During the link phase of building a dynamic library, duplicate symbol 
warnings will be produced. This is because we use compile time instantiation for
templates instead of link time instantiation.  Link time template
instantiation has caused failures in our test suite with complex templates.

3. Use of Standard Library templates may cause a compiler warnings
on template destructors. This is a reaction to the class style semantics 
used in template definitions when instantiated with built in types.  This 
has no effect on run time behavior. Here is an example of the warning:
  '1540-252: : (W) The destructor for "vector<char,allocator>*" does not exist.
   The call is ignored.'
   
4. XDR streams do not currently function properly if Tools is built with the 64 bit
option.



                     **********************
                ******   Borland users    ******
                 *** Window NT/ Windows 95 ***
                     **********************

Tools.h++ is certified for:
  Borland C++ Builder V4 for Windows 95/NT, with WIN32 threads.

  Windows Users Note:
  -------------
  You may find that you need to edit the makefile to increase the
  index page size for a librarian or linker, especially if you compile
  with BMODE=DEBUG.  Normally the warning will tell you exactly what
  to do. If not, please consult your compiler documentation.

1. The new macro RWDLL is now supported, which should be used in the
place of RWTOOLSDLL macro. This macro has been adopted by all RW 
.h++ products, and can and should be used in the place of the 
RW<PROD1>DLL RW<PROD2>DLL ... series on the command line.

2. Tools.h++ is certified for Borland C++ Builder 4.0 (BCB4).  
BCB4 introduces the Visual Component Library (VCL) which needs to be
compiled differently from previous versions. If you use VCL you must 
add '-b- -Ve' to the compiler options for Rogue Wave libraries.

3. An additional VCL issue is with the building of DLL libraries with
VCL.  The following changes to the default method of building DLLs
must be made.  If you use the default method to build DLL's with VCL 
then your applications may coredump.

A knowledge base entry has been created, it is item number 980608-001 
and the title is "Borland C++ Builder 4.0 and VCL". 

If you are using BCB4 and wish to create VCL applications and you are 
using Tools as a DLL, you must change line 217 of 
parts\tls070x\source\etc\PC\WINNT\BORLAND\makefile.in.
It currently reads:

cw32$(RWMT)i.lib import32.lib $(RWFIRST_USERLIBS) $(RWLINKLIBS) \
 $(RWLAST_USERLIBS)

cw32$(RWMT)i.lib needs to be replaced with:
cp32$(RWMT)i.lib release\vcle35.lib release\vcl35.lib
for a release library and:
cp32$(RWMT)i.lib debug\vcle35.lib debug\vcl35.lib
for a debug library.  

For example, if I were building buildtype 7d, 
line 217 of makefile.in would look like this:
cp32$(RWMT)i.lib debug\vcle35.lib debug\vcl35.lib import32.lib \
 $(RWFIRST_USERLIBS) $(RWLINKLIBS) $(RWLAST_USERLIBS)


4. When you compile Tools with BCB4, RWBoolean will be
defined to bool rather than to int.  The reason for this is
that the templatized collections use bool and the mix of ints
and bools causes compiler errors.  If you want to avoid using
bools in any case, then modify your rw/compiler.h or
rw/compiler.in files by commenting out the following statement:

    #      undef RW_NO_BOOL

5. When you build Tools with the Standard C++ Library, the compiler
will produce a warning while compiling rec.cpp.  It is complaining
about parameters not being used in the Standard C++ Library include
file "memory".  Since this is the Standard C++ Library shipped with
the compiler, we cannot fix this warning.



                   ***************************
                ****   DEC C++ on OSF users   ****
                   ***************************

Tools.h++ is certified for:
  Digital UNIX V4.0d for DEC C++ V6.1, with POSIX threads 
    NOTE: Either DEC or RW Standard Library can be used

1. If you compile Tools.h++ with the DEC Standard Library, Tools.h++ 
will use the old-style iostreams rather than the new iostreams
specified by the published C++ Standard.  The reason for this is that
DEC cxx uses the old iostreams by default and requires the user to
put -D__USE_STD_IOSTREAM in the  cxx command line in order to get
the new iostreams.

2. If you compile programs that use Tools.h++ classes and the RW Standard
Library, you may get the warning:

"cxx: Warning: ../../include/iterator, line 356: pointless comparison of 
unsigned integer with zero detected during instantiation of 
"void __advance(RW_PSeq<list<Foo *, allocator>, RWTPtrDlist<Foo>,
                    Foo>::my_iter_ &, unsigned long,
                    bidirectional_iterator_tag)" 
    if (n >= 0)
----------^"
We are unable to find a way to turn off this warning within the source code.
You may turn off this warning with the cxx compile option 
"-msg_disable unsigned_compare_with_zero"(for V5.7) or
"-msg_disable unscomzer" (for V6.1 and above).

3. For DEC 6.0 and greater, do _not_ use the -define_templates compiler option 
or you will get "Symbol multiply defined" errors for templatized member functions.
However, older versions of DEC C++ did not automatically instantiate
template functions with external linkage. But for pre-6.0 DEC cxx, 
you must explicitly indicate which functions to instantiate using either 
the define_template pragma or the -define_templates command-line 
compiler option. We have not added the define_template 
pragma to any Rogue Wave source or header files. For pre-6.0, using the 
-define_templates compiler option, we were able to
successfully build and execute test programs for all template classes
with the exception of class RWTValVirtualArray<T>.

4. The XDR stream classes are not available.  The system supplied rpc/xdr.h
header file is not suitable for use in C++ programs.



                   ***************************
                ****         HP users        ****
                   ***************************

Tools.h++ is certified on HP for:
  HP-UX V10.20 for HP CC  V A.10.36, with DCE threads
  HP-UX V10.20 for HP CC  V A.10.45, with DCE threads
  HP-UX V10.20 for HP aCC V A.01.18, with DCE threads
  HP-UX V11 for HP aCC V 3.10, with DCE & POSIX threads


1. We have certified Tools.h++ for use with aCC _only_ if the Rogue Wave C++
Standard Library is also used.  Depending on your version of aCC you
may be able to use the standard library which ships with the
compiler. If you have trouble with the HP version, it will probably look
like a mismatch between two possible typedefs for RWBoolean (int
versus bool) in which case you may want to get a more current 
version from Rogue Wave.

2. The aCC compiler ships with a precompiled version of Tools.h++ and
the Rogue Wave implementation of the Standard C++ Library. If you
choose to use the current Rogue Wave versions of these products, you
must be careful to use -I and -L commands so that ONLY the newer
versions of headers are included, and only the newer versions of the
library are linked. If you attempt to use both versions, whether
deliberately or by accident, and if your executable manages to compile
and link, then there is no guarantee that it will run correctly.

3.  Under aCC, the example file examples/tools/cstring.cpp has 
been renamed to rwcstr.cpp. The renaming was needed because
aCC's iostream.h includes within its include files a file 
called "cstring". aCC looks first for include files specified 
by the -I option, with the result that aCC attempted to 
include the executable named "examples/tools/cstring".

4. The optimizer invoked by aCC may lay down incorrect code, especially 
when compiling complex template code. We strongly recommend that you 
thoroughly test any executable which you compile with aCC using 
optimization. If possible, we suggest that compiling your code using 
minimum optimization (+O0, which is the default if you do not specify 
any other optimization level) is the most prudent course. The Tools.h++ 
library has been extensively tested with the +O2 (-O) level of optimization, 
and we believe we have found and fixed all the places where our _library_ code 
triggers these problems. Thus, by default, our library will be built -O. This
statement does NOT apply to template code in Tools.h++: Template code
instantiated in your executable or library may be laid down
incorrectly if you ask the compiler to use optimization.

5. Under CC, the compiler warns that the parameter "where"
is never used.  This parameter was used to support Object Store
and cannot be removed without breaking link compatibility.  This
will be removed in Tools.h++ v.8.0.

6. You may encounter difficulty related to the use of bool. Please see
section 7: Known difficulties for more details.  Tools.h++ used with
aCC expects that RWBoolean is a typedef for bool.

7. Under CC and aCC, the linker warns, "/usr/ccs/bin/ld: (Warning) At least one
PA 2.0 object file ("filename".o) was dectected.  The linked output may not
run on a PA 1.x system.

                     *********************
                  ****     Irix Users    ****
                     **********************

Please see the "SGI (Irix) users" section below.



                     *********************
               ****   Microsoft VC++ users  ****
                ***  Window NT/ Windows 95  ***
                     **********************

Tools.h++ is certified on:
  Microsoft Windows 95/NT for Microsoft Visual C++ V6.0 SP3, 
    with WIN32 threads


  Windows Users Note:
  -------------
  You may find that you need to edit the makefile to increase the
  index page size for a librarian or linker, especially if you compile
  with BMODE=DEBUG.  Normally the warning will tell you exactly what
  to do. If not, please consult your compiler documentation.

MICROSOFT VISUAL C++ VERSION 6.0 with Service Pack 3:

1. The new macro RW_FALSE_NEW_DELETE_MISMATCH has been introduced
and defined under the MSVC compiler.  This macro provides a signature
the compiler accepts for overloaded operators new and delete when the 
classic signatures for new and delete overloading are not recognized.

2. The new macro RWDLL is now supported, which should be used in the
place of RWTOOLSDLL macro. This macro has been adopted by all RW 
.h++ products, and can and should be used in the place of the 
RW<PROD1>DLL RW<PROD2>DLL ... series on the command line.

3. When building a DLL version of Tools.h++, multithreaded support
is automatically selected. In order to match Tools.h++ with Rogue Wave's 
implementation of the Standard C++ Library, you must build the RW Standard 
Library as a DLL with multithreading as well.
    
4.  Unfortunately, the compiler cannot deduce a template argument from
supplied function arguments (compiler error c2784).  Therefore,
the old style constructor (Tools without the Standard C++ Library) for 
RWTxxxHashDictionary will not work if you are using the Standard C++ 
Library underneath Tools.h++. So,
  RWTPtrHashDictionary<RWCString, RWDate RWDefHArgs(RWCString) > 
birthdays(rwhash);
becomes,
  RWTHasher<RWCString> hashfun(rwhash);
  RWTPtrHashDictionary<RWCString, RWDate RWDefHArgs(RWCString) > 
birthdays(hashfun);

5. MSVC is too restrictive in disallowing overloading between same
name members of template classes which share an inheritance
relationship. MSVC users who are using Tools.h++ *without* the C++
standard library will not be able to use external template persistence
with the following Tools.h++ classes:
   RWTPtrOrderedVector<T>
   RWTValOrderedVector<T>
   RWTPtrSortedVector<T>
   RWTPtrSortedVector<T>
which each derive from another Tools.h++ class. Attempts to use
external template persistence with these classes on MSVC will
result in ambiguous operator<< and ambiguous operator>> errors.
 


                   ***************************
                ****       Purify users      ****
                   ***************************

There is now a file in the docs directory called "puretool.doc".
Please see that file for details of how Purify and Tools.h++ work
together.


                   ***************************
               ****           Linux          ****
                   ***************************

Tools.h++ is certified on:
      Linux 2.2.5 for GNU/egcs g++ 1.1.2, with POSIX threads

1. If you are using templates and you encounter compilation errors
related to template instantiation depth exceeds maximum of 17, try
adding the "-ftemplate-depth-NN" option to the g++ command, where
NN in the maximum template instantiation depth.

2. The new macro RW_STD_COLLECTION_PROBLEM has been introduced
and defined under the Linux compiler.  This macro is defined if your
compiler has a problem returning a reference to the underlying 
C++-standard collection that serves as the implementation for a given 
collection, ( ie. collection.std() ).


                   ***************************
                ****     SGI (Irix) users    ****
                   ***************************

Tools.h++ is certified on:
  Irix 6.2, for MIPS Pro C++ 7.1, with POSIX threads
    (both -32 and -n32 flags)
  Irix 6.5, for MIPS Pro C++ 7.2, with POSIX threads
    (-n32 flag for 32bit, -64 flag for 64 bit)

1. The compiler reports a warning (3150), when there is no copy assignment
operator defined for a class.  The warning informs the user that a bitwise
default operator will be used.  Since this is exactly the behavior that we
want, we have woff'ed this warning.  Due to nested calls to the prelinker
caused by complex template code, this woff is lost, and the warning reappears.

2. In the "CC -32" mode, there may be trouble compiling complex
template code. We have seen a situation where the compiler refused to
accept the declaration of a global placement new operator, and
required us to make that operator part of a class which was being
stored in an RWTPtrDeque. The syntax for this is (within the public
portion of the class declaration):
  void* operator new(size_t s) { return ::new char[s]; }
  void* operator new(size_t, void* p) { return p; }
The first overloaded operator provides the placement new. The compiler
also needs the second one once the first has been declared. It is
interesting that we were also able to work around this problem if we
first preprocessed our code (CC -E .... trial.cpp > dup.cpp) and then
compiled the output (dup.cpp in this example).



                 *******************************
            ****   Sun / Solaris / SunOS users   ****
                   ***************************

Tools.h++ is certified on SunOS for:
  SunOS 4.1.X   for SunPro C++ 4.1, no threads supported
Tools.h++ is certified on Solaris for:
  Solaris 2.5.1 for SunPro 4.2, with TransArc DCE 1.1 threads
  Solaris 2.6   for SunPro 4.2, with POSIX and Solaris threads
  Solaris 2.6   for SunPro 5.0, with POSIX and Solaris threads
  Solaris 7     for SunPro 5.0, with POSIX and Solaris threads
  Solaris 7     for SunPro 5.0(-compat) with POSIX and Solaris threads

1. SPARCompiler C++ V 4.x, 5.0 ships with a slightly modified version of
the Tools.h++ library (currently based on an earlier version). By
default, the CC command will use the bundled Rogue Wave headers and
library. If you wish to build your application with a version of
Tools.h++ other than the one that ships with the compiler, be sure and
use both the "-I" and "-L" compiler/link options to explicitly set the
directory search paths so that your particular version of Tools.h++ is
used instead.

The danger in all this is that you may accidentally mix versions of the
Tools.h++ library.  This can cause confusing compiler or link errors,
or even worse, compilation and linking may appear to work well, but
cause unpredictable results at run-time.  Unfortunately,
development tools aren't generally smart enough to know if you're
using the header files from one version but linking to a different
version of the library, so please take care.

For example, assume the compiler ships with Tools.h++ 6.0, with
version 7.0.x installed in tool70x/rogue:

  # Use the 6.0 Rogue Wave headers and archive that ships with compiler:
    CC hellorw.cpp -lrwtool

  # Use the 7.0.x Rogue Wave headers and archive installed in tool70x/rogue:
    CC -Itool70x/rogue -Ltool70x/rogue/lib hellowrw.cpp -lrwtool

  # DANGER -- WATCH OUT FOR THIS ONE !
  # Error: Uses version 7.0.x header files with version 6.0 archive
    CC -Itool70x/rogue hellorw.cpp -lrwtool

  # MORE DANGER -- WATCH OUT FOR THIS TOO !
  # Error: Uses version 6.0 header files with version 7.0.x archive
    CC -Ltool70x/rogue/lib hellorw.cpp -lrwtool

To reiterate: The rule is to use BOTH "-I" and "-L" options for the
Tools.h++ files (forces the use of a chosen version of Tools.h++) or
NEITHER "-I" or "-L" option for Tools.h++ files (defaults to the
version that ships with the compiler.)

Note: If you are the _very_ careful type, you may wish to find the
headers and library(s) of Tools.h++ which ship with the compiler, and
rename them so that the compiler will not automatically find them.

2. 	SunPro 5.0 required the following patch: 107311-02


                   ***************************
                ****        xlC users        ****
                   ***************************

Please see the section "AIX xlC (CSet++) users" above.




=========================================================================
8: FAQs (Frequently Asked Questions)
-------------------------------------------------------------------------

  o The capacity of RWCString and RWWString may be changed by calling
    the clone member function: aString.clone(0). This will adjust the
    capacity of aString to be exactly large enough, whereas calling
    aString.clone(aString.length()+someMore) will leave someMore extra
    bytes in the buffer.

  o All iterators: If the collection is modified directly or through
    the use of any iterator except the one in question, then that
    iterator is no longer guaranteed to be valid. Some collections may
    be altered "most of the time" without such side effects, which
    could lead you into a trap if you come to expect that iterators
    may be trusted after the collection is modified. Beware.

  o Some templatized containers have a method clearAndDestroy(), which
    is not protected against the possibility that the container holds
    more than one pointer to the same object. Do not call
    clearAndDestroy() unless you are sure your container holds no
    duplicates. (This warning does not apply to RWCollections.)

  o Some Tools.h++ methods are overloaded to take either a pointer or
    an integer type. RWTime constructors, for example, may be passed
    either a struct tm* or an unsigned long representing seconds since
    the "beginning of time." If you attempt to pass a zero to such
    methods, the compiler will correctly complain about ambiguity.
    This may be resolved by holding the zero value in the appropriate
    type, casting it, or using a construction such as "0ul" for a
    manifest constant.

  o Problems with incorrect RWTime construction from struct tm*: The
    system function localtime() returns a pointer to a static struct
    tm. Subsequent calls to localtime overwrite that struct.  RWTime
    uses RWZone::local(), which is not created until needed. That
    creation also calls localtime().  If you experience difficulty
    related to calls to localtime(), make a call to RWZone::local()
    before you first call localtime().

  o RWLocale::asString(struct tm*, ..%U.., RWZone&= RWZone::local())
    returns different values for week of the year, for years that
    begin on Sunday, depending on platform. Although the standard is
    precise, it is apparently not clear, since many vendors disagree.
    We pass the vendor's result without examining it, so if you care
    about cross-platform results, we suggest you do not use the 
    %U format.

  o Problems with #include of Standard C++ Library header files: The
    MSVC (version 4.2+) standard library headers have no trailing ".h",
    whereas the "old standard" headers do.  If you #include both kinds
    of headers, either directly or indirectly, you will get obscure
    error messages about incompatible types. Although this behavior is
    in contradiction to the Draft C++ Standard, you have no choice but
    to be _extremely_ careful if you choose to use the MSVC standard
    library. See the Microsoft section above.

  o Problems using RWFactory, or polymorphic persistence: Before the
    factory can create an RWCollectable, that collectable and its
    identifier must be registered. The easy way to do this is by
    creating at least one instance of the particular RWCollectable in
    the program. This problem may manifest in several ways. Usually 
    you will see this message:

    "[NOCREATE] RWFactory: no create function for class with ID (something)"

    However it is possible to get a core dump or GPF during a call to
    theFactory->create(someID) (This call is made while reading in
    persisted RWCollectables). This can happen with some compilers
    which do not create an instance of an object if you instantiate
    only a pointer to the object.

  o When creating your own RWCollectable, it is important to provide
    your class with all the methods that the RWCollectable methods
    use. In particular, you must provide a default constructor that
    may be used to create new "empty" instances for the persistence
    mechanism to "fill", and a copy constructor that may be used to
    clone copies of your object to a new location.  You should also be
    careful to have related methods and operators be consistent with
    each other: If you have comparison operators defined for your
    class, they should give results that match the values returned by
    the method compareTo().

  o When to use RWCollectable::recursiveStoreSize() and when to use
    RWCollectable::binaryStoreSize().  Although the answer is simple,
    it does sometimes require a bit of thought:
    recursiveStoreSize() should be used at the _top_ level of an
    RWCollectable, when you plan to use operator<<() or the
    undocumented recursiveSaveOn() method.  On the other hand,
    binaryStoreSize() should be used when you are interested in
    working with a _part_ of the entire collection:  When you plan to
    use saveGuts().

    Neither of these methods deals with streams: They are only of use
    for RWFile. If you need to find the size of an RWCollectable as
    saved to a virtual stream, use the class RWAuditStreamBuffer.

  o If you are building a library which makes use of Tools.h++
    template classes, you may find that you cannot successfully link
    executables against that library.  The problem is that some
    compilers defer template instantiation until link time, which
    means that template-based code does not get archived.  We cannot
    give you useful a generic answer: Each compiler vendor has a
    different technique for dealing with the issue.  Examine what
    documentation comes with your compiler, or contact them directly.

  o It is critical that Tools.h++ library (or DLL) be compiled with
    options, defines, and third-party libraries which correspond
    exactly to the options, defines, and third-party libraries which
    are used to compile the code which uses that library.  If you do
    not get this right, you will likely find that there are inline
    functions which expect things to be done one way that were done a
    different way in the library. The results will not be good. Two
    examples: Some Microsoft debug options cause a variant operator
    new to be used. If those options aren't the same for the library
    and the code, the heap will become corrupt. Or: Our "debug" code
    which does sanity checking depends on some pointers to be set to
    zero, where the shipping version of the code doesn't take that
    extra step. If the code in your executable checks for a zero that
    the library didn't set, the exe will stop running.

  o Use of mutexes prior to main suffers from the paired difficulty of
    knowing the order of static initialization (no general solution)
    and knowing which pre-main thread should initialize a given mutex.
    There are no known software solutions to this problem. Therefore
    we suggest that static initialization code should not call any
    thread-hot functions.

  o Using templatized hash-based containers in your class. Many
    customers have asked us to explain how to add to their own
    classes a class member which requires a non-default constructor,
    such as the Tools.h++ hash based containers.  The answer is a bit
    of tricky C++ syntax. Suppose your class should have a
    hash dictionary member:
      class MyClass {
        // ...
        RWTValHashDictionary<RWCString,int> myDict; // no ctor args here!
      public:
         MyClass();
      };

    The special syntax is known as "member initialization", and it
    looks like this: Where you provide the actual constructor body,
    you have to use a ":" followed by a comma-separated list of
    constructors for each member which requires non-default
    construction.  This example extends the example above.

       MyClass::MyClass() : myDict(theHashFunction) /* like this */
       { /* code for your constructor */ }

    Of course, you could instead use the member initialization syntax
    to write an inline constructor if that makes sense. What you
    cannot do is add the constructor arguments to the _declaration_ of
    the dictionary in the class declaration.

  o Use of any Rogue Wave hash based container, like RWTValHashDictionary, 
    gives you the option to either use the default table size of 64 buckets or 
    for you specify the table size you would like to use.  Keep in mind that the
    smaller the table size, the faster the access time will be.  However, if a 
    too small table size is used, the probability of a collision occuring 
    increases, thus greatly reducing the performance of a hash table because 
    each bucket in the hash table must be searched linearly.
  
=========================================================================
9: Impact on other Rogue Wave products
-------------------------------------------------------------------------

Products installed using the new installation software (the Software
Parts Manager or the text-based Configuration and Build Model which
lies under it) have the same (or extended!) functionality as prior
versions. However, library names are different, header file locations
are different, and in a few cases, new compiler macros may cause
link-incompatibility. We highly recommend that you install all Rogue
Wave products using the current SPM/CBM software to avoid difficulty.

Link-incompatible versions of the library can be built using some
macros newly provided with V 7.0.3+.  These versions will not link with
libraries of other Rogue Wave products which were compiled to link to
a prior version.

The RW_CENTURY_REQD macro has not been tested with other Rogue Wave
products.



=========================================================================
10: Shared Library Versioning
-------------------------------------------------------------------------

        SunOS:   Yes.

           Versioning of SunOS shared libraries is handled
           automatically by the operating system.  Tools.h++
           7.0.x is major 3, minor 0.

        Solaris:   Yes.

           Versioning of Solaris shared libraries is accomplished
           by setting the name of the shared object.  For
           Tools.h++ 7.0.x, it is major version 3.  To allow easy
           use of -lrwtool at the link step, we set up a symbolic
           link from librwtool.so to librwtool.so.3.  After
           the executable has been created, the symbolic link
           can be changed or removed without consequence.

        Irix:   Yes.

           Irix supports major and minor versioning via a
           -set_version flag on the link line. Tools.h++ 
           libraries are not currently versioned on Irix. 

        DEC Digital Unix:   Yes.

           Tools.h++ libraries are not currently versioned 
           on Digital Unix.

        LINUX:   Yes.

	   Linux supports versioning via a -V version flag.  For
           example, version might be `2.0', meaning to run GNU CC 
           version 2.0.  Tools.h++ libraries are not currently 
           versioned on Linux.

           
        HP-UX:   Yes.

           Tools.h++ libraries are not currently versioned 
           on HP-UX. Use of #pragma HP_SHLIB_VERSION may
           be added later of Tools.h++. However, any shared
           object with a version attached is later than any
           shared object without a version attached, so this
           should not be an issue in practice.

        AIX:   Yes.

           AIX shared libraries do not seem to mandate
           any particular versioning scheme.  Tools.h++
           libraries are not currently versioned on AIX.

        Windows:   Yes.

           DLLs under Windows are not currently versioned.


    If you wish to create a customized version of a Tools.h++
    shared library, do not use any of the names that the makefile
    provided by Rogue Wave might generate.  This will prevent
    problems for both you and Rogue Wave in the future.



=========================================================================
11: Known difficulties
-------------------------------------------------------------------------

o We have changed several member functions in the template collection
  classes to return const T& rather than T.  This is generally a win
  because it means that the overhead of copying things from method to
  method is avoided. However, in a few cases, code will break: If your
  code depended on getting a copy of an object to avoid const issues,
  you may now find that your non-const methods will not work with our
  const references.  The ideal solution is to re-write your code to
  be const correct.

o Problems persisting RWBoolean or bool using operators << and >> with
  vstreams.  If your compiler supports bool as a "real type", we undef
  RW_NO_BOOL, and typedef RWBoolean to bool. But because converting a
  pointer to a bool is a standard conversion, if we had provided
  operators >> and << to extract or insert RWBoolean (bool) from and
  to vstreams, your compiler might correctly complain that it cannot
  choose between (for instance)
       RWpostream::operator<<(RWBoolean)
  (for instance)
       operator<<(RWVostream&, const RWCollectable*)
  when you attempt code like
       anRWpostream << aDerivedCollectable*
  (The reason it cannot decide is that in each case, one of the
  arguments is an exact match, but the other requires a built-in
  conversion, thus each choice is equally good.)

  This problem can be addressed by re-designing the Tools.h++ virtual
  streams, but the required change is neither link compatible (nor
  even code compatible for some users) with the current state of our
  code, so that solution will be postponed. For the moment, we have
  instead removed the insertion and extraction operators overloaded
  for bool. This restriction does not apply to the put() and get()
  methods of the vstream hierarchy, so RWBoolean (bool) may still be
  persisted, but not using the overloaded operators.

  Unfortunately, those compilers which trigger this problem will
  quietly convert a bool to some other type when inserting into a
  vstream: code such as this appears to work:
     aPostream << FALSE << " or " << TRUE;
  but the corresponding extractor will fail:
     aPistream >> oneRWBoolean >> aString >> anotherRWBoolean;
  Equally unfortunately, at least one of these compilers will issue a
  completely unhelpful diagnostic suggesting that oneRWBoolean and
  anotherRWBoolean be changed to "const int reference." If your
  compiler issues any diagnostic suggestive of a problem extracting a
  bool from a vistream, you must apply the following fix, not just to
  extraction code (flagged by the compiler) but also to insertion
  code, because otherwise the number of bytes inserted will not match
  the number which you get() from the stream. The fix is to replace
  code like this:
     aVostream << anyBoolean;
  with this instead:
     aVostream.put(anyBoolean);

  and
     aVistream >> anyBoolean;
  with this instead:
     aVistream.get(anyBoolean);

  Note that these fixes must be made in the bodies of both rwSaveGuts
  and rwRestoreGuts for any of your classes which need it, and also
  in both the saveGuts and restoreGuts methods of any of your own
  classes which derive from RWCollectable.



=========================================================================
12: Change Log --- History of changes from 7.0.0
-------------------------------------------------------------------------

For your convenience we include here a history of past changes to Tools.h++.

7.0.B --> 7.1.0
  o Ported to LINUX 2.2.5, EGCS 1.1.2.

  o A new static function has been added to zone.cpp which, when envoked, will
    deduce the current daylight saving rule fron the underlying system. It is
    named RWZone::os(). Instantiating RWZone::local( RWZone::os() ) will set
    the daylight rule for the current year. 

  o Fixed a RWXDRi(o)stream bug(7340): XDR stream supports 64-bit on IRIX. 

  o Fixed a RWTime bug(9194) in converting from time_t and back to RWTime.

  o Fixed a RWCRExpr bug(11049): infinite loop in compiling an unterminated
    bracket list.

7.0.A --> 7.0.B
  o Fixed a problem in RWCRExpr that will result in an invalid status if 
    caret ^ is found not immediately following open bracket inside a bracket 
    expression. 

  o Fixed a bug in RWCRExpr that does not match the longest pattern in a 
    string.
  
  o The removeFirst() method of templatized vectors now throw a Boundary
    Error if the index is invalid.   
  
  o Added operator== to RWT***OrderedVector and also operator< to 
    RWT***SortedVector so that these classes can now be instantiated
    recursively without using the Standard C++ Library.  

7.0.9 --> 7.0.A
  o Fixed problem where RWCRExpr would exhibit a memory fault when certain
    regular expressions were used.

  o Fixed a memory leak in RWCRExpr assignment operators.
  
  o Fixed a problem in RWDefCArgs that needed spaces in its argument list.
  
  o Fixed a problem with WIN95 setpath.bat file that failed if path contained
    a space.
  
  o Fixed a problem that required the occurencesOf() method to be const.

  o Fixed the constructor for RWDate to return an invalid date if
    RW_CENTURY_REQD is defined and years less than 100 are used.
  
  o Fixed RWCRExpr bug that caused the regular expression to fail if
    the symbol set includes a character (or end point, for ranges), above
    '7f'x, for compilers which the "char" datatype is signed.

  o Fix RWTxxxOrderedVector::clear() to only resize the vector to
    RWDEFAULT_CAPACITY  if the vector size is greater than RWDEFAULT_CAPACITY

  o Added support for Operating Systems and Compilers as Noted in the above
    section "Supported OS, Compiler and Thread Combinations."

  o Fixed a bug that had caused the last line of a file ending in <EOF> 
    instead of <CR> <EOF>  not to be read in by RWCString.

  o Implemented a workaround for lack of daylight savings correction in non 
    U.S. time zones for borland

  o Fixed the problem with outputting the time 00:00:00 1/1/1901 to a stream 
    for the time zones in which this is a legal value for RWTime

7.0.8 --> 7.0.9
  o RWCString and Mutexes

    Class RWCString uses a single mutex to protect string reference counts.  
    When run in a multithreaded, multiprocessor environment contention for 
    RWCStrings single mutex can cause performance issues. 

    To address RWCString-related performance issues that may occur in a 
    multithreaded, multiprocessor environment, we have provided a macro, 
    RW_CSTRING_MUTEX_COUNT. This macro lets you adjust RWCString to use any 
    number of mutexes.  You use the macro by creating a custom configuration 
    in Software Parts Manager that defines the macro and sets it equal to the 
    desired number of mutexes (-DRW_CSTRING_MUTEX_COUNT=X).  You then build 
    your Tools.h++ library with the new configuration. 

    NOTE-This feature should only be used in a multithreaded, multiprocessor 
    environment when your  code is RWCString intensive.  In other circumstances, 
    changing the number of mutexes available will negatively affect performance.

    To help you determine the optimal number of mutexes, we provide a second
    macro, RW_CSTRING_MUTEX_COUNT_INFO, that makes available the function 
    printStringMutexCount(). The new function prints a usage histogram for 
    the pool of mutexes. By reviewing the histogram you can determine the best 
    number of mutexes for your environment.  To use the printStringMutexCount() 
    function, update your custom configuration to include the macro definition 
    -DRW_CSTRING_MUTEX_COUNT_INFO. You can remove the second macro definition 
    from your library after determining the best number of mutexes.

  o Fixed a bug in RWCString::readToken(), which had resulted in EOF not
    being set until the read after the last token on Unix platforms.  In this
    release the proper behavior has been verified on all platforms.

  o Fixed a bug in which there was ambiguity when writing an RWCString to 
    an RWXDRostream. 

  o Fixed a bug in which there was ambiguity when using != to compare
    two RWCStrings.

  o Added support for Operating Systems and Compilers as Noted in the above
    section "Supported OS, Compiler and Thread Combinations."



7.0.7 --> 7.0.8

  o Changed thread support.  In the past, Tools was automatically configured
    to pick the best threads package available.  Now, if more than one
    threads package is detected, the installation program will ask the user
    which threads package to use. This has resulted in some changes to the RW 
    threads macros. In the old scheme, 
    "(RW_POSIX_THREADS && !RW_POSIX_D10_THREADS)" implied DCE threads, and
    "RW_POSIX_D10_THREADS" implied 1003.1c (final draft) threads.  
    In the new scheme, "RW_DCE_THREADS" implies DCE threads and
    "RW_POSIX_D10_THREADS" implies 1003.1c (final draft) threads.

  o Added support for namespace changes in the Standard Library for PC
    compilers.  One of the results of this support is that the UNIX and PC
    versions of Tools now have slightly different source code.  This 
    difference will be eliminated in a future version of Tools.

  o "signal 10 or signal 11" error when using the SunPro 4.2 compiler:

    The above problem is due to using a construct that is not yet supported
    by the compiler. The offending construct consisted of templates in a 
    function declaration or of nested templates where the template was not 
    yet instantiated. We have worked around the problem by changing our code 
    to not use the offending construct.

    Here is an example where the offending code has been changed
    from:
      bucket_t(bool v, const typename 
        rw_slist<pair<T,unsigned long> >::iterator& c) 
        :valid_(v), chain_(c){}
    to:
      typedef rw_slist<pair<T,unsigned long> >::iterator rw_slist_iterator;
      bucket_t(bool v, const rw_slist_iterator& c)
        :valid_(v), chain_(c){}

  o Ported to MS Visual C++ 5.0 with Service Pack 3.

  o Ported to Borland C++ Builder V3.

  o Ported to DEC C++ 5.7 on Digital Unix 4.0.

  o Ported to HP-UX aCC1.12 on HP-UX 10.20.

  o Ported to HP-UX aCC3.05 on HP-UX 11.

  o Ported to SunPro 4.2 (patched) for Solaris 2.51.

  o Fixed a bug in which RW_CENTURY_REQD didn't force 4 digit years.

  o Fixed a bug in RWBTreeOnDisk which was causing a small, intermittent
    memory problem on HP C++ 10.28.

  o Fixed a bug where RWTime skipped invalid characters and returned a 
    valid date.

  o Fixed typos/bugs in lhash.h, hashmset.h, mutex.h.

  o Fixed possible infinite loops in RWCString::readLine
    and RWCString::replace.

  o Replaced ~vector with rw_destroy in lhash.cc

  o Improved version of Toolread.doc (this document): 

        Removed information pertaining to obsolete platform 
        combinations; 

        Added a table of "OS, Compiler and Thread combinations supported"
        for quick reference, right in the beginning; 

        For threads support, wherever applicable, listed the version 
        of the threads package certified with the current release. 
        Please contact your sales rep if you're using a version of 
        threads package that is later than the certified version. 

    We are making every effort to improve the contents of this document.
    Your comments on improving this document further are most welcome
    and can be sent to technical support (email: support@roguewave.com).
------------------------------
7.0.6 --> 7.0.7

  o Converted OS/2 version to new "rwspm" build model.

  o Ported to Borland C++ Builder aka Borland C++ 5.02.

  o Ported to MS Visual C++ 5.0 without Standard Library support due
    to MSVC bugs. See the Microsoft users section below.

  o Ported to HP A.10.2x 

  o Ported to CSet++ 3.1 for AIX 4.2

  o Ported to SunPro C++ 4.2 for Solaris 2.5.

  o Ported to HP's aCC compiler, V 1.06.

  o Removed overloaded insertion and extraction operators for bool
    from the vstream hierarchy. See Known Difficulties (Section 7:)
    for details.

  o Fixed a bug in RWPistream which sometimes caused string data saved
    on a PC to have extraneous line-feeds inserted when it was read in
    on a Unix machine.

  o Fixed a bug deleting the wrong number of bytes in the buffers of
    RWBufferedPageHeap in destructor code.

  o Fixed bug in RWCString I/O code which caused a hang on the second
    attempt to read from a bad or unready stream.

  o Fixed a fencepost bug in RWCRExpr which caused the method
    RWCString::replace(extendedExp,replString,RWCString::all) to
    recurse forever if replString itself contained a match for
    extendedExp.

  o Fixed a logic bug in the code used to compare pairs of pointers,
    which in turn fixes a problem comparing two RWTPtrMap<K,V> or
    RWTPtrMultiMap<K,V>.

  o Fixed bug in RWPistream which caused wide characters to be
    garbaged on some 64-bit platforms.

  o Fixed a bug in RWWString which causes an assertion to fire
    incorrectly if you resize the string to zero.

  o Fixed a bug in RWWString::toMultiByte() which might leak memory
    with some compilers.

  o Fixed an incorrect typedef scoped within several different
    RWTPtr_something_ classes. This bug was causing a problem for MSVC
    in code which made use of the typedef.
------------------------------
7.0.4 --> 7.0.6
  o The biggest change is the way Tools.h++ installs itself. Please
    read your installation and build documentation for details.
    Briefly:
    -- The names of the libraries have changed to encode "dynamicity"
       (a DLL or a shared library) with a "d" and other build options
       with some number between 0 and 15. See your documentation for
       full details, or minimalist information in the SPM notes above.
    -- The location of the source code has changed: Look in the
       installation directory for directory source/src
    -- The _initial_ location of the header files has changed. You may
       find them in your installation directory in source/src/rw
    -- The installation process will automatically generate makefiles,
       build the chosen library, then copy the library, and the header
       files to your work area. Please read your documentation for
       details.
    -- The installation process will also automatically copy your
       example directory to the work area, and generate the makefiles
       for the example code.
    -- Some versions of the new installation process will also build
       the examples for you. You will still have to change to the work
       area's example directory to run them. Others merely provide a
       makefile in the work area: You will have to change to that
       directory and run make before you can run the examples.
    -- Other Rogue Wave products will automatically install themselves
       in the same work area with Tools.h++. The expectation is that
       these products will be automatically compiled to work together
       without requiring you to tweak them. Hurray!

  o We have added the macro RW_NO_BOOL which is normally defined for
    "older" compilers, and undefined for compilers which support bool
    as a true basic data type.  When RW_NO_BOOL is not defined, then
    there are link-incompatible changes to the library (incompatible
    because bool and RWBoolean may have different sizes, and because
    they cause different name mangles). These changes are:
    - Typedef RWBoolean to bool, and define TRUE and FALSE to be true
      and false.
    - Add RWBoolean overloaded << and >> operators for RWFile and the
      virtual stream classes.
    - Add RWBoolean and RWBoolean* overloaded put and get methods
      for the virtual stream classes, and Read and Write methods for
      RWFile.

    Because of the ease with which a pointer converts to a bool, you
    may find that code which shifts an RWCollectable _pointer_ in or
    out of a virtual stream will no longer work in the presence of a
    "real" bool type. Please see the "Known difficulties" section for
    a solution.

  o Changed interface not to mention "const" return value when the
    return is by value: quiets some compiler warnings.

  o Fixed the STL-conformant slist to correctly call the destructors
    of objects when they are removed from the list. This patch also
    fixes the same problem in the STL-conformant hash-based
    collections.

  o Fixed a bug which caused a string's capacity to double without
    bound when it was used to readLine successive lines in a file
    which were exactly 1 less than a power of 2 characters in
    length. Also changed string's capacity to be adjusted to fit after
    it is read from a file.

  o Fixed a bug which caused RWMemoryPool to cache the usual amount of
    space allocated from the heap, but did not allow the cached
    locations to be used.

  o Fixed a bug with compiling character sets in the extended regular
    expression class.
------------------------------
7.0.4 --> 7.0.5
  No changes to code. New version label for Software Parts manager.
------------------------------
7.0.3 --> 7.0.4
  No changes to code. New version to support Software Parts manager.
------------------------------
7.0.2 --> 7.0.3
  o Except for the Windows-specific classes RWCLIPStreambuf and
    RWDDEstreambuf, Tools.h++ now works with the static (and with some
    restrictions the DLL) version of the Standard C++ Library that
    ships with Microsoft Visual C++ V4.2. To use the Microsoft
    Standard C++ Library, you must invoke make with STDLIB=MS rather
    than "Y" (for "Y"es: use Rogue Wave's) or "N" (for "N"o standard
    library). Microsoft recognizes that this version of their Standard
    C++ Library is neither thread safe nor correct for DLLs. Please
    see the Microsoft section below for details.

  o Tools.h++ now works with IBM's VisualAge C++ For Windows. Please
    see the IBM VisualAge for Windows section below for details.

  o Each rwCreateFN is now a friend of the associated collectable
    class. This means that Collectable classes need not have public
    constructors.

  o RWLocale and RWDate code may now be compiled to provide a larger
    measure of enforcement for the use of 4-digit years by defining
    the macro RW_CENTURY_REQD. When it is defined, the behavior of
    RWDate and RWLocale change as follows:
    - RWDate::asString('x') and RWLocale::asString(struct tm*,'x')
      will always provide four characters as the year part of the
      date. ('Y' and 'y' will not change). Note that the 'x' format
      specifier is used by default when an RWDate is translated to a
      string.
    - RWDate::RWDate(const char*) and RWLocale::stringToDate(const
      RWCString&, struct tm*) will require a four-character year
      field, which evaluates to a number greater than 99.
    - RWDate::RWDate(..., unsigned year) will require that year be
      a number greater than 99.
    - If the program does not provide a year as required, code
      compiled with RWDEBUG also defined will fail.  With RWDEBUG not
      defined, the constructed RWDate will be invalid, or the struct
      tm will be unchanged.

    The intent is to provide RWDate output which will be acceptable as
    input, and to help enforce the use of fully qualified years during
    the transition to the 21st century.

	NOTE:  By defining RW_CENTURY_REQD, you may introduce runtime errors in
	your programs if they still use two digit years!

  o RWDate can now print any date after January 1, 0000 A.D.
    Previously, it could not print any date prior to January 1, 1900.
    Note that dates prior to the adoption of the Gregorian calendar at
    any particular location will not exactly match weekday or even
    month names from that era in that location.  However such dates
    are still appropriate for doing date arithmetic or comparisons.

  o We have introduced a link-incompatible fix for certain cross-
    platform RWestream persistence problems:  If you are using two
    platforms which have all these conditions:
    - Size_t resolves to different types on the platforms (int vs
      long, for instance)
    - The number of bytes of those two types is different on the two
      platforms (4 vs 8 bytes, for instance)
    - you persisted any data using a size_t type (as RWCollections do,
      which use size_t for the count of data).
    then you will be unable to use estreams to persist data between
    the platforms without the fix.  To use the fix, you must change
    your code to use the virtual methods vistream::getSizeT(&size_t)
    and vostream::putSizeT(size_t) rather than using the overloaded
    insertion and extraction operators.  The fix is available only if
    the macro RW_FIX_XSIZE_T is defined, so that link compatibility is
    preserved when the macro is not defined.

  o A miscellany of additions and changes to the platforms we support.
    See below for details.
------------------------------
7.0.1 --> 7.0.2
Date:  June 1996
  o We now officially support a recent version of the Gnu C++
    compiler available through Cygnus, for several Unix platforms.
    Details in the Gnu section.
  o We now support DLLs for OS/2.
  o Building the library or examples with BMODE=DEBUG now both turns
    on internal sanity checks and causes the compiler to provide for
    symbolic debugging.
  o Template collections based on hashing no longer abort if they are
    constructed or resized to zero capacity.
  o Modified the persistence mechanism to increase speed for storing
    large collections.
  o RWLocaleSnapshot now correctly returns false from
    stringToNum(const RWCString&,*long) when the string represents a
    number "just too large" to fit in the long.
  o A miscellany of performance enhancements, minor bug fixes, and
    changes to quiet compiler warnings.
------------------------------
7.0.0 --> 7.0.1
Date:     April 1996
------------------------------
  o Certify on 16-bit systems.
  o minor bug fixes.

------------------------------
6.1.0 --> 7.0.0
Date:     March 1996
------------------------------
  o New C++ Standard-Library based template collections:
    With this release we are adding a whole new set of template based
    collection classes -- 28 new implementations in all. These classes
    are designed to be your "Gateway to the Standard." If you have the
    Standard C++ Library available, we have provided new
    implementations of the template based collections that will make
    use of it. However, for those of you who do not have access to the
    new Standard C++ Library, most of these classes are still
    available with a slightly reduced API(The calls which are passed
    through directly to the Standard Library API are not there). This
    gives you the chance to code now (and in fact to continue to use
    Version 6.1 Tools.h++ code) and port to the standard library
    version later with a simple re-compile.

    Note to those users who absolutely must have the old classes,
    regardless of the presence of the Standard C++ Library.  There are
    two choices:
      You can edit rw/compiler.h to be sure RW_NO_STL is defined for
      your compiler.  This causes the template header files to
      use the V6.1 template code.

      Alternatively, you can do the work yourself by changing your
      code to #include the appropriate "V6.1" file. The transformation
      is to change the leading "t" in the header name to "x." For
      example, #include "rw/tphset.h" becomes #include "rw/xphset.h"
      BEWARE that the classes are named exactly the same in the two
      header files: If you use the "x" header any place, you must be
      sure never to use the "t" header in the same code, and vice
      versa, to avoid confusion (or worse, incorrect behavior) on the
      part of the compiler and linker.

  o Class RWCRExpr: A new extended regular expression class.
    This class represents an extended regular expression such as those
    found in lex and awk. The constructor "compiles" the expression to
    an internal format. The results can then be used for string
    searches using class RWCString. Regular expressions can be of
    arbitrary size, limited by memory. The extended regular expression
    features found here are a subset of those found in the POSIX.2
    standard (ANSI/IEEE Std 1003.2, ISO/IEC 9945-2), including
    grouping and alternation. Note that your compiler must support
    exception handling, templates, and Rogue Wave's C++ Standard
    Library V. 1.2 to use this class.

  o New RWStringID:
    When creating a persistable class derived from RWCollectable, you
    now have the choice of supplying an RWClassID (an unsigned short
    value) as in earlier versions of the library, or, new to this
    version, a more descriptive RWStringID. For example, instead of
       DEFINE_COLLECTABLE(MyFooClass, 0x101A)
    you might now say
       DEFINE_NAMED_COLLECTABLE(MyFooClass, "D1T3_MyFooClass")
    In return for a small amount of additional overhead, this new
    feature should make it easier for large teams of developers to
    manage their ID space. See the chapter on "Designing an
    RWCollectable Class" in the Tools.h++ User's Guide for more
    information.

  o Class RWAuditStreamBuffer:
    This class can be used to count the number of bytes that an object
    will take up when persisted via the Rogue Wave virtual stream
    mechanism. This provides, for streams, the equivalent of
    RWCollectable::recursiveStoreSize(), which only works for RWFiles.
    RWAuditStreamBuffer can also be constructed with a function
    pointer so that the function will be called with each byte that
    passes through the stream.

  o We now support the Macintosh! Platform details in the Macintosh
    section.

  o Locale-based string formatting improved:
    In classes RWDate, RWTime, and RWLocale, member functions
    asString() that take a strftime-like formatting character have
    been extended with an overloaded version that will take a string
    of format characters in one call. At the same time, because the
    formatting specification "%C" is not universally supported, and
    worse, means different things on different systems, we have
    deprecated its use. It is still present for those compilers that
    support it to mean "long date and time" but is no longer
    documented.

  o New example programs:
    We have added several new example programs for the new
    standard-library based template collections as well as the new
    extended regular expression class.  As a convenience, we have also
    provided code for many of the examples found in the printed
    manual.  Look in the toolexam and toolexam/manual directories.

  o Better access to RWDate internals:
    Both accessor and mutator functions are now provided for the
    internal julian day number within an RWDate object. Developers had
    requested this to make the class more useful as an underlying
    representation for more domain-specific date classes. (If you had
    already found a way to make these available, you may leave your
    "round the barn" code in place, or choose to make use of the
    easier interface.)

  o Storage size for nil:
    A new static member function RWCollectable::nilStoreSize() returns
    the number of bytes required to store a nil pointer in an RWFile.

  o RWFile "mode" extensions:
    An optional mode parameter has been added to the static member
    function RWFile::Exists(const char* name, int mode = F_OK). This
    allows you to check whether a file exists and is executable,
    writable, and/or readable.

    The member function RWFile::access(), returns the access mode used
    to open the FILE* upon which the class is implemented.

  o Better 16-bit DLL support (works with Windows 95):
    The 16-bit Windows Tools.h++ DLL has been re-written so that it no
    longer depends on the undocumented Windows function employed in
    previous versions of the library. This means that 16-bit
    executables built against the 16-bit DLL version of Tools.h++ will
    run successfully under Windows 95. (Such programs have always
    worked, and will continue to work, under Windows NT). Another
    benefit to the new design is that we have done away with the small
    auxiliary DLL that stays in memory "forever." Instead there is an
    auxiliary executable which takes care of managing per-task data.
    This executable politely exits when no longer needed. See
    tooldll.doc for more information.  Note that 32 bit DLLs continue
    to work as before.

  o RWBench::parse() for Windows:
    We have overloaded RWBench::parse() to take a single char*
    argument-list. This allows Windows programmers to use the RWBench
    parse function without having to translate the Windows-provided
    command line argument string into the traditional argv and argc
    parameters.

  o RWBinaryTree additions:
    We have enhanced the performance of RWBinaryTree::balance() and
    added a new method height() that returns the largest number of
    nodes traversed between the root and a leaf. (The height() of a
    tree with one element is 1.)

  o Static hash() members:
    RWDate, RWCString, RWTime, and RWWString all have new static
    hash() member functions, e.g.:
        static unsigned RWCString::hash(const RWCString& str)
     Each one simply turns around and calls its own hash member function,
    (e.g. str.hash()).  These were added so that programmers could
    supply them to hash collections such as RWTValHashTable, rather
    than repeatedly writing their own tiny hash functions.

  o New Set functions:
    Classes RWTValHashSet, and RWTPtrHashSet have been given new
    member functions providing the set-theoretic functions union,
    difference, intersection, subset, proper subset, and equivalence.

  o Improved exception safety:
    We have enhanced the library to make it still safer in a world of
    C++ exceptions. In particular, we scanned the library to protect
    against dangling resources and inconsistent states which might
    have resulted from an exception being thrown from code belonging
    to a user of our library. Even something as innocent looking as an
    assignment statement involving instances of some type T in a class
    parameterized on T is a potential culprit that might throw an
    exception. As a specific example, we wrapped up the static read
    and store tables used for persistence. Now if an exception is
    thrown, say, from a user's saveGuts function, the store table will
    be properly destroyed and not left dangling.

    Unfortunately, we cannot do that work for the RWCollectable that
    was being restored when the exception is thrown: Only the
    programmer who wrote saveGuts and restoreGuts can know the exact
    shape of the RWCollectable that is being restored so that
    programmer must be the one to write code that will correctly deal
    with the partly restored RWCollectable which will be available if
    an exception is thrown.

  o Better error messages:
    We have fixed a few run-time error messages to make a little more
    sense.  We sincerely hope your users never see the result of this
    effort!

  o Removed proprietary memory checking:
    Rogue Wave is no longer supplying or supporting the special memory
    checking compilation options that were available in previous
    releases. We highly recommend that you buy and use one of the
    commercially available memory checking utilities.

  o Bug fix for RWpostream::operator<<() and RWpistream::operator>>():
    These now handle unprintable characters such as '\n' and '\b'.
    Previously, the restored value was always the character '\', and
    the stream was left unsynchronized for subsequent restores.

  o XDR streams may now be constructed from a streambuf* or stream
    reference.

  o Change to RWCSubString and RWWSubString:
    The undocumented data() member functions have been deprecated
    although they remain publicly accessible to preserve source
    compatibility with Tools.h++ Version 6.1. Method data() has been
    replaced by the equally undocumented startData(), which will not
    remain public in a future version. Since RWCSubString works by
    referencing the RWCString's data, if you attempt to directly use
    the data() member of the substring, you will very likely be
    surprised by the result, which will not be null terminated at the
    extent of the substring, but at the end of the RWCString to which
    it refers.

  o BTree improvements:
    RWBTree and RWBTreeOnDisk made use of a cache that caused them not
    to be re-entrant. We moved the cached information onto the call
    stack, so they are both now re-entrant. In addition, since RWBTree
    calculated the number of items for each call to entries(), we were
    able to re-use the space to cache the number of items instead.
    This has the potential to be a major speed improvement if your
    program uses RWBTree::entries() on large RWBTrees.

  o RWBTreeOnDisk may now be used to access a read-only file.

  o Changed implementation of RWLocaleDefault:
    Because of "cross-talk" between ANSI C setlocale() and sprintf(),
    RWLocaleDefault now has a private constructor, and is completely
    undocumented. If you have been using RWLocaleDefault, you may
    obtain the pointer to a new RWLocale* on the heap by calling
    RWLocale* RWLocale::defaultLocale() which returns a pointer to a
    "real" RWLocaleDefault if your compiler doesn't support ANSI C
    locales, or a pointer to an RWLocaleSnapshot("C") if it does.

  o RWCSubString and RWWSubString assignment operators:
    Assignment from equivalent substrings now acts as expected: All
    substring assignments now are documented to return a reference to
    "self" (and "self" is now fixed to have the assigned extent so
    that such references are useful).

  o RWCString and RWWString from streams:
    The efficiency of reading an RWCString or RWWString from a stream
    has been much improved by changing the heuristic for stringRef
    resizing.

  o RWCString and RWWString space pre-allocation:
    The Tools.h++ string classes no longer "shrink to fit" unless you
    change them by removing one or more characters. In particular, you
    may now create a string with a larger buffer than it now needs,
    then add to it without losing the buffer.

  o Persisting large collections improved:
    Very large persisted collections will now read back into memory
    much more efficiently. The cost is that recovering medium sized
    collections may temporarily use more heap space than was used
    previously.

  o Embedded nulls handled better:
    RWCString and RWWString methods first(char), first( char*) and
    last(char) have been extended to correctly handle embedded nulls
    in both the string and search key.

    RWCTokenizer has been updated to work correctly with RWCStrings
    that contain embedded NULL characters.

  o RWTValOrderedVector and RWTValSortedVector item removal:
    A subtle fix has been made to the semantics of removing items from
    either of the RWTValOrderedVector<T> or RWTValSortedVector<T>
    collections. Previously, when an item or items were removed from
    one of these collections, the remaining items were copied (or
    "slid") to the left and the count of items adjusted accordingly.
    This sliding resulted in unused cells to the right, cells which
    nonetheless contained the same objects that were there before any
    sliding took place. In particular, this created a problem for
    reference-counted objects that were referred to by items in the
    collection. We have fixed this problem by making sure that any
    unused cells are reset, via the assignment operator, to the
    default value of the element type T. Affected member functions
    include remove(), removeAt(), removeAll(), removeFirst(),
    removeLast(), and clear().

  o RWBTreeDictionary::operator==() fixed:
    Operator==() on RWBTreeDictionary now compares values as well as
    keys. Beware that if you were depending on the previous behavior,
    the semantics of your program will change!

  o Full template support for 16-bit DLLs:
    Templates are now fully supported. (Previously they
    could not be used from a user DLL without modification to the
    RWExport macro). See tooldll.doc.

  o RWTime constructor for small times:
    The RWTime::RWTime(unsigned secs) constructor now works correctly
    for small values of s (e.g. secs = 10). Previously there was a
    problem when secs was less than the number of seconds between the
    local time zone and GMT.

  o RWTime and the 21st century:
    RWTime objects are now correctly constructed when given dates
    beyond the year 2000.  We encourage you to start NOW to use
    4-digit years in your code. For the sanity and those of us who
    must maintain code into the 21st century.

  o RWTime is now aware of the changeover between standard and
    daylight time at the exact moment of change, rather than one
    second later.

  o Config rewritten:
    Unix users will now use a much improved config script. It has what
    we hope is a much nicer "look and feel" as well as having more,
    and improved tests. Sorry to say, the "more" part of the tests
    probably mean it runs a little longer now than in previous
    versions. In particular, config should be better able to discover
    the real capabilities of your platform for wide character strings,
    multi-threading, and the use of shared libraries.

  o We have worked around a problem with iostreams in MSVC so that
    using the setw manipulator with ios::left now works correctly when
    streaming out an RWCString.

  o For g++, rw/generic.h no longer uses the generic.h provided by
    libg++. libg++ falls under the LGPL, so g++ customers don't want
    to use it, and may not even have it installed. (We should note
    that although g++ is not on the list of Tools.h++ certified
    platforms, occasionally a guerilla developer will sneak in and
    make a change for the benefit of g++ users.)

  o A miscellany of small bugs fixed, small features added, and other
    "housekeeping" changes too numerous to mention
