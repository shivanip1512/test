//constants
#define PORTER_NAME		"Yukon Port Control Service"
#define SCANNER_NAME	"Yukon Real-Time Scan Service"
#define MACS_NAME		"Yukon MAC Scheduler Service"
#define LM_NAME			"Yukon Load Management Service"
#define FDR_NAME		"Yukon Foreign Data Service"
#define DISPATCH_NAME	"Yukon Dispatch Service"
#define CC_NAME			"Yukon Cap Control Service"
#define CALC_NAME		"Yukon Calc-Logic Service"
#define WEB_NAME		"YukonWebApplicationService"
#define NOTIF_NAME		"YukonNotificationServer"
#define SM_NAME			"YukonServiceMgr"
#define SYS32			"C:\\WINDOWS\\System32\\"
#define TOMCAT_REG_KEY	"SOFTWARE\\Apache Software Foundation\\Procrun 2.0\\YukonWebApplicationService\\Parameters\\Java"
#define JVM_MX			"JvmMx"
#define JVM_OPTIONS		"Options"
#define JAVA_CALC_HIST  "CalcHist"

//global variable used to store service settings across the upgrade process
string sServiceSettings(11);
string sJvmMx, sJvmOptions;
number nTomcatSettingsExist, nJvmOptionsSize;

//-------------------------------------------------------
// Helper function to build up a list of the Yukon
// service names in the provided string array.
//-------------------------------------------------------
export prototype void PopulateServiceNameList(BYREF VARIANT); //array parameters must
function void PopulateServiceNameList(sServiceNameArray) //be prototyped as VARIANT
begin
	//if the array is too small, increase the size
	if(SizeOf(sServiceNameArray) < 11) then
		Resize(sServiceNameArray, 11);
	endif;
	//populate
	sServiceNameArray(0) = SCANNER_NAME;
	sServiceNameArray(1) = MACS_NAME;
	sServiceNameArray(2) = LM_NAME;
	sServiceNameArray(3) = FDR_NAME;
	sServiceNameArray(4) = DISPATCH_NAME;
	sServiceNameArray(5) = CC_NAME;
	sServiceNameArray(6) = CALC_NAME;
	sServiceNameArray(7) = PORTER_NAME;
	sServiceNameArray(8) = WEB_NAME;
	sServiceNameArray(9) = NOTIF_NAME;
	sServiceNameArray(10) = SM_NAME;
end;

//-------------------------------------------------------
// Helper function to save current Yukon service
// configurations prior to an upgrade so they can be
// reapplied afterward.
//-------------------------------------------------------
export prototype void SaveServiceSettings();
function void SaveServiceSettings()
number i, nType, nSize, nResult;
string sServiceNameArray(11), sRegKey, sKeyValue;
begin
	PopulateServiceNameList(sServiceNameArray);
	RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
	for i = 0 to (SizeOf(sServiceNameArray)-1)
		if (ServiceExistsService(sServiceNameArray(i))) then
			//get service start values from registry
			sRegKey = "SYSTEM\\CurrentControlSet\\Services\\" + sServiceNameArray(i);
			nResult = RegDBGetKeyValueEx(sRegKey, "Start", nType, sKeyValue, nSize);
			if(nResult < 0) then
				MessageBox ("Unable to save service settings: " + sServiceNameArray(i) + ".", SEVERE);
			endif;
			sServiceSettings(i) = sKeyValue;
		endif;
	endfor;
	RegDBSetDefaultRoot(HKEY_CLASSES_ROOT); //set back to default
end;

//-------------------------------------------------------
// Helper function to apply saved configurations to the
// Yukon services after an upgrade.
//-------------------------------------------------------
export prototype void LoadServiceSettings();
function void LoadServiceSettings()
number i, nResult;
string sServiceNameArray(11), sRegKey, sTemp;
BOOL bEntryFound;
begin
	PopulateServiceNameList(sServiceNameArray);
	RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
	//write service start values to the registry
	for i = 0 to (SizeOf(sServiceNameArray)-1)
		if (ServiceExistsService(sServiceNameArray(i))) then
			sRegKey = "SYSTEM\\CurrentControlSet\\Services\\" + sServiceNameArray(i);
			nResult = RegDBSetKeyValueEx(sRegKey, "Start", REGDB_NUMBER, sServiceSettings(i), -1);
			if(nResult < 0) then
				MessageBox ("Unable to save service settings: " + sServiceNameArray(i) + ".", SEVERE);
			endif;
		endif;
	endfor;
	RegDBSetDefaultRoot(HKEY_CLASSES_ROOT); //set back to default
end;

//-------------------------------------------------------
// Helper function to clean up the version string for the
// currently installed version.  This number is pulled
// from the registry in an odd format.  Version 5.1.2
// initially looks like 5.01.002.  Thus, we need to parse
// it.
//-------------------------------------------------------
export prototype string CleanupInstalledVersionNum();
function string CleanupInstalledVersionNum()
string sOldVersion, sV1, sV2, sV3;
number nTemp;
begin
	sOldVersion = IFX_INSTALLED_VERSION;
	//the first segment is fine
	StrSub(sV1, sOldVersion, 0, 1);
	//convert to number and back to remove leading 0s
	StrSub(sV2, sOldVersion, 2, 2);
	StrToNum(nTemp, sV2);
	NumToStr(sV2, nTemp);
	//rinse and repeat
	StrSub(sV3, sOldVersion, 5, 3);
	StrToNum(nTemp, sV3);
	NumToStr(sV3, nTemp);
	//put it all back together
	sOldVersion = sV1 + "." + sV2 + "." + sV3;
	return sOldVersion;
end;

//-------------------------------------------------------
// Helper function to determine if the user is attempting
// an upgrade on a version that does not support it. 
// Upgrades are only supported when the installed version
// is 5.1.3 or higher.
//-------------------------------------------------------
export prototype BOOL IsUpgradeSupported();
function BOOL IsUpgradeSupported()
string sOldVersion, sTemp;
number nV1, nV2, nV3;
begin
	sOldVersion = IFX_INSTALLED_VERSION;
    //split version into three version components
    StrSub(sTemp, sOldVersion, 0, 1);
    StrToNum(nV1, sTemp);
    StrSub(sTemp, sOldVersion, 2, 2);
    StrToNum(nV2, sTemp);
    StrSub(sTemp, sOldVersion, 5, 3);
    StrToNum(nV3, sTemp);
    //if version is prior to 5.1.3, upgrade is not supported
    if(nV1 < 5) then
    	//4.x.x or earlier
    	return FALSE;
    elseif(nV1 > 5) then
    	//6.x.x or later
    	return TRUE;
    endif;
    //if we didn't return above, version is 5.x.x
    if(nV2 < 1) then
    	//5.0.x
    	return FALSE;
    elseif(nV2 > 1) then
    	//5.2.x or later
    	return TRUE;
    endif;
    //if we didn't return above, version is 5.1.x
    if(nV3 < 3) then
    	//5.1.2 or earlier
    	return FALSE;
    else
    	//5.1.3 or later
    	return TRUE;
    endif;    
end;

//-------------------------------------------------------
// Helper function to determine if the installed version
// is newer than the version that is attempting to 
// install.
//-------------------------------------------------------
export prototype BOOL IsDowngrade();
function BOOL IsDowngrade()
string sOldVersion, sNewVersion, sTempOld, sTempNew;
number nOldV1, nOldV2, nOldV3, nNewV1, nNewV2, nNewV3;
BOOL isDowngrade;
begin
	sOldVersion = IFX_INSTALLED_VERSION;
	sNewVersion = IFX_PRODUCT_VERSION;
	//split old version into three version components
    StrSub(sTempOld, sOldVersion, 0, 1);
    StrToNum(nOldV1, sTempOld);
    StrSub(sTempOld, sOldVersion, 2, 2);
    StrToNum(nOldV2, sTempOld);
    StrSub(sTempOld, sOldVersion, 5, 3);
    StrToNum(nOldV3, sTempOld);
    //split new version into three version components
    //(slightly different format)
    StrSub(sTempNew, sNewVersion, 0, 1);
    StrToNum(nNewV1, sTempNew);
    StrSub(sTempNew, sNewVersion, 2, 2);
    StrToNum(nNewV2, sTempNew);
    StrSub(sTempNew, sNewVersion, 4, 3);
    StrToNum(nNewV3, sTempNew);
	//compare old to new
	isDowngrade = FALSE;
	if(nOldV1 > nNewV1) then
		isDowngrade = TRUE;
	else
		if(nOldV2 > nNewV2) then
			isDowngrade = TRUE;
		else
			if(nOldV3 > nNewV3) then
				isDowngrade = TRUE;
			endif;
		endif;
	endif;
	return isDowngrade;
end;

//-------------------------------------------------------
// Helper function to check for any running Yukon 
// services
//-------------------------------------------------------
export prototype BOOL AreYukonServicesRunning();
function BOOL AreYukonServicesRunning()
string sServiceNameArray(11);
number i, nServiceState; 
begin
	PopulateServiceNameList(sServiceNameArray);
	for i = 0 to (SizeOf(sServiceNameArray)-1)
		if(ServiceExistsService(sServiceNameArray(i))) then
			ServiceGetServiceState(sServiceNameArray(i), nServiceState);
			if (nServiceState != SERVICE_STOPPED) then
				//at least one service was not stopped
				return TRUE;
			endif;
		endif;
	endfor;
	//all services were stopped
	return FALSE;
end;

//-------------------------------------------------------
// Helper function to remove java Calc Hist service
//-------------------------------------------------------
export prototype RemoveCalcHist();
function RemoveCalcHist()
begin
    if(ServiceExistsService(JAVA_CALC_HIST)) then
	ServiceRemoveService(JAVA_CALC_HIST);
	endif;
end;

//-------------------------------------------------------
// Helper function to build up a list of the Yukon
// service names in the provided string array.
//-------------------------------------------------------
export prototype void PopulateDirNameList(BYREF VARIANT); //array parameters must
function void PopulateDirNameList(sdirArray) //be prototyped as VARIANT
begin
	//if the array is too small, increase the size
	if(SizeOf(sdirArray) < 4) then
		Resize(sdirArray, 4);
	endif;
	//populate
	sdirArray(0) = "docs";
	sdirArray(1) = "examples";
	sdirArray(2) = "host-manager";
	sdirArray(3) = "manager";
end;

//-------------------------------------------------------
// Helper function to remove WebApp directories
//-------------------------------------------------------
export prototype CleanupTomcatWebapps();
function CleanupTomcatWebapps()
string sDir;
string sdirArray(4);
number i;
begin
	PopulateDirNameList(sdirArray);
    sDir = TARGETDIR ^ "\\Server\\web\\webapps\\";
	
	for i = 0 to (SizeOf(sdirArray)-1)
		DeleteDir(sDir+sdirArray(i), ALLCONTENTS);
	endfor;
end;

//---------------------------------------------------
// Helper function to start or stop the Yukon services.
// TRUE to start services, FALSE to stop them
//---------------------------------------------------
export prototype StartYukonServices(BOOL);
function StartYukonServices(bStart)
string sServiceNameArray(11);
string sCMD;
number i;
begin
	PopulateServiceNameList(sServiceNameArray);
	sCMD = SYS32 + "net.exe";
	
	if(bStart) then
		//start services
		//this may take a moment, so give the user some feedback
		SdShowMsg("Starting Yukon Services. This may take a moment.", TRUE);
    	SaveServiceSettings(); //needed to determine the "start" parameter below
    	for i = 0 to (SizeOf(sServiceNameArray)-1)
			//only start a service if its startup is set to "automatic" - i.e. "2" in the registry
			if(sServiceSettings(i) = "2") then
				LaunchApplication(sCMD, "start \"" + sServiceNameArray(i) +"\"", "", SW_HIDE, 0, LAAW_OPTION_WAIT);
			endif;
		endfor;
		//get out of "hidden" app-launch mode
		LaunchApplication("", "", "", SW_NORMAL, 0, LAAW_OPTION_WAIT);
    	//hide the popup
    	SdShowMsg("", FALSE); 
    	return 0;	
	else
	    //stop services
	    SdShowMsg("Stopping Yukon Services.", TRUE);
	    for i = 0 to (SizeOf(sServiceNameArray)-1)
			LaunchApplication(sCMD, "stop \"" + sServiceNameArray(i) +"\"", "", SW_HIDE, 0, LAAW_OPTION_WAIT);
		endfor;
		//get out of "hidden" app-launch mode
		LaunchApplication("", "", "", SW_NORMAL, 0, LAAW_OPTION_WAIT);
	    //hide the popup
	    SdShowMsg("", FALSE);
	    return 0;
	endif;
end;

//------------------------------------------------------------
// Convenience function to stop Yukon services
//------------------------------------------------------------
export prototype StopYukonServices();
function StopYukonServices()
begin
	StartYukonServices(FALSE);
end;

//------------------------------------------------------------
// Helper function that searches the specified file for the
// "search" string and replaces all instances with the 
// "replace" string.
//------------------------------------------------------------
export prototype ReplaceStringInFile(string, string, string);
function ReplaceStringInFile(sFile, sSearch, sReplace)
number nGrepResult, nGrepLineNumber;
string sGrepReturnLine;
begin
	nGrepResult = 1;
	while(nGrepResult >= 0)
		nGrepResult = FileGrep(sFile, sSearch, sGrepReturnLine, nGrepLineNumber, RESTART);
		if(nGrepResult >= 0) then
			StrReplace(sGrepReturnLine, sSearch, sReplace, 0);
			FileInsertLine(sFile, sGrepReturnLine, nGrepLineNumber, REPLACE);
		endif;
	endwhile;
end;

//-------------------------------------------------------
// Save memory settings and jvm parameters for Tomcat,
// if they exist.
//-------------------------------------------------------
export prototype void SaveJvmParams();
function void SaveJvmParams()
string sConfPath, sMemReturnLine, sParamReturnLine, sError, sResult;
number nLooping, nType, nSize, nResult, nMemLineNumber, nParamLineNumber, nParamsSize;
begin
	//TOMCAT SETTINGS - from registry
	RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE); //set registry root
	
	nTomcatSettingsExist = RegDBKeyExist(TOMCAT_REG_KEY);
	
	if(nTomcatSettingsExist) then
		RegDBGetKeyValueEx(TOMCAT_REG_KEY, JVM_MX, nType, sJvmMx, nSize);
		RegDBGetKeyValueEx(TOMCAT_REG_KEY, JVM_OPTIONS, nType, sJvmOptions, nJvmOptionsSize);
	else
		//error - no tomcat settings found, update manually
		MessageBox("Unable to save web server JVM settings. Settings will reset to default values.", WARNING);
	endif;
	RegDBSetDefaultRoot(HKEY_CLASSES_ROOT); //set back to default
end;

//------------------------------------------------------------
// Restore saved memory settings and jvm parameters for Tomcat
//------------------------------------------------------------
export prototype void LoadJvmParams();
function void LoadJvmParams()
string sConfPath, sReturnLine, sTemp;
number nResult, nLineNumber, i;
begin
	//restore Tomcat settings to registry
	if(nTomcatSettingsExist) then
		RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE); //set registry root
		RegDBSetKeyValueEx(TOMCAT_REG_KEY, JVM_MX, REGDB_NUMBER, sJvmMx, -1);
		RegDBSetKeyValueEx(TOMCAT_REG_KEY, JVM_OPTIONS, REGDB_STRING_MULTI, sJvmOptions, nJvmOptionsSize);
		RegDBSetDefaultRoot(HKEY_CLASSES_ROOT); //set back to default
	endif;
end;

//------------------------------------------------------------
// Helper function that permits write access to a file for
// the Users group (essentially everyone).
//------------------------------------------------------------
export prototype AllowWriteAccessForUsers(string);
function AllowWriteAccessForUsers(sFilePath)
number nResult;
begin
	nResult = SetObjectPermissions(sFilePath, IS_PERMISSIONS_TYPE_FILE, "", "Users", 
				FILE_WRITE_DATA|FILE_APPEND_DATA|FILE_WRITE_EA|FILE_WRITE_ATTRIBUTES, 0);
	if(nResult != ISERR_SUCCESS) then
		MessageBox("Error setting file permissions. File: " + sFilePath, WARNING);
	endif;
end;

//------------------------------------------------------------
// Helper function that creates a backup of the current
// TARGETDIR in a location chosen by the user.
//------------------------------------------------------------
export prototype BackupTargetDir();
function BackupTargetDir()
string sDir, sDateString, sTimeString;
number nResult;
begin
	sDir = "C:\\YukonBackups";
	nResult = SdAskDestPath("Select backup location.",
							"Select a location to store the backup file."
							+ " Note that log files will not be copied.",
							sDir, 0);
	if(nResult = NEXT) then
		//disable cancel, because documentation says bad things can happen 
		//if you cancel in the middle of copying
		Disable(CANCELBUTTON);
		//disable logging so the backup isn't touched by uninstall
		Disable(LOGGING);
		SRCDIR = TARGETDIR;
		GetSystemInfo(DATE, nResult, sDateString);
		GetSystemInfo(TIME, nResult, sTimeString);
		StrReplace(sTimeString, ":", "", 0); 
		sDir = sDir + "\\YukonBackup" + sDateString + "_" + sTimeString;
		SdShowMsg("Backing up Yukon files. This may take a while.", TRUE);
		CreateDir(sDir);
		XCopyFile("*.*", sDir, INCLUDE_SUBDIR);
		//delete backup log folders, these tend to take up too much space
		DeleteDir(sDir ^ "Client\\Log", ALLCONTENTS);
		DeleteDir(sDir ^ "Server\\Log", ALLCONTENTS);
		DeleteDir(sDir ^ "Server\\web\\logs", ALLCONTENTS);
		//this could be improved by zipping the backup
		SdShowMsg("", FALSE);
		Enable(LOGGING);
		Enable(CANCELBUTTON);
		return NEXT;
	else
	    return BACK;
	endif;
end;

//---------------------------------------------------------------
//Helper function that deletes all files in a specified directory
//with a specified file extension.
//---------------------------------------------------------------
export prototype DeleteFilesOfType(string, string);
function DeleteFilesOfType(sDirectory, sExtension)
number nResult;
string sSearchString;
begin
	sSearchString = "*." + sExtension;
	nResult = DeleteFile(sDirectory ^ sSearchString); 
	if(nResult < 0) then
		MessageBox("Error deleting files of type \"" + sSearchString + "\" in directory \"" + sDirectory + ". Old files may still be present.", WARNING);
	endif;
end;

//-------------------------------------------------------
// Helper function to clean up the version string for the
// installed version passed as the parameter.  Version 5.1.2
// initially looks like 5.01.002.  Thus, we need to parse
// it.
//-------------------------------------------------------
export prototype string CleanupVersionNum(string);
function string CleanupVersionNum(versionNumber)
string sV1, sV2, sV3;
number nTemp;
begin
	
	//the first segment is fine
	StrSub(sV1, versionNumber, 0, 1);
	//convert to number and back to remove leading 0s
	StrSub(sV2, versionNumber, 2, 2);
	StrToNum(nTemp, sV2);
	NumToStr(sV2, nTemp);
	//rinse and repeat
	StrSub(sV3, versionNumber, 5, 3);
	if (sV3 != '') then
		StrToNum(nTemp, sV3);
		NumToStr(sV3, nTemp);
	else 
		sV3 = '0';
	endif;
	//put it all back together
	versionNumber = sV1 + "." + sV2 + "." + sV3;
	return versionNumber;
end;