/*****************************************************************************
*
*    FILE NAME: xcel.cpp.cpp
*
*    DATE: 02/13/2001
*
*    AUTHOR: David Sutton
*
*    PURPOSE: Import receiver data from Xcel's PMSI system
*
*    Copyright (C) 2001 Cannon Technologies, Inc.  All rights reserved.
*
*
* 	 Example input lines:

A,1416842924,REEDY CLYDE.M,,,5 SWALLOW LN,NORTH OAKS,MN,55127,6514843058,0,570485,205,01,0,16,GLK0,3569,1401,0,1656,1816,3569,0,7.5,7.5,7.5,7.5,0,2,,,,,5,082370858,E,0,,R,144457559                                                     
A,2355642216,KUEHN STEVEN.J,,,3440 BUCKBEE RD,WHITE BEAR LK.,MN,55110,6517772595,0,440022,205,01,0,16,,3569,1401,0,1656,1816,3569,0,7.5,7.5,7.5,7.5,0,2,,,,,5,028006226,E,0,,R,236911050                                                 
D,1669524655,ANDERSON JOHN.R,,,831 66TH AVE NE,FRIDLEY,MN,55432,7635710333,0,293795,205,01,0,18,MOL0,3569,,,,,,,,,,,0,1,,,,,5,094447647,O,0,,R,167571752                                                                                 
D,0093375574,LERUM TIMOTHY.J,,,8300 MISSISSIPPI BLV NW,COON RAPIDS,MN,55433,7637174972,6129278490,930426,205,01,0,18,MOL0,3569,,,,,,,,,,,0,2,,,,,6,082682114,E,0,,R,009353132                                                            
D,0064428066,MASER RICHARD.L,,,2916 WOODBRIDGE ST,ROSEVILLE,MN,55113,6514842623,0,165662,205,01,0,13,RAM0,3569,,,,,,,,,,,0,2,,,,,5,073253611,E,0,,R,009733486                                                                            
R,1416842924,REEDY CLYDE.M,,,,,,,0,0,570485,205,01,0,16,GLK0,,,,,,,,,,,,0,2,,,,,5,082370858,E,0,,R,144457559                                                                                                                             
I,1416842924,REEDY CLYDE.M,,,5 SWALLOW LN,NORTH OAKS,MN,55127,6514843058,0,570485,205,01,0,16,GLK0,3569,1401,0,1656,1816,3569,0,7.5,7.5,7.5,7.5,0,2,,,,,5,082370858,E,0,,R,144457559                                                     
R,2355642216,KUEHN STEVEN.J,,,,,,,0,0,440022,205,01,0,16,,,,,,,,,,,,,0,2,,,,,5,028006226,E,0,,R,236911050                                                                                                                                
I,2355642216,KUEHN STEVEN.J,,,3440 BUCKBEE RD,WHITE BEAR LK.,MN,55110,6517772595,0,440022,205,01,0,16,,3569,1401,0,1656,1816,3569,0,7.5,7.5,7.5,7.5,0,2,,,,,5,028006226,E,0,,R,236911050

*
****************************************************************************
*/
#include "yukon.h"
#include "xcel.h"

/***************************
*
*  This function reads in the file generated by PMSI and 
*  returns a list of text commands to configure switches,
*  send service commands, etc
****************************
*/
bool DecodePMSIFile(const string& fileName, std::vector<RWCollectableString*>* commandList)
{
    FILE* fptr;
    char workBuffer[500];  // not real sure how long each line possibly is
	char command;
	string serialNum;
	string programming;

    if( commandList == NULL )
        return false;

// cout << "file to open is:  " << fileName << endl;

   	// open file
    if( (fptr = fopen( fileName.c_str(), "r")) == NULL )
    {
        CtiLockGuard< CtiLogger > guard(dout);
        dout << "unable to open file" << endl;
            return false;
    }

	// retrieve each line in order
    while( fgets( (char*) workBuffer, 500, fptr) != NULL )
    {
		/*****************
		*  ASCII command string built from the PMSI line
		******************
		*/
        RWCollectableString* decodedCommand = new RWCollectableString();

        if( true == isValidPMSILine( workBuffer, command, serialNum, programming ))
        {
			switch (command)
			{
				case 'A':
					{
						// activate command
						*decodedCommand = "PutConfig versacom serial ";
						*decodedCommand +=serialNum.c_str();
						*decodedCommand += " service in";
						commandList->push_back(decodedCommand);
						break;
					}
				case 'D':
				case 'R':
					{
						*decodedCommand = "PutConfig versacom serial ";
						*decodedCommand +=serialNum.c_str();
						*decodedCommand += " service out";
						commandList->push_back(decodedCommand);
						break;
					}
				case 'I':
				case 'N':
					{
						// send the activate first
						*decodedCommand = "PutConfig versacom serial ";
						*decodedCommand +=serialNum.c_str();
						*decodedCommand += " service in";
						commandList->push_back(decodedCommand);

						RWCollectableString* programCommand = new RWCollectableString();

						// send the programming
						*programCommand = "PutConfig versacom serial ";
						*programCommand +=serialNum.c_str();
						*programCommand += " ";
						*programCommand += programming.c_str();
						commandList->push_back(programCommand);
						programCommand= NULL;
						break;
					}
				default:
					delete decodedCommand;
					break;
			}
			// set to null for safety sakes
			decodedCommand = NULL;

        }
		else
		{
            delete decodedCommand;
		}
    }

//    cout << "closing file now!" << endl;
    fclose(fptr);

    if( ferror( fptr ) != 0 )
        return false;

    return true;
}


bool isValidPMSILine( char* line, char &command, string &serialNum, string &programming)
{
    char* wPtr = line;
	bool retCode = true;
	string entry;

	for (int fieldNumber=0; fieldNumber < 41; fieldNumber++)
	{
		// see if an error occured, might as well get out
		if (retCode != false)
		{
			// get the next token
			wPtr = getEntry (wPtr, entry);
		}
		else
		{
			break;
		}

		/***************************
		*  add one to our loop to stay consistent with
		*  the field numbers in the document describing the file
		****************************
		*/
		switch (fieldNumber+1)
		{
			case 1:
				{
					/***********************
					* this is the command type
					************************
					*/
					std::transform(entry.begin(), entry.end(), entry.begin(), toupper);
					switch (entry[0])
					{
						case 'A':
						case 'D':
						case 'R':
						case 'I':
						case 'N':
							{
								memcpy (&command, &entry[0],1);
							   	break;
							}
						default:
							retCode = false;
							break;
					}
					break;
				}
			case 12:
				{
					//serial number of device
					serialNum = entry;
					break;
				}
			case 13:
				{
					// type of device 
					// strcmp returns 0 if match is made
					if ((stricmp(entry.c_str(),"500")) && (stricmp(entry.c_str(),"501")))
					{
						retCode = false;
					}
					break;
				}
			case 37:
				{
					std::transform(entry.begin(), entry.end(), entry.begin(), toupper);
					switch (entry[0])
					{
						case 'O':
							{
								programming = "class 1";
								break;
							}
						case 'E':
							{
								programming = "class 2";
								break;
							}
						case 'B':
							{
								programming = "class 1,2";
								break;
							}
						default:
							retCode = false;
							break;
					}
					break;
				}
			case 40:
				{
					// program type R=residential or C=Commercial
					std::transform(entry.begin(), entry.end(), entry.begin(), toupper);
					switch (entry[0])
					{
						case 'R':
							break;
						default:
						   retCode = false;
					}
					break;
				}
			default:
				break;
		}
	}
    return retCode;
}   

/**********************
* used to retrieve comma separated data
* strtok wouldn't work because of multiple
* tokens in a row ,,,,
***********************
*/
char * getEntry (char *InBuffer,
                 string &outBuffer)
{
    char *ptr;

        // find comma if one exists
    if ((ptr = strchr (InBuffer, ',')) != NULL) {

            // found one
        *ptr = '\0';
		outBuffer = InBuffer;
        InBuffer += outBuffer.length() + 1;

    } else {

            // must be at the end of a line
        if ((ptr = strchr (InBuffer, '\0')) != NULL) {
            *ptr = '\0';
			outBuffer = InBuffer;
            InBuffer = '\0';
        }
    }
        // return current buffer
    return (InBuffer);
}


