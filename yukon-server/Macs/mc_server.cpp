#include "precompiled.h"

#include "mc_server.h"
#include "numstr.h"
#include "thread_monitor.h"
#include "msg_cmd.h"
#include "msg_pdata.h"
#include "msg_reg.h"
#include "amq_constants.h"
#include "module_util.h"
#include "ServiceMetricReporter.h"

#include <time.h>
#include <algorithm>
#include <utility.h>

#include "tbl_devicereadjoblog.h"
#include <boost/scoped_array.hpp>

using Cti::WorkerThread;
using namespace std;

#pragma warning(push)
#pragma warning(disable:4355) // disable the warning generated by worker thread using "this" in constructor initializer List

CtiMCServer::CtiMCServer()
: _client_listener(),
  _db_update_thread(_schedule_manager),
  _scheduler(_schedule_manager),
  _file_interface(_schedule_manager),
  _interp_pool(Mccmd_Init, createEscapeCommandSet()),
  _dispatchThread(WorkerThread::Function(&CtiMCServer::dispatchThreadFunc, this).name("DispatchThread")),
  _dispatchConnection(Cti::Messaging::ActiveMQ::Queue::dispatch)
{
}

#pragma warning(pop)

CtiMCServer::~CtiMCServer()
{
}

void CtiMCServer::dispatchThreadFunc()
{
    unique_ptr<CtiMessage> msg;

    while( _dispatchConnection.isConnectionUsable() )
    {
        msg.reset(_dispatchConnection.ReadConnQue(1000*30));

        if( msg.get() && msg->isA() == MSG_COMMAND && ((CtiCommandMsg*)msg.get())->getOperation() == CtiCommandMsg::AreYouThere )
        {
            _dispatchConnection.WriteConnQue(msg.release(), CALLSITE);

            if( gMacsDebugLevel & MC_DEBUG_MESSAGES )
            {
                CTILOG_DEBUG(dout, "MCServer Replied to Are You There message.");
            }
        }
    }
}

set<string> CtiMCServer::createEscapeCommandSet()
{
    std::set<string> escapeCommands;

    for each(const TclCommandMap::value_type &command in pilCommands)
    {
        escapeCommands.insert(command.first);
        escapeCommands.insert(boost::to_lower_copy(command.first));
        escapeCommands.insert(boost::to_upper_copy(command.first));
    }

    return escapeCommands;
}

void CtiMCServer::run()
{
    try
    {
        CTILOG_INFO(dout, "Connecting to dispatch");

        _dispatchConnection.setName("MACServer to Dispatch");
        _dispatchConnection.start();

        // start receive and reply to dispatch thread
        _dispatchThread.start();

        // send a registration message
        _dispatchConnection.WriteConnQue(new CtiRegistrationMsg("MACServer", 0, false), CALLSITE);

        // initialize timeout to next minute
        CtiTime timeout = getNextMinute();

        if( init() )
        {
            const long threadMonitorPointId = ThreadMonitor.getProcessPointID();
            Cti::ServiceMetrics::MetricReporter metricReporter {
                Cti::ServiceMetrics::CpuPointOffsets::Macs,
                Cti::ServiceMetrics::MemoryPointOffsets::Macs,
                "MACS",
                MACS_APPLICATION_NAME };

            CtiTime LastThreadMonitorTime, NextThreadMonitorReportTime;

            CtiThreadMonitor::State previous = CtiThreadMonitor::Normal;

            /* Main Loop */
            while(true)
            {
                dout->poke();  //  called roughly each minute (see _main_queue.getQueue() below)

                // Do thread monitor stuff
                if( threadMonitorPointId != 0 )
                {
                    if( (LastThreadMonitorTime.now().seconds() - LastThreadMonitorTime.seconds()) >= 2 )
                    {
                        CtiThreadMonitor::State next;
                        LastThreadMonitorTime = LastThreadMonitorTime.now();
                        if( (next = ThreadMonitor.getState()) != previous || LastThreadMonitorTime > NextThreadMonitorReportTime )
                        {
                            previous = next;
                            NextThreadMonitorReportTime = nextScheduledTimeAlignedOnRate( LastThreadMonitorTime, CtiThreadMonitor::StandardMonitorTime / 2 );

                            _dispatchConnection.WriteConnQue(
                                CTIDBG_new CtiPointDataMsg(threadMonitorPointId, ThreadMonitor.getState(), NormalQuality, 
                                StatusPointType, ThreadMonitor.getString().c_str()), CALLSITE);
                        }
                    }
                }

                metricReporter.reportCheck(CompileInfo, _dispatchConnection);

                // adjust the timeout if the next event time is imminent
                adjustTimeout(timeout);

                {
                    boost::scoped_ptr<CtiMessage> msg(_main_queue.getQueue(getRemainingMillis(timeout)));

                    if( isSet(CtiThread::SHUTDOWN) )
                    {
                        break; // thread exit point here
                    }

                    if( msg )
                    {
                        processMessage(*msg);

                        continue; // go back to the top to empty out the queue
                    }
                }

                // Release any outstanding interpreters we can
                releaseInterpreters();

                if( gMacsDebugLevel & MC_DEBUG_EVENTS )
                {
                    CTILOG_DEBUG(dout, "Checking event queue"<<
                            _scheduler.dumpEventQueue());
                }

                // Check to see if the next event is ready to go.
                _scheduler.getEvents( CtiTime::now(), work_around );

                for( work_around_iter = work_around.begin();
                     work_around_iter != work_around.end();
                     work_around_iter++ )
                {
                    processEvent(*work_around_iter);
                }

                work_around.clear();

                // force stop any schedules with completed scripts
                checkRunningScripts();

                // update timeout to next minute
                timeout = getNextMinute();

            } /* End of Main Loop */
        }
        else
        {
            CTILOG_ERROR(dout, "Initialization has failed");
        }
    }
    catch(...)
    {
        CTILOG_UNKNOWN_EXCEPTION_ERROR(dout);
    }

    CTILOG_INFO(dout, "Shutting down MACServer connection to dispatch");

    _dispatchConnection.close();
    _dispatchThread.join();

    /* We're done lets close down the server */
    CTILOG_INFO(dout, "Metering and Control shutting down");

    deinit();

    CTILOG_INFO(dout, "Metering and Control exiting");
}


void CtiMCServer::interrupt(int id)
{
    CtiThread::interrupt( id );
    _main_queue.interruptBlockingRead(); //wake up anyone blocking on a read
}

/*----------------------------------------------------------------------------
  logEvent

  Logs an event with dispatch.
  Uses a tcl interpreter to do the logging.

  user - the user who caused whatever that needs to be logged
  text - short description of what happened
----------------------------------------------------------------------------*/
void CtiMCServer::logEvent(const string& user, const string& text)
{
    // build up the logevent tcl command
    // make sure to embed " in case there are spaces in
    // user or text
    string cmd_string("LogEvent \"");
    cmd_string.append(user);
    cmd_string.append("\" \"");
    cmd_string.append(text);
    cmd_string.append("\" \" \""); //last arg is blank space

    if( gMacsDebugLevel & MC_DEBUG_EVENTS )
    {
        CTILOG_DEBUG(dout, cmd_string);
    }

    // Acquire an interpreter and send out the command
    CtiInterpreter* interp = _interp_pool.acquireInterpreter();
    interp->evaluateRaw( cmd_string, true ); //block
    _interp_pool.releaseInterpreter(interp);
}


/*----------------------------------------------------------------------------
  executeCommand

  Executes the start command for the given schedule in a tcl interpreter
  synchronously
----------------------------------------------------------------------------*/
void CtiMCServer::executeCommand(const string& command, long target)
{
    const char* selectPrefix = "Select deviceid ";
    string to_send;

    if( command.length() == 0 )
        return;

    if( target > 0 )
    {
        to_send.append(selectPrefix)
               .append(CtiNumStr(target))
               .append("\r\n");
    }

    to_send.append(command);

    if( gMacsDebugLevel & MC_DEBUG_INTERP )
    {
        CTILOG_DEBUG(dout, "Sending command to tcl for eval: "<< to_send);
    }

    // Acquire an interpreter and send out the command
    CtiInterpreter* interp = _interp_pool.acquireInterpreter();

    // reset mccmd for this command
    interp->evaluate("MCCMDReset");

    interp->evaluate( to_send, false ); //no blocking

    _executing_commands.push_back(interp);
}


bool CtiMCServer::init()
{
    bool status = false;

    try
    {
        /* Start Initialization */
        CTILOG_INFO(dout, "Metering and Control starting up...");

        // load up the database and start the db update thread
        // do not proceed until we have loaded the db successfully
        // but do respect interruptions

        while( !(status = loadDB()) )
        {
            CTILOG_ERROR(dout, "Could not retrieve and access the database, it may not be initialized.  Retry in 15 seconds.");

            if( sleep(15000) )
                break;
        }

        if( !loadCParms() )
        {
            CTILOG_ERROR(dout, "At least one cparm not found in master.cfg");
        }

        if( status )
        {
            unsigned scheduleNbr = 0;

            {
                CtiLockGuard<CtiMutex> map_guard(_schedule_manager.getMux() );
                scheduleNbr = _schedule_manager.getMap().size();
            }

            CTILOG_INFO(dout, "Loaded "<< scheduleNbr <<" schedules from the database.");
        }
        else
        {
            CTILOG_ERROR(dout, "Could not retrieve schedules from the database");

            status = false;
        }

        /* Set up our events */
        CtiTime now = stripSeconds(CtiTime::now());
        _scheduler.initEvents(now);

        _db_update_thread.start();

        /* start up the client listener */
        _client_listener.setQueue(&_main_queue);
        _client_listener.start();

        /* start up the file interface */
        _file_interface.setQueue(&_main_queue);
        _file_interface.start();

        /* start up connections to other services */
        CtiInterpreter* interp = _interp_pool.acquireInterpreter();
        interp->evaluate("pilstartup", true );
        _interp_pool.releaseInterpreter(interp);
    }
    catch(...)
    {
        CTILOG_UNKNOWN_EXCEPTION_ERROR(dout);
        status = false;
    }

    return status;
}

bool CtiMCServer::deinit()
{
    if( gMacsDebugLevel & MC_DEBUG_SHUTDOWN )
    {
        CTILOG_DEBUG(dout, "Stopping MACS file interface");
    }

    /* stop the file interface */
    _file_interface.stop();

    if( gMacsDebugLevel & MC_DEBUG_SHUTDOWN )
    {
        CTILOG_DEBUG(dout, "Stopping MACS client listener");
    }

    /* stop accepting connections */
    _client_listener.interrupt( CtiThread::SHUTDOWN );
    _client_listener.join();

    if( gMacsDebugLevel & MC_DEBUG_SHUTDOWN )
    {
        CTILOG_DEBUG(dout, "Stopping MACS tcl interpreter pool");
    }

    CtiInterpreter* interp = _interp_pool.acquireInterpreter();
    interp->evaluate("pilshutdown", true);
    _interp_pool.releaseInterpreter(interp);

    _interp_pool.stopAndDestroyAllInterpreters();

    if( gMacsDebugLevel & MC_DEBUG_SHUTDOWN )
    {
        CTILOG_DEBUG(dout, "Stopping MACS database update thread");
    }

    _db_update_thread.interrupt( CtiThread::SHUTDOWN );
    _db_update_thread.join();

    return true;
}

 /*----------------------------------------------------------------------------
   executeScript

   Executes a script type schedules script.
   Inserts the schedule's id and a pointer to the interpreter
   into _running_scripts to keep track of it
 ----------------------------------------------------------------------------*/
void CtiMCServer::executeScript(const CtiMCSchedule& sched)
{
    if( gMacsDebugLevel & MC_DEBUG_INTERP )
    {
        CTILOG_DEBUG(dout,
                dumpRunningScripts() <<
                endl <<"Dumping interpreter pool before executing a new script"<<
                _interp_pool);
    }

    CtiMCScript script;
    script.setScriptName( sched.getCommandFile() );

    if( script.readContents() )
    {
        //Acquire an interpreter to use
        CtiInterpreter* interp = _interp_pool.acquireInterpreter();

        // reset mccmd for this script
        interp->evaluate("MCCMDReset");

        // init the correct schedule id and holiday schedule id
        string init_id("set ScheduleID ");
        init_id += CtiNumStr( sched.getScheduleID() );

        interp->evaluate(init_id, true);

        init_id = "set HolidayScheduleID ";
        init_id += CtiNumStr( sched.getHolidayScheduleID() );

        interp->evaluate(init_id, true);

        // (re)set some variables
        interp->evaluate("set ScheduleName \"" + sched.getScheduleName() + "\"");
        interp->evaluate("set ScriptName \"" + script.getScriptName() + "\"");

        CTILOG_INFO(dout, "["<< interp->getID() <<"] "<< script.getScriptName());

        interp->setScheduleId(sched.getScheduleID());

        // start the evaluation, non-blocking
        interp->evaluate( script.getContents(), false, CtiMCServer::preScriptFunction, CtiMCServer::postScriptFunction );

        _running_scripts.insert(
        map< long, CtiInterpreter* >::value_type(sched.getScheduleID(), interp ) );
    }
    else
    {
        CTILOG_ERROR(dout, "Failed to load script: "<< script.getScriptName());
    }

    if( gMacsDebugLevel & MC_DEBUG_INTERP )
    {
        CTILOG_DEBUG(dout,
                dumpRunningScripts() <<
                endl <<"Dumping interpreter pool after executing a new script"<<
                _interp_pool);
    }
}

void CtiMCServer::preScriptFunction(CtiInterpreter *interp)
{
    Tcl_Interp *tclInterpreter = NULL;

    if( interp != NULL && (tclInterpreter = interp->getTclInterpreter()) != NULL )
    {
        ULONG logId = SynchronizedIdGen("DeviceReadJobLog", 1);

        if ( logId != 0 )
        {
            Tcl_SetVar(tclInterpreter, "DeviceReadLogId", (char *)CtiNumStr(logId).toString().c_str(), 0);

            CtiTblDeviceReadJobLog jobLogTable(logId, interp->getScheduleId() , CtiTime::now(), CtiTime::now());
            jobLogTable.Insert();
        }
        else
        {
            CTILOG_ERROR(dout, "Invalid Connection to Database.");
        }
    }
}

void CtiMCServer::postScriptFunction(CtiInterpreter *interp)
{
    UINT jobId = 0;
    Tcl_Interp *tclInterpreter = NULL;

    if( interp != NULL && (tclInterpreter = interp->getTclInterpreter()) != NULL )
    {
        if( const char* jobIdStr = Tcl_GetVar(tclInterpreter, "DeviceReadLogId", 0 ) )
        {
            jobId = atoi(jobIdStr);
            Tcl_UnsetVar(tclInterpreter, "DeviceReadLogId", 0 );
        }

        if( jobId != 0 )
        {
            CtiTblDeviceReadJobLog jobLogTable(jobId);
            jobLogTable.setStopTime(CtiTime::now());
            jobLogTable.UpdateStopTime();
        }
    }


}

 /*----------------------------------------------------------------------------
   stopScript

   Stops evaluation of a schedule's script.
   Removes the schedule, interpreter from _running_scripts
 ----------------------------------------------------------------------------*/
void CtiMCServer::stopScript(long sched_id)
{
    if( gMacsDebugLevel & MC_DEBUG_INTERP )
    {
        CTILOG_DEBUG(dout,
                dumpRunningScripts() <<
                endl <<"Dumping interpreter pool before stopping script"<<
                _interp_pool);
    }

    // find the schedule and reset its manual start + stop times
    {
        CtiLockGuard<CtiMutex> guard( _schedule_manager.getMux() );
        CtiMCSchedule* sched = _schedule_manager.findSchedule( sched_id );
        sched->setManualStartTime( CtiTime( (unsigned long) 0 ));
        sched->setManualStopTime( CtiTime( (unsigned long) 0 ));
        _schedule_manager.updateSchedule( *sched );
    }


    // find the entry for the schedule and the interpreter
    map< long, CtiInterpreter* >::iterator iter =
            _running_scripts.find( sched_id );

    if( iter != _running_scripts.end() )
    {
        CtiInterpreter* interp = iter->second;

        if( interp != NULL )
        {
            interp->stopEval();
            _interp_pool.releaseInterpreter(interp);
        }

        _running_scripts.erase(iter);
    }



    if( gMacsDebugLevel & MC_DEBUG_INTERP )
    {
        CTILOG_DEBUG(dout,
                dumpRunningScripts() <<
                endl <<"Dumping interpreter pool after stopping script"<<
                _interp_pool);
    }

}

/*
    Releases any interpreters that were evaluating simple commands but have
    finished
*/
void CtiMCServer::releaseInterpreters()
{
    deque< CtiInterpreter* >::iterator iter = _executing_commands.begin();
    while( iter != _executing_commands.end() )
    {
        CtiInterpreter* interp = *iter;
        if( !interp->isEvaluating() )
        {
            interp->stopEval();
            _interp_pool.releaseInterpreter(interp);
            iter = _executing_commands.erase(iter);
        }
        else
        {
            iter++;
        }
    }
}

 /*----------------------------------------------------------------------------
   checkRunningScripts

   Goes through the running scripts list to see if they are actually
   executing.  If they aren't, the schedule will be forced stopped.
 ----------------------------------------------------------------------------*/
void CtiMCServer::checkRunningScripts()
{
    CtiTime now( stripSeconds(CtiTime::now()) );

    map< long, CtiInterpreter* >::iterator iter;
    for( iter = _running_scripts.begin();
         iter != _running_scripts.end();
         iter++ )
    {
        CtiInterpreter* interp = iter->second;

        if( interp != NULL && !interp->isEvaluating() )
        {
            // interpreter isn't evaluating, try to find the
            // schedule and force it to stop
            CtiMCSchedule* sched = NULL;

            {
                CtiLockGuard<CtiMutex> guard( _schedule_manager.getMux() );
                sched = _schedule_manager.findSchedule( iter->first );
            }

            if( sched != NULL )
            {
                sched->setManualStopTime( now );
                _scheduler.scheduleManualStop( now, *sched);
            }
        }
    }
}


std::unique_ptr<CtiMessage> replicateWithSOE(const CtiMessage& msg, const int soe)
{
    auto dup = std::unique_ptr<CtiMessage>(msg.replicateMessage());
    dup->setSOE(soe);
    return dup;
}


bool CtiMCServer::processMessage(const CtiMessage& msg)
{
    bool ret_val = false;
    unique_ptr<CtiMCInfo> errorMsg;

    if( gMacsDebugLevel & MC_DEBUG_MESSAGES )
    {
        CTILOG_DEBUG(dout, "Processing Message: "<< msg);
    }

    //  The incoming SOE needs to be echoed back in any client response.
    const auto soe = msg.getSOE();

    switch( msg.isA() )
    {
    case MSG_MC_ADD_SCHEDULE:
        {
            if( gMacsDebugLevel & MC_DEBUG_MESSAGES )
            {
                CTILOG_DEBUG(dout, "Received AddSchedule message");
            }

            const CtiMCAddSchedule& add_msg = static_cast<const CtiMCAddSchedule&>(msg);

            {
                CtiLockGuard<CtiMutex> guard(_schedule_manager.getMux());

                if( ! add_msg.getSchedule().isSimpleSchedule() )
                {
                    CtiMCScript script_to_write;
                    script_to_write.setScriptName(add_msg.getSchedule().getCommandFile());
                    script_to_write.setContents(add_msg.getScript());

                    if( ! script_to_write.writeContents() )
                    {
                        errorMsg.reset(new CtiMCInfo());
                        errorMsg->setInfo("An error occurred writing a script file.");
                        break;
                    }
                }

                if( CtiMCSchedule* new_sched = _schedule_manager.addSchedule(add_msg.getSchedule()) )
                {
                     _db_update_thread.forceImmediateUpdate();
                     _scheduler.initEvents(stripSeconds( CtiTime::now()), *new_sched);

                     _client_listener.BroadcastMessage(replicateWithSOE(*new_sched, soe));

                     string event_text("Created Schedule:  \\\"");
                     event_text += new_sched->getScheduleName();
                     event_text += "\\\"";

                     logEvent(add_msg.getUser(), event_text);
                     sleep(2500); // CGP Let the writer thread have a chance.  Yes this is bad, but we are lazy.
                     sendDBChange( new_sched->getScheduleID(), add_msg.getUser() );

                     ret_val = true;
                 }
                 else
                 {
                     errorMsg.reset(new CtiMCInfo());
                     errorMsg->setInfo("An error occurred adding a new schedule");
                 }
            }
        }
        break;

    case MSG_MC_UPDATE_SCHEDULE:
        {
            bool updated = false;

            if( gMacsDebugLevel & MC_DEBUG_MESSAGES )
            {
                CTILOG_DEBUG(dout, "Received UpdateSchedule message");
            }

            const CtiMCUpdateSchedule& update_msg = static_cast<const CtiMCUpdateSchedule&>(msg);

            {
                CtiLockGuard<CtiMutex> guard(_schedule_manager.getMux());

                if( _schedule_manager.updateSchedule( update_msg.getSchedule() ))
                {
                    if( CtiMCSchedule* updated_sched = _schedule_manager.findSchedule(update_msg.getSchedule().getScheduleID()) )
                    {
                        if( updated_sched->getCurrentState() == CtiMCSchedule::Running )
                        {
                            errorMsg.reset(new CtiMCInfo());
                            errorMsg->setInfo("Cannot update a running schedule, stop or disable it first");
                            break;
                        }

                        if( ! update_msg.getSchedule().isSimpleSchedule() )
                        {
                            CtiMCScript script_to_write;
                            script_to_write.setScriptName(update_msg.getSchedule().getCommandFile());
                            script_to_write.setContents(update_msg.getScript());

                            if( !script_to_write.writeContents() )
                            {
                                errorMsg.reset(new CtiMCInfo());
                                errorMsg->setInfo("An error occurred writing a script file.");
                                break;
                            }
                        }

                        _scheduler.removeEvents(updated_sched->getScheduleID());
                        _scheduler.initEvents( stripSeconds( CtiTime::now()), *updated_sched );

                        _client_listener.BroadcastMessage(replicateWithSOE(*updated_sched, soe));

                        string event_text("Updated Schedule: \\\"");
                        event_text += updated_sched->getScheduleName();
                        event_text += "\\\"";

                        logEvent(string(update_msg.getUser().data()), event_text);

                        ret_val = updated = true;
                    }
                }
            }

            if( ! updated )
            {
                errorMsg.reset(new CtiMCInfo());
                errorMsg->setInfo("An error occurred updating a schedule");
            }
        }
        break;

    case MSG_MC_RETRIEVE_SCHEDULE:
        {
            if( gMacsDebugLevel & MC_DEBUG_MESSAGES )
            {
                CTILOG_DEBUG(dout, "Received Retrieve Schedule message");
            }

            const CtiMCRetrieveSchedule& retrieve_msg = static_cast<const CtiMCRetrieveSchedule&>(msg);
            const long id = retrieve_msg.getScheduleID();

            if( id == CtiMCRetrieveSchedule::AllSchedules )
            {
                //send all the schedules to the client that requested them
                auto multi = std::make_unique<CtiMultiMsg>();

                CtiLockGuard<CtiMutex> guard(_schedule_manager.getMux());

                CtiMCScheduleManager::MapIterator itr = _schedule_manager.getMap().begin();

                for(;itr != _schedule_manager.getMap().end();++itr)
                {
                    if( const CtiMCSchedule* sched = (*itr).second )
                    {
                        multi->insert(sched->replicateMessage());
                    }
                }

                multi->setSOE(soe);
                _client_listener.BroadcastMessage(std::move(multi), msg.getConnectionHandle());
            }
            else
            {
                CtiLockGuard<CtiMutex> guard(_schedule_manager.getMux());

                if( const CtiMCSchedule* sched = _schedule_manager.findSchedule(id) )
                {
                    _client_listener.BroadcastMessage(replicateWithSOE(*sched, soe), msg.getConnectionHandle());
                }
            }
        }
        break;

    case MSG_MC_DELETE_SCHEDULE:
        {
            bool deleted = false;

            if( gMacsDebugLevel & MC_DEBUG_MESSAGES )
            {
                CTILOG_DEBUG(dout, "Received Delete Schedule message");
            }

            const CtiMCDeleteSchedule& delete_msg = static_cast<const CtiMCDeleteSchedule&>(msg);
            const long id = delete_msg.getScheduleID();

            // Find out the schedule name before we delete it
            // so we can log it's name
            string sched_name;

            {
                CtiLockGuard<CtiMutex> guard(_schedule_manager.getMux());

                if( const CtiMCSchedule* sched = _schedule_manager.findSchedule(id) )
                {
                    sched_name = sched->getScheduleName();
                }

                if( _schedule_manager.deleteSchedule(id) )
                {
                    // there can be no more events for this schedule
                    _scheduler.removeEvents(id);

                    string event_text("Deleted Schedule:  \\\"");
                    event_text += sched_name;
                    event_text += "\\\"";

                    logEvent(string(delete_msg.getUser().data()), event_text);

                    _client_listener.BroadcastMessage(replicateWithSOE(delete_msg, soe));

                    ret_val = deleted = true;
                }
            }

            if( ! deleted )
            {
                errorMsg.reset(new CtiMCInfo());
                errorMsg->setInfo("An error occurred deleting schedule");
            }
        }
        break;

    case MSG_MC_RETRIEVE_SCRIPT:
        {
            if( gMacsDebugLevel & MC_DEBUG_MESSAGES )
            {
                CTILOG_DEBUG(dout, "Received Retrieve Script message");
            }

            const CtiMCRetrieveScript& retrieve_msg = static_cast<const CtiMCRetrieveScript&>(msg);

            CtiMCScript script;
            script.setScriptName(retrieve_msg.getScriptName());

            if( ! script.readContents() )
            {
                errorMsg.reset(new CtiMCInfo());
                errorMsg->setInfo("An error occurred reading the script");
            }
            else
            {
                _client_listener.BroadcastMessage(replicateWithSOE(script, soe), msg.getConnectionHandle());
            }
        }
        break;

    case MSG_MC_OVERRIDE_REQUEST:
        {
            if( gMacsDebugLevel & MC_DEBUG_MESSAGES )
            {
                CTILOG_DEBUG(dout, "Received Override Request message");
            }

            const CtiMCOverrideRequest& request_msg = static_cast<const CtiMCOverrideRequest&>(msg);

            string event_text;

            {
                CtiLockGuard<CtiMutex> guard(_schedule_manager.getMux());

                if( CtiMCSchedule* sched = _schedule_manager.findSchedule(request_msg.getID()) )
                {
                    switch( request_msg.getAction() )
                    {
                    case CtiMCOverrideRequest::Start:
                        {
                            const CtiTime real_time = request_msg.getStartTime().isValid()
                                        ? stripSeconds(request_msg.getStartTime())
                                        : stripSeconds(CtiTime::now());

                            sched->setManualStartTime(real_time);

                            _scheduler.scheduleManualStart(stripSeconds(CtiTime::now()), *sched);

                            event_text = "Start Schedule: \\\"";
                            event_text += sched->getScheduleName();
                            event_text += "\\\" @ ";
                            event_text += real_time.asString();
                        }
                        break;

                    case CtiMCOverrideRequest::StartNow:
                        {
                            const CtiTime real_time = stripSeconds(CtiTime::now());
                            sched->setManualStartTime(real_time);

                            _scheduler.scheduleManualStart(stripSeconds(CtiTime::now()), *sched);

                            event_text = "Start Schedule: \\\"";
                            event_text += sched->getScheduleName();
                            event_text += "\\\" @ ";
                            event_text += real_time.asString();
                        }
                        break;

                    case CtiMCOverrideRequest::Stop:
                        {
                            const CtiTime real_time =request_msg.getStopTime().isValid()
                                   ? stripSeconds(request_msg.getStopTime())
                                   : stripSeconds(CtiTime::now());

                            sched->setManualStopTime(real_time);

                            _scheduler.scheduleManualStop(stripSeconds(CtiTime::now()), *sched);

                            event_text = "Stop Schedule: \\\"";
                            event_text += sched->getScheduleName();
                            event_text += "\\\" @ ";
                            event_text += real_time.asString();
                        }
                        break;

                    case CtiMCOverrideRequest::StopNow:
                        {
                            const CtiTime real_time = stripSeconds(CtiTime::now());
                            sched->setManualStopTime(real_time);

                            _scheduler.scheduleManualStop(stripSeconds(CtiTime::now()), *sched);

                            event_text = "Stop Schedule: \\\"";
                            event_text += sched->getScheduleName();
                            event_text += "\\\" @ ";
                            event_text += real_time.asString();
                        }
                        break;

                    case CtiMCOverrideRequest::Enable:
                        {
                            // must be disabled for this to make sense
                            if( sched->getCurrentState() == CtiMCSchedule::Disabled )
                            {
                                sched->setCurrentState( CtiMCSchedule::Waiting );

                                //reschedule it
                                _scheduler.removeEvents(sched->getScheduleID());
                                _scheduler.initEvents(stripSeconds(CtiTime::now()), *sched);

                                event_text = "Enabled Schedule:  \\\"";
                                event_text += sched->getScheduleName();
                                event_text += "\\\"";

                                ret_val = true;
                            }
                        }
                        break;

                    case CtiMCOverrideRequest::Disable:
                        {
                            if( sched->getCurrentState() != CtiMCSchedule::Disabled )
                            {
                                _scheduler.removeEvents(sched->getScheduleID());

                                if( sched->getCurrentState() == CtiMCSchedule::Running )
                                {
                                    sched->setManualStopTime(stripSeconds(CtiTime::now()));

                                    _scheduler.scheduleManualStop(stripSeconds(CtiTime::now()), *sched);
                                }

                                sched->setCurrentState( CtiMCSchedule::Disabled );

                                event_text ="Disabled Schedule:  \\\"";
                                event_text += sched->getScheduleName();
                                event_text += "\\\"";

                                ret_val = true;
                            }
                            else
                            {
                                errorMsg.reset(new CtiMCInfo());
                                errorMsg->setInfo("Schedule already disabled");
                            }
                        }
                        break;

                    default:
                        {
                            CTILOG_ERROR(dout, "Unknown action in a CtiMCOverrideRequest received ("<< request_msg.getAction() <<")");

                            sched = NULL;
                        }
                    }

                    if( sched && _schedule_manager.updateSchedule(*sched) )
                    {
                        _client_listener.BroadcastMessage(replicateWithSOE(*sched, soe));
                        logEvent(string(msg.getUser().data()), event_text);
                        ret_val = true;
                    }
                }
            }
        }
        break;

    case MSG_MC_VERIFY_SCRIPT:
        {

        }
        break;
   }

   if( errorMsg.get() )
   {
       errorMsg->setSOE(soe);
       _client_listener.BroadcastMessage(std::move(errorMsg), msg.getConnectionHandle());
   }

   return ret_val;
}

bool CtiMCServer::processEvent(const ScheduledEvent& event)
{
    if( gMacsDebugLevel & MC_DEBUG_EVENTS )
    {
        Cti::FormattedList loglist;
        loglist.add("schedule id") << event.sched_id;
        loglist.add("event type")  << event.event_type;
        loglist.add("timestamp")   << event.timestamp;

        CTILOG_DEBUG(dout, "Processing Event:"<<
                loglist);
    }

    CtiLockGuard<CtiMutex> guard(_schedule_manager.getMux() );
    const CtiMCSchedule* sched = _schedule_manager.findSchedule( event.sched_id );

    if( sched == NULL )
    {
        CTILOG_WARN(dout, "Attempting to process an event with schedule id: "<< event.sched_id <<". No schedule was found with that id.");

        return false;
    }

    string event_text;

    switch( event.event_type )
    {
    case StartSchedule:

        event_text = "Schedule Started:  \\\"";
        event_text += sched->getScheduleName();
        event_text += "\\\"";

    case RepeatInterval:

        if( sched->isSimpleSchedule() )
                executeCommand( sched->getStartCommand(), sched->getTargetPaoId() );
            else
                executeScript(*sched); // start script

        break;
    case StopSchedule:

        event_text = "Schedule Stopped:  \\\"";
        event_text += sched->getScheduleName();
        event_text += "\\\"";

        if( sched->isSimpleSchedule() )
                executeCommand( sched->getStopCommand(), sched->getTargetPaoId() );
            else
                stopScript(sched->getScheduleID()); // stop script

        CTILOG_INFO(dout, "Stopping Schedule: "<< sched->getScheduleName());

        break;
    case StartPending:
        break;
    default:
        {
            // Unknown event type.... did another one get added or?
            CTILOG_ERROR(dout, "Unknown event type ("<< event.event_type <<")");
        }
    }

    _client_listener.BroadcastMessage(std::unique_ptr<CtiMessage>(sched->replicateMessage()));

    if( ! event_text.empty() )
    {
        // no user on purpose
        logEvent(" ", event_text);
    }

    return true;
}

/**
    loadDB

    Loads all the schedules into memory
**/
bool CtiMCServer::loadDB()
{
    return _schedule_manager.refreshAllSchedules();
}

bool CtiMCServer::loadCParms()
{
   bool result = true;

   string str;
   char var[128];

   strcpy(var, MC_DEBUG_LEVEL );
   if( !(str = gConfigParms.getValueAsString(var)).empty() )
   {
      char *eptr;
      gMacsDebugLevel = strtoul(str.c_str(), &eptr, 16);

      CTILOG_INFO(dout, MC_DEBUG_LEVEL <<": 0x"<< hex <<  gMacsDebugLevel);
   }
   else
   {
       gMacsDebugLevel = DEFAULT_MC_DEBUG_LEVEL;

       CTILOG_INFO(dout, MC_DEBUG_LEVEL <<" not found in master.cfg");

       result = false;
   }

   str = gConfigParms.getValueAsPath(FTP_INTERFACE_DIR, DEFAULT_MC_FTP_INTERFACE_DIR);

   _file_interface.setDirectory(str);
   _file_interface.setConsumedDirectory(str + "\\processed");

   if( !gConfigParms.isOpt(FTP_INTERFACE_DIR) )
   {
       CTILOG_INFO(dout, FTP_INTERFACE_DIR <<" not found in master.cfg");

       result = false;
   }

   strcpy(var, FTP_INTERFACE_EXT );
   if( !(str = gConfigParms.getValueAsString(var)).empty() )
   {
       _file_interface.setExtension(str);
   }
   else
   {
       _file_interface.setExtension(DEFAULT_MC_FTP_INTERFACE_EXT);

       CTILOG_INFO(dout, FTP_INTERFACE_EXT <<" not found in master.cfg");

       result = false;
   }

   strcpy(var, FTP_DELETE_ON_START );
   if( !(str = gConfigParms.getValueAsString(var)).empty() )
   {
       std::transform(str.begin(), str.end(), str.begin(), ::tolower);
       str = trim(str);

       if( str == "true" )
       {
           _file_interface.setDeleteOnStart(true);
       }
       else
       {
           _file_interface.setDeleteOnStart(false);
       }
   }
   else
   {
       _file_interface.setDeleteOnStart(false);

       CTILOG_INFO(dout, FTP_DELETE_ON_START <<" not found in master.cfg");

       result = false;
   }

   return result;
}

CtiTime CtiMCServer::stripSeconds(const CtiTime& now) const
{
    struct tm now_tm;
    now.extract(&now_tm);
    now_tm.tm_sec = 0;

    return CtiTime(&now_tm);
}

bool CtiMCServer::isToday(const CtiTime& t) const
{
    return ( CtiDate(t) == CtiDate::now() );
}

/// get to the next minute and strip seconds
CtiTime CtiMCServer::getNextMinute()
{
    const CtiTime now;

    struct tm now_tm;
    now.extract(&now_tm);
    now_tm.tm_sec  = 0; // strip seconds
    now_tm.tm_min += 1; // add 1 minute

    // NOTE: mktime() called inside CtiTime ctor will adjust tm members if we are currently at 59 minutes
    return CtiTime(&now_tm);
}

/// adjust the timeout to the next event time if the event
void CtiMCServer::adjustTimeout(CtiTime& timeout) const
{
    const CtiTime nextEvent = _scheduler.getNextEventTime();
    if( nextEvent.isValid() )
    {
        if( nextEvent < timeout )
        {
            timeout = nextEvent;
        }
    }
}

/// find the remaining milliseconds from now to the timeout provided
unsigned long CtiMCServer::getRemainingMillis(const CtiTime& timeout)
{
    const CtiTime now;

    if(now >= timeout)
    {
        return 0;
    }

    return (timeout.seconds() - now.seconds()) * 1000;
}

std::string CtiMCServer::dumpRunningScripts() const
{
    Cti::StreamBuffer desc;
    desc << endl <<"Running scripts:";

    map< long, CtiInterpreter* >::const_iterator iter;
    for( iter = _running_scripts.begin();
         iter != _running_scripts.end();
         iter++ )
    {
        desc << endl <<"Schedule id: "<< iter->first <<" / Interpreter: "<< iter->second;
    }

    return desc;
}

/*----------------------------------------------------------------------------
  sendDBChange

  DBCHange Message to dispatch.
  Uses a tcl interpreter to do the logging.

  user - the user who caused whatever that needs to be logged
  text - short description of what happened
----------------------------------------------------------------------------*/
void CtiMCServer::sendDBChange(const int& paoid, const string& user)
{
    // build up the SendDBChange tcl command
    // make sure to embed " in case there are spaces in
    // user
    string cmd_string("SendDBChange ");
    cmd_string.append(CtiNumStr(paoid));
    cmd_string.append(" \"");
    cmd_string.append(user);
    cmd_string.append("\" \" \""); //last arg is blank space

    if( gMacsDebugLevel & MC_DEBUG_EVENTS )
    {
        CTILOG_DEBUG(dout, cmd_string);
    }

    // Acquire an interpreter and send out the command
    CtiInterpreter* interp = _interp_pool.acquireInterpreter();
    interp->evaluate( cmd_string, true ); //block
    _interp_pool.releaseInterpreter(interp);
}


