/*==============================================================================================================================
    AUTHOR:    Eric Schmit

    PURPOSE:   Interface to the Telegyr EMS

Things to note about telegyr learned the hard way...

-The ems will get angry if you ask it to reload it's groups/points too often.
   No faster than every 5 minutes seems to work ok

-The ems will tell you when he has reloaded, then you can switch your lists.
   If you don't wait, your points/data will get wonky looking because the point ids and data won't match up.

-It appears that you may build up to 128 groups with up to 128 points in each
==============================================================================================================================*/
#include "precompiled.h"

#if !defined(_WINDLL)
#error _WINDLL is required!
#endif

#include "ctitime.h"
#include "ctidate.h"

#include "cparms.h"
#include "msg_multi.h"
#include "msg_ptreg.h"
#include "msg_cmd.h"
#include "message.h"
#include "msg_reg.h"
#include "msg_ptreg.h"
#include "msg_pdata.h"
#include "msg_signal.h"
#include "pointtypes.h"
#include "dllbase.h"
#include "logger.h"
#include "guard.h"
#include "dbaccess.h"
#include "resolvers.h"

#include "fdr.h"
#include "fdrdebuglevel.h"
#include "fdrinterface.h"

// this class header
#include "fdrtelegyr.h"

#include <boost/range/adaptor/map.hpp>
#include <boost/regex.hpp>
#include <boost/tokenizer.hpp>

/*
 * The telgyr library was built on an earlier version of Visual Studio.  In VS2015 
 * the infrastructure for stdio changed.  VS2015 provides some relief from this with 
 * legacy_stdio_definitions.lib and legacy_stdio_wide_specifiers.lib but not quite 
 * enough to get us to link.  The following supplies some missing symbols.
 */
extern "C" {
    int __cdecl _imp___iob() { return 0; }
    int __cdecl _imp___pctype() { return 0; }
    int __cdecl _imp____mb_cur_max() { return 0; } 
};

using std::string;
using std::endl;

/** local definitions **/
#define FDR_TELEGYR_VERSION   "2.1.5"
#define PRIORITY              1         //only 1 is supported at this point

/** global used to start the interface by c functions **/
CtiFDRTelegyr * myInterface;

const CHAR * CtiFDRTelegyr::TBLNAME_TELEGYR_GROUPS       = "FDRTelegyrGroup";

const CHAR * CtiFDRTelegyr::KEY_APPLICATION_NAME         = "FDR_TELEGYR_APPLICATION_NAME";
const CHAR * CtiFDRTelegyr::KEY_API_VERSION              = "FDR_TELEGYR_API_VERSION";
const CHAR * CtiFDRTelegyr::KEY_HI_REASONABILITY_FILTER  = "FDR_TELEGYR_HI_REASONABILITY_FILTER";
const CHAR * CtiFDRTelegyr::KEY_DB_RELOAD_RATE           = "FDR_TELEGYR_DB_RELOAD_RATE";
const CHAR * CtiFDRTelegyr::KEY_API_PATH                 = "FDR_TELEGYR_API_PATH";
const CHAR * CtiFDRTelegyr::KEY_QUEUE_FLUSH_RATE         = "FDR_TELEGYR_QUEUE_FLUSH_RATE";
const CHAR * CtiFDRTelegyr::KEY_DEBUG_MODE               = "FDR_TELEGYR_DEBUG_MODE";
const CHAR * CtiFDRTelegyr::KEY_OPERATOR                 = "FDR_TELEGYR_OPERATOR";
const CHAR * CtiFDRTelegyr::KEY_PASSWORD                 = "FDR_TELEGYR_PASSWORD";
const CHAR * CtiFDRTelegyr::KEY_SYSTEM_NAME              = "FDR_TELEGYR_SYSTEM_NAME";
const CHAR * CtiFDRTelegyr::KEY_CHANNEL_ID               = "FDR_TELEGYR_CHANNEL_ID";
const CHAR * CtiFDRTelegyr::KEY_ACCESS                   = "FDR_TELEGYR_ACCESS";
const CHAR * CtiFDRTelegyr::KEY_RELOAD_FREQUENCY         = "FDR_TELEGYR_RELOAD_FREQUENCY";
const CHAR * CtiFDRTelegyr::KEY_PANIC_NUMBER             = "FDR_TELEGYR_EXPECTED_DATA_RATE";
const CHAR * CtiFDRTelegyr::COLNAME_TELEGYR_GROUPID      = "GroupID";
const CHAR * CtiFDRTelegyr::COLNAME_TELEGYR_NAME         = "GroupName";
const CHAR * CtiFDRTelegyr::COLNAME_TELEGYR_INTERVAL     = "CollectionInterval";
const CHAR * CtiFDRTelegyr::COLNAME_TELEGYR_TYPE         = "GroupType";



//=================================================================================================================================
// Constructor
//=================================================================================================================================

#pragma warning(push)
#pragma warning(disable:4355) // disable the warning generated by worker thread using "this" in constructor initializer List

CtiFDRTelegyr::CtiFDRTelegyr() : CtiFDRInterface( string( "TELEGYR" ) ) , _hiReasonabilityFilter( 0.0 ),
    _threadGetTelegyrData(Cti::WorkerThread::Function(&CtiFDRTelegyr::threadFunctionGetDataFromTelegyr, this).name("getTelegyrData"))
{
   _reloadTimer = CtiTime::now();   //so we'll load right away
   _reloadTimer -= _dbReloadInterval;

   _reportTimer = CtiTime::now();

   init();

   _inited = -1;
   _quit = false;
}

#pragma warning(pop)

//=================================================================================================================================
// Destructor
//=================================================================================================================================

CtiFDRTelegyr::~CtiFDRTelegyr()
{
}

//=================================================================================================================================
//=================================================================================================================================

BOOL CtiFDRTelegyr::init( void )
{
   BOOL  retVal = FALSE;

   setConnected( false );
   _numberOfConnections = 0;

   // init the base class
   if( !Inherited::init() )
   {
      retVal = FALSE;
   }
   else
   {
      if( !readConfig() )
      {
         retVal = FALSE;
      }

      //this loads the data from the FDR table and sorts it all out into chunks we can use
      loadTranslationLists();
   }
   return retVal;
}

//=================================================================================================================================
//=================================================================================================================================

bool CtiFDRTelegyr::contact( int &status )
{
   int index = 0;

   setConnected( false );

   if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
   {
       CTILOG_DEBUG(dout, "Contact");
   }

   _controlCenter.deleteTelegyrGroupList();
   _controlCenter.getTelegyrGroupList() = _groupList;

   connect( index, status );

   if( isConnected() )
   {
       CTILOG_INFO(dout, "Connected => api_client");

      CtiLockGuard<CtiMutex> sendGuard( _controlCenter.getMutex() );
      deleteGroups();
   }

   return( isConnected() );
}

//=================================================================================================================================
//we want to be able to connect to any number of Telegyr Control Centers (servers) from anywhere, so we just pass the index of the
//server we want and the method parses the info from a list of servers available
//=================================================================================================================================

bool CtiFDRTelegyr::connect( int centerNumber, int &status )
{
   char  *op;
   char  *pw;
   char  *sn;
   int   groupValid;
   int   sysType;

   op = new char[_controlCenter.getOperator().length()+1];
   strcpy( op, _controlCenter.getOperator().c_str() );

   pw = new char[_controlCenter.getPassword().length()+1];
   strcpy( pw, _controlCenter.getPassword().c_str() );

   sn = new char[_controlCenter.getSysName().length()+1];
   strcpy( sn, _controlCenter.getSysName().c_str() );

   if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
   {
       CTILOG_DEBUG(dout, "id "<< _controlCenter.getChannelID() <<
               " operator "<< op <<
               " password "<< pw <<
               " system name "<< sn <<
               " access "<< _controlCenter.getAccess());
   }

   //connect to the Telegyr server
   status = api_connect( _controlCenter.getChannelID(), op, pw, sn, _controlCenter.getAccess(), &groupValid, &sysType );

   CTILOG_INFO(dout, "api_connect returned "<< status);

   delete [] op;
   delete [] pw;
   delete [] sn;

   if( API_NORMAL != status )
   {
      setConnected( false );
   }
   else
   {
      setConnected( true );
      _numberOfConnections++;
   }

   return isConnected();
}

//=================================================================================================================================
//can't tell the ems to delete the groups you've registered for unless we're connected to the client
//FIXME : may have to add a delete counters if someone wants them
//NOTE: this can only be done every 5 minutes or so or ems gets cranky and stops talking to us
//=================================================================================================================================

void CtiFDRTelegyr::deleteGroups( void )
{
   if( isConnected() )
   {
      if( 0 != _controlCenter.getTelegyrGroupList().size() )
      {
         int status = api_disable_all_cyclic( _controlCenter.getChannelID() );
         int ch = _controlCenter.getChannelID();

         if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
         {
             CTILOG_DEBUG(dout, "Disable-all-cyclic returns: "<< status <<" on channel "<< ch);
         }

         status = api_disable_all_spontaneous( _controlCenter.getChannelID() );

         if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
         {
             CTILOG_DEBUG(dout, "Disable-all-spontaneous returns: "<< status <<" on channel "<< ch);
         }

         status = api_delete_all_groups( _controlCenter.getChannelID() );

         if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
         {
             CTILOG_DEBUG(dout, "Delete-all-groups returns: "<< status <<" on channel "<< ch);
         }
      }
      else
      {
         CTILOG_WARN(dout, "group size is zero");
      }
   }

   _reloadPending = false;
}

//====================================================================================================
//we get in here during startup and every time we do a database reload
//====================================================================================================

bool CtiFDRTelegyr::loadTranslationLists()
{
   bool  retCode = false;

   CtiLockGuard<CtiMutex> sendGuard( _controlCenter.getMutex() );

   retCode = loadGroupLists();

   if( !retCode )
   {
       CTILOG_ERROR(dout, "Translation list load for FDRTelegyr failed ");
   }

   return retCode;
}

//====================================================================================================
//this is our loop for getting data
//we just look at the queue every second or so and look for messages
//the telegyr server should be putting data in that queue for us to read as we requested in the
//buildAndRegisterGroups() method
//====================================================================================================

void CtiFDRTelegyr::threadFunctionGetDataFromTelegyr( void )
{
   int               returnCode;
   int               status;
   bool              foundList;
   char              *newPath;
   char              *applicationName;
   char              *apiVer;
   int               timer;
   bool              startUp = true;

   //queue stuff
   int               func_status;
   int               channel_id;
   int               group_type;
   int               group_num;
   APICLI_TIME       group_time;
   int               first_index;
   int               last_index;
   int               more;
   int               result[256];
   int               waiter      = 10;   //03/28 - so we try to connect the first time through without waiting
   int               disconCount = 15;
   int               badMsgCount = 0;

   try
   {
      newPath = new char[getPath().length()+1];
      strcpy( newPath, getPath().c_str() );

      applicationName = new char[_appName.length()+1];
      strcpy( applicationName, _appName.c_str() );

      apiVer = new char[_apiVersion.length()+1];
      strcpy( apiVer, _apiVersion.c_str() );

      setLinkStatusID( getClientLinkStatusID( getInterfaceName() ) );

      if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
      {
         CTILOG_DEBUG(dout, "Path To API:"<< newPath <<" - Version: "<< apiVer);
      }

      while( !_quit )
      {
         //init the Telegyr API
         while( _inited != API_NORMAL )
         {
            if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
            {
                CTILOG_DEBUG(dout, "Attempting to init TelegyrAPI");
            }

            _inited = api_init( newPath, applicationName, apiVer, PRIORITY );

            if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
            {
                CTILOG_DEBUG(dout, "TelegyrAPI init() returned code "<< _inited <<", Waiting 30 seconds");
            }

            Sleep( 30000 );
         }

         Sleep( 1000 );

         CtiLockGuard<CtiMutex> sendGuard( _controlCenter.getMutex() );

         if( isConnected() )
         {
            //peek at the input-queue and see if anybody wrote to us from home...
            int reason = -1;
            returnCode = -1;
            returnCode = api_get_queued_data( 0,
                                              API_NO_TIMEOUT,
                                              &reason,
                                              &func_status,
                                              &channel_id,
                                              &group_type,
                                              &group_num,
                                              &group_time,
                                              &first_index,
                                              &last_index,
                                              &more,
                                              &result[0] );

            if( API_NORMAL == returnCode )
            {
               if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
               {
                   CTILOG_DEBUG(dout, "Queued data returned grp_nbr "<< group_num <<" reason "<< decipherReason( reason ));
               }

               foundList = false;

               switch( reason )
               {
                  case API_DISC_NOTIFY:   //we've lost connection to the control center
                  {
                     if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
                     {
                         CTILOG_DEBUG(dout, "Disconnect detected: reason "<< decipherReason( reason ) <<" func_status "<< func_status);
                     }

                     //if we've been disconnected from the backup, we'll just keep going
                     if(( APIERR_PRIMARY_DISCONNECT == func_status ) || ( APIERR_DISCONNECT  == func_status ))
                     {
                        deleteGroups();

                        int code = api_disconnect( _controlCenter.getChannelID(), API_VALID );

                        if( API_NORMAL == code )
                        {
                           _numberOfConnections--;

                           setConnected( false );

                            CTILOG_INFO(dout, "FDRTelegyr is not connected");
                        }
                        else
                        {
                            CTILOG_ERROR(dout, "api_disconnect() returned (code #) "<< code);
                        }
                     }

                     Sleep( 10000 );
                  }
                  break;


               case API_CYC_DATA:      //we've got cyclic data on the queue
               case API_SPO_DATA:      //we've got data cause someone altered the server's database
                  {
                     int arraySize = 0;
                     int x;
                     bool done;

                     for( x = 0, done = false; ( x < _controlCenter.getTelegyrGroupList().size() ) && ( !done ); x++ )
                     {
                        if( _controlCenter.getTelegyrGroupList()[x].getGroupID() == group_num )
                        {
                           arraySize = _controlCenter.getTelegyrGroupList()[x].getPointList().size();
                           done = true;
                        }
                     }

                     if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
                     {
                        if( reason == API_CYC_DATA )
                        {
                            CTILOG_DEBUG(dout, "We're getting cyclic data for grouptype "<< group_type);
                        }
                        else
                        {
                            CTILOG_DEBUG(dout, "We're getting spontaneous data for grouptype "<< group_type);
                        }
                     }

                     switch( group_type )
                     {
                     case API_GET_CYC_MEA:
                     case API_GET_SPO_MEA:
                        {
                           receivedAnalog( arraySize, group_num, group_type, first_index, last_index, result );
                        }
                        break;

                     case API_GET_CYC_IND:
                     case API_GET_SPO_IND:
                        {
                           receivedDigital( arraySize,  group_num,  group_type,  first_index,  last_index,  result );
                        }
                        break;

                     case API_GET_CYC_CNT:
                     case API_GET_SPO_CNT:
                        {
                           receivedCounter( arraySize,  group_num,  group_type,  first_index,  last_index,  result );
                        }
                        break;
                     }
                  }
                  break;

               case API_DELALL_RES:    //we've done a global delete group call
                  {
                     if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
                     {
                         CTILOG_DEBUG(dout, "EMS has deleted his lists");
                     }

                     if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
                     {
                         CTILOG_DEBUG(dout, "Swapping our local lists...");
                     }

                     _controlCenter.deleteTelegyrGroupList();
                     _controlCenter.getTelegyrGroupList() = _groupList;

                     if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
                     {
                         CTILOG_DEBUG(dout, "Swapping our local lists finished");
                     }

                     buildAndRegisterGroups();
                     _reloadTimer = CtiTime::now();
                  }
                  break;

               case API_DISCYCALL_RES:    //we've done a call to disable cyclic
                  {
                     if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
                     {
                         CTILOG_DEBUG(dout, "EMS has disabled all cyclic data");
                     }
                  }
                  break;

               case API_DISSPOALL_RES:    //we've done a call to disable all spon data
                  {
                     if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
                     {
                         CTILOG_DEBUG(dout, "EMS has disabled all spontaneous data");
                     }
                  }
                  break;

               case API_ENCYC_RES:     //we've done a call to enable cyclic data
                  {
                     if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
                     {
                         CTILOG_DEBUG(dout, "EMS has enabled cyclic data");
                     }
                  }
                  break;

               case API_ENSPO_RES:     //we've done a call to enable spontaineous data
                  {
                     if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
                     {
                         CTILOG_DEBUG(dout, "EMS has enabled spontaneous data");
                     }
                  }
                  break;

               case API_CRE_RES:     //we've created a group
                  {
                     if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
                     {
                         CTILOG_DEBUG(dout, "Group creation attempted");
                     }
                  }
                  break;

               default:              //we don't know what the heck is going on....
                  {
                     if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
                     {
                         CTILOG_DEBUG(dout, "Unsupported message reason (code #): "<< reason <<" "<< decipherReason( reason ));
                     }
                  }
                  break;
               }

               badMsgCount = 0;
            }
            else
            {
               if( getDebugLevel() & MAJOR_DETAIL_FDR_DEBUGLEVEL )
               {
                  if (returnCode != APIERR_NO_DATA)
                  {
                      CTILOG_DEBUG(dout, "Return code not normal. Got "<< returnCode);
                  }
               }
               badMsgCount = noDataAction( badMsgCount );
            }

            if( _reloadPending && isReloadTime() )
            {
               //call delete groups, we've got a new list already
               deleteGroups();
               _reloadTimer = CtiTime::now();
            }

            if( timer >= 120 )
            {
               if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
               {
                   CTILOG_DEBUG(dout, "Valid Connection Exists To Telegyr");
               }

               timer = 0;
            }
            timer++;
         }
         else  //not connected
         {
            timer = 0;
            disconCount++;

            if( disconCount >= 15 )
            {
                CTILOG_INFO(dout, "Telegyr is disconnected from api_client");

               disconCount = 0;

               if( API_NORMAL == _inited )
               {
                  contact( status );            //NOTE:used this as it calls build&Register()
               }
               else
               {
                   CTILOG_INFO(dout, "Trying to re-init the api");
                  _inited = api_init( newPath, applicationName, apiVer, PRIORITY );
               }

               waiter = 0;

               if( !isConnected() )
               {
                  sendLinkState( FDR_NOT_CONNECTED );
               }
               else //successful reconnection
               {
                  sendLinkState( FDR_CONNECTED );
               }

               if( startUp )
               {
                  startUp = false;
               }
            }

            badMsgCount = noDataAction( badMsgCount );
         }
      }

      //
      //we're going to shut down now
      //

      delete [] newPath;
      delete [] applicationName;
      delete [] apiVer;

      halt();

      return;
   }
   catch( ... )
   {
      CTILOG_UNKNOWN_EXCEPTION_ERROR(dout);
   }
}

//====================================================================================================
//here we are yanking data out of our telegyr group list and setting up groups that the foreign system
//will understand
//we should only be here if we've gotten past the api_init() and api_connect() methods built into
//telegyr
//====================================================================================================


//** PCLINT note: Left Warning 578 here. Deemed unsafe for this late in 5.0
void CtiFDRTelegyr::buildAndRegisterGroups( void )
{
   int   index;
   int   cnt;
   int   returnCode;
   int   channel_id;
   int   group_type = 0;
   int   group_number;
   int   persistence;
   int   object_count;
   int   cycle_time;
   int   totalGroups = _controlCenter.getTelegyrGroupList().size();
   char  **name_list;
   bool  cyclic = false;
   bool  *created = new bool[totalGroups];
   bool  interval;

   if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
   {
       CTILOG_DEBUG(dout, "Build & Reg Groups with "<< totalGroups <<" groups");
   }

   for( index = 0; index < totalGroups; index++ )
   {
      interval = false;
      cyclic = false;
      cycle_time = 0;
      channel_id = _controlCenter.getChannelID();

      //FIXME: the grouptype seems like it's getting set to the groupname someplace
      //but I don't see how.  So now we check for the word 'status' or 'analog'
      //inside the name/type 'status501' or 'analog4' to decide what to do...weird
      string type = _controlCenter.getTelegyrGroupList()[index].getGroupType();
      std::transform(type.begin(), type.end(), type.begin(), tolower);
      //if there's an interval, we have cyclic data
      if( _controlCenter.getTelegyrGroupList()[index].getInterval() != 0 )
      {
         cycle_time = _controlCenter.getTelegyrGroupList()[index].getInterval();
         cyclic = true;
         interval = true;
      }

      if(( STATUS_TYPE == type ) || ( DIGITAL_TYPE == type ))
      {
         group_type = API_GET_SPO_IND;

         if( interval )
         {
            group_type = API_GET_CYC_IND;
         }
      }
      else if( ANALOG_TYPE == type )
      {
         group_type = API_GET_SPO_MEA;

         if( interval )
         {
            group_type = API_GET_CYC_MEA;
         }
      }
      else if( COUNTER_TYPE == type )
      {
         group_type = API_GET_SPO_CNT;

         if( interval )
         {
            group_type = API_GET_CYC_CNT;
         }
      }
      else
      {
         if( interval )
         {
             CTILOG_INFO(dout, "Found w/interval "<< _controlCenter.getTelegyrGroupList()[index].getGroupType());
         }
         else
         {
             CTILOG_INFO(dout, "Found w/o interval "<< _controlCenter.getTelegyrGroupList()[index].getGroupType());
         }
      }

      group_number = _controlCenter.getTelegyrGroupList()[index].getGroupID();
      persistence = API_GRP_NO_PERSISTENCE;
      object_count = _controlCenter.getTelegyrGroupList()[index].getPointList().size();

      if( 0 != object_count )       //don't create empty groups
      {
         //make enough pointers for our pointnames
         name_list = new char *[object_count];

         for( cnt = 0; cnt < object_count; cnt++ )
         {
            //makes some space to copy our pointnames
            name_list[cnt] = new char[200];
            strcpy( name_list[cnt], _controlCenter.getTelegyrGroupList()[index].getPointList()[cnt].getTranslateName( 0 ).c_str() );

            if( getDebugLevel() & MAJOR_DETAIL_FDR_DEBUGLEVEL )
            {
                CTILOG_DEBUG(dout, "Adding \""<< name_list[cnt] <<"\" to "<< group_number);
            }
         }

         //do the api-registration of the group...
         if( isConnected() )
         {
            if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
            {
                CTILOG_DEBUG(dout, "Create ch_id " << channel_id <<
                        " type " << group_type <<
                        " num " << group_number <<
                        " pers " << persistence <<
                        " pri " << PRIORITY <<
                        " objs " << object_count);
            }

            returnCode = api_create_group( channel_id, group_type, group_number, persistence, PRIORITY, object_count, name_list );

            const string error = " failed on submission.  Error code: ";

            if( returnCode != API_NORMAL )
            {
               if(( API_GET_CYC_IND == group_type ) || ( API_GET_SPO_IND == group_type ))
               {
                   CTILOG_ERROR(dout, "Creation of status group "<< group_number << error << returnCode);
               }
               else if( ( API_GET_CYC_MEA == group_type ) || ( API_GET_SPO_MEA == group_type ) )
               {
                   CTILOG_ERROR(dout, "Creation of analog group "<< group_number << error << returnCode);
               }
               else
               {
                   CTILOG_ERROR(dout, "Creation of counter group "<< group_number << error << returnCode);
               }
            }
            else
            {
                CTILOG_INFO(dout, "Group number "<< group_number <<" registered successfully");
                created[index] = true;
            }
         }

         for( cnt = 0; cnt < object_count; cnt++ )
         {
            delete [] name_list[cnt];
         }
         delete [] name_list;
      }
   }

   //enable all the groups
   for( int i = 0; i < totalGroups; i++ )
   {
      cyclic = false;
      group_number = _controlCenter.getTelegyrGroupList()[i].getGroupID();
      channel_id = _controlCenter.getChannelID();
      object_count = _controlCenter.getTelegyrGroupList()[i].getPointList().size();
      bool interval = false;

      //if there's an interval, we have cyclic data
      if( 0 != _controlCenter.getTelegyrGroupList()[i].getInterval() )
      {
         interval = true;
         cycle_time = _controlCenter.getTelegyrGroupList()[i].getInterval();
         cyclic = true;
      }

      if( STATUS_TYPE == _controlCenter.getTelegyrGroupList()[i].getGroupType() )
      {
         group_type = API_GET_SPO_IND;

         if( interval )
         {
            group_type = API_GET_CYC_IND;
         }
      }
      else if( DIGITAL_TYPE == _controlCenter.getTelegyrGroupList()[i].getGroupType() )
      {
         group_type = API_GET_SPO_IND;

         if( interval )
         {
            group_type = API_GET_CYC_IND;
         }
      }
      else if( ANALOG_TYPE == _controlCenter.getTelegyrGroupList()[i].getGroupType() )
      {
         group_type = API_GET_SPO_MEA;

         if( interval )
         {
            group_type = API_GET_CYC_MEA;
         }
      }
      else//COUNTER_TYPE
      {
         group_type = API_GET_SPO_CNT;

         if( interval )
         {
            group_type = API_GET_CYC_CNT;
         }
      }

      if( ( object_count > 0 ) && created[i] )    //don't enable empty/uncreated groups
      {
         int retCode;

         if( cyclic )
         {
            //by specifying the NOALIG parameter, we are telling the telegyr system to go ahead and start sending
            //data back to use immediately
            retCode = api_enable_cyclic( channel_id, group_type, group_number, cycle_time, API_SECOND, API_ALIG_NOALIG );

            if (getDebugLevel() & MAJOR_DETAIL_FDR_DEBUGLEVEL)
            {
                CTILOG_DEBUG(dout, "api_enable_cyclic( channel_id, group_type, group_number, cycle_time, API_SECOND, API_ALIG_NOALIG );" <<
                       endl <<" api_enable_cyclic("<< channel_id <<","<< group_type <<","<< group_number <<","<< cycle_time <<","<< API_SECOND <<","<< API_ALIG_NOALIG <<");");
            }
            if (getDebugLevel() & DETAIL_FDR_DEBUGLEVEL)
            {
                CTILOG_DEBUG(dout, "api_enable_cyclic for group_number "<< group_number <<"returned "<< retCode);
            }

            cyclic = false;
         }
         else
         {
            retCode = api_enable_spontaneous( channel_id, group_type, group_number );

            if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
            {
                CTILOG_DEBUG(dout, "api_enable_spontaneous group_number " << group_number << " returned " << retCode);
            }
         }
      }
      else
      {
          CTILOG_INFO(dout, "no points in "<< _controlCenter.getTelegyrGroupList()[index].getGroupName());
      }
   }

   delete [] created;
}

//=================================================================================================================================
//get point info from a database load/reload
//we are looking at the translation string and breaking it down to figure out what type the point is, what it's
//interval is, and what it's name is. Then we look for a group of the same specs that has room for the point
//=================================================================================================================================

bool CtiFDRTelegyr::loadGroupLists( void )
{
   bool           successful = false;
   bool           foundPoint = false;

   try
   {
       CTILOG_INFO(dout, "Loading And Building Groups");

       // make a list with all received points
      CtiFDRManager pointList( getInterfaceName(), string( FDR_INTERFACE_RECEIVE ) );

      // if status is ok, we were able to read the database at least
      if( pointList.loadPointList() )
      {
         if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
         {
            CTILOG_DEBUG(dout, "Database status is ok");
         }

         //===================================================================================
         //seeing occasional problems where we get empty data sets back and there should be
         //info in them,  we're checking this to see if is reasonable if the list may now be
         //empty the 2 entry thing is completly arbitrary
         //===================================================================================

         if( pointList.entries() >= 0 )
         {
             CTILOG_INFO(dout, "Found "<< pointList.entries() <<" Telegyr points");

            //FIXME
            //for some reason, we need to wipe the old list first
            //because it seems that the name and type get set to the name
            //which cause us to fail in build&reg
            if( !_groupList.empty() )
            {
               _groupList.clear();
            }

            //iterate through all our points in the list
            for( auto& point : pointList.getMap() | boost::adaptors::map_values )
            {
               foundPoint = true;
               successful = translatePoint(point);
            }

            {
                Cti::FormattedList loglist;
                for ( auto& group : _groupList )
                {
                    loglist.add(group.getGroupName()) << group.getPointList().size();
                }

                CTILOG_INFO(dout, loglist);
            }

            _reloadPending = true;

            if( !successful )
            {
               if( !foundPoint )
               {
                  // means there was nothing in the list, wait until next db change or reload
                  successful = true;
               }
            }

            if( !_groupList.empty() )
            {
               _controlCenter.getTelegyrGroupList() = _groupList;
               successful = true;
            }
         }
         else
         {
             CTILOG_ERROR(dout, "Could not load (Receive) points for "<< getInterfaceName() <<" : Empty data set returned");
             successful = false;
         }
      }
      else
      {
          CTILOG_ERROR(dout, "Unable to load points from database for "<< getInterfaceName());
          successful = false;
      }
   }
   catch( ... )
   {
       CTILOG_UNKNOWN_EXCEPTION_ERROR(dout, "Failed to load group points for "<< getInterfaceName());
   }

   return successful;
}

/**
 * This function is called from fdrinterface to have us process
 * a single point update. Telegyr does not support this so we
 * are going to do a full reload. (This puts the functionality
 * of FdrTelegry back to pre 4.2
 *
 * @param translationPoint
 * @param send
 *
 * @return bool
 */
bool CtiFDRTelegyr::translateSinglePoint(CtiFDRPointSPtr & translationPoint, bool send)
{

   loadTranslationLists();

   //If we are connected, send call to delete groups, triggering a new build and register.
   if (isConnected())
   {
      deleteGroups();
      _reloadTimer = CtiTime::now();
   }

   return true;
}

/**
 * Translate point and add it to a group
 *
 * @param translationPoint
 *
 * @return bool
 */
bool CtiFDRTelegyr::translatePoint(CtiFDRPointSPtr & translationPoint)
{
   bool successful = false;
   bool foundGroup = false;

   string pointType;//analog or status
   string pointStr; //pointid
   string interval;

   //iterate through all our destinations per point (should have 1 for telegyr)
   for( int x = 0; x < translationPoint->getDestinationList().size(); x++ )
   {
      pointStr = translationPoint->getDestinationList()[x].getTranslationValue( "Point" );
      interval = translationPoint->getDestinationList()[x].getTranslationValue( "Interval (sec)" );
      pointType = translationPoint->getDestinationList()[x].getTranslationValue( "POINTTYPE" );

      if( pointStr.empty() || pointType.empty() )
      {
         successful = false;

         if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
         {
             Cti::FormattedList loglist;
             loglist.add("Point") << translationPoint->getDestinationList()[x].getTranslationValue("Point");
             loglist.add("Type")  << translationPoint->getDestinationList()[x].getTranslationValue("POINTTYPE");

             CTILOG_ERROR(dout, "Empty point or type!"<<
                     loglist);
         }
      }
      else
      {
         translationPoint->getDestinationList()[x].setTranslation( pointStr );
      }
   }

   int analogNum  = 1;
   int statusNum  = 501;

   for (int i = 0; i < _groupList.size(); i++ )
   {
      string type = _groupList[i].getGroupType();
      int interval = _groupList[i].getInterval();
      int size = _groupList[i].getPointList().size();
      std::transform(type.begin(), type.end(), type.begin(), tolower);
      std::transform(pointType.begin(), pointType.end(), pointType.begin(), tolower);

      if (type == "analog")
      {
         analogNum++;
      }
      else
      {
         statusNum++;
      }

      if(( type == pointType ) && ( size < 127 ))
      {
         _groupList[i].getPointList().push_back( *translationPoint );
         foundGroup = true;
         break;
      }
   }

   //we didn't stick the point anywhere, make a new group and put it there
   if( !foundGroup )
   {
      CtiTelegyrGroup tempGroup;
      char valStr[15];

      std::transform(pointType.begin(), pointType.end(), pointType.begin(), tolower);

      if( "status" == pointType )
      {
         itoa( statusNum, valStr, 10 );
         tempGroup.setGroupID(statusNum);
      }
      else
      {
         itoa( analogNum, valStr, 10 );
         tempGroup.setGroupID(analogNum);
      }

      string name( pointType + valStr );
      tempGroup.setGroupName( name );

      if( interval.empty() )
      {
         tempGroup.setInterval( 120 );//just temp until we fix MEC's database
      }
      else
      {
         tempGroup.setInterval( 120 );
      }

      tempGroup.setGroupType( pointType );
      tempGroup.getPointList().push_back( *translationPoint );
      _groupList.push_back( tempGroup );
   }
   else
   {
      foundGroup = false;     //reset for the next point
   }

   return successful;
}

//=================================================================================================================================
//we want to decipher the point and put it on the queue to Dispatch
//=================================================================================================================================

bool CtiFDRTelegyr::processAnalog( APICLI_GET_MEA aPoint, int groupid, int group_type, int index )
{
   CtiPointDataMsg      *pData      = NULL;
   CtiCommandMsg        *pCmdMsg    = NULL;
   long                 pointid;
   bool                 returnCode;
   double               value;
   double               raw;
   USHORT               quality;
   bool                 nonUpdated = false;
   string               translationName;

   if( API_VALID == aPoint.mea_valid )
   {
      value = aPoint.mea_value.mea4_value;
      raw = value;

      //flip through our groups until the groupid matches the one this point came from
      //then snag the pointid out
      int x;
      bool done;

      for( x = 0, done = false; ( x < _controlCenter.getTelegyrGroupList().size() ) && ( !done ); x++ )
      {
         if( _controlCenter.getTelegyrGroupList()[x].getGroupID() == groupid )
         {
            pointid = _controlCenter.getTelegyrGroupList()[x].getPointList()[index].getPointID();
            translationName = _controlCenter.getTelegyrGroupList()[x].getPointList()[index].getTranslateName(0);

            value = value * ( _controlCenter.getTelegyrGroupList()[x].getPointList()[index].getMultiplier() );
            value += ( _controlCenter.getTelegyrGroupList()[x].getPointList()[index].getOffset() );

            if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
            {
                CTILOG_DEBUG(dout, "Raw Analog Value: "<< raw <<" from Point "<< _controlCenter.getTelegyrGroupList()[x].getPointList()[index].getTranslateName(0) <<" groupid "<< groupid);
            }

            //if the value is higher than it should be, we want to let the boss man know
            if( ( getHiReasonabilityFilter() > 0 ) && ( getHiReasonabilityFilter() > value ) )
            {
               nonUpdated = true;
            }

            done = true;
         }
      }

      if (done == false)
      {
         if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
         {
             CTILOG_DEBUG(dout, "Point not found for group id: "<< groupid <<" and index: "<< index);
         }
         return false;
      }

      //get the quality of the point data
      if( !api_check_any_quality_bit_set( aPoint.sys_dependent_info ) )
      {
         quality = NormalQuality;
      }
      else
      {
         if( api_check_quality_bit_set( aPoint.sys_dependent_info, API_QUAL_TELEM_F_BIT ) )
         {
            quality = NonUpdatedQuality;
            nonUpdated = true;

            if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
            {
                CTILOG_DEBUG(dout, "Telemetry fail bit set. Point Name: "<< translationName <<" Group Id: "<< groupid);
            }
         }
         else
         {
            quality = getQuality( aPoint.sys_dependent_info );
         }
      }

      if( nonUpdated )
      {
         pCmdMsg = new CtiCommandMsg( CtiCommandMsg::UpdateFailed );

         pCmdMsg->insert( -1 );                             // This is the dispatch token and is unimplemented at this time
         pCmdMsg->insert( CtiCommandMsg::OP_POINTID );                     // This device failed.  OP_POINTID indicates a point fail situation.  defined in msg_cmd.h
         pCmdMsg->insert( pointid );            // The id (device or point which failed)
         pCmdMsg->insert( ScanRateGeneral );                // One of ScanRateGeneral,ScanRateAccum,ScanRateStatus,ScanRateIntegrity, or if unknown -> ScanRateInvalid defined in yukon.h

         // consumes and deletes pData memory
         sendMessageToDispatch(pCmdMsg);
      }
      else
      {
         pData = new CtiPointDataMsg( pointid, value, quality, AnalogPointType );

         //plop whichever message is valid onto the Dispatch pile
         if( pData )
         {
            // consumes a delete memory
            queueMessageToDispatch( pData );
         }
      }
      returnCode = true;
   }
   else
   {
      returnCode = false;
   }

   return returnCode;
}

//=================================================================================================================================
//we want to decipher the point and put it on the queue to Dispatch
//=================================================================================================================================

bool CtiFDRTelegyr::processDigital( APICLI_GET_IND aPoint, int groupid, int group_type, int index )
{
   CtiPointDataMsg   *pData = NULL;
   long              pointid;
   bool              returnCode;
   double            value;
   USHORT            quality;

   if( API_VALID == aPoint.ind_valid )
   {
      value = aPoint.ind_value;

      //flip through our groups until the groupid matches the one this point came from
      //then snag the pointid out
      int x;
      bool done;

      for( x = 0, done = false; ( x < _controlCenter.getTelegyrGroupList().size() ) && ( !done ); x++ )
      {
         if( _controlCenter.getTelegyrGroupList()[x].getGroupID() == groupid )
         {
            if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
            {
                CTILOG_DEBUG(dout, "Raw Digital Value: "<< value <<" from Point "<<
                        _controlCenter.getTelegyrGroupList()[x].getPointList()[index].getTranslateName(0) <<" groupid "<< groupid);
            }

            pointid = _controlCenter.getTelegyrGroupList()[x].getPointList()[index].getPointID();
            done = true;
         }
      }

      //get the quality of the point data
      if( api_check_any_quality_bit_set( aPoint.sys_dependent_info ) )
      {
         quality = NormalQuality;
      }
      else
      {
         quality = getQuality( aPoint.sys_dependent_info );
      }

      pData = new CtiPointDataMsg( pointid, value, quality, StatusPointType );

      if( pData )
      {
         // consumes a delete memory
         queueMessageToDispatch( pData );
      }
      returnCode = true;
   }
   else
   {
      returnCode = false;
   }

   return returnCode;
}

//=================================================================================================================================
//there are a bunch more that telegyr supports, we just don't care
//=================================================================================================================================

USHORT CtiFDRTelegyr::getQuality( SYS_DEP_INFO  info )
{
   USHORT quality = NormalQuality;

   if( api_check_quality_bit_set( info, API_QUAL_OUT_SCAN_BIT ) )
   {
      quality = NonUpdatedQuality;
   }
   else if( api_check_quality_bit_set( info, API_QUAL_TELEM_F_BIT ) )
   {
      quality = NonUpdatedQuality;
   }
   else if( api_check_quality_bit_set( info, API_QUAL_MAN_BIT ) )
   {
      quality = ManualQuality;
   }
   else if( api_check_quality_bit_set( info, API_QUAL_Q_MAN_BIT ) )
   {
      quality = ManualQuality;
   }
   else if( api_check_quality_bit_set( info, API_QUAL_TEST_BIT ) )
   {
      quality = NonUpdatedQuality;
   }
   else if( api_check_quality_bit_set( info, API_QUAL_BACKUP_BIT ) )
   {
      quality = QuestionableQuality;
   }
   else if( api_check_quality_bit_set( info, API_QUAL_UN_INIT_BIT ) )
   {
      quality = UnintializedQuality;
   }
   else if( api_check_quality_bit_set( info, API_QUAL_MISSING_BIT ) )
   {
      quality = PartialIntervalQuality;
   }

   return quality;
}

//=================================================================================================================================
//we want to decipher the point and put it on the queue to Dispatch
//=================================================================================================================================

bool CtiFDRTelegyr::processCounter( APICLI_GET_CNT aPoint, int groupid, int group_type, int index )
{
   CtiPointDataMsg      *pData = NULL;
   long                 pointid;
   bool                 returnCode;
   int                  x;
   double               value;
   USHORT               quality;

   if( API_VALID == aPoint.cnt_valid )
   {
      value = aPoint.cnt_value.cnt8_value;

      //flip through our groups until the groupid matches the one this point came from
      //then snag the pointid out
      int x;
      bool done;

      for( x = 0, done = false; ( x < _controlCenter.getTelegyrGroupList().size() ) && ( !done ); x++ )
      {
         if( _controlCenter.getTelegyrGroupList()[x].getGroupID() == groupid )
         {
            pointid = _controlCenter.getTelegyrGroupList()[x].getPointList()[index].getPointID();
            done = true;
         }
      }

      //get the quality of the point data
      if( api_check_any_quality_bit_set( aPoint.sys_dependent_info ) )
      {
         quality = NormalQuality;
      }
      else
      {
         quality = getQuality( aPoint.sys_dependent_info );
      }

      pData = new CtiPointDataMsg( pointid, value, quality, PulseAccumulatorPointType );

      if( pData )
      {
         // consumes a delete memory
         queueMessageToDispatch( pData );
      }
      returnCode = true;
   }
   else
   {
      returnCode = false;
   }

   return returnCode;
}

//=================================================================================================================================
//=================================================================================================================================
//** PCLINT note: Left Warning 578 here. Deemed unsafe for this late in 5.0
bool CtiFDRTelegyr::processBadPoint( int groupid, int index )
{
   int x;
   bool done;

   for( x = 0, done = false; ( x < _controlCenter.getTelegyrGroupList().size() ) && ( !done ); x++ )
   {
      if( _controlCenter.getTelegyrGroupList()[x].getGroupID() == groupid )
      {
         const long   pointid   = _controlCenter.getTelegyrGroupList()[x].getPointList()[index].getPointID();
         const string pointName = _controlCenter.getTelegyrGroupList()[x].getPointList()[index].getTranslateName(0);

         CTILOG_INFO(dout, "Bad point "<< pointName <<" pointid "<< pointid <<" groupid "<< groupid);
         done = true;
      }
   }

   return true;
}

//=================================================================================================================================
//=================================================================================================================================

string CtiFDRTelegyr::decipherReason( int transmissionReason )
{
   string retReason;

   switch( transmissionReason )
   {
   case API_REQ_DATA:
      retReason = "API_REQ_DATA";
      break;

   case API_CYC_DATA:
      retReason = "API_CYC_DATA";
      break;

   case API_SPO_DATA:
      retReason = "API_SPO_DATA";
      break;

   case API_DQS_DATA:
      retReason = "API_DQS_DATA";
      break;

   case  API_LIST_ALM_EVT:
      retReason = "API_LIST_ALM_EVT";
      break;

   case API_ALARMS_LIST:
      retReason = "API_ALARMS_LIST";
      break;

   case API_INOUT_SCAN:
      retReason = "API_INOUT_SCAN";
      break;

   case API_CRE_RES:
      retReason = "API_CRE_RES";
      break;

   case API_DEL_RES:
      retReason = "API_DEL_RES";
      break;

   case API_DELALL_RES:
      retReason = "API_DELALL_RES";
      break;

   case API_ENCYC_RES:
      retReason = "API_ENCYC_RES";
      break;

   case API_ENSPO_RES:
      retReason = "API_ENSPO_RES";
      break;

   case API_ENDQS_RES:
      retReason = "API_ENDQS_RES";
      break;

   case API_ENLIST_RES:
      retReason = "API_ENLIST_RES";
      break;

   case API_DISCYC_RES:
      retReason = "API_DISCYC_RES";
      break;

   case API_DISSPO_RES:
      retReason = "API_DISSPO_RES";
      break;

   case API_DISDQS_RES:
      retReason = "API_DISDQS_RES";
      break;

   case API_DISLIST_RES:
      retReason = "API_DISLIST_RES";
      break;

   case API_DISCYCALL_RES:
      retReason = "API_DISCYCALL_RES";
      break;

   case API_DISSPOALL_RES:
      retReason = "API_DISSPOALL_RES";
      break;

   case API_COM_RES:
      retReason = "API_COM_RES";
      break;

   case API_WRI_RES:
      retReason = "API_WRI_RES";
      break;

   case API_WRT_RES:
      retReason = "API_WRT_RES";
      break;

   case API_TAG_RES:
      retReason = "API_TAG_RES";
      break;

   case API_DQS_RES:
      retReason = "API_DQS_RES";
      break;

   case API_ALARM_ACK_DELETE_RES:
      retReason = "API_ALARM_ACK_DELETE_RES";
      break;

   case API_SETPADQMEA_RES:
      retReason = "API_SETPADQMEA_RES";
      break;

   case API_SETPADQIND_RES:
      retReason = "API_SETPADQIND_RES";
      break;

   case API_SETPADQCNT_RES:
      retReason = "API_SETPADQCNT_RES";
      break;

   case API_DISPLAY_REQUEST_RES:
      retReason = "API_DISPLAY_REQUEST_RES";
      break;

   case API_GROUPS:
      retReason = "API_GROUPS";
      break;

   case API_READ_GRP:
      retReason = "API_READ_GRP";
      break;

   case API_DISC_NOTIFY:
      retReason = "API_DISC_NOTIFY";
      break;

   case API_FULL_NOTIFY:
      retReason = "API_FULL_NOTIFY";
      break;

   default:
      retReason = "UNKNOWN CODE";
      break;
   }

   return retReason;
}

//=================================================================================================================================
//here we read our Cparms to get our settings
//=================================================================================================================================

bool CtiFDRTelegyr::readConfig()
{
   string   tempStr;

   //
   //defaults
   //
   setReloadRate( 86400 );
   setInterfaceDebugMode( false );
   setPath( "c:/yukon/telegyr/api/" );             //not sure what else would be appropriate
   _appName = "dev_yukon";
   _apiVersion = "v4_1";
   _controlCenter.setOperator( "LGS" );
   _controlCenter.setPassword( "1234" );
   _controlCenter.setSysName( "MEC" );
   _controlCenter.setChannelID( 1 );
   _controlCenter.setAccess( 1 );
   _dbReloadInterval = 60;
   _panicNumber = 600;
   //
   //defaults
   //

   tempStr = getCparmValueAsString( KEY_DB_RELOAD_RATE );

   if( tempStr.length() > 0 )
   {
      setReloadRate( atoi( tempStr.c_str() ) );
   }

   tempStr = getCparmValueAsString( KEY_HI_REASONABILITY_FILTER );

   if( tempStr.length() > 0 )
   {
      setHiReasonabilityFilter( atof( tempStr.c_str() ) );
   }

   tempStr = getCparmValueAsString( KEY_DEBUG_MODE );

   if( tempStr.length() > 0 )
   {
      setInterfaceDebugMode( true );
   }

   tempStr = getCparmValueAsString( KEY_API_PATH );

   if( tempStr.length() > 0 )
   {
      setPath( tempStr );
   }

   tempStr = getCparmValueAsString( KEY_APPLICATION_NAME );

   if( tempStr.length() > 0 )
   {
      _appName = tempStr;
   }

   tempStr = getCparmValueAsString( KEY_API_VERSION );

   if( tempStr.length() > 0 )
   {
      _apiVersion = tempStr;
   }

   //defaults for the control center

   tempStr = getCparmValueAsString( KEY_OPERATOR );

   if( tempStr.length() > 0 )
   {
      _controlCenter.setOperator( tempStr );
   }

   tempStr = getCparmValueAsString( KEY_PASSWORD );

   if( tempStr.length() > 0 )
   {
      _controlCenter.setPassword( tempStr );
   }

   tempStr = getCparmValueAsString( KEY_SYSTEM_NAME );

   if( tempStr.length() > 0 )
   {
      _controlCenter.setSysName( tempStr );
   }

   tempStr = getCparmValueAsString( KEY_CHANNEL_ID );

   if( tempStr.length() > 0 )
   {
      _controlCenter.setChannelID( atof( tempStr.c_str() ) );
   }

   tempStr = getCparmValueAsString( KEY_ACCESS );

   if( tempStr.length() > 0 )
   {
      _controlCenter.setAccess( atof( tempStr.c_str() ) );
   }

   tempStr = getCparmValueAsString( KEY_RELOAD_FREQUENCY );

   if( tempStr.length() > 0 )
   {
      _dbReloadInterval = atof( tempStr.c_str() );
   }

   tempStr = getCparmValueAsString( KEY_PANIC_NUMBER );

   if( tempStr.length() > 0 )
   {
      _panicNumber = atof( tempStr.c_str() );
   }

   if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
   {
      Cti::FormattedList loglist;
      loglist.add("Our Name")            << getCparmValueAsString( KEY_APPLICATION_NAME );
      loglist.add("Reload Rate")         << getCparmValueAsString( KEY_DB_RELOAD_RATE ) << " secs";
      loglist.add("Hi_Res")              << getCparmValueAsString( KEY_HI_REASONABILITY_FILTER );
      loglist.add("Debug Mode")          << getCparmValueAsString( KEY_DEBUG_MODE );
      loglist.add("Api path")            << getCparmValueAsString( KEY_API_PATH );
      loglist.add("Api Version")         << getCparmValueAsString( KEY_API_VERSION );
      loglist.add("Operator")            << getCparmValueAsString( KEY_OPERATOR );
      loglist.add("Password")            << getCparmValueAsString( KEY_PASSWORD );
      loglist.add("Sysname")             << getCparmValueAsString( KEY_SYSTEM_NAME );
      loglist.add("Channel Id")          << getCparmValueAsString( KEY_CHANNEL_ID );
      loglist.add("Access")              << getCparmValueAsString( KEY_ACCESS );
      loglist.add("Minimum Reload Rate") << _dbReloadInterval << endl;
      loglist.add("Expected Data Rate")  << _panicNumber << endl;

      CTILOG_DEBUG(dout, loglist);
   }

   return true;
}

//=================================================================================================================================
//=================================================================================================================================

bool CtiFDRTelegyr::isReloadTime( void )
{
   bool retCode = false;

   if( ( CtiTime::now().seconds() - _reloadTimer.seconds() ) >= _dbReloadInterval )
   {
       CTILOG_INFO(dout, "Time for reload");
      retCode = true;
   }

   return retCode;
}

//=================================================================================================================================
//we just have this in case anyone ever really wants to send a message, right now, it's not used....
//=================================================================================================================================

void CtiFDRTelegyr::sendMessageToForeignSys( CtiMessage *aMessage )
{
   // message is deleted in fdrinterface thread
}

//=================================================================================================================================
//this is the receive message function that is our only concern for now
//here is where we'll wait for data to come back from the telegyr system after we've told it what we want
//=================================================================================================================================

INT CtiFDRTelegyr::processMessageFromForeignSystem( CHAR *data )
{
   return ClientErrors::None;
}

//=================================================================================================================================
//=================================================================================================================================

double CtiFDRTelegyr::getHiReasonabilityFilter() const
{
   return _hiReasonabilityFilter;
}

//=================================================================================================================================
//=================================================================================================================================

CtiFDRTelegyr & CtiFDRTelegyr::setHiReasonabilityFilter( const double myValue )
{
   _hiReasonabilityFilter = myValue;

   return *this;
}

//=================================================================================================================================
//=================================================================================================================================

long CtiFDRTelegyr::getLinkStatusID( void ) const
{
   return _linkStatusID;
}

//=================================================================================================================================
//=================================================================================================================================

CtiFDRTelegyr & CtiFDRTelegyr::setLinkStatusID( const long aPointID )
{
   _linkStatusID = aPointID;
   return *this;
}

//=================================================================================================================================
//=================================================================================================================================

string CtiFDRTelegyr::getPath( void )
{
   return _path;
}

//=================================================================================================================================
//=================================================================================================================================

CtiFDRTelegyr & CtiFDRTelegyr::setPath( string inPath )
{
   _path = inPath;

   return *this;
}

//=================================================================================================================================
//=================================================================================================================================

void CtiFDRTelegyr::sendLinkState( int aState )
{
   if( 0 != getLinkStatusID() )
   {
      CtiPointDataMsg   *pData;

      pData = new CtiPointDataMsg( getLinkStatusID(), aState, NormalQuality, StatusPointType );
      sendMessageToDispatch( pData );
   }
}
//=================================================================================================================================
//=================================================================================================================================

bool CtiFDRTelegyr::isConnected()
{
   return _connected;
}

//=================================================================================================================================
//=================================================================================================================================

bool CtiFDRTelegyr::needsConnection( void )
{
   if( !_connected )
   {
       CTILOG_INFO(dout, "TelegyrAPI not connected");
   }
   else
   {
      if( CtiTime::now().seconds() - _reportTimer.seconds() > 30 )
      {
         if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
         {
             CTILOG_DEBUG(dout, "TelegyrAPI is connected");
         }

         _reportTimer = CtiTime::now();
      }
   }

   return !_connected;
}

//=================================================================================================================================
//=================================================================================================================================

CtiFDRTelegyr & CtiFDRTelegyr::setConnected( bool conn )
{
   if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
   {
       CTILOG_DEBUG(dout, "Setting connected to " << conn);
   }
   _connected = conn;

   return *this;
}

//=================================================================================================================================
//runs the interface
//=================================================================================================================================

BOOL CtiFDRTelegyr::run( void )
{
    CTILOG_INFO(dout, "Starting FDR Telegyr Version " << FDR_TELEGYR_VERSION);

   // crank up the base class
   Inherited::run();

   // startup our interfaces
   _threadGetTelegyrData.start();

   return TRUE;
}

//=================================================================================================================================
//=================================================================================================================================

BOOL CtiFDRTelegyr::stop( void )
{
   _quit = true;

   _threadGetTelegyrData.tryJoinOrTerminateFor(Cti::Timing::Chrono::seconds(30));

   // stop the base class
   Inherited::stop();

   return( TRUE );
}

//=================================================================================================================================
//      Here Starts some C functions that are used to Start the
//     Interface and Stop it from the Main() of FDR.EXE.
//=================================================================================================================================

#ifdef __cplusplus
extern "C"
{
#endif

   //==============================================================================================================================
   // Function Name: Extern C int RunInterface(void)
   //
   // Description: This is used to Start the Interface from the Main()
   //              of FDR.EXE. Each interface it Dynamically loaded and
   //             this function creates a global FDRTelegyr Object and then
   //              calls its run method to cank it up.
   //==============================================================================================================================

   DLLEXPORT int RunInterface( void )
   {
      // make a point to the interface
      myInterface = new CtiFDRTelegyr();

      // now start it up
      return myInterface->run();
   }

   //==============================================================================================================================
   // Function Name: Extern C int StopInterface(void)
   //
   // Description: This is used to Stop the Interface from the Main()
   //              of FDR.EXE. Each interface is Dynamically loaded and
   //              this function stops a global FDRTelegyr Object and then
   //              deletes it.
   //
   //==============================================================================================================================

   DLLEXPORT int StopInterface( void )
   {
      myInterface->stop();
      delete myInterface;
      myInterface = 0;

      return 0;
   }
#ifdef __cplusplus
}
#endif

//=================================================================================================================================
//=================================================================================================================================
//** PCLINT note: Left Warning 578 here. Deemed unsafe for this late in 5.0
void CtiFDRTelegyr::receivedAnalog( int arraySize, int group_num, int group_type, int first, int last, int result[] )
{
   int status;

   APICLI_GET_MEA *measurands = NULL;
   measurands = new APICLI_GET_MEA[arraySize];

   if( NULL != measurands )
   {
      status = api_unpack_measurands( measurands );

      if( API_NORMAL == status )
      {
         //we might only get a few points back, so we'll have to adjust
         //for where they are on the FDR side of things during processing
         for( int index = 0; index < last - first + 1 ; index++ )
         {
            if( API_NORMAL == result[index] )
            {
               processAnalog( measurands[index], group_num, group_type, index );
            }
            else
            {
               if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
               {
                   CTILOG_DEBUG(dout, "result " << result[index]);
               }

               processBadPoint( group_num, index );
            }
         }
      }
      else
      {
         CTILOG_ERROR(dout, "TelegyrAPI api_unpack_measurands() failed: " << status);
      }

      delete [] measurands;
   }
}

//=================================================================================================================================
//=================================================================================================================================

void CtiFDRTelegyr::receivedDigital( int arraySize, int group_num, int group_type, int first, int last, int result[] )
{
   int status;
   APICLI_GET_IND *indications = NULL;

   indications = new APICLI_GET_IND[arraySize];

   if( NULL != indications )
   {
      status = api_unpack_indications( indications );

      if( API_NORMAL == status )
      {
         for( int index = 0; index < last - first+1 ; index++ )
         {
            if( API_NORMAL == result[index]  )
            {
               processDigital( indications[index], group_num, group_type, index );
            }
            else
            {
               if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
               {
                   CTILOG_DEBUG(dout, "result " << result[index]);
               }

               processBadPoint( group_num, index );
            }
         }
      }
      else
      {
          CTILOG_ERROR(dout, "TelegyrAPI api_unpack_indications() failed: " << status);
      }

      delete [] indications;
   }
}

//=================================================================================================================================
//=================================================================================================================================

void CtiFDRTelegyr::receivedCounter( int arraySize, int group_num, int group_type, int first, int last, int result[] )
{
   int status;
   APICLI_GET_CNT *counters = NULL;

   counters = new APICLI_GET_CNT[arraySize];

   if( NULL != counters )
   {
      status = api_unpack_counter_values( counters );

      if( API_NORMAL == status )
      {
         for( int index = 0; index < last - first+1 ; index++ )
         {
            if( API_NORMAL == result[index] )
            {
               processCounter( counters[index], group_num, group_type, index );
            }
            else
            {
               if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
               {
                   CTILOG_DEBUG(dout, "result "<< result[index]);
               }

               processBadPoint( group_num, index );
            }
         }
      }
      else
      {
          CTILOG_ERROR(dout, "TelegyrAPI api_unpack_counter_values() failed: " << status);
      }

      delete [] counters;
   }
}

//=================================================================================================================================
//if we stop getting data for some # minutes, we'll try to re-connect
//=================================================================================================================================

int CtiFDRTelegyr::noDataAction( int no_msg_count )
{
   no_msg_count++;

   if( no_msg_count > _panicNumber )
   {
      CTILOG_INFO(dout, "Data Timeout: Starting Over");

      deleteGroups();//debug

      api_disconnect( _controlCenter.getChannelID(), API_VALID );
      setConnected( false );

      int end = api_end();

      _inited = -1;

      if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
      {
          CTILOG_DEBUG(dout, "API shutdown returned");
      }

      no_msg_count = 0;
   }

   return no_msg_count;
}

//=================================================================================================================================
//=================================================================================================================================

void CtiFDRTelegyr::halt( void )
{
   int               func_status;
   int               channel_id;
   int               group_type;
   int               group_num;
   APICLI_TIME       group_time;
   int               first_index;
   int               last_index;
   int               more;
   int               result[256];

   if( isConnected() )
   {
       CTILOG_WARN(dout, "Going to delete due to shutdown");

      CtiLockGuard<CtiMutex> sendGuard( _controlCenter.getMutex() );
      deleteGroups();

      int i;
      bool done;

      for( i = 0, done = false; ( i < 1000 ) && ( !done ); i++ )
      {
         int reason = -1;
         int returnCode = api_get_queued_data( 0,
                                               API_NO_TIMEOUT,
                                               &reason,
                                               &func_status,
                                               &channel_id,
                                               &group_type,
                                               &group_num,
                                               &group_time,
                                               &first_index,
                                               &last_index,
                                               &more,
                                               &result[0] );

         if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
         {
             CTILOG_DEBUG(dout, "Shutdown queued data got code "<< returnCode <<"; reason "<< reason);
         }

         if( ( API_DISC_NOTIFY == reason ) || ( API_DELALL_RES == reason ) )
         {
            done = true;
         }

         Sleep( 100 );
      }

      if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
      {
          CTILOG_DEBUG(dout, "Going to disconnect due to shutdown");
      }

      int disconn = api_disconnect( _controlCenter.getChannelID(), API_VALID );

      if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
      {
          CTILOG_DEBUG(dout, "Disconnect returned "<< disconn);
      }

      if( API_NORMAL == _inited )
      {
         if( getDebugLevel() & STARTUP_FDR_DEBUGLEVEL )
         {
             CTILOG_DEBUG(dout, "Stopping the api due to shutdown");
         }

         int end = api_end();

         if( getDebugLevel() & DETAIL_FDR_DEBUGLEVEL )
         {
             CTILOG_DEBUG(dout, "API shutdown returned");
         }
      }
   }
}
