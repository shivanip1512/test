#include "precompiled.h"

#include "ctitime.h"
#include "ctidate.h"

#include "cparms.h"
#include "msg_multi.h"
#include "msg_ptreg.h"
#include "msg_cmd.h"
#include "message.h"
#include "msg_reg.h"
#include "msg_ptreg.h"
#include "msg_pdata.h"
#include "msg_signal.h"
#include "pointtypes.h"
#include "dllbase.h"
#include "logger.h"
#include "guard.h"
#include "fdrsocketinterface.h"
#include "fdrpointlist.h"
#include "fdrsocketlayer.h"
#include "fdrserverconnection.h"
#include "socket_helper.h"

// this class header
#include "fdrsinglesocket.h"

using std::string;
using std::endl;

#pragma warning(push)
#pragma warning(disable:4355) // disable the warning generated by worker thread using "this" in constructor initializer List

// Constructors, Destructor, and Operators
CtiFDRSingleSocket::CtiFDRSingleSocket(string &name)
: CtiFDRSocketInterface(name),
    iLayer (NULL),
    iThreadConnection   (Cti::WorkerThread::Function(&CtiFDRSingleSocket::threadFunctionConnection,    this).name("connection"))
{
    // init these lists so they have something
    CtiFDRManager   *recList = new CtiFDRManager(getInterfaceName(),string(FDR_INTERFACE_RECEIVE));
    getReceiveFromList().setPointList (recList);
    recList = NULL;

    CtiFDRManager   *sendList = new CtiFDRManager(getInterfaceName(), string(FDR_INTERFACE_SEND));
    getSendToList().setPointList (sendList);
    sendList = NULL;
}

#pragma warning(pop)

CtiFDRSingleSocket::~CtiFDRSingleSocket()
{

    // cleanup memory
    if (iLayer != NULL)
    {
        string desc,action;
        desc = iLayer->getName() + "'s link has failed";
        logEvent (desc,action,true);
        delete iLayer;
    }
    setCurrentClientLinkStates();
}

CtiFDRSocketLayer * CtiFDRSingleSocket::getLayer ()
{
    return iLayer;
}

CtiFDRSingleSocket& CtiFDRSingleSocket::setLayer (CtiFDRSocketLayer * aLayer)
{
    iLayer = aLayer;
    return *this;
}

bool CtiFDRSingleSocket::isRegistrationNeeded()
{
    // always false unless overridden
    return false;
}

bool CtiFDRSingleSocket::isClientConnectionValid()
{
    bool retVal;

    if (iLayer->getOutBoundConnectionStatus() == CtiFDRSocketConnection::Ok)
        retVal=true;
    else
        retVal=false;
    return retVal;
}

/*************************************************
* Function Name: CtiFDRSingleSocket::init
*
* Description: create threads and loads config
*              but does not start the interface
*
**************************************************
*/
BOOL CtiFDRSingleSocket::init( void )
{
    // init the base class
    Inherited::init();

    if ( !readConfig( ) )
    {
        return FALSE;
    }

    loadTranslationLists();

    // start up the socket layer
    iLayer = NULL;

    return TRUE;
}

/*************************************************
* Function Name: CtiFDRSingleSocket::run()
*
* Description: runs the interface
*
**************************************************
*/
BOOL CtiFDRSingleSocket::run( void )
{

    // crank up the base class
    Inherited::run();

    // startup our interfaces
    iThreadConnection.start();

    // log this now so we dont' have to everytime one comes in
    if (!shouldUpdatePCTime())
    {
        string desc = getInterfaceName() + string (" has been configured to NOT process time sync updates to PC clock");
        logEvent (desc,string());
    }

    // note:  RDEX will have a problem with this once it is written to handle muliple connections
    long linkID = getClientLinkStatusID (decodeClientName(NULL));

    if (linkID)
    {
        CtiPointDataMsg     *pData;
        pData = new CtiPointDataMsg(linkID,
                                    FDR_NOT_CONNECTED,
                                    NormalQuality,
                                    StatusPointType);
        sendMessageToDispatch (pData);
    }

    return TRUE;
}


/*************************************************
* Function Name: CtiFDRSingleSocket::stop()
*
* Description: stops all threads
*
**************************************************
*/
BOOL CtiFDRSingleSocket::stop( void )
{
    //
    // FIXFIXFIX  - may need to add exception handling here
    //
    shutdownListener();

    iThreadConnection.interrupt();
    iThreadConnection.tryJoinOrTerminateFor(Cti::Timing::Chrono::seconds(10));

    // stop the base class
    Inherited::stop();

    return TRUE;
}

/************************************************************************
* Function Name: CtiFDRSingleSocket::loadList()
*
* Description: Creates a collection of points and their translations for the
*                               specified direction
*
*************************************************************************
*/
bool CtiFDRSingleSocket::loadList(string &aDirection,  CtiFDRPointList &aList)
{
    bool successful = false;
    bool foundPoint = false;

    static bool firstPassHackFlag = false;// yuck

    try
    {
        // make a list with all received points
        CtiFDRManager   *pointList = new CtiFDRManager(getInterfaceName(), aDirection);

        // if status is ok, we were able to read the database at least
        if ( pointList->loadPointList() )
        {
            /**************************************
            * seeing occasional problems where we get empty data sets back
            * and there should be info in them,  we're checking this to see if
            * is reasonable if the list may now be empty
            * the 2 entry thing is completly arbitrary
            ***************************************
            */
            if (((pointList->entries() == 0) && (aList.getPointList()->entries() <= 2)) ||
                (pointList->entries() > 0))
            {
                // Signal the list reload to anyone who cares.
                signalReloadList();

                // get iterator on list
                CtiFDRManager::spiterator myIterator = pointList->getMap().begin();

                for ( ; myIterator != pointList->getMap().end(); ++myIterator )
                {
                    foundPoint = true;
                    successful = translateSinglePoint(myIterator->second);
                }

                // lock the list I'm inserting into so it doesn't get deleted on me
                CtiLockGuard<CtiMutex> sendGuard(aList.getMutex());
                if (aList.getPointList() != NULL)
                {
                    aList.deletePointList();
                }
                aList.setPointList (pointList);

                // set this to null, the memory is now assigned to the other point
                pointList=NULL;

                if (!successful)
                {
                    if (!foundPoint)
                    {
                        // means there was nothing in the list, wait until next db change or reload
                        successful = true;
                        if (getDebugLevel() & MIN_DETAIL_FDR_DEBUGLEVEL)
                        {
                            CTILOG_DEBUG(dout, "No ("<< aDirection <<") points defined for use by interface "<< getInterfaceName());
                        }
                    }
                }
            }
            else
            {
                CTILOG_ERROR(dout, "Could not load ("<< aDirection <<") points for "<< getInterfaceName() <<" : Empty data set returned");
                successful = false;
            }
        }
        else
        {
            CTILOG_ERROR(dout, "Unable to load points from database for "<< getInterfaceName());
            successful = false;
        }
    }
    // try and catch the thread death
    catch ( ... )
    {
        CTILOG_UNKNOWN_EXCEPTION_ERROR(dout, "Failed to load point list for "<< getInterfaceName());
    }

    return successful;
}

void CtiFDRSingleSocket::signalReloadList()
{
    //Do nothing by default
}

void CtiFDRSingleSocket::signalPointRemoved(string &pointName)
{
    //do Nothing by default
}

bool CtiFDRSingleSocket::translateSinglePoint(CtiFDRPointSPtr & translationPoint, bool sendList)
{
    bool success = false;

    for (int x = 0; x < translationPoint->getDestinationList().size(); x++)
    {
        if (getDebugLevel() & DATABASE_FDR_DEBUGLEVEL)
        {
            CTILOG_DEBUG(dout, "Point ID " << translationPoint->getPointID() <<
                    " translate: " << translationPoint->getDestinationList()[0].getTranslation());
        }

        if (translateAndUpdatePoint (translationPoint, x))
        {
            success = true;
        }
    }

    return success;
}

void CtiFDRSingleSocket::cleanupTranslationPoint(CtiFDRPointSPtr & translationPoint, bool recvList)
{
    if (recvList)
    {
        if (translationPoint.get() == NULL)
        {
            return;
        }

        int size = translationPoint->getDestinationList().size();
        for ( int i = 0 ; i < size; i++) {
            string str = translationPoint->getDestinationList()[i].getTranslation();
            if (str != "")
            {
                std::transform(str.begin(), str.end(), str.begin(), toupper);
                signalPointRemoved(str);
            }
        }
    }

    return;
}

void CtiFDRSingleSocket::setCurrentClientLinkStates()
{
    long linkID = getClientLinkStatusID (decodeClientName(NULL));

    // try and load the point here if the link is valid
    if (iLayer != NULL)
    {
        iLayer->setLinkStatusID(linkID);
        iLayer->sendLinkState (FDR_CONNECTED);
    }
    else
    {
        // note:  RDEX will have a problem with this once it is written to handle muliple connections
        if (linkID)
        {
            CtiPointDataMsg     *pData;
            pData = new CtiPointDataMsg(linkID,
                                        FDR_NOT_CONNECTED,
                                        NormalQuality,
                                        StatusPointType);
            sendMessageToDispatch (pData);
        }
    }
}
/**************************************************************************
* Function Name: CtiFDRSingleSocket::sendMessageToForeignSys ()
*
* Description:
*
***************************************************************************
*/

bool CtiFDRSingleSocket::buildAndWriteToForeignSystem (CtiFDRPoint &aPoint )
{
    bool retVal = true;
    CHAR *ptr=NULL;

    /***********************
    *  data is allocated for the buffer inside this call
    *  it will be deleted inside  the socketlayer
    ************************
    */
    ptr = buildForeignSystemMsg (aPoint);

    if (ptr != NULL)
    {
        // if the write is successful
        if (iLayer != NULL)
        {
            // this is messy, may have to try again
            if (iLayer->getOutBoundConnectionStatus() == CtiFDRSocketConnection::Ok)
            {
                if (iLayer->write (ptr))
                    retVal = false;
            }
            else
            {
                delete []ptr;
                retVal = false;
            }
        }
        else
        {
            delete []ptr;
            retVal = false;
        }
    }
    else
    {
        retVal = false;
    }

    return retVal;
}

int CtiFDRSingleSocket::processMessageFromForeignSystem(CHAR *aBuffer)
{
    int retVal = ClientErrors::None;
    USHORT *function = (USHORT *)aBuffer;

    switch (ntohs (*function))
    {
        case SINGLE_SOCKET_VALUE:
            {
                retVal = processValueMessage (aBuffer);
                break;
            }
        case SINGLE_SOCKET_REGISTRATION:
            {
                retVal = processRegistrationMessage (aBuffer);
                break;
            }
        case SINGLE_SOCKET_STATUS:
            {
                retVal = processStatusMessage (aBuffer);
                break;
            }
        case SINGLE_SOCKET_CONTROL:
        case SINGLE_SOCKET_VALMET_CONTROL:
            {
                retVal = processControlMessage (aBuffer);
                break;
            }
        case SINGLE_SOCKET_FORCESCAN:
            {
                retVal = processScanMessage (aBuffer);
                break;
            }
        case SINGLE_SOCKET_TIMESYNC:
            {
                if (shouldUpdatePCTime())
                {
                    if (getDebugLevel () & MIN_DETAIL_FDR_DEBUGLEVEL)
                    {
                        CTILOG_DEBUG(dout, "Time sync message received from "<< getInterfaceName());
                    }

                    retVal = processTimeSyncMessage (aBuffer);
                }
                else
                {
                    if (getDebugLevel () & MIN_DETAIL_FDR_DEBUGLEVEL)
                    {
                        CTILOG_DEBUG(dout, "Time sync message received from " << getInterfaceName() <<
                                endl <<" PC time will not updated due to current configuration");
                    }
                }
                break;
            }
        case SINGLE_SOCKET_NULL:
            {
                if (getDebugLevel () & MIN_DETAIL_FDR_DEBUGLEVEL)
                {
                    CTILOG_DEBUG(dout, "Heartbeat message received from "<< getInterfaceName() <<" at "<< iLayer->getInBoundConnection()->getAddr());
                }
                break;
            }
        default:
            if (getDebugLevel () & MIN_DETAIL_FDR_DEBUGLEVEL)
            {
                CTILOG_DEBUG(dout, "Unknown message type "<< ntohs(*function) <<" received from "<< getInterfaceName());
            }
    }

    return retVal;

}

int CtiFDRSingleSocket::processValueMessage(CHAR *data)
{
    int retVal = ClientErrors::None;
    return retVal;
}

int CtiFDRSingleSocket::processStatusMessage(CHAR *data)
{
    int retVal = ClientErrors::None;
    return retVal;
}

int CtiFDRSingleSocket::processRegistrationMessage(CHAR *data)
{
    int retVal = ClientErrors::None;
    return retVal;
}

int CtiFDRSingleSocket::processControlMessage(CHAR *data)
{
    int retVal = ClientErrors::None;
    return retVal;
}
int CtiFDRSingleSocket::processScanMessage(CHAR *data)
{
    int retVal = ClientErrors::None;
    return retVal;
}
int CtiFDRSingleSocket::processTimeSyncMessage(CHAR *data)
{
    int retVal = ClientErrors::None;
    return retVal;
}

CHAR *CtiFDRSingleSocket::buildForeignSystemHeartbeatMsg ()
{
    return NULL;
}

int CtiFDRSingleSocket::getMessageSize(CHAR *aBuffer)
{
    return 0;
}

string CtiFDRSingleSocket::decodeClientName(CHAR * aBuffer)
{
    return string ();
}

/**************************************************************************
* Function Name: CtiFDRSingleSocket::threadFunctionConnection
*
* Description: thread that watches connection status and re-establishes it as needed
*
***************************************************************************
*/
void CtiFDRSingleSocket::threadFunctionConnection( void )
{
    using Cti::Timing::Chrono;

    INT retVal=0;
    CtiFDRServerConnection   *serverConnection;
    CtiFDRClientConnection   *clinetConnection;
    CtiFDRSocketLayer   *layer;
    int connectionIndex;
    string            desc;
    string           action;

    SOCKET tmpConnection = INVALID_SOCKET;

    bool continueFlag;

    try
    {
        if (getDebugLevel () & DETAIL_FDR_DEBUGLEVEL)
        {
            CTILOG_DEBUG(dout, "Initializing thread for "<< getInterfaceName());
        }

        for ( ; ; )
        {
            Cti::WorkerThread::sleepFor(Cti::Timing::Chrono::milliseconds(500));

            continueFlag = false;

            if (iLayer == NULL)
            {
                // allows us in the first time and any time a catastrophic error occurred
                continueFlag = true;
            }
            else
            {
                // see if we've died
                if (iLayer->getInBoundConnectionStatus() == CtiFDRSocketConnection::Failed ||
                    iLayer->getOutBoundConnectionStatus() == CtiFDRSocketConnection::Failed)
                    continueFlag = true;
            }
            // see if we've died
            if (continueFlag)
            {
                Cti::AddrInfo pAddrInfo = Cti::makeTcpServerSocketAddress(getPortNumber());
                if( !pAddrInfo )
                {
                    if (getDebugLevel () & DETAIL_FDR_DEBUGLEVEL)
                    {
                        CTILOG_DEBUG(dout, "Failed to retrieve address info (Error: "<< pAddrInfo.getError() <<")");
                    }
                    continue;
                }

                try
                {
                    CtiLockGuard<CtiMutex> lock(_listenerMux);

                    if( isListenerShutdown() )
                    {
                        // listener sockets have shutdown
                        return;
                    }

                    // create sockets from the addrinfo
                    _listenerSockets.createSockets(pAddrInfo.get());

                    // set sockets options to allows socket to bind to an address and port already in use
                    BOOL ka = TRUE;
                    _listenerSockets.setOption(SOL_SOCKET, SO_REUSEADDR, (char*)&ka, sizeof(BOOL));

                    // bind the socket
                    _listenerSockets.bind(pAddrInfo.get());

                    // set sockets in listening state
                    _listenerSockets.listen(SOMAXCONN);
                }
                catch( Cti::SocketException& e )
                {
                    CTILOG_EXCEPTION_ERROR(dout, e, "Failed to setup listener socket for "<< getInterfaceName());
                    continue;
                }

                CTILOG_INFO(dout, "Listening for connection on port "<< getPortNumber());

                // if the interface needs a registration
                if (isRegistrationNeeded())
                {
                    setRegistered(false);
                }

                // delete the old connection if its there
                if (iLayer != NULL)
                {
                    desc = iLayer->getName() + "'s link has failed";

                    CTILOG_ERROR(dout, desc);

                    logEvent (desc,action,true);
                    delete iLayer;
                    iLayer = NULL;
                }

                Cti::SocketAddress returnAddr( Cti::SocketAddress::STORAGE_SIZE );

                // new socket
                tmpConnection = _listenerSockets.accept(returnAddr, Chrono::infinite, &_listenerShutdownEvent);

                if( tmpConnection == INVALID_SOCKET )
                {
                    if (getDebugLevel () & DETAIL_FDR_DEBUGLEVEL)
                    {
                        CTILOG_DEBUG(dout, "Accept call failed in "<< getInterfaceName());
                    }
                }
                else
                {
                    // set to non blocking mode
                    ULONG param=1;
                    ioctlsocket(tmpConnection, FIONBIO, &param);

                    /***************************
                    * note:  acs, valmet both have decodeclientname funcs that return
                    * their interface names
                    * rdex does not because its client name doesn't exist until
                    * the registration msg comes thru
                    ****************************
                    */
                    iLayer = new CtiFDRSocketLayer (decodeClientName(NULL), tmpConnection, tmpConnection, CtiFDRSocketLayer::Server_Single, this);
                    iLayer->setLinkStatusID(getClientLinkStatusID(decodeClientName(NULL)));
                    iLayer->init();
                    iLayer->run();

                    const string returnAddrStr = returnAddr.toString();

                    CTILOG_INFO(dout, "Connection established to "<< decodeClientName(NULL) <<" at "<< returnAddrStr);

                    desc = decodeClientName(NULL) + string ("'s client link has been established at ") + returnAddrStr;
                    logEvent (desc,action, true);
                }
            }
        }
    }
    catch ( Cti::WorkerThread::Interrupted & )
    {
        // delete the connection object
        if (iLayer != NULL)
        {
            delete iLayer;
            iLayer = NULL;
        }

        setCurrentClientLinkStates();
        CTILOG_INFO(dout, "Thread CANCELLATION for interface "<< getInterfaceName());
        return;
    }

    // try and catch the thread death
    catch ( ... )
    {
        // delete the connection object
        if (iLayer != NULL)
        {
            delete iLayer;
            iLayer = NULL;
        }
        setCurrentClientLinkStates();

        CTILOG_UNKNOWN_EXCEPTION_ERROR(dout, "Thread for interface "<< getInterfaceName() <<" is dead!");
    }
}


bool CtiFDRSingleSocket::alwaysSendRegistrationPoints ( )
{
    return false;
}

