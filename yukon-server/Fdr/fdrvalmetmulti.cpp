#include "precompiled.h"

#include "ctitime.h"
#include "ctidate.h"
#include "utility.h"

#include "cparms.h"
#include "msg_multi.h"
#include "msg_ptreg.h"
#include "msg_cmd.h"
#include "message.h"
#include "msg_reg.h"
#include "msg_ptreg.h"
#include "msg_pdata.h"
#include "msg_signal.h"
#include "pointtypes.h"
#include "dllbase.h"
#include "logger.h"
#include "guard.h"
#include "fdrsocketinterface.h"
#include "fdrscadahelper.h"
#include "utility.h"
#include "dbaccess.h"

// this class header
#include "fdrvalmetmulti.h"
#include "fdrvalmetutil.h"
#include "win_helper.h"

#include <sstream>

using std::string;
using std::endl;
using std::set;
using boost::thread;

using namespace Fdr::Valmet;

/** local definitions **/

/** global used to start the interface by c functions **/
CtiFDR_ValmetMulti * valmetMultiInterface;

const CHAR * CtiFDR_ValmetMulti::KEY_LISTEN_PORT_NUMBER = "FDR_VALMETMULTI_PORT_NUMBER";
const CHAR * CtiFDR_ValmetMulti::KEY_TIMESTAMP_WINDOW = "FDR_VALMETMULTI_TIMESTAMP_VALIDITY_WINDOW";
const CHAR * CtiFDR_ValmetMulti::KEY_DB_RELOAD_RATE = "FDR_VALMETMULTI_DB_RELOAD_RATE";
const CHAR * CtiFDR_ValmetMulti::KEY_QUEUE_FLUSH_RATE = "FDR_VALMETMULTI_QUEUE_FLUSH_RATE";
const CHAR * CtiFDR_ValmetMulti::KEY_DEBUG_MODE = "FDR_VALMETMULTI_DEBUG_MODE";
const CHAR * CtiFDR_ValmetMulti::KEY_OUTBOUND_SEND_RATE = "FDR_VALMETMULTI_SEND_RATE";
const CHAR * CtiFDR_ValmetMulti::KEY_OUTBOUND_SEND_INTERVAL = "FDR_VALMETMULTI_SEND_INTERVAL";
const CHAR * CtiFDR_ValmetMulti::KEY_TIMESYNC_VARIATION = "FDR_VALMETMULTI_MAXIMUM_TIMESYNC_VARIATION";
const CHAR * CtiFDR_ValmetMulti::KEY_TIMESYNC_UPDATE = "FDR_VALMETMULTI_RESET_PC_TIME_ON_TIMESYNC";
const CHAR * CtiFDR_ValmetMulti::KEY_LINK_TIMEOUT = "FDR_VALMETMULTI_LINK_TIMEOUT_SECONDS";
const CHAR * CtiFDR_ValmetMulti::KEY_SCAN_DEVICE_POINTNAME = "FDR_VALMETMULTI_SCAN_DEVICE_POINTNAME";
const CHAR * CtiFDR_ValmetMulti::KEY_SEND_ALL_POINTS_POINTNAME = "FDR_VALMETMULTI_SEND_ALL_POINTS_POINTNAME";
const CHAR * CtiFDR_ValmetMulti::KEY_STARTUP_DELAY_SECONDS = "FDR_VALMETMULTI_STARTUP_DELAY";
const CHAR * CtiFDR_ValmetMulti::KEY_PORTS_TO_LOG = "FDR_VALMETMULTI_PORTS_TO_LOG";

#pragma warning(push)
#pragma warning(disable:4355) // disable the warning generated by worker thread using "this" in constructor initializer List

// Constructors, Destructor, and Operators
CtiFDR_ValmetMulti::CtiFDR_ValmetMulti()
: CtiFDRScadaServer(string(FDR_VALMETMULTI)),
    _helper(NULL),
    _listenerThreadStartupDelay(0),
    _specificPortLoggingEnabled(false),
    _listenerStarterThread(Cti::WorkerThread::Function(&CtiFDR_ValmetMulti::threadListenerStartupMonitor, this).name("listenerStartupMonitor"))
{
    // Set to prevent normal connection thread
    setSingleListeningPort(false);
    init();
    _helper = new CtiFDRScadaHelper<CtiValmetPortId>(this);
}

#pragma warning(pop)

CtiFDR_ValmetMulti::~CtiFDR_ValmetMulti()
{
    delete _helper;
}

BOOL CtiFDR_ValmetMulti::run( void )
{
    // load up the base class
    CtiFDRScadaServer::run();

    _listenerStarterThread.start();

    return TRUE;
}

BOOL CtiFDR_ValmetMulti::stop( void )
{
    // stop the base class
    CtiFDRScadaServer::stop();

    _listenerStarterThread.interrupt();
    _listenerStarterThread.tryJoinOrTerminateFor(Cti::Timing::Chrono::seconds(10));

    //Stop all listener threads happens in CtiFDRSocketServer
    stopMultiListeners();

    return TRUE;
}

/** 
  Since ValmetMulti supports multiple forign sockets, we have elected to not 
  start listening in the fdrsocketserver code, but to start the listening of 
  these sockets to here.  We also start a listener thread for that socket.

  Note that we only listen to the socket once, even if there are multiple 
  points referencing it. 
*/
void CtiFDR_ValmetMulti::startMultiListeners()
{
    CtiLockGuard<CtiMutex> lockGuard(_listeningThreadManagementMutex);

    while ( ! _listeningPortNumbers.empty())
    {
        const int port = _listeningPortNumbers.getQueue();

        // Search to see if we alredy have a thread for this port.  If not, start one
        if(_listenerThreadMap.count(port) == 0)
        {
            thread *listenerThread = new boost::thread(&CtiFDR_ValmetMulti::threadFunctionConnection, this, port, _listenerThreadStartupDelay);
            _listenerThreads.add_thread(listenerThread);

            _listenerThreadMap[port] = listenerThread;
        }
    }
}

void CtiFDR_ValmetMulti::stopMultiListeners()
{
    CtiLockGuard<CtiMutex> lockGuard(_listeningThreadManagementMutex);

    _listenerThreads.interrupt_all();
    _listenerThreads.join_all();
}

/*************************************************
* Function Name: CtiFDR_ValmetMulti::config()
*
* Description: loads cparm config values
*
*************************************************/
bool CtiFDR_ValmetMulti::readConfig()
{
    // load up the base class
    CtiFDRScadaServer::readConfig();

    int linkTimeout = gConfigParms.getValueAsInt(KEY_LINK_TIMEOUT, 60);
    setLinkTimeout(linkTimeout);

    int portNumber = gConfigParms.getValueAsInt(KEY_LISTEN_PORT_NUMBER, VALMET_PORTNUMBER);
    setPortNumber(portNumber);

    int timestampWindow = gConfigParms.getValueAsInt(KEY_TIMESTAMP_WINDOW, 120);
    setTimestampReasonabilityWindow(timestampWindow);

    int reloadRate = gConfigParms.getValueAsInt(KEY_DB_RELOAD_RATE, 86400);
    setReloadRate(reloadRate);

    int queueFlushRate = gConfigParms.getValueAsInt(KEY_QUEUE_FLUSH_RATE, 1);
    setQueueFlushRate(queueFlushRate);

    int outboundSendRate = gConfigParms.getValueAsInt(KEY_OUTBOUND_SEND_RATE, 1);
    setOutboundSendRate(outboundSendRate);

    int outboundSendInterval = gConfigParms.getValueAsInt(KEY_OUTBOUND_SEND_INTERVAL, 0);
    setOutboundSendInterval(outboundSendInterval);

    int timesyncVariation = gConfigParms.getValueAsInt(KEY_TIMESYNC_VARIATION, 30);
    setTimeSyncVariation(timesyncVariation);

    if(getTimeSyncVariation() < 5)
    {
        if (getDebugLevel() & STARTUP_FDR_DEBUGLEVEL)
        {
            CTILOG_DEBUG(dout, "Valmet max time sync variation of "<< getTimeSyncVariation() <<" second(s) is invalid, defaulting to 5 seconds");
        }
        // default to 5 seconds
        setTimeSyncVariation(5);
    }

    bool updatePcTimeFlag = gConfigParms.isTrue(KEY_TIMESYNC_UPDATE, true);
    setUpdatePCTimeFlag(updatePcTimeFlag);

    string tempStr = getCparmValueAsString(KEY_DEBUG_MODE);
    setInterfaceDebugMode(tempStr.length() > 0);

    _scanDevicePointName = gConfigParms.getValueAsString(KEY_SCAN_DEVICE_POINTNAME, "DEVICE_SCAN");
    _sendAllPointsPointName = gConfigParms.getValueAsString(KEY_SEND_ALL_POINTS_POINTNAME, "SEND_ALL_POINTS");

    _listenerThreadStartupDelay = gConfigParms.getValueAsInt(KEY_STARTUP_DELAY_SECONDS, 0);


    string portsToLogStr = gConfigParms.getValueAsString(KEY_PORTS_TO_LOG, "");
    _portsToLog = parseCommaSeparatedInt(portsToLogStr);
    if(_portsToLog.size() > 0)
    {
        _specificPortLoggingEnabled = true;
    }

    if (getDebugLevel() & STARTUP_FDR_DEBUGLEVEL)
    {
        Cti::FormattedList loglist;

        loglist.add("Valmet Multi timestamp window")           << getTimestampReasonabilityWindow();
        loglist.add("Valmet Multi db reload rate")             << getReloadRate();
        loglist.add("Valmet Multi queue flush rate")           << getQueueFlushRate() <<" second(s)";
        loglist.add("Valmet Multi send rate")                  << getOutboundSendRate();
        loglist.add("Valmet Multi send interval")              << getOutboundSendInterval() <<" second(s) ";
        loglist.add("Valmet Multi max time sync variation")    << getTimeSyncVariation() <<" second(s) ";
        loglist.add("Valmet Multi link timeout")               << getLinkTimeout() <<" second(s) ";
        loglist.add("Valmet Multi force scan pointname")       << _sendAllPointsPointName;
        loglist.add("Valmet Multi scan device compare string") << _scanDevicePointName;

        loglist <<"Valmet time sync will "<< string(shouldUpdatePCTime() ? "" : "not") <<" reset PC clock";
        loglist <<"Valmet running in "<< string(isInterfaceInDebugMode() ? "debug" : "normal") <<" mode";

        if (_specificPortLoggingEnabled)
        {
            Cti::StreamBuffer sb;
            sb <<"Valmet Multi logging only these ports: ";

            for( int port : _portsToLog )
            {
                sb << port << " ";
            }

            loglist << sb.extractToString();
        }

        CTILOG_DEBUG(dout, loglist);
    }

    return true;
}



void CtiFDR_ValmetMulti::begineNewPoints()
{
    signalReloadList();
}

void CtiFDR_ValmetMulti::signalReloadList()
{
    _helper->clearMappings();
    //The list is being reloaded. Clear our tracking map to be re-filled.
    _receiveNameToPointId.clear();
}

bool CtiFDR_ValmetMulti::translateSinglePoint(CtiFDRPointSPtr & translationPoint, bool sendList)
{
    bool foundPoint = false;

    for each(const CtiFDRDestination &pointDestination in translationPoint->getDestinationList())
    {
        foundPoint = true;

        string pointName = pointDestination.getTranslationValue("Point");
        string portNumber = pointDestination.getTranslationValue("Port");

        if (portNumber.empty() || pointName.empty())
        {
            CTILOG_ERROR(dout, logNow() <<"Unable to add destination "<< pointDestination <<" due to misconfiguration in the database. Missing the Point Name or Port");
            return false;
        }

        CtiValmetPortId valmetPortId;
        valmetPortId.PortNumber = atoi(portNumber.c_str());
        valmetPortId.PointName = pointName;

        if (valmetPortId.PortNumber != 0)
        {
            _listeningPortNumbers.putQueue(valmetPortId.PortNumber);
        }

        if (sendList)
        {
            _helper->addSendMapping(valmetPortId, pointDestination);
            insertPortToPointsMap(valmetPortId.PortNumber,translationPoint->getPointID());
        }
        else
        {
            int pointId = translationPoint->getPointID();
            string upperPointName = pointName;
            std::transform(upperPointName.begin(), upperPointName.end(), upperPointName.begin(), toupper);
            NameToPointIdMap::iterator itr = _receiveNameToPointId.find(upperPointName);
            if(itr == _receiveNameToPointId.end())
            {
                if(getDebugLevel() & TRANSLATION_LOADING_DEBUGLEVEL)
                {
                    // We don't have this point in our translation list yet, add it!
                    CTILOG_DEBUG(dout, logNow() <<" Point [" << upperPointName << "," << pointId << "] added to translation map.");
                }
                _receiveNameToPointId.insert(std::make_pair(upperPointName, pointId));
            }
            _helper->addReceiveMapping(valmetPortId, pointDestination);
        }
    }

    return foundPoint;
}

void CtiFDR_ValmetMulti::cleanupTranslationPoint(CtiFDRPointSPtr & translationPoint, bool recvList)
{
    for each(const CtiFDRDestination &pointDestination in translationPoint->getDestinationList())
    {
        // translate and put the point id the list
        string pointName = pointDestination.getTranslationValue("Point");
        string portNumber = pointDestination.getTranslationValue("Port");

        if (portNumber.empty() || pointName.empty())
        {
            return;
        }

        CtiValmetPortId valmetPortId;
        valmetPortId.PortNumber = atoi(portNumber.c_str());
        valmetPortId.PointName = pointName;

        if (!recvList)
        {
            _helper->removeSendMapping(valmetPortId, pointDestination);
        }
        else
        {
            _helper->removeReceiveMapping(valmetPortId, pointDestination);
        }

        string upperPointName = pointName;
        std::transform(upperPointName.begin(), upperPointName.end(), upperPointName.begin(), toupper);
        _receiveNameToPointId.erase(upperPointName);

        removePortToPointsMap(valmetPortId.PortNumber,translationPoint->getPointID());
    }
}

CtiFDRClientServerConnectionSPtr CtiFDR_ValmetMulti::createNewConnection(SOCKET newSocket)
{
    Cti::SocketAddress addr( Cti::SocketAddress::STORAGE_SIZE );

    if( getsockname(newSocket, &addr._addr.sa, &addr._addrlen) == SOCKET_ERROR )
    {
        const DWORD error = WSAGetLastError();
        CTILOG_DEBUG(dout, "getsockname() failed with error code "<< error <<" / "<< Cti::getSystemErrorMessage(error));

        return CtiFDRClientServerConnectionSPtr(); // return NULL pointer if there is an error
    }

    const int port = ntohs(addr._addr.sa_in.sin_port);

    std::stringstream ss;
    ss << "port_" << port;

    const std::string connName = ss.str();
    CtiFDRClientServerConnectionSPtr newConnection(new CtiFDRClientServerConnection(connName.c_str(), newSocket, this));

    newConnection->setRegistered(true); // Valmet doesn't have a separate registration message

    return newConnection;
}

CtiFDRClientServerConnectionSPtr CtiFDR_ValmetMulti::findConnectionForDestination(const CtiFDRDestination destination) const
{
    // Port match needs to happen for ValmetMulti.
    int destPort = atoi(destination.getTranslationValue("Port").c_str());

    // Because new connections are put on the end of the list,
    // we want to search the list backwards so that we find
    // the newest connection that matches the destination.
    // Any prior connections are assumed to be a failed connection and the newest the reconnection.
    // IF we have 2 computers connecting at the same port, we WILL starve the older connections.
    ConnectionList::const_reverse_iterator myIter;

    CtiLockGuard<CtiMutex> guard(_connectionListMutex);
    for (myIter = _connectionList.rbegin(); myIter != _connectionList.rend(); ++myIter)
    {
        if ((*myIter)->getPortNumber() == destPort)
        {
            return (*myIter);
        }
    }

    return CtiFDRClientServerConnectionSPtr();
}

bool CtiFDR_ValmetMulti::buildForeignSystemMessage(const CtiFDRDestination& destination,
                                                   char** buffer,
                                                   unsigned int& bufferSize)
{
    CHAR *valmet=NULL;
    CtiFDRPointSPtr point = destination.findPointFromList( getSendToList() );
    if( point == nullptr )
    {
        CTILOG_ERROR( dout, "Point was not found in destination list: " << destination );
        return false;
    }

   /* we allocate a valmet message here and it will be deleted
    * inside of the write function on the connection
    */

    CtiValmetPortId valmetPortId;
    if (!_helper->getIdForDestination(destination, valmetPortId))
    {
        return false;
    }

    valmet = new CHAR[sizeof(ValmetExtendedInterface_t)];
    ValmetExtendedInterface_t *ptr = (ValmetExtendedInterface_t *)valmet;

    if (point->isCommStatus() && point->getValue() != 0)
    {
        updatePointQualitiesOnDevice(NonUpdatedQuality, point->getPaoID());
    }
   /**************************
    * we allocate a valmet message here and it will be deleted
    * inside of the write function on the connection
    ***************************
    */

    // make sure we have all the pieces
    if (valmet == NULL)
    {
        return false;
    }
    // set the timestamp, everything else is based on type of message
    strcpy (ptr->TimeStamp,  YukonToForeignTime (point->getLastTimeStamp()).c_str());

    switch (point->getPointType())
    {
        case AnalogPointType:
        case CalculatedPointType:
        case PulseAccumulatorPointType:
        case DemandAccumulatorPointType:
            {
                ptr->Function = htons (SINGLE_SOCKET_VALUE);
                strcpy(ptr->Value.Name,valmetPortId.PointName.c_str());
                ptr->Value.Quality = YukonToForeignQuality (*point);
                ptr->Value.LongValue = CtiFDRSocketInterface::htonieeef (point->getValue());

                if (isPortLoggingNotRestricted(destination) && getDebugLevel () & DATA_SEND_DEBUGLEVEL)
                {
                    CTILOG_DEBUG(dout, "Analog/Calculated point "<< point->getPointID() <<
                            " queued as "<< ptr->Value.Name <<
                            " value "<< point->getValue() <<" with quality of "<< ForeignQualityToString(ptr->Value.Quality) <<
                            " to "<< getInterfaceName() <<" on Port "<< atoi(destination.getTranslationValue("Port").c_str()));
                }
                break;
            }

        case CalculatedStatusPointType:
        case StatusPointType:
            {
                if (point->isControllable())
                {
                    ptr->Function = htons (SINGLE_SOCKET_CONTROL);
                    strcpy (ptr->Control.Name,valmetPortId.PointName.c_str());

                    // check for validity of the status, we only have open or closed in controls
                    if ((point->getValue() != STATE_OPENED) && (point->getValue() != STATE_CLOSED))
                    {
                        delete [] valmet;
                        valmet = NULL;

                        if (isPortLoggingNotRestricted(destination) && getDebugLevel() & DATA_SEND_ERR_DEBUGLEVEL)
                        {
                            CTILOG_ERROR(dout, "Point "<< point->getPointID() <<" State "<< point->getValue() <<" is invalid for interface "<< getInterfaceName());
                        }
                    }
                    else
                    {
                        ptr->Control.Value = YukonToForeignStatus (point->getValue());

                         if (isPortLoggingNotRestricted(destination) && getDebugLevel () & DATA_SEND_DEBUGLEVEL)
                         {
                             Cti::StreamBuffer logmsg;

                             logmsg <<"Control point "<< point->getPointID() <<" queued as " << ptr->Control.Name;
                             if (point->getValue() == STATE_OPENED)
                             {
                                 logmsg <<" state of Open ";
                             }
                             else
                             {
                                 logmsg <<" state of Close ";
                             }
                             logmsg <<"to "<< getInterfaceName() <<" on Port "<< atoi(destination.getTranslationValue("Port").c_str());

                             CTILOG_DEBUG(dout, logmsg);
                         }
                    }
                }
                else
                {
                    ptr->Function = htons (SINGLE_SOCKET_STATUS);
                    strcpy (ptr->Value.Name,valmetPortId.PointName.c_str());
                    ptr->Status.Quality = YukonToForeignQuality (*point);

                    // check for validity of the status, we only have open or closed for Valmet
                    if ((point->getValue() != STATE_OPENED) && (point->getValue() != STATE_CLOSED))
                    {
                        delete [] valmet;
                        valmet = NULL;

                        if (isPortLoggingNotRestricted(destination) && getDebugLevel() & DATA_SEND_ERR_DEBUGLEVEL)
                        {
                            CTILOG_ERROR(dout, "Point "<< point->getPointID() <<" State "<< point->getValue() <<" is invalid for interface "<< getInterfaceName());
                        }
                    }
                    else
                    {
                        ptr->Status.Value = YukonToForeignStatus (point->getValue());

                         if (isPortLoggingNotRestricted(destination) && getDebugLevel () & DATA_SEND_DEBUGLEVEL)
                         {
                             Cti::StreamBuffer logmsg;

                             logmsg <<" Status point " << point->getPointID() <<" queued as "<< point->getTranslateName(string (FDR_VALMETMULTI));
                             if (point->getValue() == STATE_OPENED)
                             {
                                 logmsg << " state of Open ";
                             }
                             else
                             {
                                 logmsg << " state of Close ";
                             }
                             logmsg <<"with quality of "<< ForeignQualityToString(ptr->Status.Quality) <<" to "<< getInterfaceName();

                             CTILOG_DEBUG(dout, logmsg);
                         }
                    }
                }
                break;
            }
        default:
            delete []valmet;
            valmet = NULL;
            break;
    }
    *buffer = valmet;
    bufferSize = sizeof(ValmetExtendedInterface_t);

    return valmet != NULL;
}

bool CtiFDR_ValmetMulti::buildForeignSystemHeartbeatMsg(char** buffer, unsigned int& bufferSize)
{
    CHAR *valmet=NULL;

    /**************************
    * we allocate a valmet message here and it will be deleted
    * inside of the write function on the connection
    ***************************
    */
    valmet = new CHAR[sizeof(ValmetExtendedInterface_t)];
    ValmetExtendedInterface_t *ptr = (ValmetExtendedInterface_t *)valmet;
    bool retVal = true;

    if (valmet != NULL)
    {
        ptr->Function = htons (SINGLE_SOCKET_NULL);
        strcpy (ptr->TimeStamp, YukonToForeignTime (CtiTime()).c_str());
    }
    *buffer = valmet;
    bufferSize = sizeof(ValmetExtendedInterface_t);
    return valmet != NULL;
}

unsigned int CtiFDR_ValmetMulti::getMessageSize(const char* data)
{
    return sizeof (ValmetExtendedInterface_t);
}

string CtiFDR_ValmetMulti::decodeClientName(CHAR * aBuffer)
{
    return getInterfaceName();
}

/**
  Process a SCADA TimeSync message (type 401)
  If Valid timestamp, set system time.
*/
bool CtiFDR_ValmetMulti::processTimeSyncMessage(Cti::Fdr::ServerConnection& connection,
                                         const char* aData, unsigned int size)
{
    int retVal = ClientErrors::None;
    CtiPointDataMsg     *pData;
    ValmetExtendedInterface_t  *data = (ValmetExtendedInterface_t*)aData;
    CtiTime              timestamp;
    string           desc;
    string               action;

    timestamp = ForeignToYukonTime (data->TimeStamp, getTimestampReasonabilityWindow(),true);
    if (timestamp == PASTDATE)
    {
        if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
        {
            CTILOG_ERROR(dout, getInterfaceName() <<" time sync request was invalid "<< data->TimeStamp);
        }
        desc = getInterfaceName() + string (" time sync request was invalid ") + string (data->TimeStamp);
        logEvent (desc,action,true);
        retVal = ClientErrors::Abnormal;
    }
    else
    {
        CtiTime now;
        // check if the stamp is inside the window
        if (timestamp.seconds() > (now.seconds()-getTimeSyncVariation()) &&
            timestamp.seconds() < (now.seconds()+getTimeSyncVariation()))
        {
            retVal = ClientErrors::None;
        }
        else
        {
            // timestamp is not inside the the window, is it realistic (inside 30 minutes)
            if (timestamp.seconds() > (now.seconds()-(30 * 60)) &&
                timestamp.seconds() < (now.seconds()+(30 * 60)))
            {
                // reset the time and log the change
                /**********************
                *   Straight from the help files
                *
                * It is not recommended that you add and subtract values
                * from the SYSTEMTIME structure to obtain relative times. Instead, you should
                *
                * Convert the SYSTEMTIME structure to a FILETIME structure.
                * Copy the resulting FILETIME structure to a ULARGE_INTEGER structure.
                * Use normal 64-bit arithmetic on the ULARGE_INTEGER value.
                ***********************
                */
                SYSTEMTIME  sysTime;
                FILETIME    fileTime;
                GetSystemTime(&sysTime);
                if (SystemTimeToFileTime (&sysTime, &fileTime))
                {
                    ULARGE_INTEGER timeNow; // 64 bit number of 100 nanosecond parts since 1601
                    timeNow.LowPart = fileTime.dwLowDateTime;
                    timeNow.HighPart = fileTime.dwHighDateTime;

                    // which way to move converted to 100 nanosecond parts
                    if (timestamp.seconds() > (now.seconds()))
                        timeNow.QuadPart += ( long long)((timestamp.seconds() - now.seconds()) * 10000000);
                    else
                        timeNow.QuadPart -= ( long long)((now.seconds() - timestamp.seconds()) * 10000000);

                    fileTime.dwLowDateTime = timeNow.LowPart;
                    fileTime.dwHighDateTime = timeNow.HighPart;

                    if (FileTimeToSystemTime (&fileTime, &sysTime))
                    {
                        SetSystemTime (&sysTime);
                        desc = getInterfaceName() + "'s request to change PC time to ";
                        desc += timestamp.asString() + " was processed";
                        action += "PC time reset to" + timestamp.asString();
                        logEvent (desc,action,true);

                        if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_DEBUGLEVEL)
                        {
                            CTILOG_DEBUG(dout, getInterfaceName() <<"'s request to change PC time to "<< timestamp <<" was processed");
                        }
                    }
                    else
                    {
                        if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
                        {
                            CTILOG_ERROR(dout, "Unable to process time change from " << getInterfaceName());
                        }

                        desc = getInterfaceName() + "'s request to change PC time to ";
                        desc += timestamp.asString() + " failed";
                        action = string ("System time update API failed");
                        logEvent (desc,action,true);
                        retVal = ClientErrors::Abnormal;
                    }
                }
                else
                {
                    if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
                    {
                        CTILOG_ERROR(dout, "Unable to process time change from "<< getInterfaceName());
                    }

                    desc = getInterfaceName() + "'s request to change PC time to ";
                    desc += timestamp.asString() + " failed";
                    action = string ("System time update API failed");
                    logEvent (desc,action,true);
                    retVal = ClientErrors::Abnormal;
                }
            }
            else
            {
                if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
                {
                    CTILOG_ERROR(dout, "Time change requested from "<< getInterfaceName() <<" of "<< timestamp <<" is outside standard +-30 minutes");
                }

                //log we're way out of whack now
                desc = getInterfaceName() + "'s request to change PC time to ";
                desc += timestamp.asString() + " was denied";
                action = string ("Requested time is greater that +-30 minutes");
                logEvent (desc,action,true);
            }
        }
    }

    return retVal;
}

CtiFDRPointSPtr CtiFDR_ValmetMulti::findFdrPointInPointList(const std::string &translationName)
{
    CtiFDRPointSPtr point;

    CtiLockGuard<CtiMutex> receiveGuard(getReceiveFromList().getMutex());

    string pointName = translationName;
    std::transform(pointName.begin(), pointName.end(), pointName.begin(), toupper);
    NameToPointIdMap::iterator iter = _receiveNameToPointId.find(pointName);
    if( iter != _receiveNameToPointId.end() ) {
        point = getReceiveFromList().getPointList()->findFDRPointID(iter->second);
    }

    return point;
}

/**
  Process a SCADA status message (type 101)

  If the point is not found log error message and return
  If AnalogPointType, PulseAccumulatorPointType, DemandAccumulatorPointType or CalculatedPointType
    get quality, value, and timestamp
    if point is controllable,
      send AnalogOutputMessage to dispatch
    else
      send PointDataMsg to dispatch

*/

bool CtiFDR_ValmetMulti::processValueMessage(Cti::Fdr::ServerConnection& connection,
                                         const char* aData, unsigned int size)
{
    int retVal = ClientErrors::None, quality;
    CtiPointDataMsg *pData;
    ValmetExtendedInterface_t *data = (ValmetExtendedInterface_t*)aData;
    string desc;
    double value;
    CtiTime timestamp;
    char action[60];

    // convert to our name
    const string translationName = string(data->Value.Name);

    //Find
    CtiFDRPointSPtr point = findFdrPointInPointList(translationName);

    if (point)
    {
        if ((point->getPointType() == AnalogPointType) ||
            (point->getPointType() == PulseAccumulatorPointType) ||
            (point->getPointType() == DemandAccumulatorPointType) ||
            (point->getPointType() == CalculatedPointType))
        {
            // assign last stuff
            quality = ForeignToYukonQuality (data->Value.Quality);
            value = CtiFDRSocketInterface::ntohieeef (data->Value.LongValue);
            value *= point->getMultiplier();
            value += point->getOffset();

            timestamp = ForeignToYukonTime (data->TimeStamp, getTimestampReasonabilityWindow());
            if (timestamp == PASTDATE)
            {
                if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
                {
                    CTILOG_ERROR(dout, getInterfaceName() <<" analog value received with an invalid timestamp "<<  data->TimeStamp);
                }

                desc = getInterfaceName() + " analog point received with an invalid timestamp ";
                desc += string (data->TimeStamp);
                _snprintf(action,60,"%s for pointID %d",
                          translationName.c_str(),
                          point->getPointID());
                logEvent (desc,string (action));
                retVal = ClientErrors::Abnormal;
            }
            else
            {
                if (point->isControllable())
                {
                    CtiCommandMsg *aoMsg = createAnalogOutputMessage(point->getPointID(), translationName, value);
                    sendMessageToDispatch(aoMsg);
                    return  ClientErrors::None;
                }
                pData = new CtiPointDataMsg(point->getPointID(),
                                                value,
                                                quality,
                                                point->getPointType());
                pData->setTime(timestamp);

                // consumes a delete memory
                queueMessageToDispatch(pData);


                if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_DEBUGLEVEL)
                {
                    CTILOG_DEBUG(dout, "Analog point "<< translationName <<" value "<< value <<" from "<< getInterfaceName() <<
                            " assigned to point "<< point->getPointID());
                }
            }
        }
        else
        {
            if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
            {
                CTILOG_ERROR(dout, "Analog point "<< translationName <<" from "<< getInterfaceName() <<
                        " was mapped incorrectly to non-analog point " << point->getPointID());

                CHAR pointID[20];
                desc = getInterfaceName() + string (" analog point is incorrectly mapped to point ") + string (ltoa(point->getPointID(),pointID,10));
                _snprintf(action,60,"%s", translationName.c_str());
                logEvent (desc,string (action));
            }
            retVal = ClientErrors::Abnormal;
        }
    }
    else
    {
        if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
        {
            CTILOG_ERROR(dout, "Translation for analog point "<< translationName <<" from "<< getInterfaceName() <<
                    " was not found");

            desc = getInterfaceName() + string (" analog point is not listed in the translation table");
            _snprintf(action,60,"%s", translationName.c_str());
            logEvent (desc,string (action));
        }
        retVal = ClientErrors::Abnormal;
    }

    return retVal;
}

/**
  Process a SCADA status message (type 102)

  If the point is not found log error message and return
  If not StatusPointType log error message and return
  get quality, value and timestamp
  send PointDataMsg to dispatch

*/
bool CtiFDR_ValmetMulti::processStatusMessage(Cti::Fdr::ServerConnection& connection,
                                         const char* aData, unsigned int size)
{
    int retVal = ClientErrors::None, quality;
    CtiPointDataMsg *pData;
    ValmetExtendedInterface_t *data = (ValmetExtendedInterface_t*)aData;
    DOUBLE value;
    CtiTime timestamp;
    string desc;
    CHAR action[60];

    string translationName = string (data->Status.Name);

    CtiFDRPointSPtr point = findFdrPointInPointList(translationName);

    if(point)
    {
        if(point->getPointType() == StatusPointType)
        {
            // assign last stuff
            quality = ForeignToYukonQuality (data->Status.Quality);

            value = ForeignToYukonStatus (data->Status.Value);
            timestamp = ForeignToYukonTime (data->TimeStamp, getTimestampReasonabilityWindow());
            if (timestamp == PASTDATE)
            {
                if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
                {
                    CTILOG_ERROR(dout, getInterfaceName() <<" status value received with an invalid timestamp "<< data->TimeStamp);
                }

                desc = getInterfaceName() + string (" status point received with an invalid timestamp ") + string (data->TimeStamp);
                _snprintf(action,60,"%s for pointID %d",
                          translationName.c_str(),
                          point->getPointID());
                logEvent (desc,string (action));
                retVal = ClientErrors::Abnormal;
            }
            else
            {
                pData = new CtiPointDataMsg(point->getPointID(),
                                            value,
                                            quality,
                                            StatusPointType);

                pData->setTime(timestamp);

                // consumes a delete memory
                queueMessageToDispatch(pData);

                if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_DEBUGLEVEL)
                {
                    Cti::StreamBuffer logmsg;

                    logmsg <<" Status point "<< translationName;
                    if (value == STATE_OPENED)
                    {
                        logmsg << " new state: Open " ;
                    }
                    else if (value == STATE_CLOSED)
                    {
                        logmsg << " new state: Closed " ;
                    }
                    else if (value == STATE_INDETERMINATE)
                    {
                        logmsg << " new state: Indeterminate " ;
                    }
                    else
                    {
                        logmsg << " new state: " << value;
                    }

                    logmsg <<" from " << getInterfaceName() << " assigned to point " << point->getPointID();

                    CTILOG_DEBUG(dout, logmsg);
                }
            }
        }
        else
        {
            if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
            {
                CTILOG_ERROR(dout, "Status point " << translationName <<" from "<< getInterfaceName() <<
                        " was mapped incorrectly to non-status point " << point->getPointID());

                CHAR pointID[20];
                desc = getInterfaceName() + string (" status point is incorrectly mapped to point ") + string (ltoa(point->getPointID(),pointID,10));
                _snprintf(action,60,"%s", translationName.c_str());
                logEvent (desc,string (action));
            }
            retVal = ClientErrors::Abnormal;
        }
    }
    else
    {
        if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
        {
            CTILOG_ERROR(dout, "Translation for status point "<<  translationName <<" from "<< getInterfaceName() <<
                    " was not found");

            desc = getInterfaceName() + string (" status point is not listed in the translation table");
            _snprintf(action,60,"%s", translationName.c_str());
            logEvent (desc,string (action));
        }
        retVal = ClientErrors::Abnormal;
    }

    return retVal;
}

bool CtiFDR_ValmetMulti::isPortLoggingNotRestricted(Cti::Fdr::ServerConnection& connection)
{
    return isPortLoggingNotRestricted(connection.getPortNumber());
}

bool CtiFDR_ValmetMulti::isPortLoggingNotRestricted(const CtiFDRDestination& destination)
{
    string portStr = destination.getTranslationValue("Port");
    int portNumber = atoi(portStr.c_str());

    //0 is an invalid port. and 0 is returned from an invalid atoi() call. default to true
    if (portNumber != 0)
    {
        return isPortLoggingNotRestricted(portNumber);
    }
    return true;
}

bool CtiFDR_ValmetMulti::isPortLoggingNotRestricted(int portNumber)
{
    if (_specificPortLoggingEnabled)
    {
        set<int>::iterator itr = _portsToLog.find(portNumber);
        if (itr == _portsToLog.end())
        {
            return false;
        }
        return true;
    }
    return true;
}

/**
  Process a SCADA force scan message (type 110)

  If the point is not _sendAllPointsPointName log error message and return.
  Send InitiateScan to dispatch.

*/
int CtiFDR_ValmetMulti::processScanMessage(CtiFDRClientServerConnection* connection, const char* aData)
{
    ValmetExtendedInterface_t  *data = (ValmetExtendedInterface_t*)aData;
    string  translationName(data->ForceScan.Name);

    if (ciStringEqual(translationName, _sendAllPointsPointName))
    {
        if (isPortLoggingNotRestricted(*((Cti::Fdr::ServerConnection*)connection)) && getDebugLevel () & DATA_RECV_DEBUGLEVEL)
        {
            CTILOG_DEBUG(dout, "Submitting Scan Request to process. Translation Point: "<< translationName <<" on "<< connection->getName());
        }

        //Put an InitiateScan command on Dispatch inQueue, this will cause the send thread to build up the points to send
        std::auto_ptr<CtiCommandMsg> cmdMessage( new CtiCommandMsg(CtiCommandMsg::InitiateScan));
        CtiCommandMsg::OpArgList ops;
        ops.push_back(connection->getPortNumber());
        cmdMessage->setOpArgList(ops);
        iDispatchInQueue.putQueue( cmdMessage.release() );

        return ClientErrors::None;
    }
    else
    {
        if (isPortLoggingNotRestricted(*((Cti::Fdr::ServerConnection*)connection)) && getDebugLevel () & DATA_RECV_DEBUGLEVEL)
        {
            CTILOG_DEBUG(dout, "Ignored bad Scan Request for Translation Point: "<< translationName <<" on "<< connection->getName());
        }
    }
    return ClientErrors::None;
}

/**
  Process a SCADA control message (type 201)

  If the point is not found or not controllable log error message and return
  If StatusPointType,
    If invalid state, log error message and return
    If point name contains _scanDevicePointName,
      If state is closed, send ScanDeviceMessage to dispatch
    else send ControlRequest with -1 to dispatch
  If AnalogPointType,
    get the floating point value
    If point offset is 10001,
      Call ForeignToYukonStatus to determine State and ForeignToYukonStatus to determine value
    Send AnalogOutputMessage to dispatch
      
*/
bool CtiFDR_ValmetMulti::processControlMessage(Cti::Fdr::ServerConnection& connection,
                                         const char* aData, unsigned int size)
{
    int retVal = ClientErrors::None, quality = NormalQuality;
    CtiPointDataMsg *pData;
    ValmetExtendedInterface_t *data = (ValmetExtendedInterface_t*)aData;
    USHORT value = ntohs(data->Control.Value);
    CtiTime timestamp;
    string desc;
    CHAR action[60];

    // convert to our name
    string translationName = string (data->Control.Name);

    CtiFDRPointSPtr point = findFdrPointInPointList(translationName);

    if (point && point->isControllable())
    {
        if (point->getPointType() == StatusPointType)
        {
            int controlState=STATE_INVALID;
            controlState = ForeignToYukonStatus (data->Control.Value);

            if ((controlState != STATE_OPENED) && (controlState != STATE_CLOSED))
            {
                if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
                {
                    CTILOG_ERROR(dout, "Control point "<< translationName <<" from "<< getInterfaceName() <<
                            " has an invalid control state " << ntohs(data->Control.Value));
                }
                CHAR state[20];
                desc = getInterfaceName() + string (" control point received with an invalid state ") + string (itoa (ntohs(data->Control.Value),state,10));
                _snprintf(action,60,"%s for pointID %d",
                          translationName.c_str(),
                          point->getPointID());
                logEvent (desc,string (action));
                retVal = ClientErrors::Abnormal;
            }
            else
            {
                // build the command message and send the control
                CtiCommandMsg *cmdMsg = NULL;
                if (stringContainsIgnoreCase(translationName, _scanDevicePointName))
                {
                    if (controlState == STATE_CLOSED)
                    {
                        cmdMsg = createScanDeviceMessage(point->getPaoID(), translationName);
                    }
                }
                else
                {
                    cmdMsg = new CtiCommandMsg(CtiCommandMsg::ControlRequest);
                    cmdMsg->insert( -1 );                // This is the dispatch token and is unimplemented at this time
                    cmdMsg->insert(0);                   // device id, unknown at this point, dispatch will find it
                    cmdMsg->insert(point->getPointID());  // point for control
                    cmdMsg->insert(controlState);
                }
                if (cmdMsg)
                {
                    sendMessageToDispatch(cmdMsg);
                }

                if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_DEBUGLEVEL)
                {
                    CTILOG_DEBUG(dout, "Control point "<< translationName <<
                            (controlState == STATE_OPENED ? " control: Open " : " control: Closed ") <<
                            " from "<< getInterfaceName() <<" and processed for point " << point->getPointID());
                }
            }
        }
        else if (point->getPointType() == AnalogPointType)
        {
            double dValue = CtiFDRSocketInterface::ntohieeef(data->Control.LongValue);
            if (point->getPointOffset() == 10001)
            {
                int controlState=STATE_INVALID;
                controlState = ForeignToYukonStatus (data->Control.Value);
                dValue = ForeignToYukonStatus (data->Control.Value);
                if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_DEBUGLEVEL)
                {
                    CTILOG_DEBUG(dout, "Analog Output Point " << translationName <<" with PointOffset "<< point->getPointOffset() <<
                            " received value of c:" << controlState << " d: " << dValue);
                }
            }
            CtiCommandMsg *aoMsg = createAnalogOutputMessage(point->getPointID(), translationName, dValue);
            sendMessageToDispatch(aoMsg);
            if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_DEBUGLEVEL)
            {
                CTILOG_DEBUG(dout, "Analog Output point with pointOffset "<< point->getPointOffset() <<" "<< translationName<<
                        " value "<< dValue <<" from "<< getInterfaceName() <<" sending to device "<< point->getPaoID());
            }
        }
    }
    else
    {
        if (!point)
        {
            if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
            {
                CTILOG_ERROR(dout, "Translation for control point "<<  translationName <<" from "<< getInterfaceName() <<
                        " was not found");

                desc = getInterfaceName() + string (" control point is not listed in the translation table");
                _snprintf(action,60,"%s", translationName.c_str());
                logEvent (desc,string (action));
            }
        }
        else if (!point->isControllable())
        {
            if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
            {
                CTILOG_ERROR(dout, "Control point "<< translationName <<" received from "<< getInterfaceName() <<
                        " was not configured receive for control for point " << point->getPointID());

                desc = getInterfaceName() + string (" control point is not configured to receive controls");
                _snprintf(action,60,"%s for pointID %d",
                          translationName.c_str(),
                          point->getPointID());
                logEvent (desc,string (action));
            }
        }
        else
        {
            if (isPortLoggingNotRestricted(connection) && getDebugLevel () & DATA_RECV_ERR_DEBUGLEVEL)
            {
                CTILOG_ERROR(dout, "Control point "<< translationName <<" received from "<< getInterfaceName() <<
                        " was mapped to non-control point "<<  point->getPointID());

                CHAR pointID[20];
                desc = getInterfaceName() + string (" control point is incorrectly mapped to point ") + string (ltoa(point->getPointID(),pointID,10));
                _snprintf(action,60,"%s", translationName.c_str());
                logEvent (desc,string (action));
            }
        }
        retVal = ClientErrors::Abnormal;
    }

    return retVal;
}


void CtiFDR_ValmetMulti::updatePointQualitiesOnDevice(PointQuality_t quality, long paoId)
{
    if (getDebugLevel () & DETAIL_FDR_DEBUGLEVEL)
    {
        CTILOG_DEBUG(dout, "Updating All Point Qualities on Device with ID: "<< paoId <<" with Send Direction to Quality of "<< quality);
    }

    CtiFDRManager* mgrPtr = getSendToList().getPointList();
    CtiFDRManager::readerLock guard(mgrPtr->getLock());
    CtiFDRPointSPtr point;

    CtiLockGuard<CtiMutex> sendGuard(getSendToList().getMutex());
    CtiFDRManager::spiterator myIterator = mgrPtr->getMap().begin();

    for ( ; myIterator != mgrPtr->getMap().end(); ++myIterator )
    {
        // find the point id
        point = (*myIterator).second;

        if (point->getPaoID() == paoId && !point->isCommStatus() && point->getQuality() != quality)
        {
            CtiPointDataMsg* localMsg = new CtiPointDataMsg (point->getPointID(), point->getValue(), quality, point->getPointType());
            if (getDebugLevel () & DETAIL_FDR_DEBUGLEVEL)
            {
                CTILOG_DEBUG(dout, "Updating quality to: "<< quality <<" for PointId: "<<point->getPointID() <<" for "<< getInterfaceName() <<" interface.");
            }
            sendMessageToDispatch (localMsg);
        }
    }
}

bool CtiFDR_ValmetMulti::alwaysSendRegistrationPoints()
{
    return true;
}

void CtiFDR_ValmetMulti::threadListenerStartupMonitor( void )
{
    int refreshDelaySeconds = 5;
    CtiTime timeNow;
    CtiTime refreshTime = timeNow + refreshDelaySeconds;

    try
    {
        if (getDebugLevel () & CONNECTION_INFORMATION_DEBUGLEVEL)
        {
            CTILOG_DEBUG(dout, logNow() <<"Initializing threadListenerStartupMonitor");
        }

        for ( ; ; )
        {
            Cti::WorkerThread::sleepFor(Cti::Timing::Chrono::milliseconds(1000));

            timeNow = CtiTime();
            if (timeNow >= refreshTime)
            {
                startMultiListeners();
                refreshTime = timeNow + refreshDelaySeconds;
            }
        }
    }
    catch ( Cti::WorkerThread::Interrupted & )
    {
        CTILOG_INFO(dout, logNow() <<"threadListenerStartupMonitor shutdown");
    }
    catch ( ... ) // try and catch the thread death
    {
        CTILOG_UNKNOWN_EXCEPTION_ERROR(dout, logNow() <<"threadListenerStartupMonitor is dead!");
    }
}


/****************************************************************************************
*
*      Here Starts some C functions that are used to Start the
*      Interface and Stop it from the Main() of FDR.EXE.
*
*/

#ifdef __cplusplus
extern "C" {
#endif

/************************************************************************
* Function Name: Extern C int RunInterface(void)
*
* Description: This is used to Start the Interface from the Main()
*              of FDR.EXE. Each interface it Dynamicly loaded and
*              this function creates a global FDRCygnet Object and then
*              calls its run method to cank it up.
*
*************************************************************************
*/

    DLLEXPORT int RunInterface(void)
    {

        // make a point to the interface
        valmetMultiInterface = new CtiFDR_ValmetMulti();

        // now start it up
        return valmetMultiInterface->run();
    }

/************************************************************************
* Function Name: Extern C int StopInterface(void)
*
* Description: This is used to Stop the Interface from the Main()
*              of FDR.EXE. Each interface it Dynamicly loaded and
*              this function stops a global FDRCygnet Object and then
*              deletes it.
*
*************************************************************************
*/
    DLLEXPORT int StopInterface( void )
    {

        valmetMultiInterface->stop();
        delete valmetMultiInterface;
        valmetMultiInterface = 0;

        return 0;
    }


#ifdef __cplusplus
}
#endif



