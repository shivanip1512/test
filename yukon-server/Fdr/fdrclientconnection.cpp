#include "precompiled.h"
#include "logger.h"
#include "guard.h"

#include "fdrinterface.h"
#include "fdrsocketlayer.h"
#include "fdrclientconnection.h"
#include "fdrdebuglevel.h"
#include "socket_helper.h"
#include "win_helper.h"

using std::string;
using std::endl;

#pragma warning(push)
#pragma warning(disable:4355) // disable the warning generated by worker thread using "this" in constructor initializer List

CtiFDRClientConnection::CtiFDRClientConnection(const Cti::SocketAddress& aAddr, CtiFDRSocketLayer * aParent)
:   Inherited(aParent, aAddr),
    iThreadSend     (Cti::WorkerThread::Function(&CtiFDRClientConnection::threadFunctionSendDataTo,    this).name("sendDataTo")),
    iThreadHeartbeat(Cti::WorkerThread::Function(&CtiFDRClientConnection::threadFunctionSendHeartbeat, this).name("sendHeartbeat"))
{
    iQueueHandle = NULL;
}

CtiFDRClientConnection::CtiFDRClientConnection(SOCKET aSocket, CtiFDRSocketLayer * aParent)
:   Inherited(aParent),
    iThreadSend     (Cti::WorkerThread::Function(&CtiFDRClientConnection::threadFunctionSendDataTo,    this).name("sendDataTo")),
    iThreadHeartbeat(Cti::WorkerThread::Function(&CtiFDRClientConnection::threadFunctionSendHeartbeat, this).name("sendHeartbeat"))
{
    setConnection (aSocket);
    iQueueHandle = NULL;
}

#pragma warning(pop)

CtiFDRClientConnection::~CtiFDRClientConnection( )
{
}

HCTIQUEUE & CtiFDRClientConnection::getQueueHandle()
{
    return iQueueHandle;
}


int CtiFDRClientConnection::init ()
{
    // this will be true only if the client and server are using the same socket
    if ( getParent() && getParent()->getConnectionType() == CtiFDRSocketLayer::Server_Single )
    {
        return ClientErrors::None;
    }

    return initializeConnection( getAddr() );
}

int CtiFDRClientConnection::run ()
{
    iThreadSend.start();
    iThreadHeartbeat.start();

    return ClientErrors::None;
}

int CtiFDRClientConnection::stop ()
{
    closeAndFailConnection();

    iThreadSend.interrupt();
    iThreadHeartbeat.interrupt();

    iThreadSend.tryJoinOrTerminateFor(Cti::Timing::Chrono::seconds(10));
    iThreadHeartbeat.tryJoinOrTerminateFor(Cti::Timing::Chrono::seconds(10));

    return ClientErrors::None;
}


/**************************************************************************
* Function Name: CtiFDR_ACS::sendDataToACSThreadFunction( void )
*
* Description: thread accesses the socket to send data
*
***************************************************************************
*/
void CtiFDRClientConnection::threadFunctionSendDataTo( void )
{
    CHAR *buffer=NULL;
    ULONG bytesSent,bytesRead;
    UCHAR priority;
    int retVal = ClientErrors::None;
    int connectionBadCount=0;
    int outCount=0;

    try
    {
        // loop until parent exists
        while (getParent() == NULL)
        {
            Cti::WorkerThread::sleepFor(Cti::Timing::Chrono::milliseconds(250));
        }

        // Create the queue for handling incoming messages
        if (CreateQueue (&iQueueHandle))
        {
            CTILOG_ERROR(dout, "Unable to allocate space for "<< getParent()->getName() <<" out queue");
        }
        else
        {
            // loop until this is created
            while (getParent()->getConnectionSem() == NULL)
            {
                Cti::WorkerThread::sleepFor(Cti::Timing::Chrono::milliseconds(250));
            }

            if (getParent()->getConnectionSem() != NULL)
            {
                // we're ready to fly now
                setConnectionStatus(CtiFDRSocketConnection::Ok);

                if (getParent()->getDebugLevel () & DETAIL_FDR_DEBUGLEVEL)
                {
                    CTILOG_DEBUG(dout, "Initializing threadFunctionSendDataTo for "<< getParent()->getName());
                }

                // this will all non-control points to the foreign system
                int retFlag = getParent()->sendAllPoints();
                int dispatchErr=0;
                int notRegErr=0;

                while (retFlag)
                {
                    // loop until we get cancelled or this is successful
                    Cti::WorkerThread::interruptionPoint();

                    if (retFlag == FDR_NOT_CONNECTED_TO_DISPATCH)
                    {
                        dispatchErr++;
                        if (dispatchErr >= 20)
                        {
                            CTILOG_ERROR(dout, "Connection to dispatch is invalid - Unable to upload requested points to "<< getParent()->getName());
                            dispatchErr=0;
                        }
                    }
                    else if (retFlag == FDR_CLIENT_NOT_REGISTERED)
                    {
                        dispatchErr=0;
                        notRegErr++;
                        if (notRegErr >= 20)
                        {
                            CTILOG_ERROR(dout, "Client for "<< getParent()->getName() <<" has not registered - Unable to upload requested points");
                            notRegErr=0;
                        }
                    }
                    retFlag = getParent()->sendAllPoints();
                }


                // Now sit and wait for stuff to come in
                for (;;)
                {
                    Cti::WorkerThread::interruptionPoint();

                    bytesRead = 0;

                    const int queueReturn = ReadFrontElement(iQueueHandle, &bytesRead, (PVOID *) &buffer, DCWW_NOWAIT, &priority);

                    // only try to send if the connection is available
                    if (getConnectionStatus() ==  CtiFDRSocketConnection::Ok)
                    {
                        if (bytesRead == 0 && queueReturn != ERROR_QUE_EMPTY)
                        {
                            CTILOG_ERROR(dout, "Could not read "<< getParent()->getName() <<" out queue ("<< queueReturn <<")");
                        }
                        else if (queueReturn == ClientErrors::None)
                        {
                            Cti::WorkerThread::interruptionPoint();

                            if (getParent()->getDebugLevel() & DATA_SEND_DEBUGLEVEL)
                            {
                                Cti::StreamBuffer outLog;

                                outLog << "\nSending message to " << getAddr() << ":" << std::hex << std::setfill('0');

                                for (int i = 0; i < getParent()->getMessageSize(buffer); i++)
                                {
                                    outLog << " " << std::setw(2) << (unsigned)buffer[i];
                                }

                                CTILOG_INFO(dout, outLog);
                            }

                            retVal = writeSocket(buffer, getParent()->getMessageSize(buffer), bytesSent);
                            int lastError = WSAGetLastError();

                            // reset this every time through
                            connectionBadCount = 0;
                            outCount++;

                            // this where we re-initialize if needed
                            if (retVal == SOCKET_ERROR)
                            {
                                CTILOG_ERROR(dout, "writeSocket() failed - client "<< getParent()->getName() << 
                                    " at " <<  getAddr() << 
                                    ": error code=" << lastError);

                                // closes and marks as failed
                                closeAndFailConnection();


                                outCount=0;
                            }
                            else
                            {
                                if (outCount >= getParent()->getOutboundSendRate())
                                {
                                    //don't call sleep routine if nothing is set
                                    if (getParent()->getOutboundSendInterval())
                                    {
                                        CTILOG_WARN(dout, "Maximum throughput of " << getParent()->getOutboundSendRate() <<" entries per "<<
                                                getParent()->getOutboundSendInterval() << " second(s) reached, waiting one interval");

                                        Cti::WorkerThread::sleepFor(Cti::Timing::Chrono::milliseconds(getParent()->getOutboundSendInterval()*1000));
                                    }
                                    outCount =0;
                                }
                            }

                            // do this no matter what
//                            SetEvent (getParent()->getConnectionSem());
                        }
                        else
                        {
                            // nothing there, sleep and set the outcount
                            outCount=0;
                            Cti::WorkerThread::sleepFor(Cti::Timing::Chrono::milliseconds(50));
                        }
                    }
                    else
                    {
                        connectionBadCount++;
                        if (connectionBadCount >= 5)
                        {
                            closeAndFailConnection();
                            connectionBadCount = 0;
                        }
                        else
                        {
                            Cti::WorkerThread::sleepFor(Cti::Timing::Chrono::milliseconds(1000));
                        }
                    }
                    // free the memory of the stuff on the queue
                    delete []buffer;
                    buffer = NULL;
                }
            }
            else
            {
                CTILOG_ERROR(dout, "Unable to open connection semaphore for "<< getParent()->getName() <<" loading interface failed");
            }
        }
    }

    catch ( Cti::WorkerThread::Interrupted & )
    {
        CTILOG_INFO(dout, "CANCELLATION of threadFunctionSendDataTo for "<< getParent()->getName());
        CloseQueue (iQueueHandle);
    }

    // try and catch the thread death
    catch ( ... )
    {
        CTILOG_UNKNOWN_EXCEPTION_ERROR(dout, "threadFunctionSendDataTo for "<< getParent()->getName() <<" is dead!");
        CloseQueue (iQueueHandle);
    }

    return;
}

/**************************************************************************
* Function Name: CtiFDR_ACS::sendHeartbeatToACSThreadFunction( void )
*
* Description: thread that sends NULL messages to ACS
*
***************************************************************************
*/
void CtiFDRClientConnection::threadFunctionSendHeartbeat( void )
{
    CHAR *heartbeat=NULL;

    try
    {
        // loop until parent exists
        while (getParent() == NULL || iQueueHandle == NULL)
        {
            Cti::WorkerThread::sleepFor(Cti::Timing::Chrono::milliseconds(500));
        }

        if (getParent()->getDebugLevel () & DETAIL_FDR_DEBUGLEVEL)
        {
            CTILOG_DEBUG(dout, "Initializing threadFunctionSendHeartbeat for "<< getParent()->getName());
        }

        for ( ; ; )
        {
            Cti::WorkerThread::sleepFor(Cti::Timing::Chrono::milliseconds(10000));

            // check and make sure we're connected
            if (getConnectionStatus() ==  CtiFDRSocketConnection::Ok)
            {
                //Allocate the memory for message to whomever
                heartbeat = getParent()->buildForeignSystemHeartbeatMsg ();

                if (heartbeat != NULL)
                {
                    // Ship it to the TCP/IP interface thread
                    if (WriteQueue (iQueueHandle,
                                    0,
                                    getParent()->getMessageSize(heartbeat),
                                    heartbeat,
                                    MAXPRIORITY))
                    {
                        delete []heartbeat;
                        heartbeat = NULL;

                        if (getParent()->getDebugLevel () & MIN_DETAIL_FDR_DEBUGLEVEL)
                        {
                            CTILOG_DEBUG(dout, "Could not send heartbeat to "<< getParent()->getName() <<" at "<<  getAddr());
                        }
                    }
                    else
                    {
                        if (getParent()->getDebugLevel () & MIN_DETAIL_FDR_DEBUGLEVEL)
                        {
                            CTILOG_DEBUG(dout, "Sent heartbeat to "<< getParent()->getName() <<" at "<<  getAddr());
                        }
                    }
                }
            }
        }
    }

    catch ( Cti::WorkerThread::Interrupted & )
    {
        CTILOG_INFO(dout, "CANCELLATION of threadFunctionSendHeartbeat for "<< getParent()->getName());
    }
    // try and catch the thread death
    catch ( ... )
    {
        setConnectionStatus(CtiFDRSocketConnection::Failed);

        CTILOG_UNKNOWN_EXCEPTION_ERROR(dout, "threadFunctionSendHeartbeat for "<< getParent()->getName() <<" is dead!");
    }
}

int CtiFDRClientConnection::initializeConnection( const Cti::SocketAddress& aAddr )
{
    // do this so we have time to get shut down properly
    CTISleep (2000);

    // create a socket
    SOCKET tmpConnection = socket(aAddr._addr.sa.sa_family, SOCK_STREAM, IPPROTO_TCP);
    if( tmpConnection == INVALID_SOCKET )
    {
        int lastError = WSAGetLastError();
        CTILOG_ERROR(dout, "Invalid Socket: " << lastError);
        return SOCKET_ERROR;
    }

    BOOL ka=true;
    if( setsockopt(tmpConnection, SOL_SOCKET, SO_REUSEADDR, (char*)&ka, sizeof(BOOL) ))
    {
        int lastError = WSAGetLastError();
        CTILOG_ERROR(dout, "Failed sockopt: " << lastError);
        shutdown(tmpConnection, SD_BOTH);
        closesocket(tmpConnection);
        return SOCKET_ERROR;
    }

    DWORD v6only = 0;
    if (::setsockopt(tmpConnection, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&v6only, sizeof v6only) == SOCKET_ERROR)
    {
        int _lastError = WSAGetLastError();
        CTILOG_ERROR(dout, "Failed to set v6only" << aAddr );

        shutdown(tmpConnection, SD_BOTH);
        closesocket(tmpConnection);
        return SOCKET_ERROR;
    }

    const string hostIp = getParent()->getIpMask();
    if( hostIp != "" )
    {
        Cti::AddrInfo ai = Cti::makeTcpClientSocketAddress(hostIp, getParent()->getConnectPortNumber());
        if( !ai )
        {
            CTILOG_ERROR(dout, "Failed to resolve host IP: "<< hostIp <<" (Error: "<< ai.getError() <<")");

            shutdown(tmpConnection, SD_BOTH);
            closesocket(tmpConnection);
            return SOCKET_ERROR;
        }

        if( bind( tmpConnection, ai->ai_addr, ai->ai_addrlen ) == SOCKET_ERROR )
        {
            CTILOG_ERROR(dout, "Failed to bind to: "<< ai <<" (Error: "<< ai.getError() <<")");

            shutdown(tmpConnection, SD_BOTH);
            closesocket(tmpConnection);
            return SOCKET_ERROR;
        }

        CTILOG_INFO(dout, "Successful bind on the return connection to "<< ai);
    }

    CTILOG_DEBUG(dout, "Connecting to " << aAddr);
    if( connect( tmpConnection, &aAddr._addr.sa, aAddr._addrlen ) == SOCKET_ERROR )
    {
        int lastError = WSAGetLastError();
        CTILOG_ERROR(dout, "Failed to connect: " << lastError);
        shutdown(tmpConnection, SD_BOTH);
        closesocket(tmpConnection);
        return SOCKET_ERROR;
    }
    CTILOG_INFO(dout, "Successful connect to " << aAddr << " with socket " << tmpConnection);

    setConnection(tmpConnection);

    return ClientErrors::None;
}

INT CtiFDRClientConnection::writeSocket (CHAR *aBuffer, ULONG length, ULONG &aBytesWritten)
{
    ULONG    bytesAvailable  = 0;
    ULONG    bytesSent  = 0;
    INT      retVal             = ClientErrors::None;
    ULONG    totalByteCnt    = 0;

    aBytesWritten = 0;

    try
    {
        // send the data
        SOCKET socket = getConnection();
        while((bytesSent = send(socket, aBuffer, length, 0)) == SOCKET_ERROR &&
          WSAGetLastError() == WSAEWOULDBLOCK)
        {
            Sleep(0);   // surrender remaining timeslice to other threads
        }

        if (bytesSent == SOCKET_ERROR)
        {
            const DWORD error = WSAGetLastError();
            CTILOG_DEBUG(dout, "Socket " << socket << " send() failed with error code "<< error <<" / "<< Cti::getSystemErrorMessage(error));

            retVal =  SOCKET_ERROR;
        }
        else if( bytesSent != length)
        {
            const DWORD error = WSAGetLastError();
            CTILOG_DEBUG(dout, "Socket send() wrote "<< bytesSent <<" bytes, intended to write "<< length);

            retVal = SOCKET_ERROR;
        }
        else
        {
            aBytesWritten = bytesSent;
        }

    }
    catch ( ... )
    {
        CTILOG_UNKNOWN_EXCEPTION_ERROR(dout)
    }

    return retVal;
}

