/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef RfnMeterReadRequest_TYPES_H
#define RfnMeterReadRequest_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>
#include "NetworkManagerMessaging_types.h"
#include "RfnAddressing_types.h"
#include "Types_types.h"


namespace Cti { namespace Messaging { namespace Serialization { namespace Thrift {

struct RfnMeterReadingReplyType {
  enum type {
    OK = 0,
    NO_NODE = 1,
    NO_GATEWAY = 2,
    FAILURE = 3,
    TIMEOUT = 4
  };
};

extern const std::map<int, const char*> _RfnMeterReadingReplyType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const RfnMeterReadingReplyType::type& val);

std::string to_string(const RfnMeterReadingReplyType::type& val);

struct RfnMeterReadingDataReplyType {
  enum type {
    OK = 0,
    FAILURE = 1,
    NETWORK_TIMEOUT = 2,
    TIMEOUT = 3
  };
};

extern const std::map<int, const char*> _RfnMeterReadingDataReplyType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const RfnMeterReadingDataReplyType::type& val);

std::string to_string(const RfnMeterReadingDataReplyType::type& val);

struct ChannelDataStatus {
  enum type {
    OK = 0,
    PARTIAL_READ_TIMEOUT = 1,
    PARTIAL_READ_FAILURE = 2,
    PARTIAL_READ_LONG = 3,
    FULL_READ_PASSWORD_ERROR = 4,
    FULL_READ_BUSY_ERROR = 5,
    FULL_READ_TIMEOUT_ERROR = 6,
    FULL_READ_PROTOCOL_ERROR = 7,
    FULL_READ_NO_SUCH_CHANNEL_ERROR = 8,
    FULL_READ_READ_RESPONSE_ERROR_UNKNOWN = 9,
    FULL_READ_UNKNOWN = 10,
    FAILURE = 11
  };
};

extern const std::map<int, const char*> _ChannelDataStatus_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ChannelDataStatus::type& val);

std::string to_string(const ChannelDataStatus::type& val);

class RfnMeterReadRequest;

class RfnMeterReadReply;

class ChannelData;

class DatedChannelData;

class RfnMeterReadingData;

class RfnMeterReadDataReply;


class RfnMeterReadRequest : public virtual ::apache::thrift::TBase {
 public:

  RfnMeterReadRequest(const RfnMeterReadRequest&);
  RfnMeterReadRequest& operator=(const RfnMeterReadRequest&);
  RfnMeterReadRequest() noexcept {
  }

  virtual ~RfnMeterReadRequest() noexcept;
   ::Cti::Messaging::Serialization::Thrift::Rfn::RfnIdentifier rfnIdentifier;

  void __set_rfnIdentifier(const  ::Cti::Messaging::Serialization::Thrift::Rfn::RfnIdentifier& val);

  bool operator == (const RfnMeterReadRequest & rhs) const
  {
    if (!(rfnIdentifier == rhs.rfnIdentifier))
      return false;
    return true;
  }
  bool operator != (const RfnMeterReadRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RfnMeterReadRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RfnMeterReadRequest &a, RfnMeterReadRequest &b);

std::ostream& operator<<(std::ostream& out, const RfnMeterReadRequest& obj);


class RfnMeterReadReply : public virtual ::apache::thrift::TBase {
 public:

  RfnMeterReadReply(const RfnMeterReadReply&) noexcept;
  RfnMeterReadReply& operator=(const RfnMeterReadReply&) noexcept;
  RfnMeterReadReply() noexcept
                    : replyType(static_cast<RfnMeterReadingReplyType::type>(0)) {
  }

  virtual ~RfnMeterReadReply() noexcept;
  /**
   * 
   * @see RfnMeterReadingReplyType
   */
  RfnMeterReadingReplyType::type replyType;

  void __set_replyType(const RfnMeterReadingReplyType::type val);

  bool operator == (const RfnMeterReadReply & rhs) const
  {
    if (!(replyType == rhs.replyType))
      return false;
    return true;
  }
  bool operator != (const RfnMeterReadReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RfnMeterReadReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RfnMeterReadReply &a, RfnMeterReadReply &b);

std::ostream& operator<<(std::ostream& out, const RfnMeterReadReply& obj);


class ChannelData : public virtual ::apache::thrift::TBase {
 public:

  ChannelData(const ChannelData&);
  ChannelData& operator=(const ChannelData&);
  ChannelData() noexcept
              : channelNumber(0),
                status(static_cast<ChannelDataStatus::type>(0)),
                unitOfMeasure(),
                value(0) {
  }

  virtual ~ChannelData() noexcept;
  int32_t channelNumber;
  /**
   * 
   * @see ChannelDataStatus
   */
  ChannelDataStatus::type status;
  std::string unitOfMeasure;
  std::set<std::string>  unitOfMeasureModifiers;
  double value;

  void __set_channelNumber(const int32_t val);

  void __set_status(const ChannelDataStatus::type val);

  void __set_unitOfMeasure(const std::string& val);

  void __set_unitOfMeasureModifiers(const std::set<std::string> & val);

  void __set_value(const double val);

  bool operator == (const ChannelData & rhs) const
  {
    if (!(channelNumber == rhs.channelNumber))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(unitOfMeasure == rhs.unitOfMeasure))
      return false;
    if (!(unitOfMeasureModifiers == rhs.unitOfMeasureModifiers))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const ChannelData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ChannelData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(ChannelData &a, ChannelData &b);

std::ostream& operator<<(std::ostream& out, const ChannelData& obj);

typedef struct _DatedChannelData__isset {
  _DatedChannelData__isset() : baseChannelData(false) {}
  bool baseChannelData :1;
} _DatedChannelData__isset;

class DatedChannelData : public virtual ::apache::thrift::TBase {
 public:

  DatedChannelData(const DatedChannelData&);
  DatedChannelData& operator=(const DatedChannelData&);
  DatedChannelData() noexcept
                   : timeStamp(0) {
  }

  virtual ~DatedChannelData() noexcept;
  ChannelData channelData;
   ::Cti::Messaging::Serialization::Thrift::Timestamp timeStamp;
  ChannelData baseChannelData;

  _DatedChannelData__isset __isset;

  void __set_channelData(const ChannelData& val);

  void __set_timeStamp(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set_baseChannelData(const ChannelData& val);

  bool operator == (const DatedChannelData & rhs) const
  {
    if (!(channelData == rhs.channelData))
      return false;
    if (!(timeStamp == rhs.timeStamp))
      return false;
    if (__isset.baseChannelData != rhs.__isset.baseChannelData)
      return false;
    else if (__isset.baseChannelData && !(baseChannelData == rhs.baseChannelData))
      return false;
    return true;
  }
  bool operator != (const DatedChannelData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DatedChannelData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(DatedChannelData &a, DatedChannelData &b);

std::ostream& operator<<(std::ostream& out, const DatedChannelData& obj);


class RfnMeterReadingData : public virtual ::apache::thrift::TBase {
 public:

  RfnMeterReadingData(const RfnMeterReadingData&);
  RfnMeterReadingData& operator=(const RfnMeterReadingData&);
  RfnMeterReadingData() noexcept
                      : timeStamp(0),
                        recordInterval(0) {
  }

  virtual ~RfnMeterReadingData() noexcept;
  std::vector<ChannelData>  channelDataList;
  std::vector<DatedChannelData>  datedChannelDataList;
   ::Cti::Messaging::Serialization::Thrift::Rfn::RfnIdentifier rfnIdentifier;
   ::Cti::Messaging::Serialization::Thrift::Timestamp timeStamp;
  int32_t recordInterval;

  void __set_channelDataList(const std::vector<ChannelData> & val);

  void __set_datedChannelDataList(const std::vector<DatedChannelData> & val);

  void __set_rfnIdentifier(const  ::Cti::Messaging::Serialization::Thrift::Rfn::RfnIdentifier& val);

  void __set_timeStamp(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set_recordInterval(const int32_t val);

  bool operator == (const RfnMeterReadingData & rhs) const
  {
    if (!(channelDataList == rhs.channelDataList))
      return false;
    if (!(datedChannelDataList == rhs.datedChannelDataList))
      return false;
    if (!(rfnIdentifier == rhs.rfnIdentifier))
      return false;
    if (!(timeStamp == rhs.timeStamp))
      return false;
    if (!(recordInterval == rhs.recordInterval))
      return false;
    return true;
  }
  bool operator != (const RfnMeterReadingData &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RfnMeterReadingData & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RfnMeterReadingData &a, RfnMeterReadingData &b);

std::ostream& operator<<(std::ostream& out, const RfnMeterReadingData& obj);


class RfnMeterReadDataReply : public virtual ::apache::thrift::TBase {
 public:

  RfnMeterReadDataReply(const RfnMeterReadDataReply&);
  RfnMeterReadDataReply& operator=(const RfnMeterReadDataReply&);
  RfnMeterReadDataReply() noexcept
                        : replyType(static_cast<RfnMeterReadingDataReplyType::type>(0)) {
  }

  virtual ~RfnMeterReadDataReply() noexcept;
  /**
   * 
   * @see RfnMeterReadingDataReplyType
   */
  RfnMeterReadingDataReplyType::type replyType;
  RfnMeterReadingData data;

  void __set_replyType(const RfnMeterReadingDataReplyType::type val);

  void __set_data(const RfnMeterReadingData& val);

  bool operator == (const RfnMeterReadDataReply & rhs) const
  {
    if (!(replyType == rhs.replyType))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const RfnMeterReadDataReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RfnMeterReadDataReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(RfnMeterReadDataReply &a, RfnMeterReadDataReply &b);

std::ostream& operator<<(std::ostream& out, const RfnMeterReadDataReply& obj);

}}}} // namespace

#endif
