/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef LMControlAreas_TYPES_H
#define LMControlAreas_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "LMMessage_types.h"
#include "Types_types.h"
#include "Message_types.h"


namespace Cti { namespace Messaging { namespace Serialization { namespace Thrift {


class LMControlAreaTrigger {
 public:

  static const char* ascii_fingerprint; // = "454A9949A527079F620E4A94BB826575";
  static const uint8_t binary_fingerprint[16]; // = {0x45,0x4A,0x99,0x49,0xA5,0x27,0x07,0x9F,0x62,0x0E,0x4A,0x94,0xBB,0x82,0x65,0x75};

  LMControlAreaTrigger() : _paoId(0), _triggerNumber(0), _triggerType(), _pointId(0), _pointValue(0), _lastPointValueTimestamp(0), _normalState(0), _threshold(0), _projectionType(), _projectionPoints(0), _projectAheadDuration(0), _thresholdKickPercent(0), _minRestoreOffset(0), _peakPointId(0), _peakPointValue(0), _lastPeakPointValueTimestamp(0), _projectedPointValue(0) {
  }

  virtual ~LMControlAreaTrigger() throw() {}

  int32_t _paoId;
  int32_t _triggerNumber;
  std::string _triggerType;
  int32_t _pointId;
  double _pointValue;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _lastPointValueTimestamp;
  int32_t _normalState;
  double _threshold;
  std::string _projectionType;
  int32_t _projectionPoints;
  int32_t _projectAheadDuration;
  int32_t _thresholdKickPercent;
  double _minRestoreOffset;
  int32_t _peakPointId;
  double _peakPointValue;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _lastPeakPointValueTimestamp;
  double _projectedPointValue;

  void __set__paoId(const int32_t val) {
    _paoId = val;
  }

  void __set__triggerNumber(const int32_t val) {
    _triggerNumber = val;
  }

  void __set__triggerType(const std::string& val) {
    _triggerType = val;
  }

  void __set__pointId(const int32_t val) {
    _pointId = val;
  }

  void __set__pointValue(const double val) {
    _pointValue = val;
  }

  void __set__lastPointValueTimestamp(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _lastPointValueTimestamp = val;
  }

  void __set__normalState(const int32_t val) {
    _normalState = val;
  }

  void __set__threshold(const double val) {
    _threshold = val;
  }

  void __set__projectionType(const std::string& val) {
    _projectionType = val;
  }

  void __set__projectionPoints(const int32_t val) {
    _projectionPoints = val;
  }

  void __set__projectAheadDuration(const int32_t val) {
    _projectAheadDuration = val;
  }

  void __set__thresholdKickPercent(const int32_t val) {
    _thresholdKickPercent = val;
  }

  void __set__minRestoreOffset(const double val) {
    _minRestoreOffset = val;
  }

  void __set__peakPointId(const int32_t val) {
    _peakPointId = val;
  }

  void __set__peakPointValue(const double val) {
    _peakPointValue = val;
  }

  void __set__lastPeakPointValueTimestamp(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _lastPeakPointValueTimestamp = val;
  }

  void __set__projectedPointValue(const double val) {
    _projectedPointValue = val;
  }

  bool operator == (const LMControlAreaTrigger & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_triggerNumber == rhs._triggerNumber))
      return false;
    if (!(_triggerType == rhs._triggerType))
      return false;
    if (!(_pointId == rhs._pointId))
      return false;
    if (!(_pointValue == rhs._pointValue))
      return false;
    if (!(_lastPointValueTimestamp == rhs._lastPointValueTimestamp))
      return false;
    if (!(_normalState == rhs._normalState))
      return false;
    if (!(_threshold == rhs._threshold))
      return false;
    if (!(_projectionType == rhs._projectionType))
      return false;
    if (!(_projectionPoints == rhs._projectionPoints))
      return false;
    if (!(_projectAheadDuration == rhs._projectAheadDuration))
      return false;
    if (!(_thresholdKickPercent == rhs._thresholdKickPercent))
      return false;
    if (!(_minRestoreOffset == rhs._minRestoreOffset))
      return false;
    if (!(_peakPointId == rhs._peakPointId))
      return false;
    if (!(_peakPointValue == rhs._peakPointValue))
      return false;
    if (!(_lastPeakPointValueTimestamp == rhs._lastPeakPointValueTimestamp))
      return false;
    if (!(_projectedPointValue == rhs._projectedPointValue))
      return false;
    return true;
  }
  bool operator != (const LMControlAreaTrigger &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMControlAreaTrigger & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMControlAreaTrigger &a, LMControlAreaTrigger &b);


class LMProgramControlWindow {
 public:

  static const char* ascii_fingerprint; // = "154BB42C2FFD70F8B3993568C50C5613";
  static const uint8_t binary_fingerprint[16]; // = {0x15,0x4B,0xB4,0x2C,0x2F,0xFD,0x70,0xF8,0xB3,0x99,0x35,0x68,0xC5,0x0C,0x56,0x13};

  LMProgramControlWindow() : _paoId(0), _windowNumber(0), _availableStartTime(0), _availableStopTime(0) {
  }

  virtual ~LMProgramControlWindow() throw() {}

  int32_t _paoId;
  int32_t _windowNumber;
  int32_t _availableStartTime;
  int32_t _availableStopTime;

  void __set__paoId(const int32_t val) {
    _paoId = val;
  }

  void __set__windowNumber(const int32_t val) {
    _windowNumber = val;
  }

  void __set__availableStartTime(const int32_t val) {
    _availableStartTime = val;
  }

  void __set__availableStopTime(const int32_t val) {
    _availableStopTime = val;
  }

  bool operator == (const LMProgramControlWindow & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_windowNumber == rhs._windowNumber))
      return false;
    if (!(_availableStartTime == rhs._availableStartTime))
      return false;
    if (!(_availableStopTime == rhs._availableStopTime))
      return false;
    return true;
  }
  bool operator != (const LMProgramControlWindow &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramControlWindow & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMProgramControlWindow &a, LMProgramControlWindow &b);


class LMProgramBase {
 public:

  static const char* ascii_fingerprint; // = "C5DDBAA440426BAE0AE85F865C145A96";
  static const uint8_t binary_fingerprint[16]; // = {0xC5,0xDD,0xBA,0xA4,0x40,0x42,0x6B,0xAE,0x0A,0xE8,0x5F,0x86,0x5C,0x14,0x5A,0x96};

  LMProgramBase() : _paoId(0), _paoCategory(), _paoClass(), _paoName(), _paoTypeString(), _paoDescription(), _disableFlag(0), _startPriority(0), _stopPriority(0), _controlType(), _availableWeekdays(), _maxHoursDaily(0), _maxHoursMonthly(0), _maxHoursSeasonal(0), _maxHoursAnnually(0), _minActivateTime(0), _minRestartTime(0), _programStatusPointId(0), _programState(0), _reductionAnalogPointId(0), _reductionTotal(0), _startedControlling(0), _lastControlSent(0), _manualControlReceivedFlag(0) {
  }

  virtual ~LMProgramBase() throw() {}

  int32_t _paoId;
  std::string _paoCategory;
  std::string _paoClass;
  std::string _paoName;
  std::string _paoTypeString;
  std::string _paoDescription;
  bool _disableFlag;
  int32_t _startPriority;
  int32_t _stopPriority;
  std::string _controlType;
  std::string _availableWeekdays;
  int32_t _maxHoursDaily;
  int32_t _maxHoursMonthly;
  int32_t _maxHoursSeasonal;
  int32_t _maxHoursAnnually;
  int32_t _minActivateTime;
  int32_t _minRestartTime;
  int32_t _programStatusPointId;
  int32_t _programState;
  int32_t _reductionAnalogPointId;
  double _reductionTotal;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _startedControlling;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _lastControlSent;
  bool _manualControlReceivedFlag;
  std::vector<LMProgramControlWindow>  _lmProgramControlWindows;

  void __set__paoId(const int32_t val) {
    _paoId = val;
  }

  void __set__paoCategory(const std::string& val) {
    _paoCategory = val;
  }

  void __set__paoClass(const std::string& val) {
    _paoClass = val;
  }

  void __set__paoName(const std::string& val) {
    _paoName = val;
  }

  void __set__paoTypeString(const std::string& val) {
    _paoTypeString = val;
  }

  void __set__paoDescription(const std::string& val) {
    _paoDescription = val;
  }

  void __set__disableFlag(const bool val) {
    _disableFlag = val;
  }

  void __set__startPriority(const int32_t val) {
    _startPriority = val;
  }

  void __set__stopPriority(const int32_t val) {
    _stopPriority = val;
  }

  void __set__controlType(const std::string& val) {
    _controlType = val;
  }

  void __set__availableWeekdays(const std::string& val) {
    _availableWeekdays = val;
  }

  void __set__maxHoursDaily(const int32_t val) {
    _maxHoursDaily = val;
  }

  void __set__maxHoursMonthly(const int32_t val) {
    _maxHoursMonthly = val;
  }

  void __set__maxHoursSeasonal(const int32_t val) {
    _maxHoursSeasonal = val;
  }

  void __set__maxHoursAnnually(const int32_t val) {
    _maxHoursAnnually = val;
  }

  void __set__minActivateTime(const int32_t val) {
    _minActivateTime = val;
  }

  void __set__minRestartTime(const int32_t val) {
    _minRestartTime = val;
  }

  void __set__programStatusPointId(const int32_t val) {
    _programStatusPointId = val;
  }

  void __set__programState(const int32_t val) {
    _programState = val;
  }

  void __set__reductionAnalogPointId(const int32_t val) {
    _reductionAnalogPointId = val;
  }

  void __set__reductionTotal(const double val) {
    _reductionTotal = val;
  }

  void __set__startedControlling(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _startedControlling = val;
  }

  void __set__lastControlSent(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _lastControlSent = val;
  }

  void __set__manualControlReceivedFlag(const bool val) {
    _manualControlReceivedFlag = val;
  }

  void __set__lmProgramControlWindows(const std::vector<LMProgramControlWindow> & val) {
    _lmProgramControlWindows = val;
  }

  bool operator == (const LMProgramBase & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_paoCategory == rhs._paoCategory))
      return false;
    if (!(_paoClass == rhs._paoClass))
      return false;
    if (!(_paoName == rhs._paoName))
      return false;
    if (!(_paoTypeString == rhs._paoTypeString))
      return false;
    if (!(_paoDescription == rhs._paoDescription))
      return false;
    if (!(_disableFlag == rhs._disableFlag))
      return false;
    if (!(_startPriority == rhs._startPriority))
      return false;
    if (!(_stopPriority == rhs._stopPriority))
      return false;
    if (!(_controlType == rhs._controlType))
      return false;
    if (!(_availableWeekdays == rhs._availableWeekdays))
      return false;
    if (!(_maxHoursDaily == rhs._maxHoursDaily))
      return false;
    if (!(_maxHoursMonthly == rhs._maxHoursMonthly))
      return false;
    if (!(_maxHoursSeasonal == rhs._maxHoursSeasonal))
      return false;
    if (!(_maxHoursAnnually == rhs._maxHoursAnnually))
      return false;
    if (!(_minActivateTime == rhs._minActivateTime))
      return false;
    if (!(_minRestartTime == rhs._minRestartTime))
      return false;
    if (!(_programStatusPointId == rhs._programStatusPointId))
      return false;
    if (!(_programState == rhs._programState))
      return false;
    if (!(_reductionAnalogPointId == rhs._reductionAnalogPointId))
      return false;
    if (!(_reductionTotal == rhs._reductionTotal))
      return false;
    if (!(_startedControlling == rhs._startedControlling))
      return false;
    if (!(_lastControlSent == rhs._lastControlSent))
      return false;
    if (!(_manualControlReceivedFlag == rhs._manualControlReceivedFlag))
      return false;
    if (!(_lmProgramControlWindows == rhs._lmProgramControlWindows))
      return false;
    return true;
  }
  bool operator != (const LMProgramBase &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramBase & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMProgramBase &a, LMProgramBase &b);


class LMCICustomerBase {
 public:

  static const char* ascii_fingerprint; // = "58BC68BB8ED6F2C9501D266941763CCF";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0xBC,0x68,0xBB,0x8E,0xD6,0xF2,0xC9,0x50,0x1D,0x26,0x69,0x41,0x76,0x3C,0xCF};

  LMCICustomerBase() : _customerId(0), _companyName(), _customerDemandLevel(0), _curtailAmount(0), _curtailmentAgreement(), _timeZone(), _customerOrder(0) {
  }

  virtual ~LMCICustomerBase() throw() {}

  int32_t _customerId;
  std::string _companyName;
  double _customerDemandLevel;
  double _curtailAmount;
  std::string _curtailmentAgreement;
  std::string _timeZone;
  int32_t _customerOrder;

  void __set__customerId(const int32_t val) {
    _customerId = val;
  }

  void __set__companyName(const std::string& val) {
    _companyName = val;
  }

  void __set__customerDemandLevel(const double val) {
    _customerDemandLevel = val;
  }

  void __set__curtailAmount(const double val) {
    _curtailAmount = val;
  }

  void __set__curtailmentAgreement(const std::string& val) {
    _curtailmentAgreement = val;
  }

  void __set__timeZone(const std::string& val) {
    _timeZone = val;
  }

  void __set__customerOrder(const int32_t val) {
    _customerOrder = val;
  }

  bool operator == (const LMCICustomerBase & rhs) const
  {
    if (!(_customerId == rhs._customerId))
      return false;
    if (!(_companyName == rhs._companyName))
      return false;
    if (!(_customerDemandLevel == rhs._customerDemandLevel))
      return false;
    if (!(_curtailAmount == rhs._curtailAmount))
      return false;
    if (!(_curtailmentAgreement == rhs._curtailmentAgreement))
      return false;
    if (!(_timeZone == rhs._timeZone))
      return false;
    if (!(_customerOrder == rhs._customerOrder))
      return false;
    return true;
  }
  bool operator != (const LMCICustomerBase &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMCICustomerBase & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMCICustomerBase &a, LMCICustomerBase &b);


class LMCurtailCustomer {
 public:

  static const char* ascii_fingerprint; // = "0110D087F2E3DEAA55387A5EA1DBD95D";
  static const uint8_t binary_fingerprint[16]; // = {0x01,0x10,0xD0,0x87,0xF2,0xE3,0xDE,0xAA,0x55,0x38,0x7A,0x5E,0xA1,0xDB,0xD9,0x5D};

  LMCurtailCustomer() : _requireAck(0), _curtailReferenceId(0), _acknowledgeStatus(), _ackDatetime(0), _ipAddressOfAckUser(), _userIdName(), _nameOfAckPerson(), _curtailmentNotes(), _ackLateFlag(0) {
  }

  virtual ~LMCurtailCustomer() throw() {}

  LMCICustomerBase _baseMessage;
  bool _requireAck;
  int32_t _curtailReferenceId;
  std::string _acknowledgeStatus;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _ackDatetime;
  std::string _ipAddressOfAckUser;
  std::string _userIdName;
  std::string _nameOfAckPerson;
  std::string _curtailmentNotes;
  bool _ackLateFlag;

  void __set__baseMessage(const LMCICustomerBase& val) {
    _baseMessage = val;
  }

  void __set__requireAck(const bool val) {
    _requireAck = val;
  }

  void __set__curtailReferenceId(const int32_t val) {
    _curtailReferenceId = val;
  }

  void __set__acknowledgeStatus(const std::string& val) {
    _acknowledgeStatus = val;
  }

  void __set__ackDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _ackDatetime = val;
  }

  void __set__ipAddressOfAckUser(const std::string& val) {
    _ipAddressOfAckUser = val;
  }

  void __set__userIdName(const std::string& val) {
    _userIdName = val;
  }

  void __set__nameOfAckPerson(const std::string& val) {
    _nameOfAckPerson = val;
  }

  void __set__curtailmentNotes(const std::string& val) {
    _curtailmentNotes = val;
  }

  void __set__ackLateFlag(const bool val) {
    _ackLateFlag = val;
  }

  bool operator == (const LMCurtailCustomer & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_requireAck == rhs._requireAck))
      return false;
    if (!(_curtailReferenceId == rhs._curtailReferenceId))
      return false;
    if (!(_acknowledgeStatus == rhs._acknowledgeStatus))
      return false;
    if (!(_ackDatetime == rhs._ackDatetime))
      return false;
    if (!(_ipAddressOfAckUser == rhs._ipAddressOfAckUser))
      return false;
    if (!(_userIdName == rhs._userIdName))
      return false;
    if (!(_nameOfAckPerson == rhs._nameOfAckPerson))
      return false;
    if (!(_curtailmentNotes == rhs._curtailmentNotes))
      return false;
    if (!(_ackLateFlag == rhs._ackLateFlag))
      return false;
    return true;
  }
  bool operator != (const LMCurtailCustomer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMCurtailCustomer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMCurtailCustomer &a, LMCurtailCustomer &b);


class LMProgramCurtailment {
 public:

  static const char* ascii_fingerprint; // = "E46755CB82FBDECB7F768B7045215B6B";
  static const uint8_t binary_fingerprint[16]; // = {0xE4,0x67,0x55,0xCB,0x82,0xFB,0xDE,0xCB,0x7F,0x76,0x8B,0x70,0x45,0x21,0x5B,0x6B};

  LMProgramCurtailment() : _minNotifyTime(0), _heading(), _messageHeader(), _messageFooter(), _acktimeLimit(0), _canceledMsg(), _stoppedEarlyMsg(), _curtailReferenceId(0), _actionDateTime(0), _notificationDateTime(0), _curtailmentStartTime(0), _curtailmentStopTime(0), _runStatus(), _additionalInfo() {
  }

  virtual ~LMProgramCurtailment() throw() {}

  LMProgramBase _baseMessage;
  int32_t _minNotifyTime;
  std::string _heading;
  std::string _messageHeader;
  std::string _messageFooter;
  int32_t _acktimeLimit;
  std::string _canceledMsg;
  std::string _stoppedEarlyMsg;
  int32_t _curtailReferenceId;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _actionDateTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _notificationDateTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _curtailmentStartTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _curtailmentStopTime;
  std::string _runStatus;
  std::string _additionalInfo;
  std::vector<LMCurtailCustomer>  _lmProgramCurtailmentCustomers;

  void __set__baseMessage(const LMProgramBase& val) {
    _baseMessage = val;
  }

  void __set__minNotifyTime(const int32_t val) {
    _minNotifyTime = val;
  }

  void __set__heading(const std::string& val) {
    _heading = val;
  }

  void __set__messageHeader(const std::string& val) {
    _messageHeader = val;
  }

  void __set__messageFooter(const std::string& val) {
    _messageFooter = val;
  }

  void __set__acktimeLimit(const int32_t val) {
    _acktimeLimit = val;
  }

  void __set__canceledMsg(const std::string& val) {
    _canceledMsg = val;
  }

  void __set__stoppedEarlyMsg(const std::string& val) {
    _stoppedEarlyMsg = val;
  }

  void __set__curtailReferenceId(const int32_t val) {
    _curtailReferenceId = val;
  }

  void __set__actionDateTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _actionDateTime = val;
  }

  void __set__notificationDateTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _notificationDateTime = val;
  }

  void __set__curtailmentStartTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _curtailmentStartTime = val;
  }

  void __set__curtailmentStopTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _curtailmentStopTime = val;
  }

  void __set__runStatus(const std::string& val) {
    _runStatus = val;
  }

  void __set__additionalInfo(const std::string& val) {
    _additionalInfo = val;
  }

  void __set__lmProgramCurtailmentCustomers(const std::vector<LMCurtailCustomer> & val) {
    _lmProgramCurtailmentCustomers = val;
  }

  bool operator == (const LMProgramCurtailment & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_minNotifyTime == rhs._minNotifyTime))
      return false;
    if (!(_heading == rhs._heading))
      return false;
    if (!(_messageHeader == rhs._messageHeader))
      return false;
    if (!(_messageFooter == rhs._messageFooter))
      return false;
    if (!(_acktimeLimit == rhs._acktimeLimit))
      return false;
    if (!(_canceledMsg == rhs._canceledMsg))
      return false;
    if (!(_stoppedEarlyMsg == rhs._stoppedEarlyMsg))
      return false;
    if (!(_curtailReferenceId == rhs._curtailReferenceId))
      return false;
    if (!(_actionDateTime == rhs._actionDateTime))
      return false;
    if (!(_notificationDateTime == rhs._notificationDateTime))
      return false;
    if (!(_curtailmentStartTime == rhs._curtailmentStartTime))
      return false;
    if (!(_curtailmentStopTime == rhs._curtailmentStopTime))
      return false;
    if (!(_runStatus == rhs._runStatus))
      return false;
    if (!(_additionalInfo == rhs._additionalInfo))
      return false;
    if (!(_lmProgramCurtailmentCustomers == rhs._lmProgramCurtailmentCustomers))
      return false;
    return true;
  }
  bool operator != (const LMProgramCurtailment &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramCurtailment & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMProgramCurtailment &a, LMProgramCurtailment &b);


class LMProgramDirectGear {
 public:

  static const char* ascii_fingerprint; // = "21E3D3CE07034F2210BB937B516EB23A";
  static const uint8_t binary_fingerprint[16]; // = {0x21,0xE3,0xD3,0xCE,0x07,0x03,0x4F,0x22,0x10,0xBB,0x93,0x7B,0x51,0x6E,0xB2,0x3A};

  LMProgramDirectGear() : _programPaoId(0), _gearName(), _gearNumber(0), _controlMethod(), _methodRate(0), _methodPeriod(0), _methodRateCount(0), _cyclereFreshRate(0), _methodStopType(), _changeCondition(), _changeDuration(0), _changePriority(0), _changeTriggerNumber(0), _changeTriggerOffset(0), _percentReduction(0), _groupSelectionMethod(), _methodOptionType(), _methodOptionMax(0), _rampInInterval(0), _rampInPercent(0), _rampOutInterval(0), _rampOutPercent(0), _kwReduction(0) {
  }

  virtual ~LMProgramDirectGear() throw() {}

  int32_t _programPaoId;
  std::string _gearName;
  int32_t _gearNumber;
  std::string _controlMethod;
  int32_t _methodRate;
  int32_t _methodPeriod;
  int32_t _methodRateCount;
  int32_t _cyclereFreshRate;
  std::string _methodStopType;
  std::string _changeCondition;
  int32_t _changeDuration;
  int32_t _changePriority;
  int32_t _changeTriggerNumber;
  double _changeTriggerOffset;
  int32_t _percentReduction;
  std::string _groupSelectionMethod;
  std::string _methodOptionType;
  int32_t _methodOptionMax;
  int32_t _rampInInterval;
  int32_t _rampInPercent;
  int32_t _rampOutInterval;
  int32_t _rampOutPercent;
  double _kwReduction;

  void __set__programPaoId(const int32_t val) {
    _programPaoId = val;
  }

  void __set__gearName(const std::string& val) {
    _gearName = val;
  }

  void __set__gearNumber(const int32_t val) {
    _gearNumber = val;
  }

  void __set__controlMethod(const std::string& val) {
    _controlMethod = val;
  }

  void __set__methodRate(const int32_t val) {
    _methodRate = val;
  }

  void __set__methodPeriod(const int32_t val) {
    _methodPeriod = val;
  }

  void __set__methodRateCount(const int32_t val) {
    _methodRateCount = val;
  }

  void __set__cyclereFreshRate(const int32_t val) {
    _cyclereFreshRate = val;
  }

  void __set__methodStopType(const std::string& val) {
    _methodStopType = val;
  }

  void __set__changeCondition(const std::string& val) {
    _changeCondition = val;
  }

  void __set__changeDuration(const int32_t val) {
    _changeDuration = val;
  }

  void __set__changePriority(const int32_t val) {
    _changePriority = val;
  }

  void __set__changeTriggerNumber(const int32_t val) {
    _changeTriggerNumber = val;
  }

  void __set__changeTriggerOffset(const double val) {
    _changeTriggerOffset = val;
  }

  void __set__percentReduction(const int32_t val) {
    _percentReduction = val;
  }

  void __set__groupSelectionMethod(const std::string& val) {
    _groupSelectionMethod = val;
  }

  void __set__methodOptionType(const std::string& val) {
    _methodOptionType = val;
  }

  void __set__methodOptionMax(const int32_t val) {
    _methodOptionMax = val;
  }

  void __set__rampInInterval(const int32_t val) {
    _rampInInterval = val;
  }

  void __set__rampInPercent(const int32_t val) {
    _rampInPercent = val;
  }

  void __set__rampOutInterval(const int32_t val) {
    _rampOutInterval = val;
  }

  void __set__rampOutPercent(const int32_t val) {
    _rampOutPercent = val;
  }

  void __set__kwReduction(const double val) {
    _kwReduction = val;
  }

  bool operator == (const LMProgramDirectGear & rhs) const
  {
    if (!(_programPaoId == rhs._programPaoId))
      return false;
    if (!(_gearName == rhs._gearName))
      return false;
    if (!(_gearNumber == rhs._gearNumber))
      return false;
    if (!(_controlMethod == rhs._controlMethod))
      return false;
    if (!(_methodRate == rhs._methodRate))
      return false;
    if (!(_methodPeriod == rhs._methodPeriod))
      return false;
    if (!(_methodRateCount == rhs._methodRateCount))
      return false;
    if (!(_cyclereFreshRate == rhs._cyclereFreshRate))
      return false;
    if (!(_methodStopType == rhs._methodStopType))
      return false;
    if (!(_changeCondition == rhs._changeCondition))
      return false;
    if (!(_changeDuration == rhs._changeDuration))
      return false;
    if (!(_changePriority == rhs._changePriority))
      return false;
    if (!(_changeTriggerNumber == rhs._changeTriggerNumber))
      return false;
    if (!(_changeTriggerOffset == rhs._changeTriggerOffset))
      return false;
    if (!(_percentReduction == rhs._percentReduction))
      return false;
    if (!(_groupSelectionMethod == rhs._groupSelectionMethod))
      return false;
    if (!(_methodOptionType == rhs._methodOptionType))
      return false;
    if (!(_methodOptionMax == rhs._methodOptionMax))
      return false;
    if (!(_rampInInterval == rhs._rampInInterval))
      return false;
    if (!(_rampInPercent == rhs._rampInPercent))
      return false;
    if (!(_rampOutInterval == rhs._rampOutInterval))
      return false;
    if (!(_rampOutPercent == rhs._rampOutPercent))
      return false;
    if (!(_kwReduction == rhs._kwReduction))
      return false;
    return true;
  }
  bool operator != (const LMProgramDirectGear &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramDirectGear & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMProgramDirectGear &a, LMProgramDirectGear &b);


class LMGroupBase {
 public:

  static const char* ascii_fingerprint; // = "54967C9507DFC665A1E47AD9EF4CD7CF";
  static const uint8_t binary_fingerprint[16]; // = {0x54,0x96,0x7C,0x95,0x07,0xDF,0xC6,0x65,0xA1,0xE4,0x7A,0xD9,0xEF,0x4C,0xD7,0xCF};

  LMGroupBase() : _paoId(0), _paoCategory(), _paoClass(), _paoName(), _paoTypeString(), _paoDescription(), _disableFlag(0), _groupOrder(0), _kwCapacity(0), _childOrder(0), _alarmInhibit(0), _controlInhibit(0), _groupControlState(0), _currentHoursDaily(0), _currentHoursMonthly(0), _currentHoursSeasonal(0), _currentHoursAnnually(0), _lastControlSent(0), _controlStartTime(0), _controlCompleteTime(0), _nextControlTime(0), _internalState(0), _dailyOps(0), _lastStopTimeSent(0) {
  }

  virtual ~LMGroupBase() throw() {}

  int32_t _paoId;
  std::string _paoCategory;
  std::string _paoClass;
  std::string _paoName;
  std::string _paoTypeString;
  std::string _paoDescription;
  bool _disableFlag;
  int32_t _groupOrder;
  double _kwCapacity;
  int32_t _childOrder;
  bool _alarmInhibit;
  bool _controlInhibit;
  int32_t _groupControlState;
  int32_t _currentHoursDaily;
  int32_t _currentHoursMonthly;
  int32_t _currentHoursSeasonal;
  int32_t _currentHoursAnnually;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _lastControlSent;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _controlStartTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _controlCompleteTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _nextControlTime;
  int32_t _internalState;
  int32_t _dailyOps;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _lastStopTimeSent;

  void __set__paoId(const int32_t val) {
    _paoId = val;
  }

  void __set__paoCategory(const std::string& val) {
    _paoCategory = val;
  }

  void __set__paoClass(const std::string& val) {
    _paoClass = val;
  }

  void __set__paoName(const std::string& val) {
    _paoName = val;
  }

  void __set__paoTypeString(const std::string& val) {
    _paoTypeString = val;
  }

  void __set__paoDescription(const std::string& val) {
    _paoDescription = val;
  }

  void __set__disableFlag(const bool val) {
    _disableFlag = val;
  }

  void __set__groupOrder(const int32_t val) {
    _groupOrder = val;
  }

  void __set__kwCapacity(const double val) {
    _kwCapacity = val;
  }

  void __set__childOrder(const int32_t val) {
    _childOrder = val;
  }

  void __set__alarmInhibit(const bool val) {
    _alarmInhibit = val;
  }

  void __set__controlInhibit(const bool val) {
    _controlInhibit = val;
  }

  void __set__groupControlState(const int32_t val) {
    _groupControlState = val;
  }

  void __set__currentHoursDaily(const int32_t val) {
    _currentHoursDaily = val;
  }

  void __set__currentHoursMonthly(const int32_t val) {
    _currentHoursMonthly = val;
  }

  void __set__currentHoursSeasonal(const int32_t val) {
    _currentHoursSeasonal = val;
  }

  void __set__currentHoursAnnually(const int32_t val) {
    _currentHoursAnnually = val;
  }

  void __set__lastControlSent(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _lastControlSent = val;
  }

  void __set__controlStartTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _controlStartTime = val;
  }

  void __set__controlCompleteTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _controlCompleteTime = val;
  }

  void __set__nextControlTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _nextControlTime = val;
  }

  void __set__internalState(const int32_t val) {
    _internalState = val;
  }

  void __set__dailyOps(const int32_t val) {
    _dailyOps = val;
  }

  void __set__lastStopTimeSent(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _lastStopTimeSent = val;
  }

  bool operator == (const LMGroupBase & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_paoCategory == rhs._paoCategory))
      return false;
    if (!(_paoClass == rhs._paoClass))
      return false;
    if (!(_paoName == rhs._paoName))
      return false;
    if (!(_paoTypeString == rhs._paoTypeString))
      return false;
    if (!(_paoDescription == rhs._paoDescription))
      return false;
    if (!(_disableFlag == rhs._disableFlag))
      return false;
    if (!(_groupOrder == rhs._groupOrder))
      return false;
    if (!(_kwCapacity == rhs._kwCapacity))
      return false;
    if (!(_childOrder == rhs._childOrder))
      return false;
    if (!(_alarmInhibit == rhs._alarmInhibit))
      return false;
    if (!(_controlInhibit == rhs._controlInhibit))
      return false;
    if (!(_groupControlState == rhs._groupControlState))
      return false;
    if (!(_currentHoursDaily == rhs._currentHoursDaily))
      return false;
    if (!(_currentHoursMonthly == rhs._currentHoursMonthly))
      return false;
    if (!(_currentHoursSeasonal == rhs._currentHoursSeasonal))
      return false;
    if (!(_currentHoursAnnually == rhs._currentHoursAnnually))
      return false;
    if (!(_lastControlSent == rhs._lastControlSent))
      return false;
    if (!(_controlStartTime == rhs._controlStartTime))
      return false;
    if (!(_controlCompleteTime == rhs._controlCompleteTime))
      return false;
    if (!(_nextControlTime == rhs._nextControlTime))
      return false;
    if (!(_internalState == rhs._internalState))
      return false;
    if (!(_dailyOps == rhs._dailyOps))
      return false;
    if (!(_lastStopTimeSent == rhs._lastStopTimeSent))
      return false;
    return true;
  }
  bool operator != (const LMGroupBase &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupBase & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupBase &a, LMGroupBase &b);


class LMGroupDigiSEP {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupDigiSEP() {
  }

  virtual ~LMGroupDigiSEP() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupDigiSEP & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupDigiSEP &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupDigiSEP & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupDigiSEP &a, LMGroupDigiSEP &b);


class LMGroupEcobee {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupEcobee() {
  }

  virtual ~LMGroupEcobee() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupEcobee & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupEcobee &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupEcobee & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupEcobee &a, LMGroupEcobee &b);


class LMGroupEmetcon {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupEmetcon() {
  }

  virtual ~LMGroupEmetcon() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupEmetcon & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupEmetcon &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupEmetcon & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupEmetcon &a, LMGroupEmetcon &b);


class LMGroupExpresscom {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupExpresscom() {
  }

  virtual ~LMGroupExpresscom() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupExpresscom & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupExpresscom &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupExpresscom & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupExpresscom &a, LMGroupExpresscom &b);


class LMGroupGolay {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupGolay() {
  }

  virtual ~LMGroupGolay() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupGolay & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupGolay &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupGolay & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupGolay &a, LMGroupGolay &b);


class LMGroupMacro {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupMacro() {
  }

  virtual ~LMGroupMacro() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupMacro & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupMacro &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupMacro & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupMacro &a, LMGroupMacro &b);


class LMGroupMCT {
 public:

  static const char* ascii_fingerprint; // = "6EAE3360CCE68EBACBE88AA2683618F9";
  static const uint8_t binary_fingerprint[16]; // = {0x6E,0xAE,0x33,0x60,0xCC,0xE6,0x8E,0xBA,0xCB,0xE8,0x8A,0xA2,0x68,0x36,0x18,0xF9};

  LMGroupMCT() {
  }

  virtual ~LMGroupMCT() throw() {}

  LMGroupEmetcon _baseMessage;

  void __set__baseMessage(const LMGroupEmetcon& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupMCT & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupMCT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupMCT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupMCT &a, LMGroupMCT &b);


class LMGroupPoint {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupPoint() {
  }

  virtual ~LMGroupPoint() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupPoint & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupPoint &a, LMGroupPoint &b);


class LMGroupRipple {
 public:

  static const char* ascii_fingerprint; // = "8425E273E944143BC6B9DB14DED7E700";
  static const uint8_t binary_fingerprint[16]; // = {0x84,0x25,0xE2,0x73,0xE9,0x44,0x14,0x3B,0xC6,0xB9,0xDB,0x14,0xDE,0xD7,0xE7,0x00};

  LMGroupRipple() : _shedTime(0) {
  }

  virtual ~LMGroupRipple() throw() {}

  LMGroupBase _baseMessage;
  int32_t _shedTime;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  void __set__shedTime(const int32_t val) {
    _shedTime = val;
  }

  bool operator == (const LMGroupRipple & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_shedTime == rhs._shedTime))
      return false;
    return true;
  }
  bool operator != (const LMGroupRipple &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupRipple & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupRipple &a, LMGroupRipple &b);


class LMGroupSA105 {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupSA105() {
  }

  virtual ~LMGroupSA105() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupSA105 & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupSA105 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupSA105 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupSA105 &a, LMGroupSA105 &b);


class LMGroupSA205 {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupSA205() {
  }

  virtual ~LMGroupSA205() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupSA205 & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupSA205 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupSA205 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupSA205 &a, LMGroupSA205 &b);


class LMGroupSA305 {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupSA305() {
  }

  virtual ~LMGroupSA305() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupSA305 & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupSA305 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupSA305 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupSA305 &a, LMGroupSA305 &b);


class LMGroupSADigital {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupSADigital() {
  }

  virtual ~LMGroupSADigital() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupSADigital & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupSADigital &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupSADigital & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupSADigital &a, LMGroupSADigital &b);


class LMGroupVersacom {
 public:

  static const char* ascii_fingerprint; // = "87D2AAE9F82EF469E961C185946711F5";
  static const uint8_t binary_fingerprint[16]; // = {0x87,0xD2,0xAA,0xE9,0xF8,0x2E,0xF4,0x69,0xE9,0x61,0xC1,0x85,0x94,0x67,0x11,0xF5};

  LMGroupVersacom() {
  }

  virtual ~LMGroupVersacom() throw() {}

  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val) {
    _baseMessage = val;
  }

  bool operator == (const LMGroupVersacom & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupVersacom &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupVersacom & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMGroupVersacom &a, LMGroupVersacom &b);


class LMProgramDirect {
 public:

  static const char* ascii_fingerprint; // = "D30E443A35527B9ABFCA2B3D252847B0";
  static const uint8_t binary_fingerprint[16]; // = {0xD3,0x0E,0x44,0x3A,0x35,0x52,0x7B,0x9A,0xBF,0xCA,0x2B,0x3D,0x25,0x28,0x47,0xB0};

  LMProgramDirect() : _currentGearNumber(0), _lastGroupControlled(0), _directStartTime(0), _directstopTime(0), _notifyActiveTime(0), _notifyInactiveTime(0), _startedRampingOut(0), _triggerOffset(0), _triggerRestoreOffset(0), _constraintOverride(0) {
  }

  virtual ~LMProgramDirect() throw() {}

  LMProgramBase _baseMessage;
  int32_t _currentGearNumber;
  int32_t _lastGroupControlled;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _directStartTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _directstopTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _notifyActiveTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _notifyInactiveTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _startedRampingOut;
  int32_t _triggerOffset;
  int32_t _triggerRestoreOffset;
  bool _constraintOverride;
  std::vector<LMProgramDirectGear>  _lmProgramDirectGears;
  std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage>  _lmProgramDirectGroups;
  std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage>  _activeMasters;
  std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage>  _activeSubordinates;

  void __set__baseMessage(const LMProgramBase& val) {
    _baseMessage = val;
  }

  void __set__currentGearNumber(const int32_t val) {
    _currentGearNumber = val;
  }

  void __set__lastGroupControlled(const int32_t val) {
    _lastGroupControlled = val;
  }

  void __set__directStartTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _directStartTime = val;
  }

  void __set__directstopTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _directstopTime = val;
  }

  void __set__notifyActiveTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _notifyActiveTime = val;
  }

  void __set__notifyInactiveTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _notifyInactiveTime = val;
  }

  void __set__startedRampingOut(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _startedRampingOut = val;
  }

  void __set__triggerOffset(const int32_t val) {
    _triggerOffset = val;
  }

  void __set__triggerRestoreOffset(const int32_t val) {
    _triggerRestoreOffset = val;
  }

  void __set__constraintOverride(const bool val) {
    _constraintOverride = val;
  }

  void __set__lmProgramDirectGears(const std::vector<LMProgramDirectGear> & val) {
    _lmProgramDirectGears = val;
  }

  void __set__lmProgramDirectGroups(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val) {
    _lmProgramDirectGroups = val;
  }

  void __set__activeMasters(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val) {
    _activeMasters = val;
  }

  void __set__activeSubordinates(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val) {
    _activeSubordinates = val;
  }

  bool operator == (const LMProgramDirect & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_currentGearNumber == rhs._currentGearNumber))
      return false;
    if (!(_lastGroupControlled == rhs._lastGroupControlled))
      return false;
    if (!(_directStartTime == rhs._directStartTime))
      return false;
    if (!(_directstopTime == rhs._directstopTime))
      return false;
    if (!(_notifyActiveTime == rhs._notifyActiveTime))
      return false;
    if (!(_notifyInactiveTime == rhs._notifyInactiveTime))
      return false;
    if (!(_startedRampingOut == rhs._startedRampingOut))
      return false;
    if (!(_triggerOffset == rhs._triggerOffset))
      return false;
    if (!(_triggerRestoreOffset == rhs._triggerRestoreOffset))
      return false;
    if (!(_constraintOverride == rhs._constraintOverride))
      return false;
    if (!(_lmProgramDirectGears == rhs._lmProgramDirectGears))
      return false;
    if (!(_lmProgramDirectGroups == rhs._lmProgramDirectGroups))
      return false;
    if (!(_activeMasters == rhs._activeMasters))
      return false;
    if (!(_activeSubordinates == rhs._activeSubordinates))
      return false;
    return true;
  }
  bool operator != (const LMProgramDirect &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramDirect & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMProgramDirect &a, LMProgramDirect &b);


class LMEnergyExchangeHourlyOffer {
 public:

  static const char* ascii_fingerprint; // = "024BC5B440BAAEB1F3BB3BD341D6521C";
  static const uint8_t binary_fingerprint[16]; // = {0x02,0x4B,0xC5,0xB4,0x40,0xBA,0xAE,0xB1,0xF3,0xBB,0x3B,0xD3,0x41,0xD6,0x52,0x1C};

  LMEnergyExchangeHourlyOffer() : _offerId(0), _revisionNumber(0), _hour(0), _price(0), _amountRequested(0) {
  }

  virtual ~LMEnergyExchangeHourlyOffer() throw() {}

  int32_t _offerId;
  int32_t _revisionNumber;
  int32_t _hour;
  double _price;
  double _amountRequested;

  void __set__offerId(const int32_t val) {
    _offerId = val;
  }

  void __set__revisionNumber(const int32_t val) {
    _revisionNumber = val;
  }

  void __set__hour(const int32_t val) {
    _hour = val;
  }

  void __set__price(const double val) {
    _price = val;
  }

  void __set__amountRequested(const double val) {
    _amountRequested = val;
  }

  bool operator == (const LMEnergyExchangeHourlyOffer & rhs) const
  {
    if (!(_offerId == rhs._offerId))
      return false;
    if (!(_revisionNumber == rhs._revisionNumber))
      return false;
    if (!(_hour == rhs._hour))
      return false;
    if (!(_price == rhs._price))
      return false;
    if (!(_amountRequested == rhs._amountRequested))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeHourlyOffer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeHourlyOffer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMEnergyExchangeHourlyOffer &a, LMEnergyExchangeHourlyOffer &b);


class LMEnergyExchangeOfferRevision {
 public:

  static const char* ascii_fingerprint; // = "BA01C93A4871DAB4F9E394FE645E018E";
  static const uint8_t binary_fingerprint[16]; // = {0xBA,0x01,0xC9,0x3A,0x48,0x71,0xDA,0xB4,0xF9,0xE3,0x94,0xFE,0x64,0x5E,0x01,0x8E};

  LMEnergyExchangeOfferRevision() : _offerId(0), _revisionNumber(0), _actionDatetime(0), _notificationDatetime(0), _offerexpirationDatetime(0), _additionalInfo() {
  }

  virtual ~LMEnergyExchangeOfferRevision() throw() {}

  int32_t _offerId;
  int32_t _revisionNumber;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _actionDatetime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _notificationDatetime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _offerexpirationDatetime;
  std::string _additionalInfo;
  std::vector<LMEnergyExchangeHourlyOffer>  _lmEnergyExchangeHourlyOffers;

  void __set__offerId(const int32_t val) {
    _offerId = val;
  }

  void __set__revisionNumber(const int32_t val) {
    _revisionNumber = val;
  }

  void __set__actionDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _actionDatetime = val;
  }

  void __set__notificationDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _notificationDatetime = val;
  }

  void __set__offerexpirationDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _offerexpirationDatetime = val;
  }

  void __set__additionalInfo(const std::string& val) {
    _additionalInfo = val;
  }

  void __set__lmEnergyExchangeHourlyOffers(const std::vector<LMEnergyExchangeHourlyOffer> & val) {
    _lmEnergyExchangeHourlyOffers = val;
  }

  bool operator == (const LMEnergyExchangeOfferRevision & rhs) const
  {
    if (!(_offerId == rhs._offerId))
      return false;
    if (!(_revisionNumber == rhs._revisionNumber))
      return false;
    if (!(_actionDatetime == rhs._actionDatetime))
      return false;
    if (!(_notificationDatetime == rhs._notificationDatetime))
      return false;
    if (!(_offerexpirationDatetime == rhs._offerexpirationDatetime))
      return false;
    if (!(_additionalInfo == rhs._additionalInfo))
      return false;
    if (!(_lmEnergyExchangeHourlyOffers == rhs._lmEnergyExchangeHourlyOffers))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeOfferRevision &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeOfferRevision & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMEnergyExchangeOfferRevision &a, LMEnergyExchangeOfferRevision &b);


class LMEnergyExchangeOffer {
 public:

  static const char* ascii_fingerprint; // = "1554181D28A09C049078BA8CB325CA35";
  static const uint8_t binary_fingerprint[16]; // = {0x15,0x54,0x18,0x1D,0x28,0xA0,0x9C,0x04,0x90,0x78,0xBA,0x8C,0xB3,0x25,0xCA,0x35};

  LMEnergyExchangeOffer() : _paoId(0), _offerId(0), _runStatus(), _offerDate(0) {
  }

  virtual ~LMEnergyExchangeOffer() throw() {}

  int32_t _paoId;
  int32_t _offerId;
  std::string _runStatus;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _offerDate;
  std::vector<LMEnergyExchangeOfferRevision>  _lmEnergyExchangeOfferRevisions;

  void __set__paoId(const int32_t val) {
    _paoId = val;
  }

  void __set__offerId(const int32_t val) {
    _offerId = val;
  }

  void __set__runStatus(const std::string& val) {
    _runStatus = val;
  }

  void __set__offerDate(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _offerDate = val;
  }

  void __set__lmEnergyExchangeOfferRevisions(const std::vector<LMEnergyExchangeOfferRevision> & val) {
    _lmEnergyExchangeOfferRevisions = val;
  }

  bool operator == (const LMEnergyExchangeOffer & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_offerId == rhs._offerId))
      return false;
    if (!(_runStatus == rhs._runStatus))
      return false;
    if (!(_offerDate == rhs._offerDate))
      return false;
    if (!(_lmEnergyExchangeOfferRevisions == rhs._lmEnergyExchangeOfferRevisions))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeOffer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeOffer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMEnergyExchangeOffer &a, LMEnergyExchangeOffer &b);


class LMEnergyExchangeHourlyCustomer {
 public:

  static const char* ascii_fingerprint; // = "7BD00650D5899D1155D6BC44CF108369";
  static const uint8_t binary_fingerprint[16]; // = {0x7B,0xD0,0x06,0x50,0xD5,0x89,0x9D,0x11,0x55,0xD6,0xBC,0x44,0xCF,0x10,0x83,0x69};

  LMEnergyExchangeHourlyCustomer() : _customerId(0), _offerId(0), _revisionNumber(0), _hour(0), _amountCommitted(0) {
  }

  virtual ~LMEnergyExchangeHourlyCustomer() throw() {}

  int32_t _customerId;
  int32_t _offerId;
  int32_t _revisionNumber;
  int32_t _hour;
  double _amountCommitted;

  void __set__customerId(const int32_t val) {
    _customerId = val;
  }

  void __set__offerId(const int32_t val) {
    _offerId = val;
  }

  void __set__revisionNumber(const int32_t val) {
    _revisionNumber = val;
  }

  void __set__hour(const int32_t val) {
    _hour = val;
  }

  void __set__amountCommitted(const double val) {
    _amountCommitted = val;
  }

  bool operator == (const LMEnergyExchangeHourlyCustomer & rhs) const
  {
    if (!(_customerId == rhs._customerId))
      return false;
    if (!(_offerId == rhs._offerId))
      return false;
    if (!(_revisionNumber == rhs._revisionNumber))
      return false;
    if (!(_hour == rhs._hour))
      return false;
    if (!(_amountCommitted == rhs._amountCommitted))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeHourlyCustomer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeHourlyCustomer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMEnergyExchangeHourlyCustomer &a, LMEnergyExchangeHourlyCustomer &b);


class LMEnergyExchangeCustomerReply {
 public:

  static const char* ascii_fingerprint; // = "E6BA8594C7384E6261E8B29BFBF9B3FE";
  static const uint8_t binary_fingerprint[16]; // = {0xE6,0xBA,0x85,0x94,0xC7,0x38,0x4E,0x62,0x61,0xE8,0xB2,0x9B,0xFB,0xF9,0xB3,0xFE};

  LMEnergyExchangeCustomerReply() : _customerId(0), _offerId(0), _acceptStatus(), _acceptDatetime(0), _revisionNumber(0), _ipAddressOfAcceptUser(), _userIdName(), _nameOfAcceptPerson(), _energyExchangeNotes() {
  }

  virtual ~LMEnergyExchangeCustomerReply() throw() {}

  int32_t _customerId;
  int32_t _offerId;
  std::string _acceptStatus;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _acceptDatetime;
  int32_t _revisionNumber;
  std::string _ipAddressOfAcceptUser;
  std::string _userIdName;
  std::string _nameOfAcceptPerson;
  std::string _energyExchangeNotes;
  std::vector<LMEnergyExchangeHourlyCustomer>  _lmEnergyExchangeHourlyCustomers;

  void __set__customerId(const int32_t val) {
    _customerId = val;
  }

  void __set__offerId(const int32_t val) {
    _offerId = val;
  }

  void __set__acceptStatus(const std::string& val) {
    _acceptStatus = val;
  }

  void __set__acceptDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _acceptDatetime = val;
  }

  void __set__revisionNumber(const int32_t val) {
    _revisionNumber = val;
  }

  void __set__ipAddressOfAcceptUser(const std::string& val) {
    _ipAddressOfAcceptUser = val;
  }

  void __set__userIdName(const std::string& val) {
    _userIdName = val;
  }

  void __set__nameOfAcceptPerson(const std::string& val) {
    _nameOfAcceptPerson = val;
  }

  void __set__energyExchangeNotes(const std::string& val) {
    _energyExchangeNotes = val;
  }

  void __set__lmEnergyExchangeHourlyCustomers(const std::vector<LMEnergyExchangeHourlyCustomer> & val) {
    _lmEnergyExchangeHourlyCustomers = val;
  }

  bool operator == (const LMEnergyExchangeCustomerReply & rhs) const
  {
    if (!(_customerId == rhs._customerId))
      return false;
    if (!(_offerId == rhs._offerId))
      return false;
    if (!(_acceptStatus == rhs._acceptStatus))
      return false;
    if (!(_acceptDatetime == rhs._acceptDatetime))
      return false;
    if (!(_revisionNumber == rhs._revisionNumber))
      return false;
    if (!(_ipAddressOfAcceptUser == rhs._ipAddressOfAcceptUser))
      return false;
    if (!(_userIdName == rhs._userIdName))
      return false;
    if (!(_nameOfAcceptPerson == rhs._nameOfAcceptPerson))
      return false;
    if (!(_energyExchangeNotes == rhs._energyExchangeNotes))
      return false;
    if (!(_lmEnergyExchangeHourlyCustomers == rhs._lmEnergyExchangeHourlyCustomers))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeCustomerReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeCustomerReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMEnergyExchangeCustomerReply &a, LMEnergyExchangeCustomerReply &b);


class LMEnergyExchangeCustomer {
 public:

  static const char* ascii_fingerprint; // = "FAB0CE5682B4D08448F53B3584E18505";
  static const uint8_t binary_fingerprint[16]; // = {0xFA,0xB0,0xCE,0x56,0x82,0xB4,0xD0,0x84,0x48,0xF5,0x3B,0x35,0x84,0xE1,0x85,0x05};

  LMEnergyExchangeCustomer() {
  }

  virtual ~LMEnergyExchangeCustomer() throw() {}

  LMCICustomerBase _baseMessage;
  std::vector<LMEnergyExchangeCustomerReply>  _lmEnergyExchangeCustomerReplies;

  void __set__baseMessage(const LMCICustomerBase& val) {
    _baseMessage = val;
  }

  void __set__lmEnergyExchangeCustomerReplies(const std::vector<LMEnergyExchangeCustomerReply> & val) {
    _lmEnergyExchangeCustomerReplies = val;
  }

  bool operator == (const LMEnergyExchangeCustomer & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_lmEnergyExchangeCustomerReplies == rhs._lmEnergyExchangeCustomerReplies))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeCustomer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeCustomer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMEnergyExchangeCustomer &a, LMEnergyExchangeCustomer &b);


class LMProgramEnergyExchange {
 public:

  static const char* ascii_fingerprint; // = "65F003D8CF0059F384EBCF0F1608F846";
  static const uint8_t binary_fingerprint[16]; // = {0x65,0xF0,0x03,0xD8,0xCF,0x00,0x59,0xF3,0x84,0xEB,0xCF,0x0F,0x16,0x08,0xF8,0x46};

  LMProgramEnergyExchange() : _minNotifyTime(0), _heading(), _messageHeader(), _messageFooter(), _canceledMsg(), _stoppedEarlyMsg() {
  }

  virtual ~LMProgramEnergyExchange() throw() {}

  LMProgramBase _baseMessage;
  int32_t _minNotifyTime;
  std::string _heading;
  std::string _messageHeader;
  std::string _messageFooter;
  std::string _canceledMsg;
  std::string _stoppedEarlyMsg;
  std::vector<LMEnergyExchangeOffer>  _lmEnergyExchangeOffers;
  std::vector<LMEnergyExchangeCustomer>  _lmEnergyExchangeCustomers;

  void __set__baseMessage(const LMProgramBase& val) {
    _baseMessage = val;
  }

  void __set__minNotifyTime(const int32_t val) {
    _minNotifyTime = val;
  }

  void __set__heading(const std::string& val) {
    _heading = val;
  }

  void __set__messageHeader(const std::string& val) {
    _messageHeader = val;
  }

  void __set__messageFooter(const std::string& val) {
    _messageFooter = val;
  }

  void __set__canceledMsg(const std::string& val) {
    _canceledMsg = val;
  }

  void __set__stoppedEarlyMsg(const std::string& val) {
    _stoppedEarlyMsg = val;
  }

  void __set__lmEnergyExchangeOffers(const std::vector<LMEnergyExchangeOffer> & val) {
    _lmEnergyExchangeOffers = val;
  }

  void __set__lmEnergyExchangeCustomers(const std::vector<LMEnergyExchangeCustomer> & val) {
    _lmEnergyExchangeCustomers = val;
  }

  bool operator == (const LMProgramEnergyExchange & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_minNotifyTime == rhs._minNotifyTime))
      return false;
    if (!(_heading == rhs._heading))
      return false;
    if (!(_messageHeader == rhs._messageHeader))
      return false;
    if (!(_messageFooter == rhs._messageFooter))
      return false;
    if (!(_canceledMsg == rhs._canceledMsg))
      return false;
    if (!(_stoppedEarlyMsg == rhs._stoppedEarlyMsg))
      return false;
    if (!(_lmEnergyExchangeOffers == rhs._lmEnergyExchangeOffers))
      return false;
    if (!(_lmEnergyExchangeCustomers == rhs._lmEnergyExchangeCustomers))
      return false;
    return true;
  }
  bool operator != (const LMProgramEnergyExchange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramEnergyExchange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMProgramEnergyExchange &a, LMProgramEnergyExchange &b);


class LMControlAreaItem {
 public:

  static const char* ascii_fingerprint; // = "648E80BF989B57498E00B7508EB18560";
  static const uint8_t binary_fingerprint[16]; // = {0x64,0x8E,0x80,0xBF,0x98,0x9B,0x57,0x49,0x8E,0x00,0xB7,0x50,0x8E,0xB1,0x85,0x60};

  LMControlAreaItem() : _paoId(0), _paoCategory(), _paoClass(), _paoName(), _paoTypeString(), _paoDescription(), _disableFlag(0), _defOperationalState(), _controlInterval(0), _minResponseTime(0), _defDailyStartTime(0), _defDailyStopTime(0), _requireAllTriggersActiveFlag(0), _nextCheckTime(0), _newPointDataReceivedFlag(0), _updatedFlag(0), _controlAreaStatusPointId(0), _controlAreaState(0), _currentPriority(0), _currentDailyStartTime(0), _currentDailyStopTime(0) {
  }

  virtual ~LMControlAreaItem() throw() {}

  int32_t _paoId;
  std::string _paoCategory;
  std::string _paoClass;
  std::string _paoName;
  std::string _paoTypeString;
  std::string _paoDescription;
  bool _disableFlag;
  std::string _defOperationalState;
  int32_t _controlInterval;
  int32_t _minResponseTime;
  int32_t _defDailyStartTime;
  int32_t _defDailyStopTime;
  bool _requireAllTriggersActiveFlag;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _nextCheckTime;
  bool _newPointDataReceivedFlag;
  bool _updatedFlag;
  int32_t _controlAreaStatusPointId;
  int32_t _controlAreaState;
  int32_t _currentPriority;
  int32_t _currentDailyStartTime;
  int32_t _currentDailyStopTime;
  std::vector<LMControlAreaTrigger>  _lmControlAreaTriggers;
  std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage>  _lmPrograms;

  void __set__paoId(const int32_t val) {
    _paoId = val;
  }

  void __set__paoCategory(const std::string& val) {
    _paoCategory = val;
  }

  void __set__paoClass(const std::string& val) {
    _paoClass = val;
  }

  void __set__paoName(const std::string& val) {
    _paoName = val;
  }

  void __set__paoTypeString(const std::string& val) {
    _paoTypeString = val;
  }

  void __set__paoDescription(const std::string& val) {
    _paoDescription = val;
  }

  void __set__disableFlag(const bool val) {
    _disableFlag = val;
  }

  void __set__defOperationalState(const std::string& val) {
    _defOperationalState = val;
  }

  void __set__controlInterval(const int32_t val) {
    _controlInterval = val;
  }

  void __set__minResponseTime(const int32_t val) {
    _minResponseTime = val;
  }

  void __set__defDailyStartTime(const int32_t val) {
    _defDailyStartTime = val;
  }

  void __set__defDailyStopTime(const int32_t val) {
    _defDailyStopTime = val;
  }

  void __set__requireAllTriggersActiveFlag(const bool val) {
    _requireAllTriggersActiveFlag = val;
  }

  void __set__nextCheckTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
    _nextCheckTime = val;
  }

  void __set__newPointDataReceivedFlag(const bool val) {
    _newPointDataReceivedFlag = val;
  }

  void __set__updatedFlag(const bool val) {
    _updatedFlag = val;
  }

  void __set__controlAreaStatusPointId(const int32_t val) {
    _controlAreaStatusPointId = val;
  }

  void __set__controlAreaState(const int32_t val) {
    _controlAreaState = val;
  }

  void __set__currentPriority(const int32_t val) {
    _currentPriority = val;
  }

  void __set__currentDailyStartTime(const int32_t val) {
    _currentDailyStartTime = val;
  }

  void __set__currentDailyStopTime(const int32_t val) {
    _currentDailyStopTime = val;
  }

  void __set__lmControlAreaTriggers(const std::vector<LMControlAreaTrigger> & val) {
    _lmControlAreaTriggers = val;
  }

  void __set__lmPrograms(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val) {
    _lmPrograms = val;
  }

  bool operator == (const LMControlAreaItem & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_paoCategory == rhs._paoCategory))
      return false;
    if (!(_paoClass == rhs._paoClass))
      return false;
    if (!(_paoName == rhs._paoName))
      return false;
    if (!(_paoTypeString == rhs._paoTypeString))
      return false;
    if (!(_paoDescription == rhs._paoDescription))
      return false;
    if (!(_disableFlag == rhs._disableFlag))
      return false;
    if (!(_defOperationalState == rhs._defOperationalState))
      return false;
    if (!(_controlInterval == rhs._controlInterval))
      return false;
    if (!(_minResponseTime == rhs._minResponseTime))
      return false;
    if (!(_defDailyStartTime == rhs._defDailyStartTime))
      return false;
    if (!(_defDailyStopTime == rhs._defDailyStopTime))
      return false;
    if (!(_requireAllTriggersActiveFlag == rhs._requireAllTriggersActiveFlag))
      return false;
    if (!(_nextCheckTime == rhs._nextCheckTime))
      return false;
    if (!(_newPointDataReceivedFlag == rhs._newPointDataReceivedFlag))
      return false;
    if (!(_updatedFlag == rhs._updatedFlag))
      return false;
    if (!(_controlAreaStatusPointId == rhs._controlAreaStatusPointId))
      return false;
    if (!(_controlAreaState == rhs._controlAreaState))
      return false;
    if (!(_currentPriority == rhs._currentPriority))
      return false;
    if (!(_currentDailyStartTime == rhs._currentDailyStartTime))
      return false;
    if (!(_currentDailyStopTime == rhs._currentDailyStopTime))
      return false;
    if (!(_lmControlAreaTriggers == rhs._lmControlAreaTriggers))
      return false;
    if (!(_lmPrograms == rhs._lmPrograms))
      return false;
    return true;
  }
  bool operator != (const LMControlAreaItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMControlAreaItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMControlAreaItem &a, LMControlAreaItem &b);


class LMControlAreas {
 public:

  static const char* ascii_fingerprint; // = "8628853A12758419A1181CF112CBB074";
  static const uint8_t binary_fingerprint[16]; // = {0x86,0x28,0x85,0x3A,0x12,0x75,0x84,0x19,0xA1,0x18,0x1C,0xF1,0x12,0xCB,0xB0,0x74};

  LMControlAreas() : _msgInfoBitMask(0) {
  }

  virtual ~LMControlAreas() throw() {}

   ::Cti::Messaging::Serialization::Thrift::LMMessage _baseMessage;
  int32_t _msgInfoBitMask;
  std::vector<LMControlAreaItem>  _controlAreas;

  void __set__baseMessage(const  ::Cti::Messaging::Serialization::Thrift::LMMessage& val) {
    _baseMessage = val;
  }

  void __set__msgInfoBitMask(const int32_t val) {
    _msgInfoBitMask = val;
  }

  void __set__controlAreas(const std::vector<LMControlAreaItem> & val) {
    _controlAreas = val;
  }

  bool operator == (const LMControlAreas & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_msgInfoBitMask == rhs._msgInfoBitMask))
      return false;
    if (!(_controlAreas == rhs._controlAreas))
      return false;
    return true;
  }
  bool operator != (const LMControlAreas &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMControlAreas & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LMControlAreas &a, LMControlAreas &b);

}}}} // namespace

#endif
