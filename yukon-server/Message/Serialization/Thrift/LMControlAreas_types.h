/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef LMControlAreas_TYPES_H
#define LMControlAreas_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>
#include "LMMessage_types.h"
#include "Types_types.h"
#include "Message_types.h"


namespace Cti { namespace Messaging { namespace Serialization { namespace Thrift {

class LMControlAreaTrigger;

class LMProgramControlWindow;

class LMProgramBase;

class LMCICustomerBase;

class LMCurtailCustomer;

class LMProgramCurtailment;

class LMProgramDirectGear;

class LMGroupBase;

class LMGroupDigiSEP;

class LMGroupEcobee;

class LMGroupHoneywell;

class LMGroupEmetcon;

class LMGroupExpresscom;

class LMGroupGolay;

class LMGroupMacro;

class LMGroupMCT;

class LMGroupPoint;

class LMGroupRipple;

class LMGroupSA105;

class LMGroupSA205;

class LMGroupSA305;

class LMGroupSADigital;

class LMGroupVersacom;

class LMProgramDirect;

class LMEnergyExchangeHourlyOffer;

class LMEnergyExchangeOfferRevision;

class LMEnergyExchangeOffer;

class LMEnergyExchangeHourlyCustomer;

class LMEnergyExchangeCustomerReply;

class LMEnergyExchangeCustomer;

class LMProgramEnergyExchange;

class LMControlAreaItem;

class LMControlAreas;


class LMControlAreaTrigger : public virtual ::apache::thrift::TBase {
 public:

  LMControlAreaTrigger(const LMControlAreaTrigger&);
  LMControlAreaTrigger& operator=(const LMControlAreaTrigger&);
  LMControlAreaTrigger() : _paoId(0), _triggerNumber(0), _triggerType(), _pointId(0), _pointValue(0), _lastPointValueTimestamp(0), _normalState(0), _threshold(0), _projectionType(), _projectionPoints(0), _projectAheadDuration(0), _thresholdKickPercent(0), _minRestoreOffset(0), _peakPointId(0), _peakPointValue(0), _lastPeakPointValueTimestamp(0), _projectedPointValue(0) {
  }

  virtual ~LMControlAreaTrigger() throw();
  int32_t _paoId;
  int32_t _triggerNumber;
  std::string _triggerType;
  int32_t _pointId;
  double _pointValue;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _lastPointValueTimestamp;
  int32_t _normalState;
  double _threshold;
  std::string _projectionType;
  int32_t _projectionPoints;
  int32_t _projectAheadDuration;
  int32_t _thresholdKickPercent;
  double _minRestoreOffset;
  int32_t _peakPointId;
  double _peakPointValue;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _lastPeakPointValueTimestamp;
  double _projectedPointValue;

  void __set__paoId(const int32_t val);

  void __set__triggerNumber(const int32_t val);

  void __set__triggerType(const std::string& val);

  void __set__pointId(const int32_t val);

  void __set__pointValue(const double val);

  void __set__lastPointValueTimestamp(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__normalState(const int32_t val);

  void __set__threshold(const double val);

  void __set__projectionType(const std::string& val);

  void __set__projectionPoints(const int32_t val);

  void __set__projectAheadDuration(const int32_t val);

  void __set__thresholdKickPercent(const int32_t val);

  void __set__minRestoreOffset(const double val);

  void __set__peakPointId(const int32_t val);

  void __set__peakPointValue(const double val);

  void __set__lastPeakPointValueTimestamp(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__projectedPointValue(const double val);

  bool operator == (const LMControlAreaTrigger & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_triggerNumber == rhs._triggerNumber))
      return false;
    if (!(_triggerType == rhs._triggerType))
      return false;
    if (!(_pointId == rhs._pointId))
      return false;
    if (!(_pointValue == rhs._pointValue))
      return false;
    if (!(_lastPointValueTimestamp == rhs._lastPointValueTimestamp))
      return false;
    if (!(_normalState == rhs._normalState))
      return false;
    if (!(_threshold == rhs._threshold))
      return false;
    if (!(_projectionType == rhs._projectionType))
      return false;
    if (!(_projectionPoints == rhs._projectionPoints))
      return false;
    if (!(_projectAheadDuration == rhs._projectAheadDuration))
      return false;
    if (!(_thresholdKickPercent == rhs._thresholdKickPercent))
      return false;
    if (!(_minRestoreOffset == rhs._minRestoreOffset))
      return false;
    if (!(_peakPointId == rhs._peakPointId))
      return false;
    if (!(_peakPointValue == rhs._peakPointValue))
      return false;
    if (!(_lastPeakPointValueTimestamp == rhs._lastPeakPointValueTimestamp))
      return false;
    if (!(_projectedPointValue == rhs._projectedPointValue))
      return false;
    return true;
  }
  bool operator != (const LMControlAreaTrigger &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMControlAreaTrigger & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMControlAreaTrigger &a, LMControlAreaTrigger &b);

std::ostream& operator<<(std::ostream& out, const LMControlAreaTrigger& obj);


class LMProgramControlWindow : public virtual ::apache::thrift::TBase {
 public:

  LMProgramControlWindow(const LMProgramControlWindow&);
  LMProgramControlWindow& operator=(const LMProgramControlWindow&);
  LMProgramControlWindow() : _paoId(0), _windowNumber(0), _availableStartTime(0), _availableStopTime(0) {
  }

  virtual ~LMProgramControlWindow() throw();
  int32_t _paoId;
  int32_t _windowNumber;
  int32_t _availableStartTime;
  int32_t _availableStopTime;

  void __set__paoId(const int32_t val);

  void __set__windowNumber(const int32_t val);

  void __set__availableStartTime(const int32_t val);

  void __set__availableStopTime(const int32_t val);

  bool operator == (const LMProgramControlWindow & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_windowNumber == rhs._windowNumber))
      return false;
    if (!(_availableStartTime == rhs._availableStartTime))
      return false;
    if (!(_availableStopTime == rhs._availableStopTime))
      return false;
    return true;
  }
  bool operator != (const LMProgramControlWindow &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramControlWindow & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMProgramControlWindow &a, LMProgramControlWindow &b);

std::ostream& operator<<(std::ostream& out, const LMProgramControlWindow& obj);


class LMProgramBase : public virtual ::apache::thrift::TBase {
 public:

  LMProgramBase(const LMProgramBase&);
  LMProgramBase& operator=(const LMProgramBase&);
  LMProgramBase() : _paoId(0), _paoCategory(), _paoClass(), _paoName(), _paoTypeString(), _paoDescription(), _disableFlag(0), _startPriority(0), _stopPriority(0), _controlType(), _availableWeekdays(), _maxHoursDaily(0), _maxHoursMonthly(0), _maxHoursSeasonal(0), _maxHoursAnnually(0), _minActivateTime(0), _minRestartTime(0), _programStatusPointId(0), _programState(0), _reductionAnalogPointId(0), _reductionTotal(0), _startedControlling(0), _lastControlSent(0), _manualControlReceivedFlag(0) {
  }

  virtual ~LMProgramBase() throw();
  int32_t _paoId;
  std::string _paoCategory;
  std::string _paoClass;
  std::string _paoName;
  std::string _paoTypeString;
  std::string _paoDescription;
  bool _disableFlag;
  int32_t _startPriority;
  int32_t _stopPriority;
  std::string _controlType;
  std::string _availableWeekdays;
  int32_t _maxHoursDaily;
  int32_t _maxHoursMonthly;
  int32_t _maxHoursSeasonal;
  int32_t _maxHoursAnnually;
  int32_t _minActivateTime;
  int32_t _minRestartTime;
  int32_t _programStatusPointId;
  int32_t _programState;
  int32_t _reductionAnalogPointId;
  double _reductionTotal;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _startedControlling;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _lastControlSent;
  bool _manualControlReceivedFlag;
  std::vector<LMProgramControlWindow>  _lmProgramControlWindows;

  void __set__paoId(const int32_t val);

  void __set__paoCategory(const std::string& val);

  void __set__paoClass(const std::string& val);

  void __set__paoName(const std::string& val);

  void __set__paoTypeString(const std::string& val);

  void __set__paoDescription(const std::string& val);

  void __set__disableFlag(const bool val);

  void __set__startPriority(const int32_t val);

  void __set__stopPriority(const int32_t val);

  void __set__controlType(const std::string& val);

  void __set__availableWeekdays(const std::string& val);

  void __set__maxHoursDaily(const int32_t val);

  void __set__maxHoursMonthly(const int32_t val);

  void __set__maxHoursSeasonal(const int32_t val);

  void __set__maxHoursAnnually(const int32_t val);

  void __set__minActivateTime(const int32_t val);

  void __set__minRestartTime(const int32_t val);

  void __set__programStatusPointId(const int32_t val);

  void __set__programState(const int32_t val);

  void __set__reductionAnalogPointId(const int32_t val);

  void __set__reductionTotal(const double val);

  void __set__startedControlling(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__lastControlSent(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__manualControlReceivedFlag(const bool val);

  void __set__lmProgramControlWindows(const std::vector<LMProgramControlWindow> & val);

  bool operator == (const LMProgramBase & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_paoCategory == rhs._paoCategory))
      return false;
    if (!(_paoClass == rhs._paoClass))
      return false;
    if (!(_paoName == rhs._paoName))
      return false;
    if (!(_paoTypeString == rhs._paoTypeString))
      return false;
    if (!(_paoDescription == rhs._paoDescription))
      return false;
    if (!(_disableFlag == rhs._disableFlag))
      return false;
    if (!(_startPriority == rhs._startPriority))
      return false;
    if (!(_stopPriority == rhs._stopPriority))
      return false;
    if (!(_controlType == rhs._controlType))
      return false;
    if (!(_availableWeekdays == rhs._availableWeekdays))
      return false;
    if (!(_maxHoursDaily == rhs._maxHoursDaily))
      return false;
    if (!(_maxHoursMonthly == rhs._maxHoursMonthly))
      return false;
    if (!(_maxHoursSeasonal == rhs._maxHoursSeasonal))
      return false;
    if (!(_maxHoursAnnually == rhs._maxHoursAnnually))
      return false;
    if (!(_minActivateTime == rhs._minActivateTime))
      return false;
    if (!(_minRestartTime == rhs._minRestartTime))
      return false;
    if (!(_programStatusPointId == rhs._programStatusPointId))
      return false;
    if (!(_programState == rhs._programState))
      return false;
    if (!(_reductionAnalogPointId == rhs._reductionAnalogPointId))
      return false;
    if (!(_reductionTotal == rhs._reductionTotal))
      return false;
    if (!(_startedControlling == rhs._startedControlling))
      return false;
    if (!(_lastControlSent == rhs._lastControlSent))
      return false;
    if (!(_manualControlReceivedFlag == rhs._manualControlReceivedFlag))
      return false;
    if (!(_lmProgramControlWindows == rhs._lmProgramControlWindows))
      return false;
    return true;
  }
  bool operator != (const LMProgramBase &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramBase & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMProgramBase &a, LMProgramBase &b);

std::ostream& operator<<(std::ostream& out, const LMProgramBase& obj);


class LMCICustomerBase : public virtual ::apache::thrift::TBase {
 public:

  LMCICustomerBase(const LMCICustomerBase&);
  LMCICustomerBase& operator=(const LMCICustomerBase&);
  LMCICustomerBase() : _customerId(0), _companyName(), _customerDemandLevel(0), _curtailAmount(0), _curtailmentAgreement(), _timeZone(), _customerOrder(0) {
  }

  virtual ~LMCICustomerBase() throw();
  int32_t _customerId;
  std::string _companyName;
  double _customerDemandLevel;
  double _curtailAmount;
  std::string _curtailmentAgreement;
  std::string _timeZone;
  int32_t _customerOrder;

  void __set__customerId(const int32_t val);

  void __set__companyName(const std::string& val);

  void __set__customerDemandLevel(const double val);

  void __set__curtailAmount(const double val);

  void __set__curtailmentAgreement(const std::string& val);

  void __set__timeZone(const std::string& val);

  void __set__customerOrder(const int32_t val);

  bool operator == (const LMCICustomerBase & rhs) const
  {
    if (!(_customerId == rhs._customerId))
      return false;
    if (!(_companyName == rhs._companyName))
      return false;
    if (!(_customerDemandLevel == rhs._customerDemandLevel))
      return false;
    if (!(_curtailAmount == rhs._curtailAmount))
      return false;
    if (!(_curtailmentAgreement == rhs._curtailmentAgreement))
      return false;
    if (!(_timeZone == rhs._timeZone))
      return false;
    if (!(_customerOrder == rhs._customerOrder))
      return false;
    return true;
  }
  bool operator != (const LMCICustomerBase &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMCICustomerBase & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMCICustomerBase &a, LMCICustomerBase &b);

std::ostream& operator<<(std::ostream& out, const LMCICustomerBase& obj);


class LMCurtailCustomer : public virtual ::apache::thrift::TBase {
 public:

  LMCurtailCustomer(const LMCurtailCustomer&);
  LMCurtailCustomer& operator=(const LMCurtailCustomer&);
  LMCurtailCustomer() : _requireAck(0), _curtailReferenceId(0), _acknowledgeStatus(), _ackDatetime(0), _ipAddressOfAckUser(), _userIdName(), _nameOfAckPerson(), _curtailmentNotes(), _ackLateFlag(0) {
  }

  virtual ~LMCurtailCustomer() throw();
  LMCICustomerBase _baseMessage;
  bool _requireAck;
  int32_t _curtailReferenceId;
  std::string _acknowledgeStatus;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _ackDatetime;
  std::string _ipAddressOfAckUser;
  std::string _userIdName;
  std::string _nameOfAckPerson;
  std::string _curtailmentNotes;
  bool _ackLateFlag;

  void __set__baseMessage(const LMCICustomerBase& val);

  void __set__requireAck(const bool val);

  void __set__curtailReferenceId(const int32_t val);

  void __set__acknowledgeStatus(const std::string& val);

  void __set__ackDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__ipAddressOfAckUser(const std::string& val);

  void __set__userIdName(const std::string& val);

  void __set__nameOfAckPerson(const std::string& val);

  void __set__curtailmentNotes(const std::string& val);

  void __set__ackLateFlag(const bool val);

  bool operator == (const LMCurtailCustomer & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_requireAck == rhs._requireAck))
      return false;
    if (!(_curtailReferenceId == rhs._curtailReferenceId))
      return false;
    if (!(_acknowledgeStatus == rhs._acknowledgeStatus))
      return false;
    if (!(_ackDatetime == rhs._ackDatetime))
      return false;
    if (!(_ipAddressOfAckUser == rhs._ipAddressOfAckUser))
      return false;
    if (!(_userIdName == rhs._userIdName))
      return false;
    if (!(_nameOfAckPerson == rhs._nameOfAckPerson))
      return false;
    if (!(_curtailmentNotes == rhs._curtailmentNotes))
      return false;
    if (!(_ackLateFlag == rhs._ackLateFlag))
      return false;
    return true;
  }
  bool operator != (const LMCurtailCustomer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMCurtailCustomer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMCurtailCustomer &a, LMCurtailCustomer &b);

std::ostream& operator<<(std::ostream& out, const LMCurtailCustomer& obj);


class LMProgramCurtailment : public virtual ::apache::thrift::TBase {
 public:

  LMProgramCurtailment(const LMProgramCurtailment&);
  LMProgramCurtailment& operator=(const LMProgramCurtailment&);
  LMProgramCurtailment() : _minNotifyTime(0), _heading(), _messageHeader(), _messageFooter(), _acktimeLimit(0), _canceledMsg(), _stoppedEarlyMsg(), _curtailReferenceId(0), _actionDateTime(0), _notificationDateTime(0), _curtailmentStartTime(0), _curtailmentStopTime(0), _runStatus(), _additionalInfo() {
  }

  virtual ~LMProgramCurtailment() throw();
  LMProgramBase _baseMessage;
  int32_t _minNotifyTime;
  std::string _heading;
  std::string _messageHeader;
  std::string _messageFooter;
  int32_t _acktimeLimit;
  std::string _canceledMsg;
  std::string _stoppedEarlyMsg;
  int32_t _curtailReferenceId;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _actionDateTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _notificationDateTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _curtailmentStartTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _curtailmentStopTime;
  std::string _runStatus;
  std::string _additionalInfo;
  std::vector<LMCurtailCustomer>  _lmProgramCurtailmentCustomers;

  void __set__baseMessage(const LMProgramBase& val);

  void __set__minNotifyTime(const int32_t val);

  void __set__heading(const std::string& val);

  void __set__messageHeader(const std::string& val);

  void __set__messageFooter(const std::string& val);

  void __set__acktimeLimit(const int32_t val);

  void __set__canceledMsg(const std::string& val);

  void __set__stoppedEarlyMsg(const std::string& val);

  void __set__curtailReferenceId(const int32_t val);

  void __set__actionDateTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__notificationDateTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__curtailmentStartTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__curtailmentStopTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__runStatus(const std::string& val);

  void __set__additionalInfo(const std::string& val);

  void __set__lmProgramCurtailmentCustomers(const std::vector<LMCurtailCustomer> & val);

  bool operator == (const LMProgramCurtailment & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_minNotifyTime == rhs._minNotifyTime))
      return false;
    if (!(_heading == rhs._heading))
      return false;
    if (!(_messageHeader == rhs._messageHeader))
      return false;
    if (!(_messageFooter == rhs._messageFooter))
      return false;
    if (!(_acktimeLimit == rhs._acktimeLimit))
      return false;
    if (!(_canceledMsg == rhs._canceledMsg))
      return false;
    if (!(_stoppedEarlyMsg == rhs._stoppedEarlyMsg))
      return false;
    if (!(_curtailReferenceId == rhs._curtailReferenceId))
      return false;
    if (!(_actionDateTime == rhs._actionDateTime))
      return false;
    if (!(_notificationDateTime == rhs._notificationDateTime))
      return false;
    if (!(_curtailmentStartTime == rhs._curtailmentStartTime))
      return false;
    if (!(_curtailmentStopTime == rhs._curtailmentStopTime))
      return false;
    if (!(_runStatus == rhs._runStatus))
      return false;
    if (!(_additionalInfo == rhs._additionalInfo))
      return false;
    if (!(_lmProgramCurtailmentCustomers == rhs._lmProgramCurtailmentCustomers))
      return false;
    return true;
  }
  bool operator != (const LMProgramCurtailment &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramCurtailment & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMProgramCurtailment &a, LMProgramCurtailment &b);

std::ostream& operator<<(std::ostream& out, const LMProgramCurtailment& obj);


class LMProgramDirectGear : public virtual ::apache::thrift::TBase {
 public:

  LMProgramDirectGear(const LMProgramDirectGear&);
  LMProgramDirectGear& operator=(const LMProgramDirectGear&);
  LMProgramDirectGear() : _programPaoId(0), _gearName(), _gearNumber(0), _controlMethod(), _methodRate(0), _methodPeriod(0), _methodRateCount(0), _cyclereFreshRate(0), _methodStopType(), _changeCondition(), _changeDuration(0), _changePriority(0), _changeTriggerNumber(0), _changeTriggerOffset(0), _percentReduction(0), _groupSelectionMethod(), _methodOptionType(), _methodOptionMax(0), _rampInInterval(0), _rampInPercent(0), _rampOutInterval(0), _rampOutPercent(0), _kwReduction(0) {
  }

  virtual ~LMProgramDirectGear() throw();
  int32_t _programPaoId;
  std::string _gearName;
  int32_t _gearNumber;
  std::string _controlMethod;
  int32_t _methodRate;
  int32_t _methodPeriod;
  int32_t _methodRateCount;
  int32_t _cyclereFreshRate;
  std::string _methodStopType;
  std::string _changeCondition;
  int32_t _changeDuration;
  int32_t _changePriority;
  int32_t _changeTriggerNumber;
  double _changeTriggerOffset;
  int32_t _percentReduction;
  std::string _groupSelectionMethod;
  std::string _methodOptionType;
  int32_t _methodOptionMax;
  int32_t _rampInInterval;
  int32_t _rampInPercent;
  int32_t _rampOutInterval;
  int32_t _rampOutPercent;
  double _kwReduction;

  void __set__programPaoId(const int32_t val);

  void __set__gearName(const std::string& val);

  void __set__gearNumber(const int32_t val);

  void __set__controlMethod(const std::string& val);

  void __set__methodRate(const int32_t val);

  void __set__methodPeriod(const int32_t val);

  void __set__methodRateCount(const int32_t val);

  void __set__cyclereFreshRate(const int32_t val);

  void __set__methodStopType(const std::string& val);

  void __set__changeCondition(const std::string& val);

  void __set__changeDuration(const int32_t val);

  void __set__changePriority(const int32_t val);

  void __set__changeTriggerNumber(const int32_t val);

  void __set__changeTriggerOffset(const double val);

  void __set__percentReduction(const int32_t val);

  void __set__groupSelectionMethod(const std::string& val);

  void __set__methodOptionType(const std::string& val);

  void __set__methodOptionMax(const int32_t val);

  void __set__rampInInterval(const int32_t val);

  void __set__rampInPercent(const int32_t val);

  void __set__rampOutInterval(const int32_t val);

  void __set__rampOutPercent(const int32_t val);

  void __set__kwReduction(const double val);

  bool operator == (const LMProgramDirectGear & rhs) const
  {
    if (!(_programPaoId == rhs._programPaoId))
      return false;
    if (!(_gearName == rhs._gearName))
      return false;
    if (!(_gearNumber == rhs._gearNumber))
      return false;
    if (!(_controlMethod == rhs._controlMethod))
      return false;
    if (!(_methodRate == rhs._methodRate))
      return false;
    if (!(_methodPeriod == rhs._methodPeriod))
      return false;
    if (!(_methodRateCount == rhs._methodRateCount))
      return false;
    if (!(_cyclereFreshRate == rhs._cyclereFreshRate))
      return false;
    if (!(_methodStopType == rhs._methodStopType))
      return false;
    if (!(_changeCondition == rhs._changeCondition))
      return false;
    if (!(_changeDuration == rhs._changeDuration))
      return false;
    if (!(_changePriority == rhs._changePriority))
      return false;
    if (!(_changeTriggerNumber == rhs._changeTriggerNumber))
      return false;
    if (!(_changeTriggerOffset == rhs._changeTriggerOffset))
      return false;
    if (!(_percentReduction == rhs._percentReduction))
      return false;
    if (!(_groupSelectionMethod == rhs._groupSelectionMethod))
      return false;
    if (!(_methodOptionType == rhs._methodOptionType))
      return false;
    if (!(_methodOptionMax == rhs._methodOptionMax))
      return false;
    if (!(_rampInInterval == rhs._rampInInterval))
      return false;
    if (!(_rampInPercent == rhs._rampInPercent))
      return false;
    if (!(_rampOutInterval == rhs._rampOutInterval))
      return false;
    if (!(_rampOutPercent == rhs._rampOutPercent))
      return false;
    if (!(_kwReduction == rhs._kwReduction))
      return false;
    return true;
  }
  bool operator != (const LMProgramDirectGear &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramDirectGear & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMProgramDirectGear &a, LMProgramDirectGear &b);

std::ostream& operator<<(std::ostream& out, const LMProgramDirectGear& obj);


class LMGroupBase : public virtual ::apache::thrift::TBase {
 public:

  LMGroupBase(const LMGroupBase&);
  LMGroupBase& operator=(const LMGroupBase&);
  LMGroupBase() : _paoId(0), _paoCategory(), _paoClass(), _paoName(), _paoTypeString(), _paoDescription(), _disableFlag(0), _groupOrder(0), _kwCapacity(0), _childOrder(0), _alarmInhibit(0), _controlInhibit(0), _groupControlState(0), _currentHoursDaily(0), _currentHoursMonthly(0), _currentHoursSeasonal(0), _currentHoursAnnually(0), _lastControlSent(0), _controlStartTime(0), _controlCompleteTime(0), _nextControlTime(0), _internalState(0), _dailyOps(0), _lastStopTimeSent(0) {
  }

  virtual ~LMGroupBase() throw();
  int32_t _paoId;
  std::string _paoCategory;
  std::string _paoClass;
  std::string _paoName;
  std::string _paoTypeString;
  std::string _paoDescription;
  bool _disableFlag;
  int32_t _groupOrder;
  double _kwCapacity;
  int32_t _childOrder;
  bool _alarmInhibit;
  bool _controlInhibit;
  int32_t _groupControlState;
  int32_t _currentHoursDaily;
  int32_t _currentHoursMonthly;
  int32_t _currentHoursSeasonal;
  int32_t _currentHoursAnnually;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _lastControlSent;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _controlStartTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _controlCompleteTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _nextControlTime;
  int32_t _internalState;
  int32_t _dailyOps;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _lastStopTimeSent;

  void __set__paoId(const int32_t val);

  void __set__paoCategory(const std::string& val);

  void __set__paoClass(const std::string& val);

  void __set__paoName(const std::string& val);

  void __set__paoTypeString(const std::string& val);

  void __set__paoDescription(const std::string& val);

  void __set__disableFlag(const bool val);

  void __set__groupOrder(const int32_t val);

  void __set__kwCapacity(const double val);

  void __set__childOrder(const int32_t val);

  void __set__alarmInhibit(const bool val);

  void __set__controlInhibit(const bool val);

  void __set__groupControlState(const int32_t val);

  void __set__currentHoursDaily(const int32_t val);

  void __set__currentHoursMonthly(const int32_t val);

  void __set__currentHoursSeasonal(const int32_t val);

  void __set__currentHoursAnnually(const int32_t val);

  void __set__lastControlSent(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__controlStartTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__controlCompleteTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__nextControlTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__internalState(const int32_t val);

  void __set__dailyOps(const int32_t val);

  void __set__lastStopTimeSent(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  bool operator == (const LMGroupBase & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_paoCategory == rhs._paoCategory))
      return false;
    if (!(_paoClass == rhs._paoClass))
      return false;
    if (!(_paoName == rhs._paoName))
      return false;
    if (!(_paoTypeString == rhs._paoTypeString))
      return false;
    if (!(_paoDescription == rhs._paoDescription))
      return false;
    if (!(_disableFlag == rhs._disableFlag))
      return false;
    if (!(_groupOrder == rhs._groupOrder))
      return false;
    if (!(_kwCapacity == rhs._kwCapacity))
      return false;
    if (!(_childOrder == rhs._childOrder))
      return false;
    if (!(_alarmInhibit == rhs._alarmInhibit))
      return false;
    if (!(_controlInhibit == rhs._controlInhibit))
      return false;
    if (!(_groupControlState == rhs._groupControlState))
      return false;
    if (!(_currentHoursDaily == rhs._currentHoursDaily))
      return false;
    if (!(_currentHoursMonthly == rhs._currentHoursMonthly))
      return false;
    if (!(_currentHoursSeasonal == rhs._currentHoursSeasonal))
      return false;
    if (!(_currentHoursAnnually == rhs._currentHoursAnnually))
      return false;
    if (!(_lastControlSent == rhs._lastControlSent))
      return false;
    if (!(_controlStartTime == rhs._controlStartTime))
      return false;
    if (!(_controlCompleteTime == rhs._controlCompleteTime))
      return false;
    if (!(_nextControlTime == rhs._nextControlTime))
      return false;
    if (!(_internalState == rhs._internalState))
      return false;
    if (!(_dailyOps == rhs._dailyOps))
      return false;
    if (!(_lastStopTimeSent == rhs._lastStopTimeSent))
      return false;
    return true;
  }
  bool operator != (const LMGroupBase &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupBase & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupBase &a, LMGroupBase &b);

std::ostream& operator<<(std::ostream& out, const LMGroupBase& obj);


class LMGroupDigiSEP : public virtual ::apache::thrift::TBase {
 public:

  LMGroupDigiSEP(const LMGroupDigiSEP&);
  LMGroupDigiSEP& operator=(const LMGroupDigiSEP&);
  LMGroupDigiSEP() {
  }

  virtual ~LMGroupDigiSEP() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupDigiSEP & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupDigiSEP &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupDigiSEP & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupDigiSEP &a, LMGroupDigiSEP &b);

std::ostream& operator<<(std::ostream& out, const LMGroupDigiSEP& obj);


class LMGroupEcobee : public virtual ::apache::thrift::TBase {
 public:

  LMGroupEcobee(const LMGroupEcobee&);
  LMGroupEcobee& operator=(const LMGroupEcobee&);
  LMGroupEcobee() {
  }

  virtual ~LMGroupEcobee() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupEcobee & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupEcobee &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupEcobee & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupEcobee &a, LMGroupEcobee &b);

std::ostream& operator<<(std::ostream& out, const LMGroupEcobee& obj);


class LMGroupHoneywell : public virtual ::apache::thrift::TBase {
 public:

  LMGroupHoneywell(const LMGroupHoneywell&);
  LMGroupHoneywell& operator=(const LMGroupHoneywell&);
  LMGroupHoneywell() {
  }

  virtual ~LMGroupHoneywell() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupHoneywell & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupHoneywell &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupHoneywell & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupHoneywell &a, LMGroupHoneywell &b);

std::ostream& operator<<(std::ostream& out, const LMGroupHoneywell& obj);


class LMGroupEmetcon : public virtual ::apache::thrift::TBase {
 public:

  LMGroupEmetcon(const LMGroupEmetcon&);
  LMGroupEmetcon& operator=(const LMGroupEmetcon&);
  LMGroupEmetcon() {
  }

  virtual ~LMGroupEmetcon() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupEmetcon & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupEmetcon &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupEmetcon & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupEmetcon &a, LMGroupEmetcon &b);

std::ostream& operator<<(std::ostream& out, const LMGroupEmetcon& obj);


class LMGroupExpresscom : public virtual ::apache::thrift::TBase {
 public:

  LMGroupExpresscom(const LMGroupExpresscom&);
  LMGroupExpresscom& operator=(const LMGroupExpresscom&);
  LMGroupExpresscom() {
  }

  virtual ~LMGroupExpresscom() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupExpresscom & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupExpresscom &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupExpresscom & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupExpresscom &a, LMGroupExpresscom &b);

std::ostream& operator<<(std::ostream& out, const LMGroupExpresscom& obj);


class LMGroupGolay : public virtual ::apache::thrift::TBase {
 public:

  LMGroupGolay(const LMGroupGolay&);
  LMGroupGolay& operator=(const LMGroupGolay&);
  LMGroupGolay() {
  }

  virtual ~LMGroupGolay() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupGolay & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupGolay &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupGolay & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupGolay &a, LMGroupGolay &b);

std::ostream& operator<<(std::ostream& out, const LMGroupGolay& obj);


class LMGroupMacro : public virtual ::apache::thrift::TBase {
 public:

  LMGroupMacro(const LMGroupMacro&);
  LMGroupMacro& operator=(const LMGroupMacro&);
  LMGroupMacro() {
  }

  virtual ~LMGroupMacro() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupMacro & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupMacro &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupMacro & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupMacro &a, LMGroupMacro &b);

std::ostream& operator<<(std::ostream& out, const LMGroupMacro& obj);


class LMGroupMCT : public virtual ::apache::thrift::TBase {
 public:

  LMGroupMCT(const LMGroupMCT&);
  LMGroupMCT& operator=(const LMGroupMCT&);
  LMGroupMCT() {
  }

  virtual ~LMGroupMCT() throw();
  LMGroupEmetcon _baseMessage;

  void __set__baseMessage(const LMGroupEmetcon& val);

  bool operator == (const LMGroupMCT & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupMCT &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupMCT & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupMCT &a, LMGroupMCT &b);

std::ostream& operator<<(std::ostream& out, const LMGroupMCT& obj);


class LMGroupPoint : public virtual ::apache::thrift::TBase {
 public:

  LMGroupPoint(const LMGroupPoint&);
  LMGroupPoint& operator=(const LMGroupPoint&);
  LMGroupPoint() {
  }

  virtual ~LMGroupPoint() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupPoint & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupPoint &a, LMGroupPoint &b);

std::ostream& operator<<(std::ostream& out, const LMGroupPoint& obj);


class LMGroupRipple : public virtual ::apache::thrift::TBase {
 public:

  LMGroupRipple(const LMGroupRipple&);
  LMGroupRipple& operator=(const LMGroupRipple&);
  LMGroupRipple() : _shedTime(0) {
  }

  virtual ~LMGroupRipple() throw();
  LMGroupBase _baseMessage;
  int32_t _shedTime;

  void __set__baseMessage(const LMGroupBase& val);

  void __set__shedTime(const int32_t val);

  bool operator == (const LMGroupRipple & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_shedTime == rhs._shedTime))
      return false;
    return true;
  }
  bool operator != (const LMGroupRipple &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupRipple & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupRipple &a, LMGroupRipple &b);

std::ostream& operator<<(std::ostream& out, const LMGroupRipple& obj);


class LMGroupSA105 : public virtual ::apache::thrift::TBase {
 public:

  LMGroupSA105(const LMGroupSA105&);
  LMGroupSA105& operator=(const LMGroupSA105&);
  LMGroupSA105() {
  }

  virtual ~LMGroupSA105() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupSA105 & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupSA105 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupSA105 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupSA105 &a, LMGroupSA105 &b);

std::ostream& operator<<(std::ostream& out, const LMGroupSA105& obj);


class LMGroupSA205 : public virtual ::apache::thrift::TBase {
 public:

  LMGroupSA205(const LMGroupSA205&);
  LMGroupSA205& operator=(const LMGroupSA205&);
  LMGroupSA205() {
  }

  virtual ~LMGroupSA205() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupSA205 & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupSA205 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupSA205 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupSA205 &a, LMGroupSA205 &b);

std::ostream& operator<<(std::ostream& out, const LMGroupSA205& obj);


class LMGroupSA305 : public virtual ::apache::thrift::TBase {
 public:

  LMGroupSA305(const LMGroupSA305&);
  LMGroupSA305& operator=(const LMGroupSA305&);
  LMGroupSA305() {
  }

  virtual ~LMGroupSA305() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupSA305 & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupSA305 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupSA305 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupSA305 &a, LMGroupSA305 &b);

std::ostream& operator<<(std::ostream& out, const LMGroupSA305& obj);


class LMGroupSADigital : public virtual ::apache::thrift::TBase {
 public:

  LMGroupSADigital(const LMGroupSADigital&);
  LMGroupSADigital& operator=(const LMGroupSADigital&);
  LMGroupSADigital() {
  }

  virtual ~LMGroupSADigital() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupSADigital & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupSADigital &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupSADigital & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupSADigital &a, LMGroupSADigital &b);

std::ostream& operator<<(std::ostream& out, const LMGroupSADigital& obj);


class LMGroupVersacom : public virtual ::apache::thrift::TBase {
 public:

  LMGroupVersacom(const LMGroupVersacom&);
  LMGroupVersacom& operator=(const LMGroupVersacom&);
  LMGroupVersacom() {
  }

  virtual ~LMGroupVersacom() throw();
  LMGroupBase _baseMessage;

  void __set__baseMessage(const LMGroupBase& val);

  bool operator == (const LMGroupVersacom & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    return true;
  }
  bool operator != (const LMGroupVersacom &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMGroupVersacom & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMGroupVersacom &a, LMGroupVersacom &b);

std::ostream& operator<<(std::ostream& out, const LMGroupVersacom& obj);


class LMProgramDirect : public virtual ::apache::thrift::TBase {
 public:

  LMProgramDirect(const LMProgramDirect&);
  LMProgramDirect& operator=(const LMProgramDirect&);
  LMProgramDirect() : _currentGearNumber(0), _lastGroupControlled(0), _directStartTime(0), _directstopTime(0), _notifyActiveTime(0), _notifyInactiveTime(0), _startedRampingOut(0), _triggerOffset(0), _triggerRestoreOffset(0), _constraintOverride(0) {
  }

  virtual ~LMProgramDirect() throw();
  LMProgramBase _baseMessage;
  int32_t _currentGearNumber;
  int32_t _lastGroupControlled;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _directStartTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _directstopTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _notifyActiveTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _notifyInactiveTime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _startedRampingOut;
  int32_t _triggerOffset;
  int32_t _triggerRestoreOffset;
  bool _constraintOverride;
  std::vector<LMProgramDirectGear>  _lmProgramDirectGears;
  std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage>  _lmProgramDirectGroups;
  std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage>  _activeMasters;
  std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage>  _activeSubordinates;

  void __set__baseMessage(const LMProgramBase& val);

  void __set__currentGearNumber(const int32_t val);

  void __set__lastGroupControlled(const int32_t val);

  void __set__directStartTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__directstopTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__notifyActiveTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__notifyInactiveTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__startedRampingOut(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__triggerOffset(const int32_t val);

  void __set__triggerRestoreOffset(const int32_t val);

  void __set__constraintOverride(const bool val);

  void __set__lmProgramDirectGears(const std::vector<LMProgramDirectGear> & val);

  void __set__lmProgramDirectGroups(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val);

  void __set__activeMasters(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val);

  void __set__activeSubordinates(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val);

  bool operator == (const LMProgramDirect & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_currentGearNumber == rhs._currentGearNumber))
      return false;
    if (!(_lastGroupControlled == rhs._lastGroupControlled))
      return false;
    if (!(_directStartTime == rhs._directStartTime))
      return false;
    if (!(_directstopTime == rhs._directstopTime))
      return false;
    if (!(_notifyActiveTime == rhs._notifyActiveTime))
      return false;
    if (!(_notifyInactiveTime == rhs._notifyInactiveTime))
      return false;
    if (!(_startedRampingOut == rhs._startedRampingOut))
      return false;
    if (!(_triggerOffset == rhs._triggerOffset))
      return false;
    if (!(_triggerRestoreOffset == rhs._triggerRestoreOffset))
      return false;
    if (!(_constraintOverride == rhs._constraintOverride))
      return false;
    if (!(_lmProgramDirectGears == rhs._lmProgramDirectGears))
      return false;
    if (!(_lmProgramDirectGroups == rhs._lmProgramDirectGroups))
      return false;
    if (!(_activeMasters == rhs._activeMasters))
      return false;
    if (!(_activeSubordinates == rhs._activeSubordinates))
      return false;
    return true;
  }
  bool operator != (const LMProgramDirect &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramDirect & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMProgramDirect &a, LMProgramDirect &b);

std::ostream& operator<<(std::ostream& out, const LMProgramDirect& obj);


class LMEnergyExchangeHourlyOffer : public virtual ::apache::thrift::TBase {
 public:

  LMEnergyExchangeHourlyOffer(const LMEnergyExchangeHourlyOffer&);
  LMEnergyExchangeHourlyOffer& operator=(const LMEnergyExchangeHourlyOffer&);
  LMEnergyExchangeHourlyOffer() : _offerId(0), _revisionNumber(0), _hour(0), _price(0), _amountRequested(0) {
  }

  virtual ~LMEnergyExchangeHourlyOffer() throw();
  int32_t _offerId;
  int32_t _revisionNumber;
  int32_t _hour;
  double _price;
  double _amountRequested;

  void __set__offerId(const int32_t val);

  void __set__revisionNumber(const int32_t val);

  void __set__hour(const int32_t val);

  void __set__price(const double val);

  void __set__amountRequested(const double val);

  bool operator == (const LMEnergyExchangeHourlyOffer & rhs) const
  {
    if (!(_offerId == rhs._offerId))
      return false;
    if (!(_revisionNumber == rhs._revisionNumber))
      return false;
    if (!(_hour == rhs._hour))
      return false;
    if (!(_price == rhs._price))
      return false;
    if (!(_amountRequested == rhs._amountRequested))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeHourlyOffer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeHourlyOffer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMEnergyExchangeHourlyOffer &a, LMEnergyExchangeHourlyOffer &b);

std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeHourlyOffer& obj);


class LMEnergyExchangeOfferRevision : public virtual ::apache::thrift::TBase {
 public:

  LMEnergyExchangeOfferRevision(const LMEnergyExchangeOfferRevision&);
  LMEnergyExchangeOfferRevision& operator=(const LMEnergyExchangeOfferRevision&);
  LMEnergyExchangeOfferRevision() : _offerId(0), _revisionNumber(0), _actionDatetime(0), _notificationDatetime(0), _offerexpirationDatetime(0), _additionalInfo() {
  }

  virtual ~LMEnergyExchangeOfferRevision() throw();
  int32_t _offerId;
  int32_t _revisionNumber;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _actionDatetime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _notificationDatetime;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _offerexpirationDatetime;
  std::string _additionalInfo;
  std::vector<LMEnergyExchangeHourlyOffer>  _lmEnergyExchangeHourlyOffers;

  void __set__offerId(const int32_t val);

  void __set__revisionNumber(const int32_t val);

  void __set__actionDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__notificationDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__offerexpirationDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__additionalInfo(const std::string& val);

  void __set__lmEnergyExchangeHourlyOffers(const std::vector<LMEnergyExchangeHourlyOffer> & val);

  bool operator == (const LMEnergyExchangeOfferRevision & rhs) const
  {
    if (!(_offerId == rhs._offerId))
      return false;
    if (!(_revisionNumber == rhs._revisionNumber))
      return false;
    if (!(_actionDatetime == rhs._actionDatetime))
      return false;
    if (!(_notificationDatetime == rhs._notificationDatetime))
      return false;
    if (!(_offerexpirationDatetime == rhs._offerexpirationDatetime))
      return false;
    if (!(_additionalInfo == rhs._additionalInfo))
      return false;
    if (!(_lmEnergyExchangeHourlyOffers == rhs._lmEnergyExchangeHourlyOffers))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeOfferRevision &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeOfferRevision & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMEnergyExchangeOfferRevision &a, LMEnergyExchangeOfferRevision &b);

std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeOfferRevision& obj);


class LMEnergyExchangeOffer : public virtual ::apache::thrift::TBase {
 public:

  LMEnergyExchangeOffer(const LMEnergyExchangeOffer&);
  LMEnergyExchangeOffer& operator=(const LMEnergyExchangeOffer&);
  LMEnergyExchangeOffer() : _paoId(0), _offerId(0), _runStatus(), _offerDate(0) {
  }

  virtual ~LMEnergyExchangeOffer() throw();
  int32_t _paoId;
  int32_t _offerId;
  std::string _runStatus;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _offerDate;
  std::vector<LMEnergyExchangeOfferRevision>  _lmEnergyExchangeOfferRevisions;

  void __set__paoId(const int32_t val);

  void __set__offerId(const int32_t val);

  void __set__runStatus(const std::string& val);

  void __set__offerDate(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__lmEnergyExchangeOfferRevisions(const std::vector<LMEnergyExchangeOfferRevision> & val);

  bool operator == (const LMEnergyExchangeOffer & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_offerId == rhs._offerId))
      return false;
    if (!(_runStatus == rhs._runStatus))
      return false;
    if (!(_offerDate == rhs._offerDate))
      return false;
    if (!(_lmEnergyExchangeOfferRevisions == rhs._lmEnergyExchangeOfferRevisions))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeOffer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeOffer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMEnergyExchangeOffer &a, LMEnergyExchangeOffer &b);

std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeOffer& obj);


class LMEnergyExchangeHourlyCustomer : public virtual ::apache::thrift::TBase {
 public:

  LMEnergyExchangeHourlyCustomer(const LMEnergyExchangeHourlyCustomer&);
  LMEnergyExchangeHourlyCustomer& operator=(const LMEnergyExchangeHourlyCustomer&);
  LMEnergyExchangeHourlyCustomer() : _customerId(0), _offerId(0), _revisionNumber(0), _hour(0), _amountCommitted(0) {
  }

  virtual ~LMEnergyExchangeHourlyCustomer() throw();
  int32_t _customerId;
  int32_t _offerId;
  int32_t _revisionNumber;
  int32_t _hour;
  double _amountCommitted;

  void __set__customerId(const int32_t val);

  void __set__offerId(const int32_t val);

  void __set__revisionNumber(const int32_t val);

  void __set__hour(const int32_t val);

  void __set__amountCommitted(const double val);

  bool operator == (const LMEnergyExchangeHourlyCustomer & rhs) const
  {
    if (!(_customerId == rhs._customerId))
      return false;
    if (!(_offerId == rhs._offerId))
      return false;
    if (!(_revisionNumber == rhs._revisionNumber))
      return false;
    if (!(_hour == rhs._hour))
      return false;
    if (!(_amountCommitted == rhs._amountCommitted))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeHourlyCustomer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeHourlyCustomer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMEnergyExchangeHourlyCustomer &a, LMEnergyExchangeHourlyCustomer &b);

std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeHourlyCustomer& obj);


class LMEnergyExchangeCustomerReply : public virtual ::apache::thrift::TBase {
 public:

  LMEnergyExchangeCustomerReply(const LMEnergyExchangeCustomerReply&);
  LMEnergyExchangeCustomerReply& operator=(const LMEnergyExchangeCustomerReply&);
  LMEnergyExchangeCustomerReply() : _customerId(0), _offerId(0), _acceptStatus(), _acceptDatetime(0), _revisionNumber(0), _ipAddressOfAcceptUser(), _userIdName(), _nameOfAcceptPerson(), _energyExchangeNotes() {
  }

  virtual ~LMEnergyExchangeCustomerReply() throw();
  int32_t _customerId;
  int32_t _offerId;
  std::string _acceptStatus;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _acceptDatetime;
  int32_t _revisionNumber;
  std::string _ipAddressOfAcceptUser;
  std::string _userIdName;
  std::string _nameOfAcceptPerson;
  std::string _energyExchangeNotes;
  std::vector<LMEnergyExchangeHourlyCustomer>  _lmEnergyExchangeHourlyCustomers;

  void __set__customerId(const int32_t val);

  void __set__offerId(const int32_t val);

  void __set__acceptStatus(const std::string& val);

  void __set__acceptDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__revisionNumber(const int32_t val);

  void __set__ipAddressOfAcceptUser(const std::string& val);

  void __set__userIdName(const std::string& val);

  void __set__nameOfAcceptPerson(const std::string& val);

  void __set__energyExchangeNotes(const std::string& val);

  void __set__lmEnergyExchangeHourlyCustomers(const std::vector<LMEnergyExchangeHourlyCustomer> & val);

  bool operator == (const LMEnergyExchangeCustomerReply & rhs) const
  {
    if (!(_customerId == rhs._customerId))
      return false;
    if (!(_offerId == rhs._offerId))
      return false;
    if (!(_acceptStatus == rhs._acceptStatus))
      return false;
    if (!(_acceptDatetime == rhs._acceptDatetime))
      return false;
    if (!(_revisionNumber == rhs._revisionNumber))
      return false;
    if (!(_ipAddressOfAcceptUser == rhs._ipAddressOfAcceptUser))
      return false;
    if (!(_userIdName == rhs._userIdName))
      return false;
    if (!(_nameOfAcceptPerson == rhs._nameOfAcceptPerson))
      return false;
    if (!(_energyExchangeNotes == rhs._energyExchangeNotes))
      return false;
    if (!(_lmEnergyExchangeHourlyCustomers == rhs._lmEnergyExchangeHourlyCustomers))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeCustomerReply &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeCustomerReply & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMEnergyExchangeCustomerReply &a, LMEnergyExchangeCustomerReply &b);

std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeCustomerReply& obj);


class LMEnergyExchangeCustomer : public virtual ::apache::thrift::TBase {
 public:

  LMEnergyExchangeCustomer(const LMEnergyExchangeCustomer&);
  LMEnergyExchangeCustomer& operator=(const LMEnergyExchangeCustomer&);
  LMEnergyExchangeCustomer() {
  }

  virtual ~LMEnergyExchangeCustomer() throw();
  LMCICustomerBase _baseMessage;
  std::vector<LMEnergyExchangeCustomerReply>  _lmEnergyExchangeCustomerReplies;

  void __set__baseMessage(const LMCICustomerBase& val);

  void __set__lmEnergyExchangeCustomerReplies(const std::vector<LMEnergyExchangeCustomerReply> & val);

  bool operator == (const LMEnergyExchangeCustomer & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_lmEnergyExchangeCustomerReplies == rhs._lmEnergyExchangeCustomerReplies))
      return false;
    return true;
  }
  bool operator != (const LMEnergyExchangeCustomer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMEnergyExchangeCustomer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMEnergyExchangeCustomer &a, LMEnergyExchangeCustomer &b);

std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeCustomer& obj);


class LMProgramEnergyExchange : public virtual ::apache::thrift::TBase {
 public:

  LMProgramEnergyExchange(const LMProgramEnergyExchange&);
  LMProgramEnergyExchange& operator=(const LMProgramEnergyExchange&);
  LMProgramEnergyExchange() : _minNotifyTime(0), _heading(), _messageHeader(), _messageFooter(), _canceledMsg(), _stoppedEarlyMsg() {
  }

  virtual ~LMProgramEnergyExchange() throw();
  LMProgramBase _baseMessage;
  int32_t _minNotifyTime;
  std::string _heading;
  std::string _messageHeader;
  std::string _messageFooter;
  std::string _canceledMsg;
  std::string _stoppedEarlyMsg;
  std::vector<LMEnergyExchangeOffer>  _lmEnergyExchangeOffers;
  std::vector<LMEnergyExchangeCustomer>  _lmEnergyExchangeCustomers;

  void __set__baseMessage(const LMProgramBase& val);

  void __set__minNotifyTime(const int32_t val);

  void __set__heading(const std::string& val);

  void __set__messageHeader(const std::string& val);

  void __set__messageFooter(const std::string& val);

  void __set__canceledMsg(const std::string& val);

  void __set__stoppedEarlyMsg(const std::string& val);

  void __set__lmEnergyExchangeOffers(const std::vector<LMEnergyExchangeOffer> & val);

  void __set__lmEnergyExchangeCustomers(const std::vector<LMEnergyExchangeCustomer> & val);

  bool operator == (const LMProgramEnergyExchange & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_minNotifyTime == rhs._minNotifyTime))
      return false;
    if (!(_heading == rhs._heading))
      return false;
    if (!(_messageHeader == rhs._messageHeader))
      return false;
    if (!(_messageFooter == rhs._messageFooter))
      return false;
    if (!(_canceledMsg == rhs._canceledMsg))
      return false;
    if (!(_stoppedEarlyMsg == rhs._stoppedEarlyMsg))
      return false;
    if (!(_lmEnergyExchangeOffers == rhs._lmEnergyExchangeOffers))
      return false;
    if (!(_lmEnergyExchangeCustomers == rhs._lmEnergyExchangeCustomers))
      return false;
    return true;
  }
  bool operator != (const LMProgramEnergyExchange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMProgramEnergyExchange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMProgramEnergyExchange &a, LMProgramEnergyExchange &b);

std::ostream& operator<<(std::ostream& out, const LMProgramEnergyExchange& obj);


class LMControlAreaItem : public virtual ::apache::thrift::TBase {
 public:

  LMControlAreaItem(const LMControlAreaItem&);
  LMControlAreaItem& operator=(const LMControlAreaItem&);
  LMControlAreaItem() : _paoId(0), _paoCategory(), _paoClass(), _paoName(), _paoTypeString(), _paoDescription(), _disableFlag(0), _defOperationalState(), _controlInterval(0), _minResponseTime(0), _defDailyStartTime(0), _defDailyStopTime(0), _requireAllTriggersActiveFlag(0), _nextCheckTime(0), _newPointDataReceivedFlag(0), _updatedFlag(0), _controlAreaStatusPointId(0), _controlAreaState(0), _currentPriority(0), _currentDailyStartTime(0), _currentDailyStopTime(0) {
  }

  virtual ~LMControlAreaItem() throw();
  int32_t _paoId;
  std::string _paoCategory;
  std::string _paoClass;
  std::string _paoName;
  std::string _paoTypeString;
  std::string _paoDescription;
  bool _disableFlag;
  std::string _defOperationalState;
  int32_t _controlInterval;
  int32_t _minResponseTime;
  int32_t _defDailyStartTime;
  int32_t _defDailyStopTime;
  bool _requireAllTriggersActiveFlag;
   ::Cti::Messaging::Serialization::Thrift::Timestamp _nextCheckTime;
  bool _newPointDataReceivedFlag;
  bool _updatedFlag;
  int32_t _controlAreaStatusPointId;
  int32_t _controlAreaState;
  int32_t _currentPriority;
  int32_t _currentDailyStartTime;
  int32_t _currentDailyStopTime;
  std::vector<LMControlAreaTrigger>  _lmControlAreaTriggers;
  std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage>  _lmPrograms;

  void __set__paoId(const int32_t val);

  void __set__paoCategory(const std::string& val);

  void __set__paoClass(const std::string& val);

  void __set__paoName(const std::string& val);

  void __set__paoTypeString(const std::string& val);

  void __set__paoDescription(const std::string& val);

  void __set__disableFlag(const bool val);

  void __set__defOperationalState(const std::string& val);

  void __set__controlInterval(const int32_t val);

  void __set__minResponseTime(const int32_t val);

  void __set__defDailyStartTime(const int32_t val);

  void __set__defDailyStopTime(const int32_t val);

  void __set__requireAllTriggersActiveFlag(const bool val);

  void __set__nextCheckTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val);

  void __set__newPointDataReceivedFlag(const bool val);

  void __set__updatedFlag(const bool val);

  void __set__controlAreaStatusPointId(const int32_t val);

  void __set__controlAreaState(const int32_t val);

  void __set__currentPriority(const int32_t val);

  void __set__currentDailyStartTime(const int32_t val);

  void __set__currentDailyStopTime(const int32_t val);

  void __set__lmControlAreaTriggers(const std::vector<LMControlAreaTrigger> & val);

  void __set__lmPrograms(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val);

  bool operator == (const LMControlAreaItem & rhs) const
  {
    if (!(_paoId == rhs._paoId))
      return false;
    if (!(_paoCategory == rhs._paoCategory))
      return false;
    if (!(_paoClass == rhs._paoClass))
      return false;
    if (!(_paoName == rhs._paoName))
      return false;
    if (!(_paoTypeString == rhs._paoTypeString))
      return false;
    if (!(_paoDescription == rhs._paoDescription))
      return false;
    if (!(_disableFlag == rhs._disableFlag))
      return false;
    if (!(_defOperationalState == rhs._defOperationalState))
      return false;
    if (!(_controlInterval == rhs._controlInterval))
      return false;
    if (!(_minResponseTime == rhs._minResponseTime))
      return false;
    if (!(_defDailyStartTime == rhs._defDailyStartTime))
      return false;
    if (!(_defDailyStopTime == rhs._defDailyStopTime))
      return false;
    if (!(_requireAllTriggersActiveFlag == rhs._requireAllTriggersActiveFlag))
      return false;
    if (!(_nextCheckTime == rhs._nextCheckTime))
      return false;
    if (!(_newPointDataReceivedFlag == rhs._newPointDataReceivedFlag))
      return false;
    if (!(_updatedFlag == rhs._updatedFlag))
      return false;
    if (!(_controlAreaStatusPointId == rhs._controlAreaStatusPointId))
      return false;
    if (!(_controlAreaState == rhs._controlAreaState))
      return false;
    if (!(_currentPriority == rhs._currentPriority))
      return false;
    if (!(_currentDailyStartTime == rhs._currentDailyStartTime))
      return false;
    if (!(_currentDailyStopTime == rhs._currentDailyStopTime))
      return false;
    if (!(_lmControlAreaTriggers == rhs._lmControlAreaTriggers))
      return false;
    if (!(_lmPrograms == rhs._lmPrograms))
      return false;
    return true;
  }
  bool operator != (const LMControlAreaItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMControlAreaItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMControlAreaItem &a, LMControlAreaItem &b);

std::ostream& operator<<(std::ostream& out, const LMControlAreaItem& obj);


class LMControlAreas : public virtual ::apache::thrift::TBase {
 public:

  LMControlAreas(const LMControlAreas&);
  LMControlAreas& operator=(const LMControlAreas&);
  LMControlAreas() : _msgInfoBitMask(0) {
  }

  virtual ~LMControlAreas() throw();
   ::Cti::Messaging::Serialization::Thrift::LMMessage _baseMessage;
  int32_t _msgInfoBitMask;
  std::vector<LMControlAreaItem>  _controlAreas;

  void __set__baseMessage(const  ::Cti::Messaging::Serialization::Thrift::LMMessage& val);

  void __set__msgInfoBitMask(const int32_t val);

  void __set__controlAreas(const std::vector<LMControlAreaItem> & val);

  bool operator == (const LMControlAreas & rhs) const
  {
    if (!(_baseMessage == rhs._baseMessage))
      return false;
    if (!(_msgInfoBitMask == rhs._msgInfoBitMask))
      return false;
    if (!(_controlAreas == rhs._controlAreas))
      return false;
    return true;
  }
  bool operator != (const LMControlAreas &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LMControlAreas & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(LMControlAreas &a, LMControlAreas &b);

std::ostream& operator<<(std::ostream& out, const LMControlAreas& obj);

}}}} // namespace

#endif
