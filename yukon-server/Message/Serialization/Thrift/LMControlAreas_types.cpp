/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "LMControlAreas_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Cti { namespace Messaging { namespace Serialization { namespace Thrift {


LMControlAreaTrigger::~LMControlAreaTrigger() noexcept {
}


void LMControlAreaTrigger::__set__paoId(const int32_t val) {
  this->_paoId = val;
}

void LMControlAreaTrigger::__set__triggerNumber(const int32_t val) {
  this->_triggerNumber = val;
}

void LMControlAreaTrigger::__set__triggerType(const std::string& val) {
  this->_triggerType = val;
}

void LMControlAreaTrigger::__set__pointId(const int32_t val) {
  this->_pointId = val;
}

void LMControlAreaTrigger::__set__pointValue(const double val) {
  this->_pointValue = val;
}

void LMControlAreaTrigger::__set__lastPointValueTimestamp(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_lastPointValueTimestamp = val;
}

void LMControlAreaTrigger::__set__normalState(const int32_t val) {
  this->_normalState = val;
}

void LMControlAreaTrigger::__set__threshold(const double val) {
  this->_threshold = val;
}

void LMControlAreaTrigger::__set__projectionType(const std::string& val) {
  this->_projectionType = val;
}

void LMControlAreaTrigger::__set__projectionPoints(const int32_t val) {
  this->_projectionPoints = val;
}

void LMControlAreaTrigger::__set__projectAheadDuration(const int32_t val) {
  this->_projectAheadDuration = val;
}

void LMControlAreaTrigger::__set__thresholdKickPercent(const int32_t val) {
  this->_thresholdKickPercent = val;
}

void LMControlAreaTrigger::__set__minRestoreOffset(const double val) {
  this->_minRestoreOffset = val;
}

void LMControlAreaTrigger::__set__peakPointId(const int32_t val) {
  this->_peakPointId = val;
}

void LMControlAreaTrigger::__set__peakPointValue(const double val) {
  this->_peakPointValue = val;
}

void LMControlAreaTrigger::__set__lastPeakPointValueTimestamp(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_lastPeakPointValueTimestamp = val;
}

void LMControlAreaTrigger::__set__projectedPointValue(const double val) {
  this->_projectedPointValue = val;
}
std::ostream& operator<<(std::ostream& out, const LMControlAreaTrigger& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMControlAreaTrigger::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__paoId = false;
  bool isset__triggerNumber = false;
  bool isset__triggerType = false;
  bool isset__pointId = false;
  bool isset__pointValue = false;
  bool isset__lastPointValueTimestamp = false;
  bool isset__normalState = false;
  bool isset__threshold = false;
  bool isset__projectionType = false;
  bool isset__projectionPoints = false;
  bool isset__projectAheadDuration = false;
  bool isset__thresholdKickPercent = false;
  bool isset__minRestoreOffset = false;
  bool isset__peakPointId = false;
  bool isset__peakPointValue = false;
  bool isset__lastPeakPointValueTimestamp = false;
  bool isset__projectedPointValue = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_paoId);
          isset__paoId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_triggerNumber);
          isset__triggerNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_triggerType);
          isset__triggerType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_pointId);
          isset__pointId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_pointValue);
          isset__pointValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_lastPointValueTimestamp);
          isset__lastPointValueTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_normalState);
          isset__normalState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_threshold);
          isset__threshold = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_projectionType);
          isset__projectionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_projectionPoints);
          isset__projectionPoints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_projectAheadDuration);
          isset__projectAheadDuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_thresholdKickPercent);
          isset__thresholdKickPercent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_minRestoreOffset);
          isset__minRestoreOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_peakPointId);
          isset__peakPointId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_peakPointValue);
          isset__peakPointValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_lastPeakPointValueTimestamp);
          isset__lastPeakPointValueTimestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_projectedPointValue);
          isset__projectedPointValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__paoId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__triggerNumber)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__triggerType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__pointId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__pointValue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lastPointValueTimestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__normalState)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__threshold)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__projectionType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__projectionPoints)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__projectAheadDuration)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__thresholdKickPercent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__minRestoreOffset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__peakPointId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__peakPointValue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lastPeakPointValueTimestamp)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__projectedPointValue)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMControlAreaTrigger::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMControlAreaTrigger");

  xfer += oprot->writeFieldBegin("_paoId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_paoId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_triggerNumber", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_triggerNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_triggerType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->_triggerType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_pointId", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->_pointId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_pointValue", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->_pointValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lastPointValueTimestamp", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->_lastPointValueTimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_normalState", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->_normalState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_threshold", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->_threshold);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_projectionType", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->_projectionType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_projectionPoints", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->_projectionPoints);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_projectAheadDuration", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->_projectAheadDuration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_thresholdKickPercent", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->_thresholdKickPercent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_minRestoreOffset", ::apache::thrift::protocol::T_DOUBLE, 13);
  xfer += oprot->writeDouble(this->_minRestoreOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_peakPointId", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->_peakPointId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_peakPointValue", ::apache::thrift::protocol::T_DOUBLE, 15);
  xfer += oprot->writeDouble(this->_peakPointValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lastPeakPointValueTimestamp", ::apache::thrift::protocol::T_I64, 16);
  xfer += oprot->writeI64(this->_lastPeakPointValueTimestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_projectedPointValue", ::apache::thrift::protocol::T_DOUBLE, 17);
  xfer += oprot->writeDouble(this->_projectedPointValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMControlAreaTrigger &a, LMControlAreaTrigger &b) {
  using ::std::swap;
  swap(a._paoId, b._paoId);
  swap(a._triggerNumber, b._triggerNumber);
  swap(a._triggerType, b._triggerType);
  swap(a._pointId, b._pointId);
  swap(a._pointValue, b._pointValue);
  swap(a._lastPointValueTimestamp, b._lastPointValueTimestamp);
  swap(a._normalState, b._normalState);
  swap(a._threshold, b._threshold);
  swap(a._projectionType, b._projectionType);
  swap(a._projectionPoints, b._projectionPoints);
  swap(a._projectAheadDuration, b._projectAheadDuration);
  swap(a._thresholdKickPercent, b._thresholdKickPercent);
  swap(a._minRestoreOffset, b._minRestoreOffset);
  swap(a._peakPointId, b._peakPointId);
  swap(a._peakPointValue, b._peakPointValue);
  swap(a._lastPeakPointValueTimestamp, b._lastPeakPointValueTimestamp);
  swap(a._projectedPointValue, b._projectedPointValue);
}

LMControlAreaTrigger::LMControlAreaTrigger(const LMControlAreaTrigger& other0) {
  _paoId = other0._paoId;
  _triggerNumber = other0._triggerNumber;
  _triggerType = other0._triggerType;
  _pointId = other0._pointId;
  _pointValue = other0._pointValue;
  _lastPointValueTimestamp = other0._lastPointValueTimestamp;
  _normalState = other0._normalState;
  _threshold = other0._threshold;
  _projectionType = other0._projectionType;
  _projectionPoints = other0._projectionPoints;
  _projectAheadDuration = other0._projectAheadDuration;
  _thresholdKickPercent = other0._thresholdKickPercent;
  _minRestoreOffset = other0._minRestoreOffset;
  _peakPointId = other0._peakPointId;
  _peakPointValue = other0._peakPointValue;
  _lastPeakPointValueTimestamp = other0._lastPeakPointValueTimestamp;
  _projectedPointValue = other0._projectedPointValue;
}
LMControlAreaTrigger& LMControlAreaTrigger::operator=(const LMControlAreaTrigger& other1) {
  _paoId = other1._paoId;
  _triggerNumber = other1._triggerNumber;
  _triggerType = other1._triggerType;
  _pointId = other1._pointId;
  _pointValue = other1._pointValue;
  _lastPointValueTimestamp = other1._lastPointValueTimestamp;
  _normalState = other1._normalState;
  _threshold = other1._threshold;
  _projectionType = other1._projectionType;
  _projectionPoints = other1._projectionPoints;
  _projectAheadDuration = other1._projectAheadDuration;
  _thresholdKickPercent = other1._thresholdKickPercent;
  _minRestoreOffset = other1._minRestoreOffset;
  _peakPointId = other1._peakPointId;
  _peakPointValue = other1._peakPointValue;
  _lastPeakPointValueTimestamp = other1._lastPeakPointValueTimestamp;
  _projectedPointValue = other1._projectedPointValue;
  return *this;
}
void LMControlAreaTrigger::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMControlAreaTrigger(";
  out << "_paoId=" << to_string(_paoId);
  out << ", " << "_triggerNumber=" << to_string(_triggerNumber);
  out << ", " << "_triggerType=" << to_string(_triggerType);
  out << ", " << "_pointId=" << to_string(_pointId);
  out << ", " << "_pointValue=" << to_string(_pointValue);
  out << ", " << "_lastPointValueTimestamp=" << to_string(_lastPointValueTimestamp);
  out << ", " << "_normalState=" << to_string(_normalState);
  out << ", " << "_threshold=" << to_string(_threshold);
  out << ", " << "_projectionType=" << to_string(_projectionType);
  out << ", " << "_projectionPoints=" << to_string(_projectionPoints);
  out << ", " << "_projectAheadDuration=" << to_string(_projectAheadDuration);
  out << ", " << "_thresholdKickPercent=" << to_string(_thresholdKickPercent);
  out << ", " << "_minRestoreOffset=" << to_string(_minRestoreOffset);
  out << ", " << "_peakPointId=" << to_string(_peakPointId);
  out << ", " << "_peakPointValue=" << to_string(_peakPointValue);
  out << ", " << "_lastPeakPointValueTimestamp=" << to_string(_lastPeakPointValueTimestamp);
  out << ", " << "_projectedPointValue=" << to_string(_projectedPointValue);
  out << ")";
}


LMProgramControlWindow::~LMProgramControlWindow() noexcept {
}


void LMProgramControlWindow::__set__paoId(const int32_t val) {
  this->_paoId = val;
}

void LMProgramControlWindow::__set__windowNumber(const int32_t val) {
  this->_windowNumber = val;
}

void LMProgramControlWindow::__set__availableStartTime(const int32_t val) {
  this->_availableStartTime = val;
}

void LMProgramControlWindow::__set__availableStopTime(const int32_t val) {
  this->_availableStopTime = val;
}
std::ostream& operator<<(std::ostream& out, const LMProgramControlWindow& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMProgramControlWindow::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__paoId = false;
  bool isset__windowNumber = false;
  bool isset__availableStartTime = false;
  bool isset__availableStopTime = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_paoId);
          isset__paoId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_windowNumber);
          isset__windowNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_availableStartTime);
          isset__availableStartTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_availableStopTime);
          isset__availableStopTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__paoId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__windowNumber)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__availableStartTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__availableStopTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMProgramControlWindow::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMProgramControlWindow");

  xfer += oprot->writeFieldBegin("_paoId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_paoId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_windowNumber", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_windowNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_availableStartTime", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->_availableStartTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_availableStopTime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->_availableStopTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMProgramControlWindow &a, LMProgramControlWindow &b) {
  using ::std::swap;
  swap(a._paoId, b._paoId);
  swap(a._windowNumber, b._windowNumber);
  swap(a._availableStartTime, b._availableStartTime);
  swap(a._availableStopTime, b._availableStopTime);
}

LMProgramControlWindow::LMProgramControlWindow(const LMProgramControlWindow& other2) {
  _paoId = other2._paoId;
  _windowNumber = other2._windowNumber;
  _availableStartTime = other2._availableStartTime;
  _availableStopTime = other2._availableStopTime;
}
LMProgramControlWindow& LMProgramControlWindow::operator=(const LMProgramControlWindow& other3) {
  _paoId = other3._paoId;
  _windowNumber = other3._windowNumber;
  _availableStartTime = other3._availableStartTime;
  _availableStopTime = other3._availableStopTime;
  return *this;
}
void LMProgramControlWindow::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMProgramControlWindow(";
  out << "_paoId=" << to_string(_paoId);
  out << ", " << "_windowNumber=" << to_string(_windowNumber);
  out << ", " << "_availableStartTime=" << to_string(_availableStartTime);
  out << ", " << "_availableStopTime=" << to_string(_availableStopTime);
  out << ")";
}


LMProgramBase::~LMProgramBase() noexcept {
}


void LMProgramBase::__set__paoId(const int32_t val) {
  this->_paoId = val;
}

void LMProgramBase::__set__paoCategory(const std::string& val) {
  this->_paoCategory = val;
}

void LMProgramBase::__set__paoClass(const std::string& val) {
  this->_paoClass = val;
}

void LMProgramBase::__set__paoName(const std::string& val) {
  this->_paoName = val;
}

void LMProgramBase::__set__paoTypeString(const std::string& val) {
  this->_paoTypeString = val;
}

void LMProgramBase::__set__paoDescription(const std::string& val) {
  this->_paoDescription = val;
}

void LMProgramBase::__set__disableFlag(const bool val) {
  this->_disableFlag = val;
}

void LMProgramBase::__set__startPriority(const int32_t val) {
  this->_startPriority = val;
}

void LMProgramBase::__set__stopPriority(const int32_t val) {
  this->_stopPriority = val;
}

void LMProgramBase::__set__controlType(const std::string& val) {
  this->_controlType = val;
}

void LMProgramBase::__set__availableWeekdays(const std::string& val) {
  this->_availableWeekdays = val;
}

void LMProgramBase::__set__maxHoursDaily(const int32_t val) {
  this->_maxHoursDaily = val;
}

void LMProgramBase::__set__maxHoursMonthly(const int32_t val) {
  this->_maxHoursMonthly = val;
}

void LMProgramBase::__set__maxHoursSeasonal(const int32_t val) {
  this->_maxHoursSeasonal = val;
}

void LMProgramBase::__set__maxHoursAnnually(const int32_t val) {
  this->_maxHoursAnnually = val;
}

void LMProgramBase::__set__minActivateTime(const int32_t val) {
  this->_minActivateTime = val;
}

void LMProgramBase::__set__minRestartTime(const int32_t val) {
  this->_minRestartTime = val;
}

void LMProgramBase::__set__programStatusPointId(const int32_t val) {
  this->_programStatusPointId = val;
}

void LMProgramBase::__set__programState(const int32_t val) {
  this->_programState = val;
}

void LMProgramBase::__set__reductionAnalogPointId(const int32_t val) {
  this->_reductionAnalogPointId = val;
}

void LMProgramBase::__set__reductionTotal(const double val) {
  this->_reductionTotal = val;
}

void LMProgramBase::__set__startedControlling(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_startedControlling = val;
}

void LMProgramBase::__set__lastControlSent(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_lastControlSent = val;
}

void LMProgramBase::__set__manualControlReceivedFlag(const bool val) {
  this->_manualControlReceivedFlag = val;
}

void LMProgramBase::__set__lmProgramControlWindows(const std::vector<LMProgramControlWindow> & val) {
  this->_lmProgramControlWindows = val;
}
std::ostream& operator<<(std::ostream& out, const LMProgramBase& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMProgramBase::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__paoId = false;
  bool isset__paoCategory = false;
  bool isset__paoClass = false;
  bool isset__paoName = false;
  bool isset__paoTypeString = false;
  bool isset__paoDescription = false;
  bool isset__disableFlag = false;
  bool isset__startPriority = false;
  bool isset__stopPriority = false;
  bool isset__controlType = false;
  bool isset__availableWeekdays = false;
  bool isset__maxHoursDaily = false;
  bool isset__maxHoursMonthly = false;
  bool isset__maxHoursSeasonal = false;
  bool isset__maxHoursAnnually = false;
  bool isset__minActivateTime = false;
  bool isset__minRestartTime = false;
  bool isset__programStatusPointId = false;
  bool isset__programState = false;
  bool isset__reductionAnalogPointId = false;
  bool isset__reductionTotal = false;
  bool isset__startedControlling = false;
  bool isset__lastControlSent = false;
  bool isset__manualControlReceivedFlag = false;
  bool isset__lmProgramControlWindows = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_paoId);
          isset__paoId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoCategory);
          isset__paoCategory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoClass);
          isset__paoClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoName);
          isset__paoName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoTypeString);
          isset__paoTypeString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoDescription);
          isset__paoDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_disableFlag);
          isset__disableFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_startPriority);
          isset__startPriority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_stopPriority);
          isset__stopPriority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_controlType);
          isset__controlType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_availableWeekdays);
          isset__availableWeekdays = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_maxHoursDaily);
          isset__maxHoursDaily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_maxHoursMonthly);
          isset__maxHoursMonthly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_maxHoursSeasonal);
          isset__maxHoursSeasonal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_maxHoursAnnually);
          isset__maxHoursAnnually = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_minActivateTime);
          isset__minActivateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_minRestartTime);
          isset__minRestartTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_programStatusPointId);
          isset__programStatusPointId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_programState);
          isset__programState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_reductionAnalogPointId);
          isset__reductionAnalogPointId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_reductionTotal);
          isset__reductionTotal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_startedControlling);
          isset__startedControlling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_lastControlSent);
          isset__lastControlSent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_manualControlReceivedFlag);
          isset__manualControlReceivedFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmProgramControlWindows.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->_lmProgramControlWindows.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->_lmProgramControlWindows[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmProgramControlWindows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__paoId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoCategory)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoClass)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoTypeString)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoDescription)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__disableFlag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__startPriority)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__stopPriority)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__controlType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__availableWeekdays)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__maxHoursDaily)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__maxHoursMonthly)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__maxHoursSeasonal)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__maxHoursAnnually)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__minActivateTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__minRestartTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__programStatusPointId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__programState)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__reductionAnalogPointId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__reductionTotal)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__startedControlling)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lastControlSent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__manualControlReceivedFlag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmProgramControlWindows)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMProgramBase::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMProgramBase");

  xfer += oprot->writeFieldBegin("_paoId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_paoId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoCategory", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->_paoCategory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoClass", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->_paoClass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->_paoName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoTypeString", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->_paoTypeString);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoDescription", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->_paoDescription);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_disableFlag", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->_disableFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_startPriority", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->_startPriority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_stopPriority", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->_stopPriority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_controlType", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->_controlType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_availableWeekdays", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->_availableWeekdays);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_maxHoursDaily", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->_maxHoursDaily);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_maxHoursMonthly", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->_maxHoursMonthly);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_maxHoursSeasonal", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->_maxHoursSeasonal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_maxHoursAnnually", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->_maxHoursAnnually);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_minActivateTime", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32(this->_minActivateTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_minRestartTime", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->_minRestartTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_programStatusPointId", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32(this->_programStatusPointId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_programState", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->_programState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_reductionAnalogPointId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->_reductionAnalogPointId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_reductionTotal", ::apache::thrift::protocol::T_DOUBLE, 21);
  xfer += oprot->writeDouble(this->_reductionTotal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_startedControlling", ::apache::thrift::protocol::T_I64, 22);
  xfer += oprot->writeI64(this->_startedControlling);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lastControlSent", ::apache::thrift::protocol::T_I64, 23);
  xfer += oprot->writeI64(this->_lastControlSent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_manualControlReceivedFlag", ::apache::thrift::protocol::T_BOOL, 24);
  xfer += oprot->writeBool(this->_manualControlReceivedFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmProgramControlWindows", ::apache::thrift::protocol::T_LIST, 25);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmProgramControlWindows.size()));
    std::vector<LMProgramControlWindow> ::const_iterator _iter9;
    for (_iter9 = this->_lmProgramControlWindows.begin(); _iter9 != this->_lmProgramControlWindows.end(); ++_iter9)
    {
      xfer += (*_iter9).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMProgramBase &a, LMProgramBase &b) {
  using ::std::swap;
  swap(a._paoId, b._paoId);
  swap(a._paoCategory, b._paoCategory);
  swap(a._paoClass, b._paoClass);
  swap(a._paoName, b._paoName);
  swap(a._paoTypeString, b._paoTypeString);
  swap(a._paoDescription, b._paoDescription);
  swap(a._disableFlag, b._disableFlag);
  swap(a._startPriority, b._startPriority);
  swap(a._stopPriority, b._stopPriority);
  swap(a._controlType, b._controlType);
  swap(a._availableWeekdays, b._availableWeekdays);
  swap(a._maxHoursDaily, b._maxHoursDaily);
  swap(a._maxHoursMonthly, b._maxHoursMonthly);
  swap(a._maxHoursSeasonal, b._maxHoursSeasonal);
  swap(a._maxHoursAnnually, b._maxHoursAnnually);
  swap(a._minActivateTime, b._minActivateTime);
  swap(a._minRestartTime, b._minRestartTime);
  swap(a._programStatusPointId, b._programStatusPointId);
  swap(a._programState, b._programState);
  swap(a._reductionAnalogPointId, b._reductionAnalogPointId);
  swap(a._reductionTotal, b._reductionTotal);
  swap(a._startedControlling, b._startedControlling);
  swap(a._lastControlSent, b._lastControlSent);
  swap(a._manualControlReceivedFlag, b._manualControlReceivedFlag);
  swap(a._lmProgramControlWindows, b._lmProgramControlWindows);
}

LMProgramBase::LMProgramBase(const LMProgramBase& other10) {
  _paoId = other10._paoId;
  _paoCategory = other10._paoCategory;
  _paoClass = other10._paoClass;
  _paoName = other10._paoName;
  _paoTypeString = other10._paoTypeString;
  _paoDescription = other10._paoDescription;
  _disableFlag = other10._disableFlag;
  _startPriority = other10._startPriority;
  _stopPriority = other10._stopPriority;
  _controlType = other10._controlType;
  _availableWeekdays = other10._availableWeekdays;
  _maxHoursDaily = other10._maxHoursDaily;
  _maxHoursMonthly = other10._maxHoursMonthly;
  _maxHoursSeasonal = other10._maxHoursSeasonal;
  _maxHoursAnnually = other10._maxHoursAnnually;
  _minActivateTime = other10._minActivateTime;
  _minRestartTime = other10._minRestartTime;
  _programStatusPointId = other10._programStatusPointId;
  _programState = other10._programState;
  _reductionAnalogPointId = other10._reductionAnalogPointId;
  _reductionTotal = other10._reductionTotal;
  _startedControlling = other10._startedControlling;
  _lastControlSent = other10._lastControlSent;
  _manualControlReceivedFlag = other10._manualControlReceivedFlag;
  _lmProgramControlWindows = other10._lmProgramControlWindows;
}
LMProgramBase& LMProgramBase::operator=(const LMProgramBase& other11) {
  _paoId = other11._paoId;
  _paoCategory = other11._paoCategory;
  _paoClass = other11._paoClass;
  _paoName = other11._paoName;
  _paoTypeString = other11._paoTypeString;
  _paoDescription = other11._paoDescription;
  _disableFlag = other11._disableFlag;
  _startPriority = other11._startPriority;
  _stopPriority = other11._stopPriority;
  _controlType = other11._controlType;
  _availableWeekdays = other11._availableWeekdays;
  _maxHoursDaily = other11._maxHoursDaily;
  _maxHoursMonthly = other11._maxHoursMonthly;
  _maxHoursSeasonal = other11._maxHoursSeasonal;
  _maxHoursAnnually = other11._maxHoursAnnually;
  _minActivateTime = other11._minActivateTime;
  _minRestartTime = other11._minRestartTime;
  _programStatusPointId = other11._programStatusPointId;
  _programState = other11._programState;
  _reductionAnalogPointId = other11._reductionAnalogPointId;
  _reductionTotal = other11._reductionTotal;
  _startedControlling = other11._startedControlling;
  _lastControlSent = other11._lastControlSent;
  _manualControlReceivedFlag = other11._manualControlReceivedFlag;
  _lmProgramControlWindows = other11._lmProgramControlWindows;
  return *this;
}
void LMProgramBase::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMProgramBase(";
  out << "_paoId=" << to_string(_paoId);
  out << ", " << "_paoCategory=" << to_string(_paoCategory);
  out << ", " << "_paoClass=" << to_string(_paoClass);
  out << ", " << "_paoName=" << to_string(_paoName);
  out << ", " << "_paoTypeString=" << to_string(_paoTypeString);
  out << ", " << "_paoDescription=" << to_string(_paoDescription);
  out << ", " << "_disableFlag=" << to_string(_disableFlag);
  out << ", " << "_startPriority=" << to_string(_startPriority);
  out << ", " << "_stopPriority=" << to_string(_stopPriority);
  out << ", " << "_controlType=" << to_string(_controlType);
  out << ", " << "_availableWeekdays=" << to_string(_availableWeekdays);
  out << ", " << "_maxHoursDaily=" << to_string(_maxHoursDaily);
  out << ", " << "_maxHoursMonthly=" << to_string(_maxHoursMonthly);
  out << ", " << "_maxHoursSeasonal=" << to_string(_maxHoursSeasonal);
  out << ", " << "_maxHoursAnnually=" << to_string(_maxHoursAnnually);
  out << ", " << "_minActivateTime=" << to_string(_minActivateTime);
  out << ", " << "_minRestartTime=" << to_string(_minRestartTime);
  out << ", " << "_programStatusPointId=" << to_string(_programStatusPointId);
  out << ", " << "_programState=" << to_string(_programState);
  out << ", " << "_reductionAnalogPointId=" << to_string(_reductionAnalogPointId);
  out << ", " << "_reductionTotal=" << to_string(_reductionTotal);
  out << ", " << "_startedControlling=" << to_string(_startedControlling);
  out << ", " << "_lastControlSent=" << to_string(_lastControlSent);
  out << ", " << "_manualControlReceivedFlag=" << to_string(_manualControlReceivedFlag);
  out << ", " << "_lmProgramControlWindows=" << to_string(_lmProgramControlWindows);
  out << ")";
}


LMCICustomerBase::~LMCICustomerBase() noexcept {
}


void LMCICustomerBase::__set__customerId(const int32_t val) {
  this->_customerId = val;
}

void LMCICustomerBase::__set__companyName(const std::string& val) {
  this->_companyName = val;
}

void LMCICustomerBase::__set__customerDemandLevel(const double val) {
  this->_customerDemandLevel = val;
}

void LMCICustomerBase::__set__curtailAmount(const double val) {
  this->_curtailAmount = val;
}

void LMCICustomerBase::__set__curtailmentAgreement(const std::string& val) {
  this->_curtailmentAgreement = val;
}

void LMCICustomerBase::__set__timeZone(const std::string& val) {
  this->_timeZone = val;
}

void LMCICustomerBase::__set__customerOrder(const int32_t val) {
  this->_customerOrder = val;
}
std::ostream& operator<<(std::ostream& out, const LMCICustomerBase& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMCICustomerBase::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__customerId = false;
  bool isset__companyName = false;
  bool isset__customerDemandLevel = false;
  bool isset__curtailAmount = false;
  bool isset__curtailmentAgreement = false;
  bool isset__timeZone = false;
  bool isset__customerOrder = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_customerId);
          isset__customerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_companyName);
          isset__companyName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_customerDemandLevel);
          isset__customerDemandLevel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_curtailAmount);
          isset__curtailAmount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_curtailmentAgreement);
          isset__curtailmentAgreement = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_timeZone);
          isset__timeZone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_customerOrder);
          isset__customerOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__customerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__companyName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__customerDemandLevel)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__curtailAmount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__curtailmentAgreement)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__timeZone)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__customerOrder)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMCICustomerBase::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMCICustomerBase");

  xfer += oprot->writeFieldBegin("_customerId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_customerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_companyName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->_companyName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_customerDemandLevel", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->_customerDemandLevel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_curtailAmount", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->_curtailAmount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_curtailmentAgreement", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->_curtailmentAgreement);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_timeZone", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->_timeZone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_customerOrder", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->_customerOrder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMCICustomerBase &a, LMCICustomerBase &b) {
  using ::std::swap;
  swap(a._customerId, b._customerId);
  swap(a._companyName, b._companyName);
  swap(a._customerDemandLevel, b._customerDemandLevel);
  swap(a._curtailAmount, b._curtailAmount);
  swap(a._curtailmentAgreement, b._curtailmentAgreement);
  swap(a._timeZone, b._timeZone);
  swap(a._customerOrder, b._customerOrder);
}

LMCICustomerBase::LMCICustomerBase(const LMCICustomerBase& other12) {
  _customerId = other12._customerId;
  _companyName = other12._companyName;
  _customerDemandLevel = other12._customerDemandLevel;
  _curtailAmount = other12._curtailAmount;
  _curtailmentAgreement = other12._curtailmentAgreement;
  _timeZone = other12._timeZone;
  _customerOrder = other12._customerOrder;
}
LMCICustomerBase& LMCICustomerBase::operator=(const LMCICustomerBase& other13) {
  _customerId = other13._customerId;
  _companyName = other13._companyName;
  _customerDemandLevel = other13._customerDemandLevel;
  _curtailAmount = other13._curtailAmount;
  _curtailmentAgreement = other13._curtailmentAgreement;
  _timeZone = other13._timeZone;
  _customerOrder = other13._customerOrder;
  return *this;
}
void LMCICustomerBase::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMCICustomerBase(";
  out << "_customerId=" << to_string(_customerId);
  out << ", " << "_companyName=" << to_string(_companyName);
  out << ", " << "_customerDemandLevel=" << to_string(_customerDemandLevel);
  out << ", " << "_curtailAmount=" << to_string(_curtailAmount);
  out << ", " << "_curtailmentAgreement=" << to_string(_curtailmentAgreement);
  out << ", " << "_timeZone=" << to_string(_timeZone);
  out << ", " << "_customerOrder=" << to_string(_customerOrder);
  out << ")";
}


LMCurtailCustomer::~LMCurtailCustomer() noexcept {
}


void LMCurtailCustomer::__set__baseMessage(const LMCICustomerBase& val) {
  this->_baseMessage = val;
}

void LMCurtailCustomer::__set__requireAck(const bool val) {
  this->_requireAck = val;
}

void LMCurtailCustomer::__set__curtailReferenceId(const int32_t val) {
  this->_curtailReferenceId = val;
}

void LMCurtailCustomer::__set__acknowledgeStatus(const std::string& val) {
  this->_acknowledgeStatus = val;
}

void LMCurtailCustomer::__set__ackDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_ackDatetime = val;
}

void LMCurtailCustomer::__set__ipAddressOfAckUser(const std::string& val) {
  this->_ipAddressOfAckUser = val;
}

void LMCurtailCustomer::__set__userIdName(const std::string& val) {
  this->_userIdName = val;
}

void LMCurtailCustomer::__set__nameOfAckPerson(const std::string& val) {
  this->_nameOfAckPerson = val;
}

void LMCurtailCustomer::__set__curtailmentNotes(const std::string& val) {
  this->_curtailmentNotes = val;
}

void LMCurtailCustomer::__set__ackLateFlag(const bool val) {
  this->_ackLateFlag = val;
}
std::ostream& operator<<(std::ostream& out, const LMCurtailCustomer& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMCurtailCustomer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;
  bool isset__requireAck = false;
  bool isset__curtailReferenceId = false;
  bool isset__acknowledgeStatus = false;
  bool isset__ackDatetime = false;
  bool isset__ipAddressOfAckUser = false;
  bool isset__userIdName = false;
  bool isset__nameOfAckPerson = false;
  bool isset__curtailmentNotes = false;
  bool isset__ackLateFlag = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_requireAck);
          isset__requireAck = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_curtailReferenceId);
          isset__curtailReferenceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_acknowledgeStatus);
          isset__acknowledgeStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_ackDatetime);
          isset__ackDatetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_ipAddressOfAckUser);
          isset__ipAddressOfAckUser = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_userIdName);
          isset__userIdName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_nameOfAckPerson);
          isset__nameOfAckPerson = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_curtailmentNotes);
          isset__curtailmentNotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_ackLateFlag);
          isset__ackLateFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__requireAck)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__curtailReferenceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__acknowledgeStatus)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__ackDatetime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__ipAddressOfAckUser)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__userIdName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__nameOfAckPerson)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__curtailmentNotes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__ackLateFlag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMCurtailCustomer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMCurtailCustomer");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_requireAck", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->_requireAck);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_curtailReferenceId", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->_curtailReferenceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_acknowledgeStatus", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->_acknowledgeStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_ackDatetime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->_ackDatetime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_ipAddressOfAckUser", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->_ipAddressOfAckUser);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_userIdName", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->_userIdName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_nameOfAckPerson", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->_nameOfAckPerson);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_curtailmentNotes", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->_curtailmentNotes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_ackLateFlag", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->_ackLateFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMCurtailCustomer &a, LMCurtailCustomer &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
  swap(a._requireAck, b._requireAck);
  swap(a._curtailReferenceId, b._curtailReferenceId);
  swap(a._acknowledgeStatus, b._acknowledgeStatus);
  swap(a._ackDatetime, b._ackDatetime);
  swap(a._ipAddressOfAckUser, b._ipAddressOfAckUser);
  swap(a._userIdName, b._userIdName);
  swap(a._nameOfAckPerson, b._nameOfAckPerson);
  swap(a._curtailmentNotes, b._curtailmentNotes);
  swap(a._ackLateFlag, b._ackLateFlag);
}

LMCurtailCustomer::LMCurtailCustomer(const LMCurtailCustomer& other14) {
  _baseMessage = other14._baseMessage;
  _requireAck = other14._requireAck;
  _curtailReferenceId = other14._curtailReferenceId;
  _acknowledgeStatus = other14._acknowledgeStatus;
  _ackDatetime = other14._ackDatetime;
  _ipAddressOfAckUser = other14._ipAddressOfAckUser;
  _userIdName = other14._userIdName;
  _nameOfAckPerson = other14._nameOfAckPerson;
  _curtailmentNotes = other14._curtailmentNotes;
  _ackLateFlag = other14._ackLateFlag;
}
LMCurtailCustomer& LMCurtailCustomer::operator=(const LMCurtailCustomer& other15) {
  _baseMessage = other15._baseMessage;
  _requireAck = other15._requireAck;
  _curtailReferenceId = other15._curtailReferenceId;
  _acknowledgeStatus = other15._acknowledgeStatus;
  _ackDatetime = other15._ackDatetime;
  _ipAddressOfAckUser = other15._ipAddressOfAckUser;
  _userIdName = other15._userIdName;
  _nameOfAckPerson = other15._nameOfAckPerson;
  _curtailmentNotes = other15._curtailmentNotes;
  _ackLateFlag = other15._ackLateFlag;
  return *this;
}
void LMCurtailCustomer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMCurtailCustomer(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ", " << "_requireAck=" << to_string(_requireAck);
  out << ", " << "_curtailReferenceId=" << to_string(_curtailReferenceId);
  out << ", " << "_acknowledgeStatus=" << to_string(_acknowledgeStatus);
  out << ", " << "_ackDatetime=" << to_string(_ackDatetime);
  out << ", " << "_ipAddressOfAckUser=" << to_string(_ipAddressOfAckUser);
  out << ", " << "_userIdName=" << to_string(_userIdName);
  out << ", " << "_nameOfAckPerson=" << to_string(_nameOfAckPerson);
  out << ", " << "_curtailmentNotes=" << to_string(_curtailmentNotes);
  out << ", " << "_ackLateFlag=" << to_string(_ackLateFlag);
  out << ")";
}


LMProgramCurtailment::~LMProgramCurtailment() noexcept {
}


void LMProgramCurtailment::__set__baseMessage(const LMProgramBase& val) {
  this->_baseMessage = val;
}

void LMProgramCurtailment::__set__minNotifyTime(const int32_t val) {
  this->_minNotifyTime = val;
}

void LMProgramCurtailment::__set__heading(const std::string& val) {
  this->_heading = val;
}

void LMProgramCurtailment::__set__messageHeader(const std::string& val) {
  this->_messageHeader = val;
}

void LMProgramCurtailment::__set__messageFooter(const std::string& val) {
  this->_messageFooter = val;
}

void LMProgramCurtailment::__set__acktimeLimit(const int32_t val) {
  this->_acktimeLimit = val;
}

void LMProgramCurtailment::__set__canceledMsg(const std::string& val) {
  this->_canceledMsg = val;
}

void LMProgramCurtailment::__set__stoppedEarlyMsg(const std::string& val) {
  this->_stoppedEarlyMsg = val;
}

void LMProgramCurtailment::__set__curtailReferenceId(const int32_t val) {
  this->_curtailReferenceId = val;
}

void LMProgramCurtailment::__set__actionDateTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_actionDateTime = val;
}

void LMProgramCurtailment::__set__notificationDateTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_notificationDateTime = val;
}

void LMProgramCurtailment::__set__curtailmentStartTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_curtailmentStartTime = val;
}

void LMProgramCurtailment::__set__curtailmentStopTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_curtailmentStopTime = val;
}

void LMProgramCurtailment::__set__runStatus(const std::string& val) {
  this->_runStatus = val;
}

void LMProgramCurtailment::__set__additionalInfo(const std::string& val) {
  this->_additionalInfo = val;
}

void LMProgramCurtailment::__set__lmProgramCurtailmentCustomers(const std::vector<LMCurtailCustomer> & val) {
  this->_lmProgramCurtailmentCustomers = val;
}
std::ostream& operator<<(std::ostream& out, const LMProgramCurtailment& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMProgramCurtailment::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;
  bool isset__minNotifyTime = false;
  bool isset__heading = false;
  bool isset__messageHeader = false;
  bool isset__messageFooter = false;
  bool isset__acktimeLimit = false;
  bool isset__canceledMsg = false;
  bool isset__stoppedEarlyMsg = false;
  bool isset__curtailReferenceId = false;
  bool isset__actionDateTime = false;
  bool isset__notificationDateTime = false;
  bool isset__curtailmentStartTime = false;
  bool isset__curtailmentStopTime = false;
  bool isset__runStatus = false;
  bool isset__additionalInfo = false;
  bool isset__lmProgramCurtailmentCustomers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_minNotifyTime);
          isset__minNotifyTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_heading);
          isset__heading = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_messageHeader);
          isset__messageHeader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_messageFooter);
          isset__messageFooter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_acktimeLimit);
          isset__acktimeLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_canceledMsg);
          isset__canceledMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_stoppedEarlyMsg);
          isset__stoppedEarlyMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_curtailReferenceId);
          isset__curtailReferenceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_actionDateTime);
          isset__actionDateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_notificationDateTime);
          isset__notificationDateTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_curtailmentStartTime);
          isset__curtailmentStartTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_curtailmentStopTime);
          isset__curtailmentStopTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_runStatus);
          isset__runStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_additionalInfo);
          isset__additionalInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmProgramCurtailmentCustomers.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->_lmProgramCurtailmentCustomers.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += this->_lmProgramCurtailmentCustomers[_i20].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmProgramCurtailmentCustomers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__minNotifyTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__heading)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__messageHeader)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__messageFooter)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__acktimeLimit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__canceledMsg)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__stoppedEarlyMsg)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__curtailReferenceId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__actionDateTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__notificationDateTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__curtailmentStartTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__curtailmentStopTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__runStatus)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__additionalInfo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmProgramCurtailmentCustomers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMProgramCurtailment::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMProgramCurtailment");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_minNotifyTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_minNotifyTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_heading", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->_heading);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_messageHeader", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->_messageHeader);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_messageFooter", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->_messageFooter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_acktimeLimit", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->_acktimeLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_canceledMsg", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->_canceledMsg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_stoppedEarlyMsg", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->_stoppedEarlyMsg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_curtailReferenceId", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->_curtailReferenceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_actionDateTime", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->_actionDateTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_notificationDateTime", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->_notificationDateTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_curtailmentStartTime", ::apache::thrift::protocol::T_I64, 12);
  xfer += oprot->writeI64(this->_curtailmentStartTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_curtailmentStopTime", ::apache::thrift::protocol::T_I64, 13);
  xfer += oprot->writeI64(this->_curtailmentStopTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_runStatus", ::apache::thrift::protocol::T_STRING, 14);
  xfer += oprot->writeString(this->_runStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_additionalInfo", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->_additionalInfo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmProgramCurtailmentCustomers", ::apache::thrift::protocol::T_LIST, 16);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmProgramCurtailmentCustomers.size()));
    std::vector<LMCurtailCustomer> ::const_iterator _iter21;
    for (_iter21 = this->_lmProgramCurtailmentCustomers.begin(); _iter21 != this->_lmProgramCurtailmentCustomers.end(); ++_iter21)
    {
      xfer += (*_iter21).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMProgramCurtailment &a, LMProgramCurtailment &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
  swap(a._minNotifyTime, b._minNotifyTime);
  swap(a._heading, b._heading);
  swap(a._messageHeader, b._messageHeader);
  swap(a._messageFooter, b._messageFooter);
  swap(a._acktimeLimit, b._acktimeLimit);
  swap(a._canceledMsg, b._canceledMsg);
  swap(a._stoppedEarlyMsg, b._stoppedEarlyMsg);
  swap(a._curtailReferenceId, b._curtailReferenceId);
  swap(a._actionDateTime, b._actionDateTime);
  swap(a._notificationDateTime, b._notificationDateTime);
  swap(a._curtailmentStartTime, b._curtailmentStartTime);
  swap(a._curtailmentStopTime, b._curtailmentStopTime);
  swap(a._runStatus, b._runStatus);
  swap(a._additionalInfo, b._additionalInfo);
  swap(a._lmProgramCurtailmentCustomers, b._lmProgramCurtailmentCustomers);
}

LMProgramCurtailment::LMProgramCurtailment(const LMProgramCurtailment& other22) {
  _baseMessage = other22._baseMessage;
  _minNotifyTime = other22._minNotifyTime;
  _heading = other22._heading;
  _messageHeader = other22._messageHeader;
  _messageFooter = other22._messageFooter;
  _acktimeLimit = other22._acktimeLimit;
  _canceledMsg = other22._canceledMsg;
  _stoppedEarlyMsg = other22._stoppedEarlyMsg;
  _curtailReferenceId = other22._curtailReferenceId;
  _actionDateTime = other22._actionDateTime;
  _notificationDateTime = other22._notificationDateTime;
  _curtailmentStartTime = other22._curtailmentStartTime;
  _curtailmentStopTime = other22._curtailmentStopTime;
  _runStatus = other22._runStatus;
  _additionalInfo = other22._additionalInfo;
  _lmProgramCurtailmentCustomers = other22._lmProgramCurtailmentCustomers;
}
LMProgramCurtailment& LMProgramCurtailment::operator=(const LMProgramCurtailment& other23) {
  _baseMessage = other23._baseMessage;
  _minNotifyTime = other23._minNotifyTime;
  _heading = other23._heading;
  _messageHeader = other23._messageHeader;
  _messageFooter = other23._messageFooter;
  _acktimeLimit = other23._acktimeLimit;
  _canceledMsg = other23._canceledMsg;
  _stoppedEarlyMsg = other23._stoppedEarlyMsg;
  _curtailReferenceId = other23._curtailReferenceId;
  _actionDateTime = other23._actionDateTime;
  _notificationDateTime = other23._notificationDateTime;
  _curtailmentStartTime = other23._curtailmentStartTime;
  _curtailmentStopTime = other23._curtailmentStopTime;
  _runStatus = other23._runStatus;
  _additionalInfo = other23._additionalInfo;
  _lmProgramCurtailmentCustomers = other23._lmProgramCurtailmentCustomers;
  return *this;
}
void LMProgramCurtailment::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMProgramCurtailment(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ", " << "_minNotifyTime=" << to_string(_minNotifyTime);
  out << ", " << "_heading=" << to_string(_heading);
  out << ", " << "_messageHeader=" << to_string(_messageHeader);
  out << ", " << "_messageFooter=" << to_string(_messageFooter);
  out << ", " << "_acktimeLimit=" << to_string(_acktimeLimit);
  out << ", " << "_canceledMsg=" << to_string(_canceledMsg);
  out << ", " << "_stoppedEarlyMsg=" << to_string(_stoppedEarlyMsg);
  out << ", " << "_curtailReferenceId=" << to_string(_curtailReferenceId);
  out << ", " << "_actionDateTime=" << to_string(_actionDateTime);
  out << ", " << "_notificationDateTime=" << to_string(_notificationDateTime);
  out << ", " << "_curtailmentStartTime=" << to_string(_curtailmentStartTime);
  out << ", " << "_curtailmentStopTime=" << to_string(_curtailmentStopTime);
  out << ", " << "_runStatus=" << to_string(_runStatus);
  out << ", " << "_additionalInfo=" << to_string(_additionalInfo);
  out << ", " << "_lmProgramCurtailmentCustomers=" << to_string(_lmProgramCurtailmentCustomers);
  out << ")";
}


LMProgramDirectGear::~LMProgramDirectGear() noexcept {
}


void LMProgramDirectGear::__set__programPaoId(const int32_t val) {
  this->_programPaoId = val;
}

void LMProgramDirectGear::__set__gearName(const std::string& val) {
  this->_gearName = val;
}

void LMProgramDirectGear::__set__gearNumber(const int32_t val) {
  this->_gearNumber = val;
}

void LMProgramDirectGear::__set__controlMethod(const std::string& val) {
  this->_controlMethod = val;
}

void LMProgramDirectGear::__set__methodRate(const int32_t val) {
  this->_methodRate = val;
}

void LMProgramDirectGear::__set__methodPeriod(const int32_t val) {
  this->_methodPeriod = val;
}

void LMProgramDirectGear::__set__methodRateCount(const int32_t val) {
  this->_methodRateCount = val;
}

void LMProgramDirectGear::__set__cyclereFreshRate(const int32_t val) {
  this->_cyclereFreshRate = val;
}

void LMProgramDirectGear::__set__methodStopType(const std::string& val) {
  this->_methodStopType = val;
}

void LMProgramDirectGear::__set__changeCondition(const std::string& val) {
  this->_changeCondition = val;
}

void LMProgramDirectGear::__set__changeDuration(const int32_t val) {
  this->_changeDuration = val;
}

void LMProgramDirectGear::__set__changePriority(const int32_t val) {
  this->_changePriority = val;
}

void LMProgramDirectGear::__set__changeTriggerNumber(const int32_t val) {
  this->_changeTriggerNumber = val;
}

void LMProgramDirectGear::__set__changeTriggerOffset(const double val) {
  this->_changeTriggerOffset = val;
}

void LMProgramDirectGear::__set__percentReduction(const int32_t val) {
  this->_percentReduction = val;
}

void LMProgramDirectGear::__set__groupSelectionMethod(const std::string& val) {
  this->_groupSelectionMethod = val;
}

void LMProgramDirectGear::__set__methodOptionType(const std::string& val) {
  this->_methodOptionType = val;
}

void LMProgramDirectGear::__set__methodOptionMax(const int32_t val) {
  this->_methodOptionMax = val;
}

void LMProgramDirectGear::__set__rampInInterval(const int32_t val) {
  this->_rampInInterval = val;
}

void LMProgramDirectGear::__set__rampInPercent(const int32_t val) {
  this->_rampInPercent = val;
}

void LMProgramDirectGear::__set__rampOutInterval(const int32_t val) {
  this->_rampOutInterval = val;
}

void LMProgramDirectGear::__set__rampOutPercent(const int32_t val) {
  this->_rampOutPercent = val;
}

void LMProgramDirectGear::__set__kwReduction(const double val) {
  this->_kwReduction = val;
}
std::ostream& operator<<(std::ostream& out, const LMProgramDirectGear& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMProgramDirectGear::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__programPaoId = false;
  bool isset__gearName = false;
  bool isset__gearNumber = false;
  bool isset__controlMethod = false;
  bool isset__methodRate = false;
  bool isset__methodPeriod = false;
  bool isset__methodRateCount = false;
  bool isset__cyclereFreshRate = false;
  bool isset__methodStopType = false;
  bool isset__changeCondition = false;
  bool isset__changeDuration = false;
  bool isset__changePriority = false;
  bool isset__changeTriggerNumber = false;
  bool isset__changeTriggerOffset = false;
  bool isset__percentReduction = false;
  bool isset__groupSelectionMethod = false;
  bool isset__methodOptionType = false;
  bool isset__methodOptionMax = false;
  bool isset__rampInInterval = false;
  bool isset__rampInPercent = false;
  bool isset__rampOutInterval = false;
  bool isset__rampOutPercent = false;
  bool isset__kwReduction = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_programPaoId);
          isset__programPaoId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_gearName);
          isset__gearName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_gearNumber);
          isset__gearNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_controlMethod);
          isset__controlMethod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_methodRate);
          isset__methodRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_methodPeriod);
          isset__methodPeriod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_methodRateCount);
          isset__methodRateCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_cyclereFreshRate);
          isset__cyclereFreshRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_methodStopType);
          isset__methodStopType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_changeCondition);
          isset__changeCondition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_changeDuration);
          isset__changeDuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_changePriority);
          isset__changePriority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_changeTriggerNumber);
          isset__changeTriggerNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_changeTriggerOffset);
          isset__changeTriggerOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_percentReduction);
          isset__percentReduction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_groupSelectionMethod);
          isset__groupSelectionMethod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_methodOptionType);
          isset__methodOptionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_methodOptionMax);
          isset__methodOptionMax = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_rampInInterval);
          isset__rampInInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_rampInPercent);
          isset__rampInPercent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_rampOutInterval);
          isset__rampOutInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_rampOutPercent);
          isset__rampOutPercent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_kwReduction);
          isset__kwReduction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__programPaoId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__gearName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__gearNumber)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__controlMethod)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__methodRate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__methodPeriod)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__methodRateCount)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__cyclereFreshRate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__methodStopType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__changeCondition)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__changeDuration)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__changePriority)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__changeTriggerNumber)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__changeTriggerOffset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__percentReduction)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__groupSelectionMethod)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__methodOptionType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__methodOptionMax)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__rampInInterval)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__rampInPercent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__rampOutInterval)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__rampOutPercent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__kwReduction)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMProgramDirectGear::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMProgramDirectGear");

  xfer += oprot->writeFieldBegin("_programPaoId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_programPaoId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_gearName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->_gearName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_gearNumber", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->_gearNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_controlMethod", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->_controlMethod);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_methodRate", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->_methodRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_methodPeriod", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->_methodPeriod);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_methodRateCount", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->_methodRateCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_cyclereFreshRate", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->_cyclereFreshRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_methodStopType", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->_methodStopType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_changeCondition", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->_changeCondition);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_changeDuration", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->_changeDuration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_changePriority", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->_changePriority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_changeTriggerNumber", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->_changeTriggerNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_changeTriggerOffset", ::apache::thrift::protocol::T_DOUBLE, 15);
  xfer += oprot->writeDouble(this->_changeTriggerOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_percentReduction", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32(this->_percentReduction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_groupSelectionMethod", ::apache::thrift::protocol::T_STRING, 17);
  xfer += oprot->writeString(this->_groupSelectionMethod);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_methodOptionType", ::apache::thrift::protocol::T_STRING, 18);
  xfer += oprot->writeString(this->_methodOptionType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_methodOptionMax", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->_methodOptionMax);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_rampInInterval", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->_rampInInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_rampInPercent", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->_rampInPercent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_rampOutInterval", ::apache::thrift::protocol::T_I32, 22);
  xfer += oprot->writeI32(this->_rampOutInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_rampOutPercent", ::apache::thrift::protocol::T_I32, 23);
  xfer += oprot->writeI32(this->_rampOutPercent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_kwReduction", ::apache::thrift::protocol::T_DOUBLE, 24);
  xfer += oprot->writeDouble(this->_kwReduction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMProgramDirectGear &a, LMProgramDirectGear &b) {
  using ::std::swap;
  swap(a._programPaoId, b._programPaoId);
  swap(a._gearName, b._gearName);
  swap(a._gearNumber, b._gearNumber);
  swap(a._controlMethod, b._controlMethod);
  swap(a._methodRate, b._methodRate);
  swap(a._methodPeriod, b._methodPeriod);
  swap(a._methodRateCount, b._methodRateCount);
  swap(a._cyclereFreshRate, b._cyclereFreshRate);
  swap(a._methodStopType, b._methodStopType);
  swap(a._changeCondition, b._changeCondition);
  swap(a._changeDuration, b._changeDuration);
  swap(a._changePriority, b._changePriority);
  swap(a._changeTriggerNumber, b._changeTriggerNumber);
  swap(a._changeTriggerOffset, b._changeTriggerOffset);
  swap(a._percentReduction, b._percentReduction);
  swap(a._groupSelectionMethod, b._groupSelectionMethod);
  swap(a._methodOptionType, b._methodOptionType);
  swap(a._methodOptionMax, b._methodOptionMax);
  swap(a._rampInInterval, b._rampInInterval);
  swap(a._rampInPercent, b._rampInPercent);
  swap(a._rampOutInterval, b._rampOutInterval);
  swap(a._rampOutPercent, b._rampOutPercent);
  swap(a._kwReduction, b._kwReduction);
}

LMProgramDirectGear::LMProgramDirectGear(const LMProgramDirectGear& other24) {
  _programPaoId = other24._programPaoId;
  _gearName = other24._gearName;
  _gearNumber = other24._gearNumber;
  _controlMethod = other24._controlMethod;
  _methodRate = other24._methodRate;
  _methodPeriod = other24._methodPeriod;
  _methodRateCount = other24._methodRateCount;
  _cyclereFreshRate = other24._cyclereFreshRate;
  _methodStopType = other24._methodStopType;
  _changeCondition = other24._changeCondition;
  _changeDuration = other24._changeDuration;
  _changePriority = other24._changePriority;
  _changeTriggerNumber = other24._changeTriggerNumber;
  _changeTriggerOffset = other24._changeTriggerOffset;
  _percentReduction = other24._percentReduction;
  _groupSelectionMethod = other24._groupSelectionMethod;
  _methodOptionType = other24._methodOptionType;
  _methodOptionMax = other24._methodOptionMax;
  _rampInInterval = other24._rampInInterval;
  _rampInPercent = other24._rampInPercent;
  _rampOutInterval = other24._rampOutInterval;
  _rampOutPercent = other24._rampOutPercent;
  _kwReduction = other24._kwReduction;
}
LMProgramDirectGear& LMProgramDirectGear::operator=(const LMProgramDirectGear& other25) {
  _programPaoId = other25._programPaoId;
  _gearName = other25._gearName;
  _gearNumber = other25._gearNumber;
  _controlMethod = other25._controlMethod;
  _methodRate = other25._methodRate;
  _methodPeriod = other25._methodPeriod;
  _methodRateCount = other25._methodRateCount;
  _cyclereFreshRate = other25._cyclereFreshRate;
  _methodStopType = other25._methodStopType;
  _changeCondition = other25._changeCondition;
  _changeDuration = other25._changeDuration;
  _changePriority = other25._changePriority;
  _changeTriggerNumber = other25._changeTriggerNumber;
  _changeTriggerOffset = other25._changeTriggerOffset;
  _percentReduction = other25._percentReduction;
  _groupSelectionMethod = other25._groupSelectionMethod;
  _methodOptionType = other25._methodOptionType;
  _methodOptionMax = other25._methodOptionMax;
  _rampInInterval = other25._rampInInterval;
  _rampInPercent = other25._rampInPercent;
  _rampOutInterval = other25._rampOutInterval;
  _rampOutPercent = other25._rampOutPercent;
  _kwReduction = other25._kwReduction;
  return *this;
}
void LMProgramDirectGear::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMProgramDirectGear(";
  out << "_programPaoId=" << to_string(_programPaoId);
  out << ", " << "_gearName=" << to_string(_gearName);
  out << ", " << "_gearNumber=" << to_string(_gearNumber);
  out << ", " << "_controlMethod=" << to_string(_controlMethod);
  out << ", " << "_methodRate=" << to_string(_methodRate);
  out << ", " << "_methodPeriod=" << to_string(_methodPeriod);
  out << ", " << "_methodRateCount=" << to_string(_methodRateCount);
  out << ", " << "_cyclereFreshRate=" << to_string(_cyclereFreshRate);
  out << ", " << "_methodStopType=" << to_string(_methodStopType);
  out << ", " << "_changeCondition=" << to_string(_changeCondition);
  out << ", " << "_changeDuration=" << to_string(_changeDuration);
  out << ", " << "_changePriority=" << to_string(_changePriority);
  out << ", " << "_changeTriggerNumber=" << to_string(_changeTriggerNumber);
  out << ", " << "_changeTriggerOffset=" << to_string(_changeTriggerOffset);
  out << ", " << "_percentReduction=" << to_string(_percentReduction);
  out << ", " << "_groupSelectionMethod=" << to_string(_groupSelectionMethod);
  out << ", " << "_methodOptionType=" << to_string(_methodOptionType);
  out << ", " << "_methodOptionMax=" << to_string(_methodOptionMax);
  out << ", " << "_rampInInterval=" << to_string(_rampInInterval);
  out << ", " << "_rampInPercent=" << to_string(_rampInPercent);
  out << ", " << "_rampOutInterval=" << to_string(_rampOutInterval);
  out << ", " << "_rampOutPercent=" << to_string(_rampOutPercent);
  out << ", " << "_kwReduction=" << to_string(_kwReduction);
  out << ")";
}


LMGroupBase::~LMGroupBase() noexcept {
}


void LMGroupBase::__set__paoId(const int32_t val) {
  this->_paoId = val;
}

void LMGroupBase::__set__paoCategory(const std::string& val) {
  this->_paoCategory = val;
}

void LMGroupBase::__set__paoClass(const std::string& val) {
  this->_paoClass = val;
}

void LMGroupBase::__set__paoName(const std::string& val) {
  this->_paoName = val;
}

void LMGroupBase::__set__paoTypeString(const std::string& val) {
  this->_paoTypeString = val;
}

void LMGroupBase::__set__paoDescription(const std::string& val) {
  this->_paoDescription = val;
}

void LMGroupBase::__set__disableFlag(const bool val) {
  this->_disableFlag = val;
}

void LMGroupBase::__set__groupOrder(const int32_t val) {
  this->_groupOrder = val;
}

void LMGroupBase::__set__kwCapacity(const double val) {
  this->_kwCapacity = val;
}

void LMGroupBase::__set__childOrder(const int32_t val) {
  this->_childOrder = val;
}

void LMGroupBase::__set__alarmInhibit(const bool val) {
  this->_alarmInhibit = val;
}

void LMGroupBase::__set__controlInhibit(const bool val) {
  this->_controlInhibit = val;
}

void LMGroupBase::__set__groupControlState(const int32_t val) {
  this->_groupControlState = val;
}

void LMGroupBase::__set__currentHoursDaily(const int32_t val) {
  this->_currentHoursDaily = val;
}

void LMGroupBase::__set__currentHoursMonthly(const int32_t val) {
  this->_currentHoursMonthly = val;
}

void LMGroupBase::__set__currentHoursSeasonal(const int32_t val) {
  this->_currentHoursSeasonal = val;
}

void LMGroupBase::__set__currentHoursAnnually(const int32_t val) {
  this->_currentHoursAnnually = val;
}

void LMGroupBase::__set__lastControlSent(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_lastControlSent = val;
}

void LMGroupBase::__set__controlStartTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_controlStartTime = val;
}

void LMGroupBase::__set__controlCompleteTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_controlCompleteTime = val;
}

void LMGroupBase::__set__nextControlTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_nextControlTime = val;
}

void LMGroupBase::__set__internalState(const int32_t val) {
  this->_internalState = val;
}

void LMGroupBase::__set__dailyOps(const int32_t val) {
  this->_dailyOps = val;
}

void LMGroupBase::__set__lastStopTimeSent(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_lastStopTimeSent = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupBase& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupBase::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__paoId = false;
  bool isset__paoCategory = false;
  bool isset__paoClass = false;
  bool isset__paoName = false;
  bool isset__paoTypeString = false;
  bool isset__paoDescription = false;
  bool isset__disableFlag = false;
  bool isset__groupOrder = false;
  bool isset__kwCapacity = false;
  bool isset__childOrder = false;
  bool isset__alarmInhibit = false;
  bool isset__controlInhibit = false;
  bool isset__groupControlState = false;
  bool isset__currentHoursDaily = false;
  bool isset__currentHoursMonthly = false;
  bool isset__currentHoursSeasonal = false;
  bool isset__currentHoursAnnually = false;
  bool isset__lastControlSent = false;
  bool isset__controlStartTime = false;
  bool isset__controlCompleteTime = false;
  bool isset__nextControlTime = false;
  bool isset__internalState = false;
  bool isset__dailyOps = false;
  bool isset__lastStopTimeSent = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_paoId);
          isset__paoId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoCategory);
          isset__paoCategory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoClass);
          isset__paoClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoName);
          isset__paoName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoTypeString);
          isset__paoTypeString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoDescription);
          isset__paoDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_disableFlag);
          isset__disableFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_groupOrder);
          isset__groupOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_kwCapacity);
          isset__kwCapacity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_childOrder);
          isset__childOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_alarmInhibit);
          isset__alarmInhibit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_controlInhibit);
          isset__controlInhibit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_groupControlState);
          isset__groupControlState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_currentHoursDaily);
          isset__currentHoursDaily = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_currentHoursMonthly);
          isset__currentHoursMonthly = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_currentHoursSeasonal);
          isset__currentHoursSeasonal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_currentHoursAnnually);
          isset__currentHoursAnnually = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_lastControlSent);
          isset__lastControlSent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_controlStartTime);
          isset__controlStartTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_controlCompleteTime);
          isset__controlCompleteTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_nextControlTime);
          isset__nextControlTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_internalState);
          isset__internalState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_dailyOps);
          isset__dailyOps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_lastStopTimeSent);
          isset__lastStopTimeSent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__paoId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoCategory)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoClass)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoTypeString)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoDescription)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__disableFlag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__groupOrder)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__kwCapacity)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__childOrder)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__alarmInhibit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__controlInhibit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__groupControlState)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__currentHoursDaily)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__currentHoursMonthly)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__currentHoursSeasonal)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__currentHoursAnnually)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lastControlSent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__controlStartTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__controlCompleteTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__nextControlTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__internalState)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__dailyOps)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lastStopTimeSent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupBase::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupBase");

  xfer += oprot->writeFieldBegin("_paoId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_paoId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoCategory", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->_paoCategory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoClass", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->_paoClass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->_paoName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoTypeString", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->_paoTypeString);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoDescription", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->_paoDescription);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_disableFlag", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->_disableFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_groupOrder", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->_groupOrder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_kwCapacity", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->_kwCapacity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_childOrder", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->_childOrder);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_alarmInhibit", ::apache::thrift::protocol::T_BOOL, 11);
  xfer += oprot->writeBool(this->_alarmInhibit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_controlInhibit", ::apache::thrift::protocol::T_BOOL, 12);
  xfer += oprot->writeBool(this->_controlInhibit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_groupControlState", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->_groupControlState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_currentHoursDaily", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->_currentHoursDaily);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_currentHoursMonthly", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->_currentHoursMonthly);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_currentHoursSeasonal", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32(this->_currentHoursSeasonal);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_currentHoursAnnually", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->_currentHoursAnnually);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lastControlSent", ::apache::thrift::protocol::T_I64, 18);
  xfer += oprot->writeI64(this->_lastControlSent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_controlStartTime", ::apache::thrift::protocol::T_I64, 19);
  xfer += oprot->writeI64(this->_controlStartTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_controlCompleteTime", ::apache::thrift::protocol::T_I64, 21);
  xfer += oprot->writeI64(this->_controlCompleteTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_nextControlTime", ::apache::thrift::protocol::T_I64, 23);
  xfer += oprot->writeI64(this->_nextControlTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_internalState", ::apache::thrift::protocol::T_I32, 24);
  xfer += oprot->writeI32(this->_internalState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_dailyOps", ::apache::thrift::protocol::T_I32, 25);
  xfer += oprot->writeI32(this->_dailyOps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lastStopTimeSent", ::apache::thrift::protocol::T_I64, 26);
  xfer += oprot->writeI64(this->_lastStopTimeSent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupBase &a, LMGroupBase &b) {
  using ::std::swap;
  swap(a._paoId, b._paoId);
  swap(a._paoCategory, b._paoCategory);
  swap(a._paoClass, b._paoClass);
  swap(a._paoName, b._paoName);
  swap(a._paoTypeString, b._paoTypeString);
  swap(a._paoDescription, b._paoDescription);
  swap(a._disableFlag, b._disableFlag);
  swap(a._groupOrder, b._groupOrder);
  swap(a._kwCapacity, b._kwCapacity);
  swap(a._childOrder, b._childOrder);
  swap(a._alarmInhibit, b._alarmInhibit);
  swap(a._controlInhibit, b._controlInhibit);
  swap(a._groupControlState, b._groupControlState);
  swap(a._currentHoursDaily, b._currentHoursDaily);
  swap(a._currentHoursMonthly, b._currentHoursMonthly);
  swap(a._currentHoursSeasonal, b._currentHoursSeasonal);
  swap(a._currentHoursAnnually, b._currentHoursAnnually);
  swap(a._lastControlSent, b._lastControlSent);
  swap(a._controlStartTime, b._controlStartTime);
  swap(a._controlCompleteTime, b._controlCompleteTime);
  swap(a._nextControlTime, b._nextControlTime);
  swap(a._internalState, b._internalState);
  swap(a._dailyOps, b._dailyOps);
  swap(a._lastStopTimeSent, b._lastStopTimeSent);
}

LMGroupBase::LMGroupBase(const LMGroupBase& other26) {
  _paoId = other26._paoId;
  _paoCategory = other26._paoCategory;
  _paoClass = other26._paoClass;
  _paoName = other26._paoName;
  _paoTypeString = other26._paoTypeString;
  _paoDescription = other26._paoDescription;
  _disableFlag = other26._disableFlag;
  _groupOrder = other26._groupOrder;
  _kwCapacity = other26._kwCapacity;
  _childOrder = other26._childOrder;
  _alarmInhibit = other26._alarmInhibit;
  _controlInhibit = other26._controlInhibit;
  _groupControlState = other26._groupControlState;
  _currentHoursDaily = other26._currentHoursDaily;
  _currentHoursMonthly = other26._currentHoursMonthly;
  _currentHoursSeasonal = other26._currentHoursSeasonal;
  _currentHoursAnnually = other26._currentHoursAnnually;
  _lastControlSent = other26._lastControlSent;
  _controlStartTime = other26._controlStartTime;
  _controlCompleteTime = other26._controlCompleteTime;
  _nextControlTime = other26._nextControlTime;
  _internalState = other26._internalState;
  _dailyOps = other26._dailyOps;
  _lastStopTimeSent = other26._lastStopTimeSent;
}
LMGroupBase& LMGroupBase::operator=(const LMGroupBase& other27) {
  _paoId = other27._paoId;
  _paoCategory = other27._paoCategory;
  _paoClass = other27._paoClass;
  _paoName = other27._paoName;
  _paoTypeString = other27._paoTypeString;
  _paoDescription = other27._paoDescription;
  _disableFlag = other27._disableFlag;
  _groupOrder = other27._groupOrder;
  _kwCapacity = other27._kwCapacity;
  _childOrder = other27._childOrder;
  _alarmInhibit = other27._alarmInhibit;
  _controlInhibit = other27._controlInhibit;
  _groupControlState = other27._groupControlState;
  _currentHoursDaily = other27._currentHoursDaily;
  _currentHoursMonthly = other27._currentHoursMonthly;
  _currentHoursSeasonal = other27._currentHoursSeasonal;
  _currentHoursAnnually = other27._currentHoursAnnually;
  _lastControlSent = other27._lastControlSent;
  _controlStartTime = other27._controlStartTime;
  _controlCompleteTime = other27._controlCompleteTime;
  _nextControlTime = other27._nextControlTime;
  _internalState = other27._internalState;
  _dailyOps = other27._dailyOps;
  _lastStopTimeSent = other27._lastStopTimeSent;
  return *this;
}
void LMGroupBase::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupBase(";
  out << "_paoId=" << to_string(_paoId);
  out << ", " << "_paoCategory=" << to_string(_paoCategory);
  out << ", " << "_paoClass=" << to_string(_paoClass);
  out << ", " << "_paoName=" << to_string(_paoName);
  out << ", " << "_paoTypeString=" << to_string(_paoTypeString);
  out << ", " << "_paoDescription=" << to_string(_paoDescription);
  out << ", " << "_disableFlag=" << to_string(_disableFlag);
  out << ", " << "_groupOrder=" << to_string(_groupOrder);
  out << ", " << "_kwCapacity=" << to_string(_kwCapacity);
  out << ", " << "_childOrder=" << to_string(_childOrder);
  out << ", " << "_alarmInhibit=" << to_string(_alarmInhibit);
  out << ", " << "_controlInhibit=" << to_string(_controlInhibit);
  out << ", " << "_groupControlState=" << to_string(_groupControlState);
  out << ", " << "_currentHoursDaily=" << to_string(_currentHoursDaily);
  out << ", " << "_currentHoursMonthly=" << to_string(_currentHoursMonthly);
  out << ", " << "_currentHoursSeasonal=" << to_string(_currentHoursSeasonal);
  out << ", " << "_currentHoursAnnually=" << to_string(_currentHoursAnnually);
  out << ", " << "_lastControlSent=" << to_string(_lastControlSent);
  out << ", " << "_controlStartTime=" << to_string(_controlStartTime);
  out << ", " << "_controlCompleteTime=" << to_string(_controlCompleteTime);
  out << ", " << "_nextControlTime=" << to_string(_nextControlTime);
  out << ", " << "_internalState=" << to_string(_internalState);
  out << ", " << "_dailyOps=" << to_string(_dailyOps);
  out << ", " << "_lastStopTimeSent=" << to_string(_lastStopTimeSent);
  out << ")";
}


LMGroupDigiSEP::~LMGroupDigiSEP() noexcept {
}


void LMGroupDigiSEP::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupDigiSEP& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupDigiSEP::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupDigiSEP::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupDigiSEP");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupDigiSEP &a, LMGroupDigiSEP &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupDigiSEP::LMGroupDigiSEP(const LMGroupDigiSEP& other28) {
  _baseMessage = other28._baseMessage;
}
LMGroupDigiSEP& LMGroupDigiSEP::operator=(const LMGroupDigiSEP& other29) {
  _baseMessage = other29._baseMessage;
  return *this;
}
void LMGroupDigiSEP::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupDigiSEP(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupEcobee::~LMGroupEcobee() noexcept {
}


void LMGroupEcobee::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupEcobee& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupEcobee::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupEcobee::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupEcobee");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupEcobee &a, LMGroupEcobee &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupEcobee::LMGroupEcobee(const LMGroupEcobee& other30) {
  _baseMessage = other30._baseMessage;
}
LMGroupEcobee& LMGroupEcobee::operator=(const LMGroupEcobee& other31) {
  _baseMessage = other31._baseMessage;
  return *this;
}
void LMGroupEcobee::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupEcobee(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupHoneywell::~LMGroupHoneywell() noexcept {
}


void LMGroupHoneywell::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupHoneywell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupHoneywell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupHoneywell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupHoneywell");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupHoneywell &a, LMGroupHoneywell &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupHoneywell::LMGroupHoneywell(const LMGroupHoneywell& other32) {
  _baseMessage = other32._baseMessage;
}
LMGroupHoneywell& LMGroupHoneywell::operator=(const LMGroupHoneywell& other33) {
  _baseMessage = other33._baseMessage;
  return *this;
}
void LMGroupHoneywell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupHoneywell(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupNest::~LMGroupNest() noexcept {
}


void LMGroupNest::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupNest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupNest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupNest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupNest");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupNest &a, LMGroupNest &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupNest::LMGroupNest(const LMGroupNest& other34) {
  _baseMessage = other34._baseMessage;
}
LMGroupNest& LMGroupNest::operator=(const LMGroupNest& other35) {
  _baseMessage = other35._baseMessage;
  return *this;
}
void LMGroupNest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupNest(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupItron::~LMGroupItron() noexcept {
}


void LMGroupItron::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupItron& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupItron::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupItron::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupItron");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupItron &a, LMGroupItron &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupItron::LMGroupItron(const LMGroupItron& other36) {
  _baseMessage = other36._baseMessage;
}
LMGroupItron& LMGroupItron::operator=(const LMGroupItron& other37) {
  _baseMessage = other37._baseMessage;
  return *this;
}
void LMGroupItron::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupItron(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupMeterDisconnect::~LMGroupMeterDisconnect() noexcept {
}


void LMGroupMeterDisconnect::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupMeterDisconnect& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupMeterDisconnect::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupMeterDisconnect::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupMeterDisconnect");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupMeterDisconnect &a, LMGroupMeterDisconnect &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupMeterDisconnect::LMGroupMeterDisconnect(const LMGroupMeterDisconnect& other38) {
  _baseMessage = other38._baseMessage;
}
LMGroupMeterDisconnect& LMGroupMeterDisconnect::operator=(const LMGroupMeterDisconnect& other39) {
  _baseMessage = other39._baseMessage;
  return *this;
}
void LMGroupMeterDisconnect::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupMeterDisconnect(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupEmetcon::~LMGroupEmetcon() noexcept {
}


void LMGroupEmetcon::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupEmetcon& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupEmetcon::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupEmetcon::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupEmetcon");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupEmetcon &a, LMGroupEmetcon &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupEmetcon::LMGroupEmetcon(const LMGroupEmetcon& other40) {
  _baseMessage = other40._baseMessage;
}
LMGroupEmetcon& LMGroupEmetcon::operator=(const LMGroupEmetcon& other41) {
  _baseMessage = other41._baseMessage;
  return *this;
}
void LMGroupEmetcon::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupEmetcon(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupExpresscom::~LMGroupExpresscom() noexcept {
}


void LMGroupExpresscom::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupExpresscom& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupExpresscom::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupExpresscom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupExpresscom");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupExpresscom &a, LMGroupExpresscom &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupExpresscom::LMGroupExpresscom(const LMGroupExpresscom& other42) {
  _baseMessage = other42._baseMessage;
}
LMGroupExpresscom& LMGroupExpresscom::operator=(const LMGroupExpresscom& other43) {
  _baseMessage = other43._baseMessage;
  return *this;
}
void LMGroupExpresscom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupExpresscom(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupGolay::~LMGroupGolay() noexcept {
}


void LMGroupGolay::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupGolay& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupGolay::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupGolay::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupGolay");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupGolay &a, LMGroupGolay &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupGolay::LMGroupGolay(const LMGroupGolay& other44) {
  _baseMessage = other44._baseMessage;
}
LMGroupGolay& LMGroupGolay::operator=(const LMGroupGolay& other45) {
  _baseMessage = other45._baseMessage;
  return *this;
}
void LMGroupGolay::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupGolay(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupMacro::~LMGroupMacro() noexcept {
}


void LMGroupMacro::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupMacro& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupMacro::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupMacro::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupMacro");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupMacro &a, LMGroupMacro &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupMacro::LMGroupMacro(const LMGroupMacro& other46) {
  _baseMessage = other46._baseMessage;
}
LMGroupMacro& LMGroupMacro::operator=(const LMGroupMacro& other47) {
  _baseMessage = other47._baseMessage;
  return *this;
}
void LMGroupMacro::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupMacro(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupMCT::~LMGroupMCT() noexcept {
}


void LMGroupMCT::__set__baseMessage(const LMGroupEmetcon& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupMCT& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupMCT::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupMCT::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupMCT");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupMCT &a, LMGroupMCT &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupMCT::LMGroupMCT(const LMGroupMCT& other48) {
  _baseMessage = other48._baseMessage;
}
LMGroupMCT& LMGroupMCT::operator=(const LMGroupMCT& other49) {
  _baseMessage = other49._baseMessage;
  return *this;
}
void LMGroupMCT::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupMCT(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupPoint::~LMGroupPoint() noexcept {
}


void LMGroupPoint::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupPoint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupPoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupPoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupPoint");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupPoint &a, LMGroupPoint &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupPoint::LMGroupPoint(const LMGroupPoint& other50) {
  _baseMessage = other50._baseMessage;
}
LMGroupPoint& LMGroupPoint::operator=(const LMGroupPoint& other51) {
  _baseMessage = other51._baseMessage;
  return *this;
}
void LMGroupPoint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupPoint(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupRipple::~LMGroupRipple() noexcept {
}


void LMGroupRipple::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}

void LMGroupRipple::__set__shedTime(const int32_t val) {
  this->_shedTime = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupRipple& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupRipple::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;
  bool isset__shedTime = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_shedTime);
          isset__shedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__shedTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupRipple::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupRipple");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_shedTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_shedTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupRipple &a, LMGroupRipple &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
  swap(a._shedTime, b._shedTime);
}

LMGroupRipple::LMGroupRipple(const LMGroupRipple& other52) {
  _baseMessage = other52._baseMessage;
  _shedTime = other52._shedTime;
}
LMGroupRipple& LMGroupRipple::operator=(const LMGroupRipple& other53) {
  _baseMessage = other53._baseMessage;
  _shedTime = other53._shedTime;
  return *this;
}
void LMGroupRipple::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupRipple(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ", " << "_shedTime=" << to_string(_shedTime);
  out << ")";
}


LMGroupSA105::~LMGroupSA105() noexcept {
}


void LMGroupSA105::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupSA105& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupSA105::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupSA105::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupSA105");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupSA105 &a, LMGroupSA105 &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupSA105::LMGroupSA105(const LMGroupSA105& other54) {
  _baseMessage = other54._baseMessage;
}
LMGroupSA105& LMGroupSA105::operator=(const LMGroupSA105& other55) {
  _baseMessage = other55._baseMessage;
  return *this;
}
void LMGroupSA105::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupSA105(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupSA205::~LMGroupSA205() noexcept {
}


void LMGroupSA205::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupSA205& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupSA205::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupSA205::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupSA205");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupSA205 &a, LMGroupSA205 &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupSA205::LMGroupSA205(const LMGroupSA205& other56) {
  _baseMessage = other56._baseMessage;
}
LMGroupSA205& LMGroupSA205::operator=(const LMGroupSA205& other57) {
  _baseMessage = other57._baseMessage;
  return *this;
}
void LMGroupSA205::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupSA205(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupSA305::~LMGroupSA305() noexcept {
}


void LMGroupSA305::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupSA305& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupSA305::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupSA305::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupSA305");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupSA305 &a, LMGroupSA305 &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupSA305::LMGroupSA305(const LMGroupSA305& other58) {
  _baseMessage = other58._baseMessage;
}
LMGroupSA305& LMGroupSA305::operator=(const LMGroupSA305& other59) {
  _baseMessage = other59._baseMessage;
  return *this;
}
void LMGroupSA305::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupSA305(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupSADigital::~LMGroupSADigital() noexcept {
}


void LMGroupSADigital::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupSADigital& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupSADigital::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupSADigital::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupSADigital");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupSADigital &a, LMGroupSADigital &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupSADigital::LMGroupSADigital(const LMGroupSADigital& other60) {
  _baseMessage = other60._baseMessage;
}
LMGroupSADigital& LMGroupSADigital::operator=(const LMGroupSADigital& other61) {
  _baseMessage = other61._baseMessage;
  return *this;
}
void LMGroupSADigital::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupSADigital(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMGroupVersacom::~LMGroupVersacom() noexcept {
}


void LMGroupVersacom::__set__baseMessage(const LMGroupBase& val) {
  this->_baseMessage = val;
}
std::ostream& operator<<(std::ostream& out, const LMGroupVersacom& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMGroupVersacom::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMGroupVersacom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMGroupVersacom");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMGroupVersacom &a, LMGroupVersacom &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
}

LMGroupVersacom::LMGroupVersacom(const LMGroupVersacom& other62) {
  _baseMessage = other62._baseMessage;
}
LMGroupVersacom& LMGroupVersacom::operator=(const LMGroupVersacom& other63) {
  _baseMessage = other63._baseMessage;
  return *this;
}
void LMGroupVersacom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMGroupVersacom(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ")";
}


LMProgramDirect::~LMProgramDirect() noexcept {
}


void LMProgramDirect::__set__baseMessage(const LMProgramBase& val) {
  this->_baseMessage = val;
}

void LMProgramDirect::__set__currentGearNumber(const int32_t val) {
  this->_currentGearNumber = val;
}

void LMProgramDirect::__set__lastGroupControlled(const int32_t val) {
  this->_lastGroupControlled = val;
}

void LMProgramDirect::__set__directStartTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_directStartTime = val;
}

void LMProgramDirect::__set__directstopTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_directstopTime = val;
}

void LMProgramDirect::__set__notifyActiveTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_notifyActiveTime = val;
}

void LMProgramDirect::__set__notifyInactiveTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_notifyInactiveTime = val;
}

void LMProgramDirect::__set__startedRampingOut(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_startedRampingOut = val;
}

void LMProgramDirect::__set__triggerOffset(const int32_t val) {
  this->_triggerOffset = val;
}

void LMProgramDirect::__set__triggerRestoreOffset(const int32_t val) {
  this->_triggerRestoreOffset = val;
}

void LMProgramDirect::__set__constraintOverride(const bool val) {
  this->_constraintOverride = val;
}

void LMProgramDirect::__set__lmProgramDirectGears(const std::vector<LMProgramDirectGear> & val) {
  this->_lmProgramDirectGears = val;
}

void LMProgramDirect::__set__lmProgramDirectGroups(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val) {
  this->_lmProgramDirectGroups = val;
}

void LMProgramDirect::__set__activeMasters(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val) {
  this->_activeMasters = val;
}

void LMProgramDirect::__set__activeSubordinates(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val) {
  this->_activeSubordinates = val;
}

void LMProgramDirect::__set__originSource(const std::string& val) {
  this->_originSource = val;
}
std::ostream& operator<<(std::ostream& out, const LMProgramDirect& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMProgramDirect::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;
  bool isset__currentGearNumber = false;
  bool isset__lastGroupControlled = false;
  bool isset__directStartTime = false;
  bool isset__directstopTime = false;
  bool isset__notifyActiveTime = false;
  bool isset__notifyInactiveTime = false;
  bool isset__startedRampingOut = false;
  bool isset__triggerOffset = false;
  bool isset__triggerRestoreOffset = false;
  bool isset__constraintOverride = false;
  bool isset__lmProgramDirectGears = false;
  bool isset__lmProgramDirectGroups = false;
  bool isset__activeMasters = false;
  bool isset__activeSubordinates = false;
  bool isset__originSource = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_currentGearNumber);
          isset__currentGearNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_lastGroupControlled);
          isset__lastGroupControlled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_directStartTime);
          isset__directStartTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_directstopTime);
          isset__directstopTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_notifyActiveTime);
          isset__notifyActiveTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_notifyInactiveTime);
          isset__notifyInactiveTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_startedRampingOut);
          isset__startedRampingOut = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_triggerOffset);
          isset__triggerOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_triggerRestoreOffset);
          isset__triggerRestoreOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_constraintOverride);
          isset__constraintOverride = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmProgramDirectGears.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->_lmProgramDirectGears.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += this->_lmProgramDirectGears[_i68].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmProgramDirectGears = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmProgramDirectGroups.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readListBegin(_etype72, _size69);
            this->_lmProgramDirectGroups.resize(_size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              xfer += this->_lmProgramDirectGroups[_i73].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmProgramDirectGroups = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_activeMasters.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readListBegin(_etype77, _size74);
            this->_activeMasters.resize(_size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              xfer += this->_activeMasters[_i78].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__activeMasters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_activeSubordinates.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->_activeSubordinates.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += this->_activeSubordinates[_i83].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__activeSubordinates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_originSource);
          isset__originSource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__currentGearNumber)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lastGroupControlled)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__directStartTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__directstopTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__notifyActiveTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__notifyInactiveTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__startedRampingOut)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__triggerOffset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__triggerRestoreOffset)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__constraintOverride)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmProgramDirectGears)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmProgramDirectGroups)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__activeMasters)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__activeSubordinates)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__originSource)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMProgramDirect::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMProgramDirect");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_currentGearNumber", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_currentGearNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lastGroupControlled", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->_lastGroupControlled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_directStartTime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->_directStartTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_directstopTime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->_directstopTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_notifyActiveTime", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->_notifyActiveTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_notifyInactiveTime", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->_notifyInactiveTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_startedRampingOut", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->_startedRampingOut);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_triggerOffset", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->_triggerOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_triggerRestoreOffset", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->_triggerRestoreOffset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_constraintOverride", ::apache::thrift::protocol::T_BOOL, 11);
  xfer += oprot->writeBool(this->_constraintOverride);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmProgramDirectGears", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmProgramDirectGears.size()));
    std::vector<LMProgramDirectGear> ::const_iterator _iter84;
    for (_iter84 = this->_lmProgramDirectGears.begin(); _iter84 != this->_lmProgramDirectGears.end(); ++_iter84)
    {
      xfer += (*_iter84).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmProgramDirectGroups", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmProgramDirectGroups.size()));
    std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> ::const_iterator _iter85;
    for (_iter85 = this->_lmProgramDirectGroups.begin(); _iter85 != this->_lmProgramDirectGroups.end(); ++_iter85)
    {
      xfer += (*_iter85).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_activeMasters", ::apache::thrift::protocol::T_LIST, 14);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_activeMasters.size()));
    std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> ::const_iterator _iter86;
    for (_iter86 = this->_activeMasters.begin(); _iter86 != this->_activeMasters.end(); ++_iter86)
    {
      xfer += (*_iter86).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_activeSubordinates", ::apache::thrift::protocol::T_LIST, 15);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_activeSubordinates.size()));
    std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> ::const_iterator _iter87;
    for (_iter87 = this->_activeSubordinates.begin(); _iter87 != this->_activeSubordinates.end(); ++_iter87)
    {
      xfer += (*_iter87).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_originSource", ::apache::thrift::protocol::T_STRING, 16);
  xfer += oprot->writeString(this->_originSource);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMProgramDirect &a, LMProgramDirect &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
  swap(a._currentGearNumber, b._currentGearNumber);
  swap(a._lastGroupControlled, b._lastGroupControlled);
  swap(a._directStartTime, b._directStartTime);
  swap(a._directstopTime, b._directstopTime);
  swap(a._notifyActiveTime, b._notifyActiveTime);
  swap(a._notifyInactiveTime, b._notifyInactiveTime);
  swap(a._startedRampingOut, b._startedRampingOut);
  swap(a._triggerOffset, b._triggerOffset);
  swap(a._triggerRestoreOffset, b._triggerRestoreOffset);
  swap(a._constraintOverride, b._constraintOverride);
  swap(a._lmProgramDirectGears, b._lmProgramDirectGears);
  swap(a._lmProgramDirectGroups, b._lmProgramDirectGroups);
  swap(a._activeMasters, b._activeMasters);
  swap(a._activeSubordinates, b._activeSubordinates);
  swap(a._originSource, b._originSource);
}

LMProgramDirect::LMProgramDirect(const LMProgramDirect& other88) {
  _baseMessage = other88._baseMessage;
  _currentGearNumber = other88._currentGearNumber;
  _lastGroupControlled = other88._lastGroupControlled;
  _directStartTime = other88._directStartTime;
  _directstopTime = other88._directstopTime;
  _notifyActiveTime = other88._notifyActiveTime;
  _notifyInactiveTime = other88._notifyInactiveTime;
  _startedRampingOut = other88._startedRampingOut;
  _triggerOffset = other88._triggerOffset;
  _triggerRestoreOffset = other88._triggerRestoreOffset;
  _constraintOverride = other88._constraintOverride;
  _lmProgramDirectGears = other88._lmProgramDirectGears;
  _lmProgramDirectGroups = other88._lmProgramDirectGroups;
  _activeMasters = other88._activeMasters;
  _activeSubordinates = other88._activeSubordinates;
  _originSource = other88._originSource;
}
LMProgramDirect& LMProgramDirect::operator=(const LMProgramDirect& other89) {
  _baseMessage = other89._baseMessage;
  _currentGearNumber = other89._currentGearNumber;
  _lastGroupControlled = other89._lastGroupControlled;
  _directStartTime = other89._directStartTime;
  _directstopTime = other89._directstopTime;
  _notifyActiveTime = other89._notifyActiveTime;
  _notifyInactiveTime = other89._notifyInactiveTime;
  _startedRampingOut = other89._startedRampingOut;
  _triggerOffset = other89._triggerOffset;
  _triggerRestoreOffset = other89._triggerRestoreOffset;
  _constraintOverride = other89._constraintOverride;
  _lmProgramDirectGears = other89._lmProgramDirectGears;
  _lmProgramDirectGroups = other89._lmProgramDirectGroups;
  _activeMasters = other89._activeMasters;
  _activeSubordinates = other89._activeSubordinates;
  _originSource = other89._originSource;
  return *this;
}
void LMProgramDirect::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMProgramDirect(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ", " << "_currentGearNumber=" << to_string(_currentGearNumber);
  out << ", " << "_lastGroupControlled=" << to_string(_lastGroupControlled);
  out << ", " << "_directStartTime=" << to_string(_directStartTime);
  out << ", " << "_directstopTime=" << to_string(_directstopTime);
  out << ", " << "_notifyActiveTime=" << to_string(_notifyActiveTime);
  out << ", " << "_notifyInactiveTime=" << to_string(_notifyInactiveTime);
  out << ", " << "_startedRampingOut=" << to_string(_startedRampingOut);
  out << ", " << "_triggerOffset=" << to_string(_triggerOffset);
  out << ", " << "_triggerRestoreOffset=" << to_string(_triggerRestoreOffset);
  out << ", " << "_constraintOverride=" << to_string(_constraintOverride);
  out << ", " << "_lmProgramDirectGears=" << to_string(_lmProgramDirectGears);
  out << ", " << "_lmProgramDirectGroups=" << to_string(_lmProgramDirectGroups);
  out << ", " << "_activeMasters=" << to_string(_activeMasters);
  out << ", " << "_activeSubordinates=" << to_string(_activeSubordinates);
  out << ", " << "_originSource=" << to_string(_originSource);
  out << ")";
}


LMEnergyExchangeHourlyOffer::~LMEnergyExchangeHourlyOffer() noexcept {
}


void LMEnergyExchangeHourlyOffer::__set__offerId(const int32_t val) {
  this->_offerId = val;
}

void LMEnergyExchangeHourlyOffer::__set__revisionNumber(const int32_t val) {
  this->_revisionNumber = val;
}

void LMEnergyExchangeHourlyOffer::__set__hour(const int32_t val) {
  this->_hour = val;
}

void LMEnergyExchangeHourlyOffer::__set__price(const double val) {
  this->_price = val;
}

void LMEnergyExchangeHourlyOffer::__set__amountRequested(const double val) {
  this->_amountRequested = val;
}
std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeHourlyOffer& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMEnergyExchangeHourlyOffer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__offerId = false;
  bool isset__revisionNumber = false;
  bool isset__hour = false;
  bool isset__price = false;
  bool isset__amountRequested = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_offerId);
          isset__offerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_revisionNumber);
          isset__revisionNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_hour);
          isset__hour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_price);
          isset__price = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_amountRequested);
          isset__amountRequested = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__offerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__revisionNumber)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__hour)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__price)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__amountRequested)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMEnergyExchangeHourlyOffer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMEnergyExchangeHourlyOffer");

  xfer += oprot->writeFieldBegin("_offerId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_offerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_revisionNumber", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_revisionNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_hour", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->_hour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_price", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->_price);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_amountRequested", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->_amountRequested);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMEnergyExchangeHourlyOffer &a, LMEnergyExchangeHourlyOffer &b) {
  using ::std::swap;
  swap(a._offerId, b._offerId);
  swap(a._revisionNumber, b._revisionNumber);
  swap(a._hour, b._hour);
  swap(a._price, b._price);
  swap(a._amountRequested, b._amountRequested);
}

LMEnergyExchangeHourlyOffer::LMEnergyExchangeHourlyOffer(const LMEnergyExchangeHourlyOffer& other90) {
  _offerId = other90._offerId;
  _revisionNumber = other90._revisionNumber;
  _hour = other90._hour;
  _price = other90._price;
  _amountRequested = other90._amountRequested;
}
LMEnergyExchangeHourlyOffer& LMEnergyExchangeHourlyOffer::operator=(const LMEnergyExchangeHourlyOffer& other91) {
  _offerId = other91._offerId;
  _revisionNumber = other91._revisionNumber;
  _hour = other91._hour;
  _price = other91._price;
  _amountRequested = other91._amountRequested;
  return *this;
}
void LMEnergyExchangeHourlyOffer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMEnergyExchangeHourlyOffer(";
  out << "_offerId=" << to_string(_offerId);
  out << ", " << "_revisionNumber=" << to_string(_revisionNumber);
  out << ", " << "_hour=" << to_string(_hour);
  out << ", " << "_price=" << to_string(_price);
  out << ", " << "_amountRequested=" << to_string(_amountRequested);
  out << ")";
}


LMEnergyExchangeOfferRevision::~LMEnergyExchangeOfferRevision() noexcept {
}


void LMEnergyExchangeOfferRevision::__set__offerId(const int32_t val) {
  this->_offerId = val;
}

void LMEnergyExchangeOfferRevision::__set__revisionNumber(const int32_t val) {
  this->_revisionNumber = val;
}

void LMEnergyExchangeOfferRevision::__set__actionDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_actionDatetime = val;
}

void LMEnergyExchangeOfferRevision::__set__notificationDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_notificationDatetime = val;
}

void LMEnergyExchangeOfferRevision::__set__offerexpirationDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_offerexpirationDatetime = val;
}

void LMEnergyExchangeOfferRevision::__set__additionalInfo(const std::string& val) {
  this->_additionalInfo = val;
}

void LMEnergyExchangeOfferRevision::__set__lmEnergyExchangeHourlyOffers(const std::vector<LMEnergyExchangeHourlyOffer> & val) {
  this->_lmEnergyExchangeHourlyOffers = val;
}
std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeOfferRevision& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMEnergyExchangeOfferRevision::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__offerId = false;
  bool isset__revisionNumber = false;
  bool isset__actionDatetime = false;
  bool isset__notificationDatetime = false;
  bool isset__offerexpirationDatetime = false;
  bool isset__additionalInfo = false;
  bool isset__lmEnergyExchangeHourlyOffers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_offerId);
          isset__offerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_revisionNumber);
          isset__revisionNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_actionDatetime);
          isset__actionDatetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_notificationDatetime);
          isset__notificationDatetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_offerexpirationDatetime);
          isset__offerexpirationDatetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_additionalInfo);
          isset__additionalInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmEnergyExchangeHourlyOffers.clear();
            uint32_t _size92;
            ::apache::thrift::protocol::TType _etype95;
            xfer += iprot->readListBegin(_etype95, _size92);
            this->_lmEnergyExchangeHourlyOffers.resize(_size92);
            uint32_t _i96;
            for (_i96 = 0; _i96 < _size92; ++_i96)
            {
              xfer += this->_lmEnergyExchangeHourlyOffers[_i96].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmEnergyExchangeHourlyOffers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__offerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__revisionNumber)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__actionDatetime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__notificationDatetime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__offerexpirationDatetime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__additionalInfo)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmEnergyExchangeHourlyOffers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMEnergyExchangeOfferRevision::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMEnergyExchangeOfferRevision");

  xfer += oprot->writeFieldBegin("_offerId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_offerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_revisionNumber", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_revisionNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_actionDatetime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->_actionDatetime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_notificationDatetime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->_notificationDatetime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_offerexpirationDatetime", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->_offerexpirationDatetime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_additionalInfo", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->_additionalInfo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmEnergyExchangeHourlyOffers", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmEnergyExchangeHourlyOffers.size()));
    std::vector<LMEnergyExchangeHourlyOffer> ::const_iterator _iter97;
    for (_iter97 = this->_lmEnergyExchangeHourlyOffers.begin(); _iter97 != this->_lmEnergyExchangeHourlyOffers.end(); ++_iter97)
    {
      xfer += (*_iter97).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMEnergyExchangeOfferRevision &a, LMEnergyExchangeOfferRevision &b) {
  using ::std::swap;
  swap(a._offerId, b._offerId);
  swap(a._revisionNumber, b._revisionNumber);
  swap(a._actionDatetime, b._actionDatetime);
  swap(a._notificationDatetime, b._notificationDatetime);
  swap(a._offerexpirationDatetime, b._offerexpirationDatetime);
  swap(a._additionalInfo, b._additionalInfo);
  swap(a._lmEnergyExchangeHourlyOffers, b._lmEnergyExchangeHourlyOffers);
}

LMEnergyExchangeOfferRevision::LMEnergyExchangeOfferRevision(const LMEnergyExchangeOfferRevision& other98) {
  _offerId = other98._offerId;
  _revisionNumber = other98._revisionNumber;
  _actionDatetime = other98._actionDatetime;
  _notificationDatetime = other98._notificationDatetime;
  _offerexpirationDatetime = other98._offerexpirationDatetime;
  _additionalInfo = other98._additionalInfo;
  _lmEnergyExchangeHourlyOffers = other98._lmEnergyExchangeHourlyOffers;
}
LMEnergyExchangeOfferRevision& LMEnergyExchangeOfferRevision::operator=(const LMEnergyExchangeOfferRevision& other99) {
  _offerId = other99._offerId;
  _revisionNumber = other99._revisionNumber;
  _actionDatetime = other99._actionDatetime;
  _notificationDatetime = other99._notificationDatetime;
  _offerexpirationDatetime = other99._offerexpirationDatetime;
  _additionalInfo = other99._additionalInfo;
  _lmEnergyExchangeHourlyOffers = other99._lmEnergyExchangeHourlyOffers;
  return *this;
}
void LMEnergyExchangeOfferRevision::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMEnergyExchangeOfferRevision(";
  out << "_offerId=" << to_string(_offerId);
  out << ", " << "_revisionNumber=" << to_string(_revisionNumber);
  out << ", " << "_actionDatetime=" << to_string(_actionDatetime);
  out << ", " << "_notificationDatetime=" << to_string(_notificationDatetime);
  out << ", " << "_offerexpirationDatetime=" << to_string(_offerexpirationDatetime);
  out << ", " << "_additionalInfo=" << to_string(_additionalInfo);
  out << ", " << "_lmEnergyExchangeHourlyOffers=" << to_string(_lmEnergyExchangeHourlyOffers);
  out << ")";
}


LMEnergyExchangeOffer::~LMEnergyExchangeOffer() noexcept {
}


void LMEnergyExchangeOffer::__set__paoId(const int32_t val) {
  this->_paoId = val;
}

void LMEnergyExchangeOffer::__set__offerId(const int32_t val) {
  this->_offerId = val;
}

void LMEnergyExchangeOffer::__set__runStatus(const std::string& val) {
  this->_runStatus = val;
}

void LMEnergyExchangeOffer::__set__offerDate(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_offerDate = val;
}

void LMEnergyExchangeOffer::__set__lmEnergyExchangeOfferRevisions(const std::vector<LMEnergyExchangeOfferRevision> & val) {
  this->_lmEnergyExchangeOfferRevisions = val;
}
std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeOffer& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMEnergyExchangeOffer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__paoId = false;
  bool isset__offerId = false;
  bool isset__runStatus = false;
  bool isset__offerDate = false;
  bool isset__lmEnergyExchangeOfferRevisions = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_paoId);
          isset__paoId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_offerId);
          isset__offerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_runStatus);
          isset__runStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_offerDate);
          isset__offerDate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmEnergyExchangeOfferRevisions.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _etype103;
            xfer += iprot->readListBegin(_etype103, _size100);
            this->_lmEnergyExchangeOfferRevisions.resize(_size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              xfer += this->_lmEnergyExchangeOfferRevisions[_i104].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmEnergyExchangeOfferRevisions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__paoId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__offerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__runStatus)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__offerDate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmEnergyExchangeOfferRevisions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMEnergyExchangeOffer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMEnergyExchangeOffer");

  xfer += oprot->writeFieldBegin("_paoId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_paoId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_offerId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_offerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_runStatus", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->_runStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_offerDate", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->_offerDate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmEnergyExchangeOfferRevisions", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmEnergyExchangeOfferRevisions.size()));
    std::vector<LMEnergyExchangeOfferRevision> ::const_iterator _iter105;
    for (_iter105 = this->_lmEnergyExchangeOfferRevisions.begin(); _iter105 != this->_lmEnergyExchangeOfferRevisions.end(); ++_iter105)
    {
      xfer += (*_iter105).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMEnergyExchangeOffer &a, LMEnergyExchangeOffer &b) {
  using ::std::swap;
  swap(a._paoId, b._paoId);
  swap(a._offerId, b._offerId);
  swap(a._runStatus, b._runStatus);
  swap(a._offerDate, b._offerDate);
  swap(a._lmEnergyExchangeOfferRevisions, b._lmEnergyExchangeOfferRevisions);
}

LMEnergyExchangeOffer::LMEnergyExchangeOffer(const LMEnergyExchangeOffer& other106) {
  _paoId = other106._paoId;
  _offerId = other106._offerId;
  _runStatus = other106._runStatus;
  _offerDate = other106._offerDate;
  _lmEnergyExchangeOfferRevisions = other106._lmEnergyExchangeOfferRevisions;
}
LMEnergyExchangeOffer& LMEnergyExchangeOffer::operator=(const LMEnergyExchangeOffer& other107) {
  _paoId = other107._paoId;
  _offerId = other107._offerId;
  _runStatus = other107._runStatus;
  _offerDate = other107._offerDate;
  _lmEnergyExchangeOfferRevisions = other107._lmEnergyExchangeOfferRevisions;
  return *this;
}
void LMEnergyExchangeOffer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMEnergyExchangeOffer(";
  out << "_paoId=" << to_string(_paoId);
  out << ", " << "_offerId=" << to_string(_offerId);
  out << ", " << "_runStatus=" << to_string(_runStatus);
  out << ", " << "_offerDate=" << to_string(_offerDate);
  out << ", " << "_lmEnergyExchangeOfferRevisions=" << to_string(_lmEnergyExchangeOfferRevisions);
  out << ")";
}


LMEnergyExchangeHourlyCustomer::~LMEnergyExchangeHourlyCustomer() noexcept {
}


void LMEnergyExchangeHourlyCustomer::__set__customerId(const int32_t val) {
  this->_customerId = val;
}

void LMEnergyExchangeHourlyCustomer::__set__offerId(const int32_t val) {
  this->_offerId = val;
}

void LMEnergyExchangeHourlyCustomer::__set__revisionNumber(const int32_t val) {
  this->_revisionNumber = val;
}

void LMEnergyExchangeHourlyCustomer::__set__hour(const int32_t val) {
  this->_hour = val;
}

void LMEnergyExchangeHourlyCustomer::__set__amountCommitted(const double val) {
  this->_amountCommitted = val;
}
std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeHourlyCustomer& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMEnergyExchangeHourlyCustomer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__customerId = false;
  bool isset__offerId = false;
  bool isset__revisionNumber = false;
  bool isset__hour = false;
  bool isset__amountCommitted = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_customerId);
          isset__customerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_offerId);
          isset__offerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_revisionNumber);
          isset__revisionNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_hour);
          isset__hour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->_amountCommitted);
          isset__amountCommitted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__customerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__offerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__revisionNumber)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__hour)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__amountCommitted)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMEnergyExchangeHourlyCustomer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMEnergyExchangeHourlyCustomer");

  xfer += oprot->writeFieldBegin("_customerId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_customerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_offerId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_offerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_revisionNumber", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->_revisionNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_hour", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->_hour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_amountCommitted", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->_amountCommitted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMEnergyExchangeHourlyCustomer &a, LMEnergyExchangeHourlyCustomer &b) {
  using ::std::swap;
  swap(a._customerId, b._customerId);
  swap(a._offerId, b._offerId);
  swap(a._revisionNumber, b._revisionNumber);
  swap(a._hour, b._hour);
  swap(a._amountCommitted, b._amountCommitted);
}

LMEnergyExchangeHourlyCustomer::LMEnergyExchangeHourlyCustomer(const LMEnergyExchangeHourlyCustomer& other108) {
  _customerId = other108._customerId;
  _offerId = other108._offerId;
  _revisionNumber = other108._revisionNumber;
  _hour = other108._hour;
  _amountCommitted = other108._amountCommitted;
}
LMEnergyExchangeHourlyCustomer& LMEnergyExchangeHourlyCustomer::operator=(const LMEnergyExchangeHourlyCustomer& other109) {
  _customerId = other109._customerId;
  _offerId = other109._offerId;
  _revisionNumber = other109._revisionNumber;
  _hour = other109._hour;
  _amountCommitted = other109._amountCommitted;
  return *this;
}
void LMEnergyExchangeHourlyCustomer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMEnergyExchangeHourlyCustomer(";
  out << "_customerId=" << to_string(_customerId);
  out << ", " << "_offerId=" << to_string(_offerId);
  out << ", " << "_revisionNumber=" << to_string(_revisionNumber);
  out << ", " << "_hour=" << to_string(_hour);
  out << ", " << "_amountCommitted=" << to_string(_amountCommitted);
  out << ")";
}


LMEnergyExchangeCustomerReply::~LMEnergyExchangeCustomerReply() noexcept {
}


void LMEnergyExchangeCustomerReply::__set__customerId(const int32_t val) {
  this->_customerId = val;
}

void LMEnergyExchangeCustomerReply::__set__offerId(const int32_t val) {
  this->_offerId = val;
}

void LMEnergyExchangeCustomerReply::__set__acceptStatus(const std::string& val) {
  this->_acceptStatus = val;
}

void LMEnergyExchangeCustomerReply::__set__acceptDatetime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_acceptDatetime = val;
}

void LMEnergyExchangeCustomerReply::__set__revisionNumber(const int32_t val) {
  this->_revisionNumber = val;
}

void LMEnergyExchangeCustomerReply::__set__ipAddressOfAcceptUser(const std::string& val) {
  this->_ipAddressOfAcceptUser = val;
}

void LMEnergyExchangeCustomerReply::__set__userIdName(const std::string& val) {
  this->_userIdName = val;
}

void LMEnergyExchangeCustomerReply::__set__nameOfAcceptPerson(const std::string& val) {
  this->_nameOfAcceptPerson = val;
}

void LMEnergyExchangeCustomerReply::__set__energyExchangeNotes(const std::string& val) {
  this->_energyExchangeNotes = val;
}

void LMEnergyExchangeCustomerReply::__set__lmEnergyExchangeHourlyCustomers(const std::vector<LMEnergyExchangeHourlyCustomer> & val) {
  this->_lmEnergyExchangeHourlyCustomers = val;
}
std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeCustomerReply& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMEnergyExchangeCustomerReply::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__customerId = false;
  bool isset__offerId = false;
  bool isset__acceptStatus = false;
  bool isset__acceptDatetime = false;
  bool isset__revisionNumber = false;
  bool isset__ipAddressOfAcceptUser = false;
  bool isset__userIdName = false;
  bool isset__nameOfAcceptPerson = false;
  bool isset__energyExchangeNotes = false;
  bool isset__lmEnergyExchangeHourlyCustomers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_customerId);
          isset__customerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_offerId);
          isset__offerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_acceptStatus);
          isset__acceptStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_acceptDatetime);
          isset__acceptDatetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_revisionNumber);
          isset__revisionNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_ipAddressOfAcceptUser);
          isset__ipAddressOfAcceptUser = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_userIdName);
          isset__userIdName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_nameOfAcceptPerson);
          isset__nameOfAcceptPerson = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_energyExchangeNotes);
          isset__energyExchangeNotes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmEnergyExchangeHourlyCustomers.clear();
            uint32_t _size110;
            ::apache::thrift::protocol::TType _etype113;
            xfer += iprot->readListBegin(_etype113, _size110);
            this->_lmEnergyExchangeHourlyCustomers.resize(_size110);
            uint32_t _i114;
            for (_i114 = 0; _i114 < _size110; ++_i114)
            {
              xfer += this->_lmEnergyExchangeHourlyCustomers[_i114].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmEnergyExchangeHourlyCustomers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__customerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__offerId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__acceptStatus)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__acceptDatetime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__revisionNumber)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__ipAddressOfAcceptUser)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__userIdName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__nameOfAcceptPerson)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__energyExchangeNotes)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmEnergyExchangeHourlyCustomers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMEnergyExchangeCustomerReply::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMEnergyExchangeCustomerReply");

  xfer += oprot->writeFieldBegin("_customerId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_customerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_offerId", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_offerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_acceptStatus", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->_acceptStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_acceptDatetime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->_acceptDatetime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_revisionNumber", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->_revisionNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_ipAddressOfAcceptUser", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->_ipAddressOfAcceptUser);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_userIdName", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->_userIdName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_nameOfAcceptPerson", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->_nameOfAcceptPerson);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_energyExchangeNotes", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->_energyExchangeNotes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmEnergyExchangeHourlyCustomers", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmEnergyExchangeHourlyCustomers.size()));
    std::vector<LMEnergyExchangeHourlyCustomer> ::const_iterator _iter115;
    for (_iter115 = this->_lmEnergyExchangeHourlyCustomers.begin(); _iter115 != this->_lmEnergyExchangeHourlyCustomers.end(); ++_iter115)
    {
      xfer += (*_iter115).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMEnergyExchangeCustomerReply &a, LMEnergyExchangeCustomerReply &b) {
  using ::std::swap;
  swap(a._customerId, b._customerId);
  swap(a._offerId, b._offerId);
  swap(a._acceptStatus, b._acceptStatus);
  swap(a._acceptDatetime, b._acceptDatetime);
  swap(a._revisionNumber, b._revisionNumber);
  swap(a._ipAddressOfAcceptUser, b._ipAddressOfAcceptUser);
  swap(a._userIdName, b._userIdName);
  swap(a._nameOfAcceptPerson, b._nameOfAcceptPerson);
  swap(a._energyExchangeNotes, b._energyExchangeNotes);
  swap(a._lmEnergyExchangeHourlyCustomers, b._lmEnergyExchangeHourlyCustomers);
}

LMEnergyExchangeCustomerReply::LMEnergyExchangeCustomerReply(const LMEnergyExchangeCustomerReply& other116) {
  _customerId = other116._customerId;
  _offerId = other116._offerId;
  _acceptStatus = other116._acceptStatus;
  _acceptDatetime = other116._acceptDatetime;
  _revisionNumber = other116._revisionNumber;
  _ipAddressOfAcceptUser = other116._ipAddressOfAcceptUser;
  _userIdName = other116._userIdName;
  _nameOfAcceptPerson = other116._nameOfAcceptPerson;
  _energyExchangeNotes = other116._energyExchangeNotes;
  _lmEnergyExchangeHourlyCustomers = other116._lmEnergyExchangeHourlyCustomers;
}
LMEnergyExchangeCustomerReply& LMEnergyExchangeCustomerReply::operator=(const LMEnergyExchangeCustomerReply& other117) {
  _customerId = other117._customerId;
  _offerId = other117._offerId;
  _acceptStatus = other117._acceptStatus;
  _acceptDatetime = other117._acceptDatetime;
  _revisionNumber = other117._revisionNumber;
  _ipAddressOfAcceptUser = other117._ipAddressOfAcceptUser;
  _userIdName = other117._userIdName;
  _nameOfAcceptPerson = other117._nameOfAcceptPerson;
  _energyExchangeNotes = other117._energyExchangeNotes;
  _lmEnergyExchangeHourlyCustomers = other117._lmEnergyExchangeHourlyCustomers;
  return *this;
}
void LMEnergyExchangeCustomerReply::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMEnergyExchangeCustomerReply(";
  out << "_customerId=" << to_string(_customerId);
  out << ", " << "_offerId=" << to_string(_offerId);
  out << ", " << "_acceptStatus=" << to_string(_acceptStatus);
  out << ", " << "_acceptDatetime=" << to_string(_acceptDatetime);
  out << ", " << "_revisionNumber=" << to_string(_revisionNumber);
  out << ", " << "_ipAddressOfAcceptUser=" << to_string(_ipAddressOfAcceptUser);
  out << ", " << "_userIdName=" << to_string(_userIdName);
  out << ", " << "_nameOfAcceptPerson=" << to_string(_nameOfAcceptPerson);
  out << ", " << "_energyExchangeNotes=" << to_string(_energyExchangeNotes);
  out << ", " << "_lmEnergyExchangeHourlyCustomers=" << to_string(_lmEnergyExchangeHourlyCustomers);
  out << ")";
}


LMEnergyExchangeCustomer::~LMEnergyExchangeCustomer() noexcept {
}


void LMEnergyExchangeCustomer::__set__baseMessage(const LMCICustomerBase& val) {
  this->_baseMessage = val;
}

void LMEnergyExchangeCustomer::__set__lmEnergyExchangeCustomerReplies(const std::vector<LMEnergyExchangeCustomerReply> & val) {
  this->_lmEnergyExchangeCustomerReplies = val;
}
std::ostream& operator<<(std::ostream& out, const LMEnergyExchangeCustomer& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMEnergyExchangeCustomer::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;
  bool isset__lmEnergyExchangeCustomerReplies = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmEnergyExchangeCustomerReplies.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->_lmEnergyExchangeCustomerReplies.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += this->_lmEnergyExchangeCustomerReplies[_i122].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmEnergyExchangeCustomerReplies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmEnergyExchangeCustomerReplies)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMEnergyExchangeCustomer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMEnergyExchangeCustomer");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmEnergyExchangeCustomerReplies", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmEnergyExchangeCustomerReplies.size()));
    std::vector<LMEnergyExchangeCustomerReply> ::const_iterator _iter123;
    for (_iter123 = this->_lmEnergyExchangeCustomerReplies.begin(); _iter123 != this->_lmEnergyExchangeCustomerReplies.end(); ++_iter123)
    {
      xfer += (*_iter123).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMEnergyExchangeCustomer &a, LMEnergyExchangeCustomer &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
  swap(a._lmEnergyExchangeCustomerReplies, b._lmEnergyExchangeCustomerReplies);
}

LMEnergyExchangeCustomer::LMEnergyExchangeCustomer(const LMEnergyExchangeCustomer& other124) {
  _baseMessage = other124._baseMessage;
  _lmEnergyExchangeCustomerReplies = other124._lmEnergyExchangeCustomerReplies;
}
LMEnergyExchangeCustomer& LMEnergyExchangeCustomer::operator=(const LMEnergyExchangeCustomer& other125) {
  _baseMessage = other125._baseMessage;
  _lmEnergyExchangeCustomerReplies = other125._lmEnergyExchangeCustomerReplies;
  return *this;
}
void LMEnergyExchangeCustomer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMEnergyExchangeCustomer(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ", " << "_lmEnergyExchangeCustomerReplies=" << to_string(_lmEnergyExchangeCustomerReplies);
  out << ")";
}


LMProgramEnergyExchange::~LMProgramEnergyExchange() noexcept {
}


void LMProgramEnergyExchange::__set__baseMessage(const LMProgramBase& val) {
  this->_baseMessage = val;
}

void LMProgramEnergyExchange::__set__minNotifyTime(const int32_t val) {
  this->_minNotifyTime = val;
}

void LMProgramEnergyExchange::__set__heading(const std::string& val) {
  this->_heading = val;
}

void LMProgramEnergyExchange::__set__messageHeader(const std::string& val) {
  this->_messageHeader = val;
}

void LMProgramEnergyExchange::__set__messageFooter(const std::string& val) {
  this->_messageFooter = val;
}

void LMProgramEnergyExchange::__set__canceledMsg(const std::string& val) {
  this->_canceledMsg = val;
}

void LMProgramEnergyExchange::__set__stoppedEarlyMsg(const std::string& val) {
  this->_stoppedEarlyMsg = val;
}

void LMProgramEnergyExchange::__set__lmEnergyExchangeOffers(const std::vector<LMEnergyExchangeOffer> & val) {
  this->_lmEnergyExchangeOffers = val;
}

void LMProgramEnergyExchange::__set__lmEnergyExchangeCustomers(const std::vector<LMEnergyExchangeCustomer> & val) {
  this->_lmEnergyExchangeCustomers = val;
}
std::ostream& operator<<(std::ostream& out, const LMProgramEnergyExchange& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMProgramEnergyExchange::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;
  bool isset__minNotifyTime = false;
  bool isset__heading = false;
  bool isset__messageHeader = false;
  bool isset__messageFooter = false;
  bool isset__canceledMsg = false;
  bool isset__stoppedEarlyMsg = false;
  bool isset__lmEnergyExchangeOffers = false;
  bool isset__lmEnergyExchangeCustomers = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_minNotifyTime);
          isset__minNotifyTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_heading);
          isset__heading = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_messageHeader);
          isset__messageHeader = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_messageFooter);
          isset__messageFooter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_canceledMsg);
          isset__canceledMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_stoppedEarlyMsg);
          isset__stoppedEarlyMsg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmEnergyExchangeOffers.clear();
            uint32_t _size126;
            ::apache::thrift::protocol::TType _etype129;
            xfer += iprot->readListBegin(_etype129, _size126);
            this->_lmEnergyExchangeOffers.resize(_size126);
            uint32_t _i130;
            for (_i130 = 0; _i130 < _size126; ++_i130)
            {
              xfer += this->_lmEnergyExchangeOffers[_i130].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmEnergyExchangeOffers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmEnergyExchangeCustomers.clear();
            uint32_t _size131;
            ::apache::thrift::protocol::TType _etype134;
            xfer += iprot->readListBegin(_etype134, _size131);
            this->_lmEnergyExchangeCustomers.resize(_size131);
            uint32_t _i135;
            for (_i135 = 0; _i135 < _size131; ++_i135)
            {
              xfer += this->_lmEnergyExchangeCustomers[_i135].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmEnergyExchangeCustomers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__minNotifyTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__heading)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__messageHeader)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__messageFooter)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__canceledMsg)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__stoppedEarlyMsg)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmEnergyExchangeOffers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmEnergyExchangeCustomers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMProgramEnergyExchange::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMProgramEnergyExchange");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_minNotifyTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_minNotifyTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_heading", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->_heading);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_messageHeader", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->_messageHeader);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_messageFooter", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->_messageFooter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_canceledMsg", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->_canceledMsg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_stoppedEarlyMsg", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->_stoppedEarlyMsg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmEnergyExchangeOffers", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmEnergyExchangeOffers.size()));
    std::vector<LMEnergyExchangeOffer> ::const_iterator _iter136;
    for (_iter136 = this->_lmEnergyExchangeOffers.begin(); _iter136 != this->_lmEnergyExchangeOffers.end(); ++_iter136)
    {
      xfer += (*_iter136).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmEnergyExchangeCustomers", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmEnergyExchangeCustomers.size()));
    std::vector<LMEnergyExchangeCustomer> ::const_iterator _iter137;
    for (_iter137 = this->_lmEnergyExchangeCustomers.begin(); _iter137 != this->_lmEnergyExchangeCustomers.end(); ++_iter137)
    {
      xfer += (*_iter137).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMProgramEnergyExchange &a, LMProgramEnergyExchange &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
  swap(a._minNotifyTime, b._minNotifyTime);
  swap(a._heading, b._heading);
  swap(a._messageHeader, b._messageHeader);
  swap(a._messageFooter, b._messageFooter);
  swap(a._canceledMsg, b._canceledMsg);
  swap(a._stoppedEarlyMsg, b._stoppedEarlyMsg);
  swap(a._lmEnergyExchangeOffers, b._lmEnergyExchangeOffers);
  swap(a._lmEnergyExchangeCustomers, b._lmEnergyExchangeCustomers);
}

LMProgramEnergyExchange::LMProgramEnergyExchange(const LMProgramEnergyExchange& other138) {
  _baseMessage = other138._baseMessage;
  _minNotifyTime = other138._minNotifyTime;
  _heading = other138._heading;
  _messageHeader = other138._messageHeader;
  _messageFooter = other138._messageFooter;
  _canceledMsg = other138._canceledMsg;
  _stoppedEarlyMsg = other138._stoppedEarlyMsg;
  _lmEnergyExchangeOffers = other138._lmEnergyExchangeOffers;
  _lmEnergyExchangeCustomers = other138._lmEnergyExchangeCustomers;
}
LMProgramEnergyExchange& LMProgramEnergyExchange::operator=(const LMProgramEnergyExchange& other139) {
  _baseMessage = other139._baseMessage;
  _minNotifyTime = other139._minNotifyTime;
  _heading = other139._heading;
  _messageHeader = other139._messageHeader;
  _messageFooter = other139._messageFooter;
  _canceledMsg = other139._canceledMsg;
  _stoppedEarlyMsg = other139._stoppedEarlyMsg;
  _lmEnergyExchangeOffers = other139._lmEnergyExchangeOffers;
  _lmEnergyExchangeCustomers = other139._lmEnergyExchangeCustomers;
  return *this;
}
void LMProgramEnergyExchange::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMProgramEnergyExchange(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ", " << "_minNotifyTime=" << to_string(_minNotifyTime);
  out << ", " << "_heading=" << to_string(_heading);
  out << ", " << "_messageHeader=" << to_string(_messageHeader);
  out << ", " << "_messageFooter=" << to_string(_messageFooter);
  out << ", " << "_canceledMsg=" << to_string(_canceledMsg);
  out << ", " << "_stoppedEarlyMsg=" << to_string(_stoppedEarlyMsg);
  out << ", " << "_lmEnergyExchangeOffers=" << to_string(_lmEnergyExchangeOffers);
  out << ", " << "_lmEnergyExchangeCustomers=" << to_string(_lmEnergyExchangeCustomers);
  out << ")";
}


LMControlAreaItem::~LMControlAreaItem() noexcept {
}


void LMControlAreaItem::__set__paoId(const int32_t val) {
  this->_paoId = val;
}

void LMControlAreaItem::__set__paoCategory(const std::string& val) {
  this->_paoCategory = val;
}

void LMControlAreaItem::__set__paoClass(const std::string& val) {
  this->_paoClass = val;
}

void LMControlAreaItem::__set__paoName(const std::string& val) {
  this->_paoName = val;
}

void LMControlAreaItem::__set__paoTypeString(const std::string& val) {
  this->_paoTypeString = val;
}

void LMControlAreaItem::__set__paoDescription(const std::string& val) {
  this->_paoDescription = val;
}

void LMControlAreaItem::__set__disableFlag(const bool val) {
  this->_disableFlag = val;
}

void LMControlAreaItem::__set__defOperationalState(const std::string& val) {
  this->_defOperationalState = val;
}

void LMControlAreaItem::__set__controlInterval(const int32_t val) {
  this->_controlInterval = val;
}

void LMControlAreaItem::__set__minResponseTime(const int32_t val) {
  this->_minResponseTime = val;
}

void LMControlAreaItem::__set__defDailyStartTime(const int32_t val) {
  this->_defDailyStartTime = val;
}

void LMControlAreaItem::__set__defDailyStopTime(const int32_t val) {
  this->_defDailyStopTime = val;
}

void LMControlAreaItem::__set__requireAllTriggersActiveFlag(const bool val) {
  this->_requireAllTriggersActiveFlag = val;
}

void LMControlAreaItem::__set__nextCheckTime(const  ::Cti::Messaging::Serialization::Thrift::Timestamp val) {
  this->_nextCheckTime = val;
}

void LMControlAreaItem::__set__newPointDataReceivedFlag(const bool val) {
  this->_newPointDataReceivedFlag = val;
}

void LMControlAreaItem::__set__updatedFlag(const bool val) {
  this->_updatedFlag = val;
}

void LMControlAreaItem::__set__controlAreaStatusPointId(const int32_t val) {
  this->_controlAreaStatusPointId = val;
}

void LMControlAreaItem::__set__controlAreaState(const int32_t val) {
  this->_controlAreaState = val;
}

void LMControlAreaItem::__set__currentPriority(const int32_t val) {
  this->_currentPriority = val;
}

void LMControlAreaItem::__set__currentDailyStartTime(const int32_t val) {
  this->_currentDailyStartTime = val;
}

void LMControlAreaItem::__set__currentDailyStopTime(const int32_t val) {
  this->_currentDailyStopTime = val;
}

void LMControlAreaItem::__set__lmControlAreaTriggers(const std::vector<LMControlAreaTrigger> & val) {
  this->_lmControlAreaTriggers = val;
}

void LMControlAreaItem::__set__lmPrograms(const std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> & val) {
  this->_lmPrograms = val;
}
std::ostream& operator<<(std::ostream& out, const LMControlAreaItem& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMControlAreaItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__paoId = false;
  bool isset__paoCategory = false;
  bool isset__paoClass = false;
  bool isset__paoName = false;
  bool isset__paoTypeString = false;
  bool isset__paoDescription = false;
  bool isset__disableFlag = false;
  bool isset__defOperationalState = false;
  bool isset__controlInterval = false;
  bool isset__minResponseTime = false;
  bool isset__defDailyStartTime = false;
  bool isset__defDailyStopTime = false;
  bool isset__requireAllTriggersActiveFlag = false;
  bool isset__nextCheckTime = false;
  bool isset__newPointDataReceivedFlag = false;
  bool isset__updatedFlag = false;
  bool isset__controlAreaStatusPointId = false;
  bool isset__controlAreaState = false;
  bool isset__currentPriority = false;
  bool isset__currentDailyStartTime = false;
  bool isset__currentDailyStopTime = false;
  bool isset__lmControlAreaTriggers = false;
  bool isset__lmPrograms = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_paoId);
          isset__paoId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoCategory);
          isset__paoCategory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoClass);
          isset__paoClass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoName);
          isset__paoName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoTypeString);
          isset__paoTypeString = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_paoDescription);
          isset__paoDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_disableFlag);
          isset__disableFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->_defOperationalState);
          isset__defOperationalState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_controlInterval);
          isset__controlInterval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_minResponseTime);
          isset__minResponseTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_defDailyStartTime);
          isset__defDailyStartTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_defDailyStopTime);
          isset__defDailyStopTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_requireAllTriggersActiveFlag);
          isset__requireAllTriggersActiveFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->_nextCheckTime);
          isset__nextCheckTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_newPointDataReceivedFlag);
          isset__newPointDataReceivedFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->_updatedFlag);
          isset__updatedFlag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_controlAreaStatusPointId);
          isset__controlAreaStatusPointId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_controlAreaState);
          isset__controlAreaState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_currentPriority);
          isset__currentPriority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_currentDailyStartTime);
          isset__currentDailyStartTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_currentDailyStopTime);
          isset__currentDailyStopTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmControlAreaTriggers.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size140);
            this->_lmControlAreaTriggers.resize(_size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              xfer += this->_lmControlAreaTriggers[_i144].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmControlAreaTriggers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_lmPrograms.clear();
            uint32_t _size145;
            ::apache::thrift::protocol::TType _etype148;
            xfer += iprot->readListBegin(_etype148, _size145);
            this->_lmPrograms.resize(_size145);
            uint32_t _i149;
            for (_i149 = 0; _i149 < _size145; ++_i149)
            {
              xfer += this->_lmPrograms[_i149].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__lmPrograms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__paoId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoCategory)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoClass)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoTypeString)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__paoDescription)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__disableFlag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__defOperationalState)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__controlInterval)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__minResponseTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__defDailyStartTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__defDailyStopTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__requireAllTriggersActiveFlag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__nextCheckTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__newPointDataReceivedFlag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__updatedFlag)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__controlAreaStatusPointId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__controlAreaState)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__currentPriority)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__currentDailyStartTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__currentDailyStopTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmControlAreaTriggers)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__lmPrograms)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMControlAreaItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMControlAreaItem");

  xfer += oprot->writeFieldBegin("_paoId", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->_paoId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoCategory", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->_paoCategory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoClass", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->_paoClass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->_paoName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoTypeString", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->_paoTypeString);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_paoDescription", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->_paoDescription);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_disableFlag", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->_disableFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_defOperationalState", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->_defOperationalState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_controlInterval", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->_controlInterval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_minResponseTime", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->_minResponseTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_defDailyStartTime", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->_defDailyStartTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_defDailyStopTime", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->_defDailyStopTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_requireAllTriggersActiveFlag", ::apache::thrift::protocol::T_BOOL, 13);
  xfer += oprot->writeBool(this->_requireAllTriggersActiveFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_nextCheckTime", ::apache::thrift::protocol::T_I64, 14);
  xfer += oprot->writeI64(this->_nextCheckTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_newPointDataReceivedFlag", ::apache::thrift::protocol::T_BOOL, 15);
  xfer += oprot->writeBool(this->_newPointDataReceivedFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_updatedFlag", ::apache::thrift::protocol::T_BOOL, 16);
  xfer += oprot->writeBool(this->_updatedFlag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_controlAreaStatusPointId", ::apache::thrift::protocol::T_I32, 17);
  xfer += oprot->writeI32(this->_controlAreaStatusPointId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_controlAreaState", ::apache::thrift::protocol::T_I32, 18);
  xfer += oprot->writeI32(this->_controlAreaState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_currentPriority", ::apache::thrift::protocol::T_I32, 19);
  xfer += oprot->writeI32(this->_currentPriority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_currentDailyStartTime", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->_currentDailyStartTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_currentDailyStopTime", ::apache::thrift::protocol::T_I32, 21);
  xfer += oprot->writeI32(this->_currentDailyStopTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmControlAreaTriggers", ::apache::thrift::protocol::T_LIST, 22);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmControlAreaTriggers.size()));
    std::vector<LMControlAreaTrigger> ::const_iterator _iter150;
    for (_iter150 = this->_lmControlAreaTriggers.begin(); _iter150 != this->_lmControlAreaTriggers.end(); ++_iter150)
    {
      xfer += (*_iter150).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_lmPrograms", ::apache::thrift::protocol::T_LIST, 23);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_lmPrograms.size()));
    std::vector< ::Cti::Messaging::Serialization::Thrift::GenericMessage> ::const_iterator _iter151;
    for (_iter151 = this->_lmPrograms.begin(); _iter151 != this->_lmPrograms.end(); ++_iter151)
    {
      xfer += (*_iter151).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMControlAreaItem &a, LMControlAreaItem &b) {
  using ::std::swap;
  swap(a._paoId, b._paoId);
  swap(a._paoCategory, b._paoCategory);
  swap(a._paoClass, b._paoClass);
  swap(a._paoName, b._paoName);
  swap(a._paoTypeString, b._paoTypeString);
  swap(a._paoDescription, b._paoDescription);
  swap(a._disableFlag, b._disableFlag);
  swap(a._defOperationalState, b._defOperationalState);
  swap(a._controlInterval, b._controlInterval);
  swap(a._minResponseTime, b._minResponseTime);
  swap(a._defDailyStartTime, b._defDailyStartTime);
  swap(a._defDailyStopTime, b._defDailyStopTime);
  swap(a._requireAllTriggersActiveFlag, b._requireAllTriggersActiveFlag);
  swap(a._nextCheckTime, b._nextCheckTime);
  swap(a._newPointDataReceivedFlag, b._newPointDataReceivedFlag);
  swap(a._updatedFlag, b._updatedFlag);
  swap(a._controlAreaStatusPointId, b._controlAreaStatusPointId);
  swap(a._controlAreaState, b._controlAreaState);
  swap(a._currentPriority, b._currentPriority);
  swap(a._currentDailyStartTime, b._currentDailyStartTime);
  swap(a._currentDailyStopTime, b._currentDailyStopTime);
  swap(a._lmControlAreaTriggers, b._lmControlAreaTriggers);
  swap(a._lmPrograms, b._lmPrograms);
}

LMControlAreaItem::LMControlAreaItem(const LMControlAreaItem& other152) {
  _paoId = other152._paoId;
  _paoCategory = other152._paoCategory;
  _paoClass = other152._paoClass;
  _paoName = other152._paoName;
  _paoTypeString = other152._paoTypeString;
  _paoDescription = other152._paoDescription;
  _disableFlag = other152._disableFlag;
  _defOperationalState = other152._defOperationalState;
  _controlInterval = other152._controlInterval;
  _minResponseTime = other152._minResponseTime;
  _defDailyStartTime = other152._defDailyStartTime;
  _defDailyStopTime = other152._defDailyStopTime;
  _requireAllTriggersActiveFlag = other152._requireAllTriggersActiveFlag;
  _nextCheckTime = other152._nextCheckTime;
  _newPointDataReceivedFlag = other152._newPointDataReceivedFlag;
  _updatedFlag = other152._updatedFlag;
  _controlAreaStatusPointId = other152._controlAreaStatusPointId;
  _controlAreaState = other152._controlAreaState;
  _currentPriority = other152._currentPriority;
  _currentDailyStartTime = other152._currentDailyStartTime;
  _currentDailyStopTime = other152._currentDailyStopTime;
  _lmControlAreaTriggers = other152._lmControlAreaTriggers;
  _lmPrograms = other152._lmPrograms;
}
LMControlAreaItem& LMControlAreaItem::operator=(const LMControlAreaItem& other153) {
  _paoId = other153._paoId;
  _paoCategory = other153._paoCategory;
  _paoClass = other153._paoClass;
  _paoName = other153._paoName;
  _paoTypeString = other153._paoTypeString;
  _paoDescription = other153._paoDescription;
  _disableFlag = other153._disableFlag;
  _defOperationalState = other153._defOperationalState;
  _controlInterval = other153._controlInterval;
  _minResponseTime = other153._minResponseTime;
  _defDailyStartTime = other153._defDailyStartTime;
  _defDailyStopTime = other153._defDailyStopTime;
  _requireAllTriggersActiveFlag = other153._requireAllTriggersActiveFlag;
  _nextCheckTime = other153._nextCheckTime;
  _newPointDataReceivedFlag = other153._newPointDataReceivedFlag;
  _updatedFlag = other153._updatedFlag;
  _controlAreaStatusPointId = other153._controlAreaStatusPointId;
  _controlAreaState = other153._controlAreaState;
  _currentPriority = other153._currentPriority;
  _currentDailyStartTime = other153._currentDailyStartTime;
  _currentDailyStopTime = other153._currentDailyStopTime;
  _lmControlAreaTriggers = other153._lmControlAreaTriggers;
  _lmPrograms = other153._lmPrograms;
  return *this;
}
void LMControlAreaItem::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMControlAreaItem(";
  out << "_paoId=" << to_string(_paoId);
  out << ", " << "_paoCategory=" << to_string(_paoCategory);
  out << ", " << "_paoClass=" << to_string(_paoClass);
  out << ", " << "_paoName=" << to_string(_paoName);
  out << ", " << "_paoTypeString=" << to_string(_paoTypeString);
  out << ", " << "_paoDescription=" << to_string(_paoDescription);
  out << ", " << "_disableFlag=" << to_string(_disableFlag);
  out << ", " << "_defOperationalState=" << to_string(_defOperationalState);
  out << ", " << "_controlInterval=" << to_string(_controlInterval);
  out << ", " << "_minResponseTime=" << to_string(_minResponseTime);
  out << ", " << "_defDailyStartTime=" << to_string(_defDailyStartTime);
  out << ", " << "_defDailyStopTime=" << to_string(_defDailyStopTime);
  out << ", " << "_requireAllTriggersActiveFlag=" << to_string(_requireAllTriggersActiveFlag);
  out << ", " << "_nextCheckTime=" << to_string(_nextCheckTime);
  out << ", " << "_newPointDataReceivedFlag=" << to_string(_newPointDataReceivedFlag);
  out << ", " << "_updatedFlag=" << to_string(_updatedFlag);
  out << ", " << "_controlAreaStatusPointId=" << to_string(_controlAreaStatusPointId);
  out << ", " << "_controlAreaState=" << to_string(_controlAreaState);
  out << ", " << "_currentPriority=" << to_string(_currentPriority);
  out << ", " << "_currentDailyStartTime=" << to_string(_currentDailyStartTime);
  out << ", " << "_currentDailyStopTime=" << to_string(_currentDailyStopTime);
  out << ", " << "_lmControlAreaTriggers=" << to_string(_lmControlAreaTriggers);
  out << ", " << "_lmPrograms=" << to_string(_lmPrograms);
  out << ")";
}


LMControlAreas::~LMControlAreas() noexcept {
}


void LMControlAreas::__set__baseMessage(const  ::Cti::Messaging::Serialization::Thrift::LMMessage& val) {
  this->_baseMessage = val;
}

void LMControlAreas::__set__msgInfoBitMask(const int32_t val) {
  this->_msgInfoBitMask = val;
}

void LMControlAreas::__set__controlAreas(const std::vector<LMControlAreaItem> & val) {
  this->_controlAreas = val;
}
std::ostream& operator<<(std::ostream& out, const LMControlAreas& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LMControlAreas::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset__baseMessage = false;
  bool isset__msgInfoBitMask = false;
  bool isset__controlAreas = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->_baseMessage.read(iprot);
          isset__baseMessage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->_msgInfoBitMask);
          isset__msgInfoBitMask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->_controlAreas.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->_controlAreas.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              xfer += this->_controlAreas[_i158].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset__controlAreas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset__baseMessage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__msgInfoBitMask)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset__controlAreas)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LMControlAreas::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LMControlAreas");

  xfer += oprot->writeFieldBegin("_baseMessage", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->_baseMessage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_msgInfoBitMask", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->_msgInfoBitMask);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("_controlAreas", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->_controlAreas.size()));
    std::vector<LMControlAreaItem> ::const_iterator _iter159;
    for (_iter159 = this->_controlAreas.begin(); _iter159 != this->_controlAreas.end(); ++_iter159)
    {
      xfer += (*_iter159).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LMControlAreas &a, LMControlAreas &b) {
  using ::std::swap;
  swap(a._baseMessage, b._baseMessage);
  swap(a._msgInfoBitMask, b._msgInfoBitMask);
  swap(a._controlAreas, b._controlAreas);
}

LMControlAreas::LMControlAreas(const LMControlAreas& other160) {
  _baseMessage = other160._baseMessage;
  _msgInfoBitMask = other160._msgInfoBitMask;
  _controlAreas = other160._controlAreas;
}
LMControlAreas& LMControlAreas::operator=(const LMControlAreas& other161) {
  _baseMessage = other161._baseMessage;
  _msgInfoBitMask = other161._msgInfoBitMask;
  _controlAreas = other161._controlAreas;
  return *this;
}
void LMControlAreas::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LMControlAreas(";
  out << "_baseMessage=" << to_string(_baseMessage);
  out << ", " << "_msgInfoBitMask=" << to_string(_msgInfoBitMask);
  out << ", " << "_controlAreas=" << to_string(_controlAreas);
  out << ")";
}

}}}} // namespace
