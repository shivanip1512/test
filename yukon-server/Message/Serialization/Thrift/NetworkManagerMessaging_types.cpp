/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "NetworkManagerMessaging_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace Cti { namespace Messaging { namespace Serialization { namespace Thrift {

int _kNetworkManagerMessageLifetimeValues[] = {
  NetworkManagerMessageLifetime::SESSION,
  NetworkManagerMessageLifetime::UNTIL_CANCEL
};
const char* _kNetworkManagerMessageLifetimeNames[] = {
  "SESSION",
  "UNTIL_CANCEL"
};
const std::map<int, const char*> _NetworkManagerMessageLifetime_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kNetworkManagerMessageLifetimeValues, _kNetworkManagerMessageLifetimeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const NetworkManagerMessageLifetime::type& val) {
  std::map<int, const char*>::const_iterator it = _NetworkManagerMessageLifetime_VALUES_TO_NAMES.find(val);
  if (it != _NetworkManagerMessageLifetime_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const NetworkManagerMessageLifetime::type& val) {
  std::map<int, const char*>::const_iterator it = _NetworkManagerMessageLifetime_VALUES_TO_NAMES.find(val);
  if (it != _NetworkManagerMessageLifetime_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kNetworkManagerCancelTypeValues[] = {
  NetworkManagerCancelType::MESSAGE_IDS,
  NetworkManagerCancelType::GROUP_IDS
};
const char* _kNetworkManagerCancelTypeNames[] = {
  "MESSAGE_IDS",
  "GROUP_IDS"
};
const std::map<int, const char*> _NetworkManagerCancelType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kNetworkManagerCancelTypeValues, _kNetworkManagerCancelTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const NetworkManagerCancelType::type& val) {
  std::map<int, const char*>::const_iterator it = _NetworkManagerCancelType_VALUES_TO_NAMES.find(val);
  if (it != _NetworkManagerCancelType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const NetworkManagerCancelType::type& val) {
  std::map<int, const char*>::const_iterator it = _NetworkManagerCancelType_VALUES_TO_NAMES.find(val);
  if (it != _NetworkManagerCancelType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kNetworkManagerMessageCancelStatusValues[] = {
  NetworkManagerMessageCancelStatus::SUCCESS,
  NetworkManagerMessageCancelStatus::NOT_FOUND
};
const char* _kNetworkManagerMessageCancelStatusNames[] = {
  "SUCCESS",
  "NOT_FOUND"
};
const std::map<int, const char*> _NetworkManagerMessageCancelStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kNetworkManagerMessageCancelStatusValues, _kNetworkManagerMessageCancelStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const NetworkManagerMessageCancelStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _NetworkManagerMessageCancelStatus_VALUES_TO_NAMES.find(val);
  if (it != _NetworkManagerMessageCancelStatus_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const NetworkManagerMessageCancelStatus::type& val) {
  std::map<int, const char*>::const_iterator it = _NetworkManagerMessageCancelStatus_VALUES_TO_NAMES.find(val);
  if (it != _NetworkManagerMessageCancelStatus_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


NetworkManagerRequestHeader::~NetworkManagerRequestHeader() noexcept {
}


void NetworkManagerRequestHeader::__set_clientGuid(const std::string& val) {
  this->clientGuid = val;
}

void NetworkManagerRequestHeader::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void NetworkManagerRequestHeader::__set_messageId(const int64_t val) {
  this->messageId = val;
}

void NetworkManagerRequestHeader::__set_groupId(const int64_t val) {
  this->groupId = val;
__isset.groupId = true;
}

void NetworkManagerRequestHeader::__set_priority(const int8_t val) {
  this->priority = val;
}

void NetworkManagerRequestHeader::__set_expiration(const int64_t val) {
  this->expiration = val;
__isset.expiration = true;
}

void NetworkManagerRequestHeader::__set_lifetime(const NetworkManagerMessageLifetime::type val) {
  this->lifetime = val;
__isset.lifetime = true;
}
std::ostream& operator<<(std::ostream& out, const NetworkManagerRequestHeader& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NetworkManagerRequestHeader::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_clientGuid = false;
  bool isset_sessionId = false;
  bool isset_messageId = false;
  bool isset_priority = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clientGuid);
          isset_clientGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->messageId);
          isset_messageId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->groupId);
          this->__isset.groupId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->priority);
          isset_priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expiration);
          this->__isset.expiration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->lifetime = (NetworkManagerMessageLifetime::type)ecast0;
          this->__isset.lifetime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_clientGuid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_messageId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_priority)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NetworkManagerRequestHeader::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NetworkManagerRequestHeader");

  xfer += oprot->writeFieldBegin("clientGuid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->clientGuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("messageId", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->messageId);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.groupId) {
    xfer += oprot->writeFieldBegin("groupId", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->groupId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->priority);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.expiration) {
    xfer += oprot->writeFieldBegin("expiration", ::apache::thrift::protocol::T_I64, 6);
    xfer += oprot->writeI64(this->expiration);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lifetime) {
    xfer += oprot->writeFieldBegin("lifetime", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->lifetime);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NetworkManagerRequestHeader &a, NetworkManagerRequestHeader &b) {
  using ::std::swap;
  swap(a.clientGuid, b.clientGuid);
  swap(a.sessionId, b.sessionId);
  swap(a.messageId, b.messageId);
  swap(a.groupId, b.groupId);
  swap(a.priority, b.priority);
  swap(a.expiration, b.expiration);
  swap(a.lifetime, b.lifetime);
  swap(a.__isset, b.__isset);
}

NetworkManagerRequestHeader::NetworkManagerRequestHeader(const NetworkManagerRequestHeader& other1) {
  clientGuid = other1.clientGuid;
  sessionId = other1.sessionId;
  messageId = other1.messageId;
  groupId = other1.groupId;
  priority = other1.priority;
  expiration = other1.expiration;
  lifetime = other1.lifetime;
  __isset = other1.__isset;
}
NetworkManagerRequestHeader& NetworkManagerRequestHeader::operator=(const NetworkManagerRequestHeader& other2) {
  clientGuid = other2.clientGuid;
  sessionId = other2.sessionId;
  messageId = other2.messageId;
  groupId = other2.groupId;
  priority = other2.priority;
  expiration = other2.expiration;
  lifetime = other2.lifetime;
  __isset = other2.__isset;
  return *this;
}
void NetworkManagerRequestHeader::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NetworkManagerRequestHeader(";
  out << "clientGuid=" << to_string(clientGuid);
  out << ", " << "sessionId=" << to_string(sessionId);
  out << ", " << "messageId=" << to_string(messageId);
  out << ", " << "groupId="; (__isset.groupId ? (out << to_string(groupId)) : (out << "<null>"));
  out << ", " << "priority=" << to_string(priority);
  out << ", " << "expiration="; (__isset.expiration ? (out << to_string(expiration)) : (out << "<null>"));
  out << ", " << "lifetime="; (__isset.lifetime ? (out << to_string(lifetime)) : (out << "<null>"));
  out << ")";
}


NetworkManagerRequestAck::~NetworkManagerRequestAck() noexcept {
}


void NetworkManagerRequestAck::__set_header(const NetworkManagerRequestHeader& val) {
  this->header = val;
}
std::ostream& operator<<(std::ostream& out, const NetworkManagerRequestAck& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NetworkManagerRequestAck::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_header = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->header.read(iprot);
          isset_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_header)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NetworkManagerRequestAck::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NetworkManagerRequestAck");

  xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->header.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NetworkManagerRequestAck &a, NetworkManagerRequestAck &b) {
  using ::std::swap;
  swap(a.header, b.header);
}

NetworkManagerRequestAck::NetworkManagerRequestAck(const NetworkManagerRequestAck& other3) {
  header = other3.header;
}
NetworkManagerRequestAck& NetworkManagerRequestAck::operator=(const NetworkManagerRequestAck& other4) {
  header = other4.header;
  return *this;
}
void NetworkManagerRequestAck::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NetworkManagerRequestAck(";
  out << "header=" << to_string(header);
  out << ")";
}


NetworkManagerCancelRequest::~NetworkManagerCancelRequest() noexcept {
}


void NetworkManagerCancelRequest::__set_clientGuid(const std::string& val) {
  this->clientGuid = val;
}

void NetworkManagerCancelRequest::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void NetworkManagerCancelRequest::__set_type(const NetworkManagerCancelType::type val) {
  this->type = val;
}

void NetworkManagerCancelRequest::__set_ids(const std::set<int64_t> & val) {
  this->ids = val;
}
std::ostream& operator<<(std::ostream& out, const NetworkManagerCancelRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NetworkManagerCancelRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_clientGuid = false;
  bool isset_sessionId = false;
  bool isset_type = false;
  bool isset_ids = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clientGuid);
          isset_clientGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->type = (NetworkManagerCancelType::type)ecast5;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->ids.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readSetBegin(_etype9, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              int64_t _elem11;
              xfer += iprot->readI64(_elem11);
              this->ids.insert(_elem11);
            }
            xfer += iprot->readSetEnd();
          }
          isset_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_clientGuid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ids)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NetworkManagerCancelRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NetworkManagerCancelRequest");

  xfer += oprot->writeFieldBegin("clientGuid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->clientGuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ids", ::apache::thrift::protocol::T_SET, 4);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->ids.size()));
    std::set<int64_t> ::const_iterator _iter12;
    for (_iter12 = this->ids.begin(); _iter12 != this->ids.end(); ++_iter12)
    {
      xfer += oprot->writeI64((*_iter12));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NetworkManagerCancelRequest &a, NetworkManagerCancelRequest &b) {
  using ::std::swap;
  swap(a.clientGuid, b.clientGuid);
  swap(a.sessionId, b.sessionId);
  swap(a.type, b.type);
  swap(a.ids, b.ids);
}

NetworkManagerCancelRequest::NetworkManagerCancelRequest(const NetworkManagerCancelRequest& other13) {
  clientGuid = other13.clientGuid;
  sessionId = other13.sessionId;
  type = other13.type;
  ids = other13.ids;
}
NetworkManagerCancelRequest& NetworkManagerCancelRequest::operator=(const NetworkManagerCancelRequest& other14) {
  clientGuid = other14.clientGuid;
  sessionId = other14.sessionId;
  type = other14.type;
  ids = other14.ids;
  return *this;
}
void NetworkManagerCancelRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NetworkManagerCancelRequest(";
  out << "clientGuid=" << to_string(clientGuid);
  out << ", " << "sessionId=" << to_string(sessionId);
  out << ", " << "type=" << to_string(type);
  out << ", " << "ids=" << to_string(ids);
  out << ")";
}


NetworkManagerCancelRequestAck::~NetworkManagerCancelRequestAck() noexcept {
}


void NetworkManagerCancelRequestAck::__set_request(const NetworkManagerCancelRequest& val) {
  this->request = val;
}
std::ostream& operator<<(std::ostream& out, const NetworkManagerCancelRequestAck& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NetworkManagerCancelRequestAck::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_request = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->request.read(iprot);
          isset_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_request)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NetworkManagerCancelRequestAck::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NetworkManagerCancelRequestAck");

  xfer += oprot->writeFieldBegin("request", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NetworkManagerCancelRequestAck &a, NetworkManagerCancelRequestAck &b) {
  using ::std::swap;
  swap(a.request, b.request);
}

NetworkManagerCancelRequestAck::NetworkManagerCancelRequestAck(const NetworkManagerCancelRequestAck& other15) {
  request = other15.request;
}
NetworkManagerCancelRequestAck& NetworkManagerCancelRequestAck::operator=(const NetworkManagerCancelRequestAck& other16) {
  request = other16.request;
  return *this;
}
void NetworkManagerCancelRequestAck::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NetworkManagerCancelRequestAck(";
  out << "request=" << to_string(request);
  out << ")";
}


NetworkManagerCancelResponse::~NetworkManagerCancelResponse() noexcept {
}


void NetworkManagerCancelResponse::__set_clientGuid(const std::string& val) {
  this->clientGuid = val;
}

void NetworkManagerCancelResponse::__set_sessionId(const int64_t val) {
  this->sessionId = val;
}

void NetworkManagerCancelResponse::__set_messageIds(const MessageStatusPerId& val) {
  this->messageIds = val;
}
std::ostream& operator<<(std::ostream& out, const NetworkManagerCancelResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NetworkManagerCancelResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_clientGuid = false;
  bool isset_sessionId = false;
  bool isset_messageIds = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clientGuid);
          isset_clientGuid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sessionId);
          isset_sessionId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->messageIds.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _ktype18;
            ::apache::thrift::protocol::TType _vtype19;
            xfer += iprot->readMapBegin(_ktype18, _vtype19, _size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              int64_t _key22;
              xfer += iprot->readI64(_key22);
              NetworkManagerMessageCancelStatus::type& _val23 = this->messageIds[_key22];
              int32_t ecast24;
              xfer += iprot->readI32(ecast24);
              _val23 = (NetworkManagerMessageCancelStatus::type)ecast24;
            }
            xfer += iprot->readMapEnd();
          }
          isset_messageIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_clientGuid)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sessionId)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_messageIds)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t NetworkManagerCancelResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NetworkManagerCancelResponse");

  xfer += oprot->writeFieldBegin("clientGuid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->clientGuid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionId", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->sessionId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("messageIds", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->messageIds.size()));
    std::map<int64_t, NetworkManagerMessageCancelStatus::type> ::const_iterator _iter25;
    for (_iter25 = this->messageIds.begin(); _iter25 != this->messageIds.end(); ++_iter25)
    {
      xfer += oprot->writeI64(_iter25->first);
      xfer += oprot->writeI32((int32_t)_iter25->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NetworkManagerCancelResponse &a, NetworkManagerCancelResponse &b) {
  using ::std::swap;
  swap(a.clientGuid, b.clientGuid);
  swap(a.sessionId, b.sessionId);
  swap(a.messageIds, b.messageIds);
}

NetworkManagerCancelResponse::NetworkManagerCancelResponse(const NetworkManagerCancelResponse& other26) {
  clientGuid = other26.clientGuid;
  sessionId = other26.sessionId;
  messageIds = other26.messageIds;
}
NetworkManagerCancelResponse& NetworkManagerCancelResponse::operator=(const NetworkManagerCancelResponse& other27) {
  clientGuid = other27.clientGuid;
  sessionId = other27.sessionId;
  messageIds = other27.messageIds;
  return *this;
}
void NetworkManagerCancelResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NetworkManagerCancelResponse(";
  out << "clientGuid=" << to_string(clientGuid);
  out << ", " << "sessionId=" << to_string(sessionId);
  out << ", " << "messageIds=" << to_string(messageIds);
  out << ")";
}

}}}} // namespace
