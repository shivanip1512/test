#include "precompiled.h"

#include "fileint.h"
#include "dllbase.h"
#include "ctitime.h"
#include "logger.h"
#include "guard.h"

using namespace std;

namespace Cti {

#pragma warning(push)
#pragma warning(disable:4355) // disable the warning generated by worker thread using "this" in constructor initializer List

/*---------------------------------------------------------------------------
    Constructor

    Takes the name of the directory to watch.
---------------------------------------------------------------------------*/
FileInterface::FileInterface(const string& dirtowatch, const string& extension) :
    _extension(extension),
    _dir(dirtowatch),
    _delete_on_start(false),
    _watchthr(WorkerThread::Function(&FileInterface::_watch, this)
                    .name("File Interface watch thread"))
{
}

#pragma warning(pop)

void FileInterface::setDirectory(const string& dir)
{
   _dir = dir;
}

void FileInterface::setExtension(const string& ext)
{
    _extension = ext;
}

void FileInterface::setDeleteOnStart(bool del)
{
    _delete_on_start = del;
}

/*---------------------------------------------------------------------------
    start

    Starts the thread that watches the directory for new files.
    Does nothing if the thread is alread running.
---------------------------------------------------------------------------*/
void FileInterface::start()
{
    CtiLockGuard<CtiCriticalSection> guard(_mutex);

    //Make sure that the watch thread isn't already running
    if ( ! _watchthr.isRunning() )
    {
        _watchthr.start();
    }

}

/*---------------------------------------------------------------------------
    stop

    Stops the thread that watches the directory for new files.
    Does nothing if the thread isn't already running.
---------------------------------------------------------------------------*/
void FileInterface::stop()
{
    CtiLockGuard<CtiCriticalSection> guard(_mutex);

    //Make sure that the watch thread is running
    if ( _watchthr.isRunning() )
    {
        _watchthr.interrupt();

        _watchthr.tryJoinOrTerminateFor(Timing::Chrono::seconds(1));
    }
}

/*---------------------------------------------------------------------------
    _watch

    This is where the watch thread loops waiting for new files to appear.
---------------------------------------------------------------------------*/
void FileInterface::_watch()
{
    DWORD dwWaitStatus;
    HANDLE dwChangeHandle;

    try
    {
        //The find functions work in the current directory
        //Lets hope there are no conflicts with others!
        CTILOG_INFO(dout, "Setting Current Directory to "<< _dir);

        if ( !SetCurrentDirectory( _dir.c_str() ) )
        {
            CTILOG_ERROR(dout, "An error occurred changing the current directory");
            //where should this be going FIX FIX - maybe that'll get someones attention
            return;
        }

        // flag indicates we need to delete
        // all matching files on startup, don't allow these to be handled
        // if this is set true
        bool do_delete = _delete_on_start;

        while (TRUE)
        {
            WIN32_FIND_DATA FileData;
            HANDLE hSearch;

            string search_string = "*" + _extension;
            hSearch = FindFirstFile( search_string.c_str(), &FileData );

            if ( hSearch == INVALID_HANDLE_VALUE )
            {
                WorkerThread::sleepFor(Timing::Chrono::seconds(1));  //  interruption point

                if( do_delete )
                {
                    do_delete = false;
                }
                continue;
            }

            do
            {
                if( !do_delete)
                {
                    //Actually handle the file in some child class
                    CTILOG_INFO(dout, "Handling file "<< FileData.cFileName);
                    handleFile( FileData.cFileName );
                }
                else
                {
                    CTILOG_INFO(dout, "Deleting file "<< FileData.cFileName);
                }

                //Delete it
                unlink( FileData.cFileName );
            }
            while ( FindNextFile( hSearch, &FileData ) );

            FindClose(hSearch);
        }
    }
    catch (boost::thread_interrupted&)
    {
        CTILOG_INFO(dout, "Exiting");
    }
}

}

